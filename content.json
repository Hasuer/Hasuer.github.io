{"meta":{"title":"Hasuer's Studio.","subtitle":"","description":"","author":"Hasuer","url":"https://hasuer.github.io","root":"/"},"pages":[{"title":"about","date":"2020-09-30T17:10:37.000Z","updated":"2020-09-30T17:11:32.046Z","comments":true,"path":"about/index.html","permalink":"https://hasuer.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"1. Pattern Two Pointers","slug":"1. Pattern Two Pointers","date":"2024-04-30T01:42:18.000Z","updated":"2024-04-30T01:47:50.921Z","comments":true,"path":"1-pattern-two-pointers/index.html","link":"","permalink":"https://hasuer.github.io/1-pattern-two-pointers/index.html","excerpt":"","text":"IntroductionIn problems where we deal with sorted arrays (or LinkedLists) and need to find a set of elements that fulfill certain constraints, the Two Pointers approach becomes quite useful. The set of elements could be a pair, a triplet or even a subarray. For example, take a look at the following problem: Given an array of sorted numbers and a target sum, find a pair in the array whose sum is equal to the given target. To solve this problem, we can consider each element one by one (pointed out by the first pointer) and iterate through the remaining elements (pointed out by the second pointer) to find a pair with the given sum. The time complexity of this algorithm will be O(N^2) where ‘N’ is the number of elements in the input array. Given that the input array is sorted, an efficient way would be to start with one pointer in the beginning and another pointer at the end. At every step, we will see if the numbers pointed by the two pointers add up to the target sum. If they do not, we will do one of two things: If the sum of the two numbers pointed by the two pointers is greater than the target sum, this means that we need a pair with a smaller sum. So, to try more pairs, we can decrement the end-pointer. If the sum of the two numbers pointed by the two pointers is smaller than the target sum, this means that we need a pair with a larger sum. So, to try more pairs, we can increment the start-pointer. Here is the visual representation of this algorithm: The time complexity of the above algorithm will be O(N). In the following chapters, we will apply the Two Pointers approach to solve a few problems. Pair with Target Sum (easy)不在leetcode Problem StatementGiven an array of sorted numbers and a target sum, find a pair in the array whose sum is equal to the given target. Write a function to return the indices of the two numbers (i.e. the pair) such that they add up to the given target. Example 1: 123Input: [1, 2, 3, 4, 6], target=6Output: [1, 3]Explanation: The numbers at index 1 and 3 add up to 6: 2+4=6 Example 2: 123Input: [2, 5, 9, 11], target=11Output: [0, 2]Explanation: The numbers at index 0 and 2 add up to 11: 2+9=11 Try it yourselfTry solving this question here: 12345678910111213141516171819202122def pari_with_targetsum(arr, target_sum): p1, p2 = 0, len(arr) - 1 while p1 &lt; p2: if arr[p1] + arr[p2] == target_sum: return [p1, p2] elif arr[p1] + arr[p2] &lt; target_sum: p1 += 1 else: p2 -= 1 return [-1, -1]def main(): result = pari_with_targetsum([1, 2, 3, 4, 6], 6) print(&quot;Result: &quot; + str(result)) result = pari_with_targetsum([2, 5, 9, 11], 11) print(&quot;Result: &quot; + str(result))if __name__ == &#x27;__main__&#x27;: main() SolutionSince the given array is sorted, a brute-force solution could be to iterate through the array, taking one number at a time and searching for the second number through Binary Search. The time complexity of this algorithm will be O(N\\logN)*. Can we do better than this? We can follow the Two Pointers approach. We will start with one pointer pointing to the beginning of the array and another pointing at the end. At every step, we will see if the numbers pointed by the two pointers add up to the target sum. If they do, we have found our pair; otherwise, we will do one of two things: If the sum of the two numbers pointed by the two pointers is greater than the target sum, this means that we need a pair with a smaller sum. So, to try more pairs, we can decrement the end-pointer. If the sum of the two numbers pointed by the two pointers is smaller than the target sum, this means that we need a pair with a larger sum. So, to try more pairs, we can increment the start-pointer. Here is the visual representation of this algorithm for Example-1: CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324def pari_with_targetsum(arr, target_sum): p1, p2 = 0, len(arr) - 1 while p1 &lt; p2: # 减少计算 sum = arr[p1] + arr[p2] if sum == target_sum: return [p1, p2] elif sum &lt; target_sum: p1 += 1 else: p2 -= 1 return [-1, -1]def main(): result = pari_with_targetsum([1, 2, 3, 4, 6], 6) print(&quot;Result: &quot; + str(result)) result = pari_with_targetsum([2, 5, 9, 11], 11) print(&quot;Result: &quot; + str(result))if __name__ == &#x27;__main__&#x27;: main() Time ComplexityThe time complexity of the above algorithm will be O(N), where ‘N’ is the total number of elements in the given array. Space ComplexityThe algorithm runs in constant space O(1). An Alternate approachInstead of using a two-pointer or a binary search approach, we can utilize a HashTable to search for the required pair. We can iterate through the array one number at a time. Let’s say during our iteration we are at number ‘X’, so we need to find ‘Y’ such that “X + Y == Target”. We will do two things here: Search for ‘Y’ (which is equivalent to “Target - X“ in the HashTable. If it is there, we have found the required pair. Otherwise, insert “X” in the HashTable, so that we can search it for the later numbers. Here is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;#include &lt;string&gt;#include &lt;unordered_map&gt;#include &lt;vector&gt;class PairWithTargetSum &#123; public: static pair&lt;int, int&gt; search(const vector&lt;int&gt;&amp; str, int target) &#123; // todo: unordered_map&lt;int, int&gt; nums; // store the num and the index for (int i = 0; i &lt; str.size(); i++) &#123; if (nums.find(target - str[i]) != nums.end()) &#123; return make_pair(nums[target - str[i]], i); &#125; else &#123; nums[str[i]] = i; &#125; &#125; return make_pair(-1, -1); &#125;&#125;;int main() &#123; auto result = PairWithTargetSum::search(vector&lt;int&gt;&#123;1, 2, 3, 4, 6&#125;, 6); cout &lt;&lt; &quot;Pair with target sum: [&quot; &lt;&lt; result.first &lt;&lt; &quot;,&quot; &lt;&lt; result.second &lt;&lt; &quot;]&quot; &lt;&lt; endl; result = PairWithTargetSum::search(vector&lt;int&gt;&#123;2, 5, 9, 11&#125;, 11); cout &lt;&lt; &quot;Pair with target sum: [&quot; &lt;&lt; result.first &lt;&lt; &quot;,&quot; &lt;&lt; result.second &lt;&lt; &quot;]&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; Time ComplexityThe time complexity of the above algorithm will be O(N), where ‘N’ is the total number of elements in the given array. Space ComplexityThe space complexity will also be O(N), as, in the worst case, we will be pushing ‘N’ numbers in the HashTable. Remove Duplicates (easy)leetcode 26 Problem StatementGiven an array of sorted numbers, remove all duplicates from it. You should not use any extra space; after removing the duplicates in-place return the new length of the array. Example 1: 123Input: [2, 3, 3, 3, 6, 9, 9]Output: 4Explanation: The first four elements after removing the duplicates will be [2, 3, 6, 9]. Example 2: 123Input: [2, 2, 2, 11]Output: 2Explanation: The first two elements after removing the duplicates will be [2, 11]. Try it yourselfTry solving this question here: 12345678910111213141516171819202122232425262728def remove_duplicates(arr): if len(arr) == 0: return 0 length = 0 now = 0 next_new = 1 while next_new &lt; len(arr): while next_new &lt; len(arr) and arr[next_new] == arr[now]: next_new += 1 else: length += 1 now = next_new next_new += 1 return length + 1def main(): result = remove_duplicates([2, 3, 3, 3, 6, 9, 9]) print(&quot;Result: &quot; + str(result)) result = remove_duplicates([2, 2, 2, 11]) print(&quot;Result: &quot; + str(result)) result = remove_duplicates([1]) print(&quot;Result: &quot; + str(result))if __name__ == &#x27;__main__&#x27;: main() SolutionIn this problem, we need to remove the duplicates in-place such that the resultant length of the array remains sorted. As the input array is sorted, therefore, one way to do this is to shift the elements left whenever we encounter duplicates. In other words, we will keep one pointer for iterating the array and one pointer for placing the next non-duplicate number. So our algorithm will be to iterate the array and whenever we see a non-duplicate number we move it next to the last non-duplicate number we’ve seen. Here is the visual representation of this algorithm for Example-1: CodeHere is what our algorithm will look like: 1234567891011121314151617181920212223def remove_duplicates(arr): end = 1 # 这是做替换用的 pointer = 1 while pointer &lt; len(arr): if arr[pointer] != arr[pointer - 1]: arr[end] = arr[pointer] end += 1 pointer += 1 return enddef main(): result = remove_duplicates([2, 3, 3, 3, 6, 9, 9]) print(&quot;Result: &quot; + str(result)) result = remove_duplicates([2, 2, 2, 11]) print(&quot;Result: &quot; + str(result)) result = remove_duplicates([1]) print(&quot;Result: &quot; + str(result))if __name__ == &#x27;__main__&#x27;: main() Time ComplexityThe time complexity of the above algorithm will be O(N)O(N), where ‘N’ is the total number of elements in the given array. Space ComplexityThe algorithm runs in constant space O(1)O(1). Similar QuestionsProblem 1: Given an unsorted array of numbers and a target ‘key’, remove all instances of ‘key’ in-place and return the new length of the array. Example 1: 123Input: [3, 2, 3, 6, 3, 10, 9, 3], Key=3Output: 4Explanation: The first four elements after removing every &#x27;Key&#x27; will be [2, 6, 10, 9]. Example 2: 123Input: [2, 11, 2, 2, 1], Key=2Output: 2Explanation: The first two elements after removing every &#x27;Key&#x27; will be [11, 1]. Solution: This problem is quite similar to our parent problem. We can follow a two-pointer approach and shift numbers left upon encountering the ‘key’. Here is what the code will look like: 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;#include &lt;string&gt;#include &lt;unordered_map&gt;#include &lt;vector&gt;class RemoveDuplicates &#123; public: static int remove(vector&lt;int&gt;&amp; arr, int key) &#123; // todo: int nextElement = 0; // index of the mext element which is not &quot;key&quot; for (int i = 1; i &lt; arr.size(); i++) &#123; if (arr[i] != key) &#123; arr[nextElement] = arr[i]; nextElement++; &#125; &#125; return nextElement; &#125;&#125;;int main() &#123; vector&lt;int&gt; arr = &#123;3, 2, 3, 6, 3, 10, 9, 3&#125;; cout &lt;&lt; &quot;Array new length: &quot; &lt;&lt; RemoveDuplicates::remove(arr, 3) &lt;&lt; endl; arr = &#123;2, 11, 2, 2, 1&#125;; cout &lt;&lt; &quot;Array new length: &quot; &lt;&lt; RemoveDuplicates::remove(arr, 2) &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; Time and Space Complexity: The time complexity of the above algorithm will be O(N), where ‘N’ is the total number of elements in the given array. The algorithm runs in constant space O(1). Squaring a Sorted Array (easy)leetcode 977 Problem StatementGiven a sorted array, create a new array containing squares of all the number of the input array in the sorted order. Example 1: 12Input: [-2, -1, 0, 2, 3]Output: [0, 1, 4, 4, 9] Example 2: 12Input: [-3, -1, 0, 1, 2]Output: [0 1 1 4 9] Try it yourselfTry solving this question here: 12345678910111213141516171819202122def make_squares(arr): res = [0] * len(arr) pointer1, pointer2 = 0, len(arr) - 1 for i in range(len(arr) - 1, -1, -1): if pow(arr[pointer1], 2) &lt; pow(arr[pointer2], 2): res[i] = pow(arr[pointer2], 2) pointer2 -= 1 else: res[i] = pow(arr[pointer1], 2) pointer1 += 1 return resdef main(): result = make_squares([-2, -1, 0, 2, 3]) print(&quot;Result: &quot; + str(result)) result = make_squares([-3, -1, 0, 1, 2]) print(&quot;Result: &quot; + str(result))if __name__ == &#x27;__main__&#x27;: main() SolutionThis is a straightforward question. The only trick is that we can have negative numbers in the input array, which will make it a bit difficult to generate the output array with squares in sorted order. An easier approach could be to first find the index of the first non-negative number in the array. After that, we can use Two Pointers to iterate the array. One pointer will move forward to iterate the non-negative numbers and the other pointer will move backward to iterate the negative numbers. At any step, whichever number gives us a bigger square will be added to the output array. For the above-mentioned Example-1, we will do something like this: Since the numbers at both the ends can give us the largest square, an alternate approach could be to use two pointers starting at both the ends of the input array. At any step, whichever pointer gives us the bigger square we add it to the result array and move to the next/previous number according to the pointer. For the above-mentioned Example-1, we will do something like this: CodeHere is what our algorithm will look like: 1234567891011121314151617181920212223242526def make_squares(arr): n = len(arr) res = [0 for x in range(n)] pointer1, pointer2 = 0, len(arr) - 1 highestSquarIdx = n - 1 while pointer1 &lt;= pointer2: if pow(arr[pointer1], 2) &lt; pow(arr[pointer2], 2): res[highestSquarIdx] = pow(arr[pointer2], 2) pointer2 -= 1 else: res[highestSquarIdx] = pow(arr[pointer1], 2) pointer1 += 1 highestSquarIdx -= 1 return resdef main(): result = make_squares([-2, -1, 0, 2, 3]) print(&quot;Result: &quot; + str(result)) result = make_squares([-3, -1, 0, 1, 2]) print(&quot;Result: &quot; + str(result))if __name__ == &#x27;__main__&#x27;: main() Time complexityThe time complexity of the above algorithm will be O(N) as we are iterating the input array only once. Space complexityThe space complexity of the above algorithm will also be O(N); this space will be used for the output array. *Triplet Sum to Zero (medium)leetcode 15 Problem StatementGiven an array of unsorted numbers, find all unique triplets in it that add up to zero. Example 1: 123Input: [-3, 0, 1, 2, -1, 1, -2]Output: [-3, 1, 2], [-2, 0, 2], [-2, 1, 1], [-1, 0, 1]Explanation: There are four unique triplets whose sum is equal to zero. Example 2: 123Input: [-5, 2, -1, -2, 3]Output: [[-5, 2, 3], [-2, -1, 3]]Explanation: There are two unique triplets whose sum is equal to zero. Try it yourselfTry solving this question here: 123456789101112131415161718192021222324252627282930313233343536def search_triples(arr): arr.sort() triples = [] for i in range(len(arr)): # 去重 if i &gt; 0 and arr[i] == arr[i - 1]: continue search_pair(arr, -arr[i], i + 1, triples) return triplesdef search_pair(arr, target_sum, left, triples): right = len(arr) - 1 while left &lt; right: current_sum = arr[left] + arr[right] # 这个可以修改的更好一点，看solution if current_sum &lt; target_sum: left += 1 elif current_sum &gt; target_sum: right -= 1 else: triples.append([-target_sum, arr[left], arr[right]]) left += 1 right -= 1def main(): result = search_triples([-3, 0, 1, 2, -1, 1, -2]) print(&quot;Result: &quot; + str(result)) result = search_triples([-5, 2, -1, -2, 3]) print(&quot;Result: &quot; + str(result))if __name__ == &#x27;__main__&#x27;: main() SolutionThis problem follows the Two Pointers pattern and shares similarities with Pair with Target Sum. A couple of differences are that the input array is not sorted and instead of a pair we need to find triplets with a target sum of zero. To follow a similar approach, first, we will sort the array and then iterate through it taking one number at a time. Let’s say during our iteration we are at number ‘X’, so we need to find ‘Y’ and ‘Z’ such that X + Y + Z == 0. At this stage, our problem translates into finding a pair whose sum is equal to “-X” (as from the above equation Y + Z == -X). Another difference from Pair with Target Sum is that we need to find all the unique triplets. To handle this, we have to skip any duplicate number. Since we will be sorting the array, so all the duplicate numbers will be next to each other and are easier to skip. CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233343536def search_triples(arr): arr.sort() triples = [] for i in range(len(arr)): search_pair(arr, -arr[i], i + 1, triples) return triplesdef search_pair(arr, target_sum, left, triples): right = len(arr) - 1 while left &lt; right: current_sum = arr[left] + arr[right] if current_sum &lt; target_sum: left += 1 elif current_sum &gt; target_sum: right -= 1 else: triples.append([-target_sum, arr[left], arr[right]]) left += 1 right -= 1 while left &lt; right and arr[left] == arr[left - 1]: left += 1 while left &lt; right and arr[right] == arr[right + 1]: right -= 1def main(): result = search_triples([-3, 0, 1, 2, -1, 1, -2]) print(&quot;Result: &quot; + str(result)) result = search_triples([-5, 2, -1, -2, 3]) print(&quot;Result: &quot; + str(result))if __name__ == &#x27;__main__&#x27;: main() Time complexitySorting the array will take O(N \\ logN)*. The searchPair() function will take O(N). As we are calling searchPair() for every number in the input array, this means that overall searchTriplets() will take O(N \\ logN + N^2)*, which is asymptotically equivalent to O(N^2). Space complexityIgnoring the space required for the output array, the space complexity of the above algorithm will be O(N)O(N) which is required for sorting. Triplet Sum Close to Target (medium)不在leecode Problem StatementGiven an array of unsorted numbers and a target number, find a triplet in the array whose sum is as close to the target number as possible, return the sum of the triplet. If there are more than one such triplet, return the sum of the triplet with the smallest sum. Example 1: 123Input: [-2, 0, 1, 2], target=2Output: 1Explanation: The triplet [-2, 1, 2] has the closest sum to the target. Example 2: 123Input: [-3, -1, 1, 2], target=1Output: 0Explanation: The triplet [-3, 1, 2] has the closest sum to the target. Example 3: 123Input: [1, 0, 1, 1], target=100Output: 3Explanation: The triplet [1, 1, 1] has the closest sum to the target. Try it yourselfTry solving this question here: 12345678910111213141516171819202122232425262728293031323334353637import mathdef search_triples(arr, target): arr.sort() closest_sum = 0 diff = math.inf for i in range(len(arr) - 2): left, right = i + 1, len(arr) - 1 while left &lt; right: local_sum = arr[i] + arr[left] + arr[right] if abs(local_sum - target) &lt; diff: closest_sum = local_sum diff = abs(local_sum - target) elif abs(local_sum - target) == diff: closest_sum = min(closest_sum, local_sum) if local_sum &lt; target: left += 1 elif local_sum &gt; target: right -= 1 else: return local_sum return closest_sumdef main(): result = search_triples([-2, 0, 1, 2], 2) print(&quot;Result: &quot; + str(result)) result = search_triples([-3, -1, 1, 2], 1) print(&quot;Result: &quot; + str(result)) result = search_triples([1, 0, 1, 1], 100) print(&quot;Result: &quot; + str(result))if __name__ == &#x27;__main__&#x27;: main() SolutionThis problem follows the Two Pointers pattern and is quite similar to Triplet Sum to Zero. We can follow a similar approach to iterate through the array, taking one number at a time. At every step, we will save the difference between the triplet and the target number, so that in the end, we can return the triplet with the closest sum. CodeHere is what our algorithm will look like: 1# 和我的一样，不在赘述 Time complexitySorting the array will take O(N\\ logN)*. Overall searchTriplet() will take O(N \\ logN + N^2)*, which is asymptotically equivalent to O(N^2). Space complexityThe space complexity of the above algorithm will be O(N) which is required for sorting. Triplets with Smaller Sum (medium)不在leetcode Problem StatementGiven an array arr of unsorted numbers and a target sum, count all triplets in it such that arr[i] + arr[j] + arr[k] &lt; target where i, j, and k are three different indices. Write a function to return the count of such triplets. Example 1: 123Input: [-1, 0, 2, 3], target=3 Output: 2Explanation: There are two triplets whose sum is less than the target: [-1, 0, 3], [-1, 0, 2] Example 2: 1234Input: [-1, 4, 2, 1, 3], target=5 Output: 4Explanation: There are four triplets whose sum is less than the target: [-1, 1, 4], [-1, 1, 3], [-1, 1, 2], [-1, 2, 3] Try it yourselfTry solving this question here: 123456789101112131415161718192021222324252627282930313233import mathdef triplets_with_smaller_sum(arr, target): arr.sort() count = 0 for i in range(len(arr) - 2): count += search_pair(arr, target - arr[i], i + 1) return countdef search_pair(arr, target, left): right = len(arr) - 1 count = 0 while left &lt; right: if arr[left] + arr[right] &lt; target: count += right - left left += 1 else: right -= 1 return countdef main(): result = triplets_with_smaller_sum([-1, 0, 2, 3], 3) print(&quot;Result: &quot; + str(result)) result = triplets_with_smaller_sum([-1, 4, 2, 1, 3], 5) print(&quot;Result: &quot; + str(result))if __name__ == &#x27;__main__&#x27;: main() SolutionThis problem follows the Two Pointers pattern and shares similarities with Triplet Sum to Zero. The only difference is that, in this problem, we need to find the triplets whose sum is less than the given target. To meet the condition i != j != k we need to make sure that each number is not used more than once. Following a similar approach, first we can sort the array and then iterate through it, taking one number at a time. Let’s say during our iteration we are at number ‘X’, so we need to find ‘Y’ and ‘Z’ such that X + Y + Z &lt; target. At this stage, our problem translates into finding a pair whose sum is less than “$ target - X$” (as from the above equation Y + Z == target - X). We can use a similar approach as discussed in Triplet Sum to Zero. CodeHere is what our algorithm will look like: 1// 上面的就是看了solution之后才写出来的，所以这里就不在重新写了 Time complexitySorting the array will take O(N * logN). The searchPair() will take O(N)O(N). So, overall searchTriplets() will take O(N * logN + N^2), which is asymptotically equivalent to O(N^2). Space complexityIgnoring the space required for the output array, the space complexity of the above algorithm will be O(N) which is required for sorting if we are not using an in-place sorting algorithm. Similar ProblemsProblem: Write a function to return the list of all such triplets instead of the count. How will the time complexity change in this case? Solution: Following a similar approach we can create a list containing all the triplets. Here is the code - only the highlighted lines have changed: 1// 无非就是吧符合条件的加到list中去，这里就不再演示了 Another simpler approach could be to check every triplet of the array with three nested loops and create a list of triplets that meet the required condition. Time complexitySorting the array will take O(N \\ logN)*. The searchPair(), in this case, will take O(N^2); the main while loop will run in O(N) but the nested for loop can also take O(N)O(N) - this will happen when the target sum is bigger than every triplet in the array. So, overall searchTriplets() will take O(N logN + N^3)*, which is asymptotically equivalent to O(N^3). Space complexityIgnoring the space required for the output array, the space complexity of the above algorithm will be O(N) which is required for sorting. *Dutch National Flag Problem (medium)leetcode 75 Problem Statement Given an array containing 0s, 1s and 2s, sort the array in-place. You should treat numbers of the array as objects, hence, we can’t count 0s, 1s, and 2s to recreate the array. The flag of the Netherlands consists of three colors: red, white and blue; and since our input array also consists of three different numbers that is why it is called Dutch National Flag problem. Example 1: 12Input: [1, 0, 2, 1, 0]Output: [0 0 1 1 2] Example 2: 12Input: [2, 2, 0, 1, 2, 0]Output: [0 0 1 2 2 2 ] Try it yourselfTry solving this question here: 12345678910111213141516171819202122232425262728293031import mathdef dutch_flag(arr): left, right = 0, len(arr) - 1 i = 0 while i &lt;= right: if arr[i] == 0: arr[left], arr[i] = arr[i], arr[left] left += 1 # I think more accurate, The groups that girikuncoro mentioned are nums[0 : red - 1] = 0, nums[red : white - 1] = 1, nums[white : blue] = unclassified, nums[blue + 1: n - 1] = 2. red, and blue are exclusively # 这里的i += 1之前不太理解 i += 1 elif arr[i] == 2: arr[right], arr[i] = arr[i], arr[right] right -= 1 else: i += 1 return arrdef main(): result = dutch_flag([2, 0, 2, 1, 0]) print(&quot;Result: &quot; + str(result)) result = dutch_flag([2, 2, 0, 1, 2, 0]) print(&quot;Result: &quot; + str(result))if __name__ == &#x27;__main__&#x27;: main() SolutionThe brute force solution will be to use an in-place sorting algorithm like Heapsort which will take O(NlogN)*. Can we do better than this? Is it possible to sort the array in one iteration? We can use a Two Pointers approach while iterating through the array. Let’s say the two pointers are called low and high which are pointing to the first and the last element of the array respectively. So while iterating, we will move all 0s before low and all 2s after high so that in the end, all 1s will be between low and high. CodeHere is what our algorithm will look like: 1# 和我写的一样，这里就不在赘述 Time complexityThe time complexity of the above algorithm will be O(N) as we are iterating the input array only once. Space complexityThe algorithm runs in constant space O(1). Problem Challenge 1Quadruple Sum to Target (medium)Given an array of unsorted numbers and a target number, find all unique quadruplets in it, whose sum is equal to the target number. Example 1: 123Input: [4, 1, 2, -1, 1, -3], target=1Output: [-3, -1, 1, 4], [-3, 1, 1, 2]Explanation: Both the quadruplets add up to the target. Example 2: 123Input: [2, 0, -1, 1, -2, 2], target=2Output: [-2, 0, 2, 2], [-1, 0, 1, 2]Explanation: Both the quadruplets add up to the target. Try it yourselfTry solving this question here: 1234567891011121314151617181920212223242526272829303132333435363738394041424344def search_quadruplets(arr, target): arr.sort() quadruplets = [] for i in range(len(arr) - 3): # skip same element to avoid duplicate quadruplets if i &gt; 0 and arr[i] == arr[i - 1]: continue for j in range(i + 1, len(arr) - 2): # skip same element to avoid duplicate quadruplets if j &gt; i + 1 and arr[j] == arr[j - 1]: continue search_pair(arr, target, i, j, quadruplets) return quadrupletsdef search_pair(arr, target, first, second, quadruplets): left, right = second + 1, len(arr) - 1 while left &lt; right: local_sum = arr[first] + arr[second] + arr[left] + arr[right] if local_sum &lt; target: left += 1 elif local_sum &gt; target: right -= 1 else: quadruplets.append([arr[first], arr[second], arr[left], arr[right]]) left += 1 right -= 1 while left &lt; right and arr[left] == arr[left - 1]: left += 1 while left &lt; right and arr[right] == arr[right + 1]: right -= 1 return quadrupletsdef main(): result = search_quadruplets([4, 1, 2, -1, 1, -3], 1) print(&quot;Result: &quot; + str(result)) result = search_quadruplets([2, 0, -1, 1, -2, 2], 2) print(&quot;Result: &quot; + str(result))if __name__ == &#x27;__main__&#x27;: main() SolutionThis problem follows the Two Pointers pattern and shares similarities with Triplet Sum to Zero（哈哈，答案也是参考了这道题）. We can follow a similar approach to iterate through the array, taking one number at a time. At every step during the iteration, we will search for the quadruplets similar to Triplet Sum to Zero whose sum is equal to the given target. CodeHere is what our algorithm will look like: 1# 和我写的一样，这里就不在赘述 Time complexitySorting the array will take O(NlogN). Overall searchQuadruplets() will take O(N \\ logN + N^3)*, which is asymptotically equivalent to O(N^3). Space complexityThe space complexity of the above algorithm will be O(N) which is required for sorting. # Problem Challenge 2leetcode 844 和leetcode 有点不一样比如这个例子(“ab##”, “c#d#”) 还有leetcode125 也是比较类似的变体 Comparing Strings containing Backspaces (medium)Given two strings containing backspaces (identified by the character ‘#’), check if the two strings are equal. Example 1: 123Input: str1=&quot;xy#z&quot;, str2=&quot;xzz#&quot;Output: trueExplanation: After applying backspaces the strings become &quot;xz&quot; and &quot;xz&quot; respectively. Example 2: 123Input: str1=&quot;xy#z&quot;, str2=&quot;xyz#&quot;Output: falseExplanation: After applying backspaces the strings become &quot;xz&quot; and &quot;xy&quot; respectively. Example 3: 1234Input: str1=&quot;xp#&quot;, str2=&quot;xyz##&quot;Output: trueExplanation: After applying backspaces the strings become &quot;x&quot; and &quot;x&quot; respectively.In &quot;xyz##&quot;, the first &#x27;#&#x27; removes the character &#x27;z&#x27; and the second &#x27;#&#x27; removes the character &#x27;y&#x27;. Example 4: 123Input: str1=&quot;xywrrmp&quot;, str2=&quot;xywrrmu#p&quot;Output: trueExplanation: After applying backspaces the strings become &quot;xywrrmp&quot; and &quot;xywrrmp&quot; respectively. Try it yourselfTry solving this question here: 1# 不会 SolutionTo compare the given strings, first, we need to apply the backspaces. An efficient way to do this would be from the end of both the strings. We can have separate pointers, pointing to the last element of the given strings. We can start comparing the characters pointed out by both the pointers to see if the strings are equal. If, at any stage, the character pointed out by any of the pointers is a backspace (’#’), we will skip and apply the backspace until we have a valid character available for comparison. CodeHere is what our algorithm will look like: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455def backspace_compare(str1, str2): index1 = len(str1) - 1 index2 = len(str2) - 1 # 注意这里是or (&quot;bbbextm&quot;, &quot;bbb#extm&quot;) while index1 &gt; 0 or index2 &gt; 0: i1 = get_next_valid_index(str1, index1) i2 = get_next_valid_index(str2, index2) # 这个if是对于这个例子(&quot;ab##&quot;, &quot;c#d#&quot;) if i1 == -1 and i2 == -1: return True if i1 &lt; 0 and i2 &lt; 0: return False if i1 &lt; 0 or i2 &lt; 0: return False if str1[i1] != str2[i2]: return False index1 = i1 - 1 index2 = i2 - 1 return Truedef get_next_valid_index(str, index): backspace_count = 0 while index &gt;= 0: if str[index] == &quot;#&quot;: backspace_count += 1 elif backspace_count &gt; 0: backspace_count -= 1 else: break index -= 1 return indexdef main(): result = backspace_compare(&quot;xy#z&quot;, &quot;xzz#&quot;) print(&quot;Result: &quot; + str(result)) result = backspace_compare(&quot;xy#z&quot;, &quot;xyz#&quot;) print(&quot;Result: &quot; + str(result)) result = backspace_compare(&quot;xp#&quot;, &quot;xyz##&quot;) print(&quot;Result: &quot; + str(result)) result = backspace_compare(&quot;xywrrmp&quot;, &quot;xywrrmu#p&quot;) print(&quot;Result: &quot; + str(result)) print(&quot;leetcode:&quot;) result = backspace_compare(&quot;ab##&quot;, &quot;c#d#&quot;) print(&quot;Result: &quot; + str(result)) result = backspace_compare(&quot;a#c&quot;, &quot;b&quot;) print(&quot;Result: &quot; + str(result)) result = backspace_compare(&quot;bbbextm&quot;, &quot;bbb#extm&quot;) print(&quot;Result: &quot; + str(result))if __name__ == &#x27;__main__&#x27;: main() Time complexityThe time complexity of the above algorithm will be O(M+N) where ‘M’ and ‘N’ are the lengths of the two input strings respectively. Space complexityThe algorithm runs in constant space O(1). *Problem Challenge 3leetcode 581 Minimum Window Sort (medium)Given an array, find the length of the smallest subarray in it which when sorted will sort the whole array. Example 1: 123Input: [1, 2, 5, 3, 7, 10, 9, 12]Output: 5Explanation: We need to sort only the subarray [5, 3, 7, 10, 9] to make the whole array sorted Example 2: 123Input: [1, 3, 2, 0, -1, 7, 10]Output: 5Explanation: We need to sort only the subarray [1, 3, 2, 0, -1] to make the whole array sorted Example 3: 123Input: [1, 2, 3]Output: 0Explanation: The array is already sorted Example 4: 123Input: [3, 2, 1]Output: 3Explanation: The whole array needs to be sorted. Try it yourselfTry solving this question here: 1# 不会 SolutionAs we know, once an array is sorted (in ascending order), the smallest number is at the beginning and the largest number is at the end of the array. So if we start from the beginning of the array to find the first element which is out of sorting order i.e., which is smaller than its previous element, and similarly from the end of array to find the first element which is bigger than its previous element, will sorting the subarray between these two numbers result in the whole array being sorted? Let’s try to understand this with Example-2 mentioned above. In the following array, what are the first numbers out of sorting order from the beginning and the end of the array: 1[1, 3, 2, 0, -1, 7, 10] Starting from the beginning of the array the first number out of the sorting order is ‘2’ as it is smaller than its previous element which is ‘3’. Starting from the end of the array the first number out of the sorting order is ‘0’ as it is bigger than its previous element which is ‘-1’ As you can see, sorting the numbers between ‘3’ and ‘-1’ will not sort the whole array. To see this, the following will be our original array after the sorted subarray: 1[1, -1, 0, 2, 3, 7, 10] The problem here is that the smallest number of our subarray is ‘-1’ which dictates that we need to include more numbers from the beginning of the array to make the whole array sorted. We will have a similar problem if the maximum of the subarray is bigger than some elements at the end of the array. To sort the whole array we need to include all such elements that are smaller than the biggest element of the subarray. So our final algorithm will look like: From the beginning and end of the array, find the first elements that are out of the sorting order. The two elements will be our candidate subarray. Find the maximum and minimum of this subarray. Extend the subarray from beginning to include any number which is bigger than the minimum of the subarray. Similarly, extend the subarray from the end to include any number which is smaller than the maximum of the subarray. CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233343536373839import mathdef shortest_window_sort(arr): low, high = 0, len(arr) - 1 while low &lt; len(arr) - 1 and arr[low] &lt;= arr[low + 1]: low += 1 if low == len(arr) - 1: # already sorted return 0 while high &gt; 0 and arr[high] &gt;= arr[high - 1]: high -= 1 subarray_max = -math.inf subarray_min = math.inf # subarray_max = -float(&#x27;inf&#x27;) 也可以 # subarray_min = float(&#x27;inf&#x27;) for k in range(low, high + 1): subarray_min = min(subarray_min, arr[k]) subarray_max = max(subarray_max, arr[k]) while low &gt; 0 and arr[low - 1] &gt; subarray_min: low -= 1 while high &lt; len(arr) - 1 and arr[high + 1] &lt; subarray_max: high += 1 return high - low + 1def main(): result = shortest_window_sort([1, 2, 5, 3, 7, 10, 9, 12]) print(&quot;Result: &quot; + str(result)) result = shortest_window_sort([1, 3, 2, 0, -1, 7, 10]) print(&quot;Result: &quot; + str(result)) result = shortest_window_sort([1, 2, 3]) print(&quot;Result: &quot; + str(result)) result = shortest_window_sort([3, 2, 1]) print(&quot;Result: &quot; + str(result))if __name__ == &#x27;__main__&#x27;: main() Time complexityThe time complexity of the above algorithm will be O(N). Space complexityThe algorithm runs in constant space O(1).","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://hasuer.github.io/categories/Algorithm/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hasuer.github.io/tags/Interview/"}]},{"title":"0.Introduction","slug":"0. Introduction","date":"2024-04-30T01:39:45.000Z","updated":"2024-04-30T01:41:37.199Z","comments":true,"path":"0-introduction/index.html","link":"","permalink":"https://hasuer.github.io/0-introduction/index.html","excerpt":"","text":"IntroductionWho should take this course?Thanks for choosing this course! We hope the techniques you learn here go a long way towards building solid algorithmic skills. Intended AudienceIf you want to work on your algorithms and problem-solving skills, this course is for you. Systematically, we will start with easier problems to develop an understanding of the underlying solution patterns and then apply these patterns to solve difficult ones. Every problem presented in this course has been solved in Java, Python, C++, and JavaScript. PrerequisitesYou need to have a basic understanding of common data-structures like Array, LinkedList, HashMap, Stack, Queue, Heap, and Graph. You should also be familiar with Recursion) and Big-O. Course OverviewThis course categorizes coding interview problems into a set of 16 patterns. Each pattern will be a complete tool - consisting of data structures, algorithms, and analysis techniques - to solve a specific category of problems. The goal is to develop an understanding of the underlying pattern, so that, we can apply that pattern to solve other problems. We have chosen each problem carefully such that it not only maps to the same pattern but also presents different constraints. Overall, the course has around 150 problems mapped to 16 patterns. The problems solved under these patterns use a varied set of algorithmic techniques. We will make use of Breadth-First Search and Depth-First Search to solve problems related to Trees and Graphs. Similarly, we will also cover Dynamic Programming, Backtracking, Recursion, Greedy algorithms, and Divide &amp; Conquer. We will start with a brief introduction of each pattern before jumping onto the problems. Under each pattern, the first problem will explain the underlying pattern in detail to build the concepts that can be applied to later problems. The later problems will focus on the different constraints each problem presents and how our algorithm needs to change to handle them. Let’s start with the Sliding Window pattern.","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://hasuer.github.io/categories/Algorithm/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hasuer.github.io/tags/Interview/"}]},{"title":"Ubuntu20.04安装配置MySQL8(详细)","slug":"Ubuntu20-04安装配置MySQL8","date":"2022-06-12T15:01:42.000Z","updated":"2022-06-12T17:59:52.398Z","comments":true,"path":"ubuntu20-04安装配置mysql8-详细/index.html","link":"","permalink":"https://hasuer.github.io/ubuntu20-04%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEmysql8-%E8%AF%A6%E7%BB%86/index.html","excerpt":"","text":"文章的第一节转载自原文连接 本文实现了服务器ubuntu18.04和虚拟机ubuntu20.04两个版本的MySQL8 的安装，和navicat的连接。其中ubuntu18.04对应第二节，ubuntu20.04是ubuntu focal的，对应第三节。 1. 彻底删除mysql5.71.1 查看mysql的依赖项1dpkg --list|grep mysql 1.2 卸载1sudo apt-get remove mysql-common 在卸载过程中输入yes 1.3 卸载（最后的版本数字根据自己具体的版本进行相应的修改）1sudo apt-get autoremove --purge mysql-server-5.7 1.4 清除残留数据1dpkg -l|grep ^rc|awk &#x27;&#123;print$2&#125;&#x27;|sudo xargs dpkg -P 出现下图界面，选择&lt;YES&gt; 1.5 再次查看依赖1dpkg --list|grep mysql 发现有如下残留 使用命令sudo apt-get autoremove --purge xxxx来卸载： 1sudo apt-get autoremove --purge php5.6-mysql 执行之后再次使用命令查看： 1dpkg --list|grep mysql 输入命令之后没有任何返回即成功，这里输入了两次： 2. 服务器（ubuntu18.04）安装MySQL82.1 使用命令下载存储库软件包1wget -c https://dev.mysql.com/get/mysql-apt-config_0.8.10-1_all.deb 2.2 使用命令安装上边下载的安装包1sudo dpkg -i mysql-apt-config_0.8.10-1_all.deb 安装过程中提示选择安装版本，默认安装的就是8.0版本，所以直接选择“OK”确认即可； 2.3 从所有已配置的存储库（包括新添加的 MySQL 8存储库）中下载最新的软件包信息：1sudo apt update 可能的报错： 解决： 查看签名列表： 1apt-key list 删除过期的签名；（del 后跟上条指令查到的pub） 1sudo apt-key del dsa1024 重新添加新的签名 GPG error: http://repo.mysql.com/apt/ubuntu focal InRelease: The following signatures couldn’t be verified because the public key is not available: NO_PUBKEY 467B942D3A79BD29 1sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 467B942D3A79BD29 之后继续执行更新命令: 1sudo apt update 2.4 安装MySQL81sudo apt install mysql-server 安装过程中会提示设置root密码。按照提示输入即可； 输入之后会出现选择加密方式的提示界面，我在网上的教程中看到默认的mysql8.0的加密方式与ubuntu18.04 及以上不兼容，所以选择5.x的加密方式；建议选择下边的那个： 2.5 验证1mysql -uroot -p [图片] 3. 在Ubuntu 20.04 LTS Focal Fossa上安装MySQL8在上一节中，执行命令sudo dpkg -i mysql-apt-config_0.8.10-1_all.deb的时候提示这是ubuntu focal系统，这里根据教程来安装。 Step 1: Update the system to the latest1sudo apt update Step 2: Install MySQL on Ubuntu 20.041sudo apt install mysql-server Step 3: Secure MySQL installation\\1sudo mysql_secure_installation 可能的问题： 设置完密码之后按照要求”Do you wish to continue with the password provided?”输入yes报错如下： [MySQL Failed! Error: SET PASSWORD has no significance for user ‘root’@’localhost’ as the authentication method used doesn’t store authentication data in the MySQL server. Please consider using ALTER USER](https://www.nixcraft.com/t/mysql-failed-error-set-password-has-no-significance-for-user-root-localhost-as-the-authentication-method-used-doesnt-store-authentication-data-in-the-mysql-server-please-consider-using-alter-user/4233) 解决： Open the terminal application. Terminate the mysql_secure_installation from another terminal using the killall command:sudo killall -9 mysql_secure_installation Start the mysql client:sudo mysql Run the following SQL query: 12ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;SetRootPasswordHere&#x27;;exit Then run the following command to secure it:sudo mysql_secure_installation When promoted for the password enter the SetRootPasswordHere (or whatever you set when you ran the above SQL query) That is all. 成功界面如下： Step 4: Test MySQL Community Server service1systemctl status mysql.service 1mysql -uroot -p 4. navicat 连接4.1 连接报错1103[图片] 原因:帐号不允许从远程登陆，只能在localhost。这个时候只要在localhost的那台电脑，登入mysql后，更改”mysql” 数据库里的 “user” 表里的 “host”项，从”localhost”改称”%” 在虚拟机/服务器上进入mysql: use mysql; select host, user from user; update user set host = &#39;%&#39; where user = &#39;root&#39;; flush privileges; service mysql restart 4.2 连接报错2003 在windows下，cmd 输入 1telnet 192.168.xxx.xxx 3306 在虚拟机下输入 1netstat -anp| grep 3306 修改/etc/mysql/mysql.conf.d/mysqld.cnf 需要root权限，sudo passwd root设置root密码， su进入root. 1vim /etc/mysql/mysql.conf.d/mysqld.cnf 把 bind-address = 127.0.0.1 改为 bind-address = 0.0.0.0 上面的意思是改为监听所有地址 重启MySQL 1service mysql restart","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://hasuer.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"新英文杂志","slug":"新英文杂志","date":"2022-03-12T18:11:58.000Z","updated":"2022-03-12T18:15:30.099Z","comments":true,"path":"新英文杂志/index.html","link":"","permalink":"https://hasuer.github.io/%E6%96%B0%E8%8B%B1%E6%96%87%E6%9D%82%E5%BF%97/index.html","excerpt":"","text":"in light of 考虑到 nuanced adj. 有细微差别的 a much more nuanced picture 一个更加细致的局面/情况 wind up doing/ in sth. 以…告终 I always said he would wiind up in prison. quintessential adj. 典型的，范例的 take hold 产生影响后受欢迎 as the idea took hold that … sobering 令人警醒的，使人冷静的 a/the silver lining 困境中的一丝希望","categories":[],"tags":[]},{"title":"Axios学习笔记","slug":"Axios学习笔记","date":"2022-02-25T07:03:16.000Z","updated":"2022-02-25T12:06:54.964Z","comments":true,"path":"axios学习笔记/index.html","link":"","permalink":"https://hasuer.github.io/axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html","excerpt":"","text":"此笔记转载自这里,对应的视频课程是尚硅谷Web前端axios入门与源码解析 预备工具 作为一个前端开发工程师，在后端还没有ready的时候，不可避免的要使用mock的数据。很多时候，我们并不想使用简单的静态数据，而是希望自己起一个本地的mock-server来完全模拟请求以及请求回来的过程。json-server是一个很好的可以替我们完成这一工作的工具。我们只需要提供一个json文件，或者写几行简单的js脚本就可以模拟出RESTful API的接口。 安装json-servernpm install -g json-server 创建db.json在一个文件夹下新建一个db.json文件 123456789&gt;&#123;&gt;&quot;posts&quot;: [ &#123; &quot;id&quot;: 1, &quot;title&quot;: &quot;json-server&quot;, &quot;author&quot;: &quot;typicode&quot; &#125;&gt;],&gt;&quot;comments&quot;: [ &#123; &quot;id&quot;: 1, &quot;body&quot;: &quot;some comment&quot;, &quot;postId&quot;: 1 &#125;&gt;],&gt;&quot;profile&quot;: &#123; &quot;name&quot;: &quot;typicode&quot; &#125;&gt;&#125; 启动json-server在当前文件夹下输入如下命令：json-server db.json 文档 一、Axios的理解与使用axios 是什么? 前端最流行的 ajax 请求库 react/vue 官方都推荐使用 axios 发 ajax 请求 文档: https://github.com/axios/axios axios 特点 基于 xhr + promise 的异步 ajax 请求库 浏览器端/node 端都可以使用 支持请求／响应拦截器 支持请求取消 请求/响应数据转换 批量发送多个请求 axios 常用语法 axios(config): 通用/最本质的发任意类型请求的方式 axios(url[, config]): 可以只指定 url 发 get 请求 axios.request(config): 等同于 axios(config) axios.get(url[, config]): 发 get 请求 axios.delete(url[, config]): 发 delete 请求 axios.post(url[, data, config]): 发 post 请求 axios.put(url[, data, config]): 发 put 请求 axios.defaults.xxx: 请求的默认全局配置 axios.interceptors.request.use(): 添加请求拦截器 axios.interceptors.response.use(): 添加响应拦截器 axios.create([config]): 创建一个新的 axios(它没有下面的功能) axios.Cancel(): 用于创建取消请求的错误对象 axios.CancelToken(): 用于创建取消请求的 token 对象 axios.isCancel(): 是否是一个取消请求的错误 axios.all(promises): 用于批量执行多个异步请求 axios.spread(): 用来指定接收所有成功数据的回调函数的方法 原理图 难点语法的理解和使用axios.create(config) 根据指定配置创建一个新的 axios, 也就就每个新 axios 都有自己的配置 新 axios 只是没有取消请求和批量发请求的方法, 其它所有语法都是一致的 为什么要设计这个语法? (1) 需求: 项目中有部分接口需要的配置与另一部分接口需要的配置不太一样, 如何处理 (2) 解决: 创建 2 个新 axios, 每个都有自己特有的配置, 分别应用到不同要 求的接口请求中 123456789101112131415161718//创建实例对象 /getJoke const duanzi = axios.create(&#123; baseURL: &#x27;https://api.apiopen.top&#x27;, timeout: 2000 &#125;); const onather = axios.create(&#123; baseURL: &#x27;https://b.com&#x27;, timeout: 2000 &#125;); //这里 duanzi 与 axios 对象的功能几近是一样的 // duanzi(&#123; // url: &#x27;/getJoke&#x27;, // &#125;).then(response =&gt; &#123; // console.log(response); // &#125;); duanzi.get(&#x27;/getJoke&#x27;).then(response =&gt; &#123; console.log(response.data) &#125;) 拦截器函数/ajax 请求/请求的回调函数的调用顺序 说明: 调用 axios()并不是立即发送 ajax 请求, 而是需要经历一个较长的流程 流程: 请求拦截器2 =&gt; 请求拦截器1 =&gt; 发ajax请求 =&gt; 响应拦截器1 =&gt; 响应拦截器 2 =&gt; 请求的回调 注意: 此流程是通过 promise 串连起来的, 请求拦截器传递的是 config, 响应 拦截器传递的是 response 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;script&gt; // Promise // 设置请求拦截器 config 配置对象 axios.interceptors.request.use(function (config) &#123; console.log(&#x27;请求拦截器 成功 - 1号&#x27;); //修改 config 中的参数 config.params = &#123; a: 100 &#125;; return config; &#125;, function (error) &#123; console.log(&#x27;请求拦截器 失败 - 1号&#x27;); return Promise.reject(error); &#125;); axios.interceptors.request.use(function (config) &#123; console.log(&#x27;请求拦截器 成功 - 2号&#x27;); //修改 config 中的参数 config.timeout = 2000; return config; &#125;, function (error) &#123; console.log(&#x27;请求拦截器 失败 - 2号&#x27;); return Promise.reject(error); &#125;); // 设置响应拦截器 axios.interceptors.response.use(function (response) &#123; console.log(&#x27;响应拦截器 成功 1号&#x27;); return response.data; // return response; &#125;, function (error) &#123; console.log(&#x27;响应拦截器 失败 1号&#x27;) return Promise.reject(error); &#125;); axios.interceptors.response.use(function (response) &#123; console.log(&#x27;响应拦截器 成功 2号&#x27;) return response; &#125;, function (error) &#123; console.log(&#x27;响应拦截器 失败 2号&#x27;) return Promise.reject(error); &#125;); //发送请求 axios(&#123; method: &#x27;GET&#x27;, url: &#x27;http://localhost:3000/posts&#x27; &#125;).then(response =&gt; &#123; console.log(&#x27;自定义回调处理成功的结果&#x27;); console.log(response); &#125;);&lt;/script&gt; 取消请求 基本流程 配置 cancelToken 对象 缓存用于取消请求的 cancel 函数 在后面特定时机调用 cancel 函数取消请求 在错误回调中判断如果 error 是 cancel, 做相应处理 实现功能 点击按钮, 取消某个正在请求中的请求, 实现功能 点击按钮, 取消某个正在请求中的请求 123456789101112131415161718192021222324252627282930&lt;script&gt; //获取按钮 const btns = document.querySelectorAll(&#x27;button&#x27;); //2.声明全局变量 let cancel = null; //发送请求 btns[0].onclick = function () &#123; //检测上一次的请求是否已经完成 if (cancel !== null) &#123; //取消上一次的请求 cancel(); &#125; axios(&#123; method: &#x27;GET&#x27;, url: &#x27;http://localhost:3000/posts&#x27;, //1. 添加配置对象的属性 cancelToken: new axios.CancelToken(function (c) &#123; //3. 将 c 的值赋值给 cancel cancel = c; &#125;) &#125;).then(response =&gt; &#123; console.log(response); //将 cancel 的值初始化 cancel = null; &#125;) &#125; //绑定第二个事件取消请求 btns[1].onclick = function () &#123;cancel(); &#125;&lt;/script&gt; 默认配置 12345678910111213&gt;//默认配置 axios.defaults.method = &#x27;GET&#x27;;//设置默认的请求类型为 GET axios.defaults.baseURL = &#x27;http://localhost:3000&#x27;;//设置基础 URL axios.defaults.params = &#123;id:100&#125;; axios.defaults.timeout = 3000;// btns[0].onclick = function()&#123; axios(&#123; url: &#x27;/posts&#x27; &#125;).then(response =&gt; &#123; console.log(response); &#125;) &#125; Axios的难点问题目录结构 ├── /dist/ # 项目输出目录├── /lib/ # 项目源码目录│ ├── /adapters/ # 定义请求的适配器 xhr、http│ │ ├── http.js # 实现 http 适配器(包装 http 包)│ │ └── xhr.js # 实现 xhr 适配器(包装 xhr 对象)│ ├── /cancel/ # 定义取消功能│ ├── /core/ # 一些核心功能│ │ ├── Axios.js # axios 的核心主类│ │ ├── dispatchRequest.js # 用来调用 http 请求适配器方法发送请求的函数│ │ ├── InterceptorManager.js # 拦截器的管理器│ │ └── settle.js # 根据 http 响应状态，改变 Promise 的状态│ ├── /helpers/ # 一些辅助方法│ ├── axios.js # 对外暴露接口│ ├── defaults.js # axios 的默认配置│ └── utils.js # 公用工具├── package.json # 项目信息├── index.d.ts # 配置 TypeScript 的声明文件└── index.js # 入口文件 axios 与 Axios 的关系 从语法上来说: axios 不是 Axios 的实例 从功能上来说: axios 是 Axios 的实例 axios 是 Axios.prototype.request 函数 bind()返回的函数 axios 作为对象有 Axios 原型对象上的所有方法, 有 Axios 对象上所有属性 instance 与 axios 的区别? 相同:(1) 都是一个能发任意请求的函数: request(config)(2) 都有发特定请求的各种方法: get()/post()/put()/delete()(3) 都有默认配置和拦截器的属性: defaults/interceptors 不同:(1) 默认配置很可能不一样(2) instance 没有 axios 后面添加的一些方法: create()/CancelToken()/all() axios运行的整体流程 整体流程:request(config) ==&gt; dispatchRequest(config) ==&gt; xhrAdapter(config) request(config):将请求拦截器 / dispatchRequest() / 响应拦截器 通过 promise 链串连起来, 返回 promise dispatchRequest(config):转换请求数据 ===&gt; 调用 xhrAdapter()发请求 ===&gt; 请求返回后转换响应数 据. 返回 promise xhrAdapter(config):创建 XHR 对象, 根据 config 进行相应设置, 发送特定请求, 并接收响应数据, 返回 promise 流程图: axios 的请求/响应拦截器是什么? 请求拦截器:Ⅰ- 在真正发送请求前执行的回调函数Ⅱ- 可以对请求进行检查或配置进行特定处理Ⅲ- 成功的回调函数, 传递的默认是 config(也必须是)Ⅳ- 失败的回调函数, 传递的默认是 error 响应拦截器Ⅰ- 在请求得到响应后执行的回调函数Ⅱ- 可以对响应数据进行特定处理Ⅲ- 成功的回调函数, 传递的默认是 responseⅣ- 失败的回调函数, 传递的默认是 error axios 的请求/响应数据转换器是什么? 请求转换器: 对请求头和请求体数据进行特定处理的函数 1234&gt;if (utils.isObject(data)) &#123;setContentTypeIfUnset(headers, &#x27;application/json;charset=utf-8&#x27;);return JSON.stringify(data);&gt;&#125; 响应转换器: 将响应体 json 字符串解析为 js 对象或数组的函数 1&gt;response.data = JSON.parse(response.data) response与error 的整体结构 response的整体结构 123&gt;&#123;&gt;data, status,statusText,headers,config,request&gt;&#125; error 的整体结构 123&gt;&#123;&gt;message,response,request,&gt;&#125; 如何取消未完成的请求? 当配置了 cancelToken 对象时, 保存 cancel 函数(1) 创建一个用于将来中断请求的 cancelPromise(2) 并定义了一个用于取消请求的 cancel 函数(3) 将 cancel 函数传递出来 调用 cancel()取消请求(1) 执行 cacel 函数, 传入错误信息 message(2) 内部会让 cancelPromise 变为成功, 且成功的值为一个 Cancel 对象(3) 在 cancelPromise 的成功回调中中断请求, 并让发请求的 proimse 失败,失败的 reason 为 Cancel 对象 Axios源码模拟实现axios 的创建过程模拟实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&gt;&lt;script&gt;&gt;//构造函数&gt;function Axios(config) &#123;//初始化this.defaults = config; //为了创建 default 默认属性this.intercepters = &#123; request: &#123;&#125;, response: &#123;&#125;&#125;&gt;&#125;&gt;//原型添加相关的方法&gt;Axios.prototype.request = function (config) &#123;console.log(&#x27;发送 AJAX 请求 请求的类型为 &#x27; + config.method);&gt;&#125;&gt;Axios.prototype.get = function (config) &#123;return this.request(&#123; method: &#x27;GET&#x27;&#125;);&gt;&#125;&gt;Axios.prototype.post = function (config) &#123;return this.request(&#123; method: &#x27;POST&#x27;&#125;);&gt;&#125;&gt;//声明函数&gt;function createInstance(config) &#123;//实例化一个对象let context = new Axios(config); // context.get() context.post() 但是不能当做函数使用 context() X//创建请求函数let instance = Axios.prototype.request.bind(context); // instance 是一个函数 并且可以 instance(&#123;&#125;) 此时 instance 不能 instance.get X//将 Axios.prototype 对象中的方法添加到instance函数对象中,才可以instance.get....Object.keys(Axios.prototype).forEach(key =&gt; &#123; instance[key] = Axios.prototype[key].bind(context); // this.default this.interceptors&#125;);//为 instance 函数对象添加属性 default 与 interceptorsObject.keys(context).forEach(key =&gt; &#123; instance[key] = context[key];&#125;);return instance;&gt;&#125;&gt;let axios = createInstance();&gt;//发送请求&gt;// axios(&#123;method:&#x27;POST&#x27;&#125;);&gt;axios.get(&#123;&#125;);&gt;axios.post(&#123;&#125;);&gt;&lt;/script&gt; axios发送请求过程详解 整体流程:request(config) ==&gt; dispatchRequest(config) ==&gt; xhrAdapter(config) request(config):将请求拦截器 / dispatchRequest() / 响应拦截器 通过 promise 链串连起来,返回 promise dispatchRequest(config):转换请求数据 ===&gt; 调用 xhrAdapter()发请求 ===&gt; 请求返回后转换响应数据. 返回 promise xhrAdapter(config):创建 XHR 对象, 根据 config 进行相应设置, 发送特定请求, 并接收响应数据,返回 promise 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&gt;&lt;script&gt; // axios 发送请求 axios Axios.prototype.request bind //1. 声明构造函数 function Axios(config) &#123; this.config = config; &#125; Axios.prototype.request = function (config) &#123; //发送请求 //创建一个 promise 对象 let promise = Promise.resolve(config); //声明一个数组 let chains = [dispatchRequest, undefined]; // undefined 占位 //调用 then 方法指定回调 let result = promise.then(chains[0], chains[1]); //返回 promise 的结果 return result; &#125; //2. dispatchRequest 函数 function dispatchRequest(config) &#123; //调用适配器发送请求 return xhrAdapter(config).then(response =&gt; &#123; //响应的结果进行转换处理 //.... return response; &#125;, error =&gt; &#123; throw error; &#125;); &#125; //3. adapter 适配器 function xhrAdapter(config) &#123; console.log(&#x27;xhrAdapter 函数执行&#x27;); return new Promise((resolve, reject) =&gt; &#123; //发送 AJAX 请求 let xhr = new XMLHttpRequest(); //初始化 xhr.open(config.method, config.url); //发送 xhr.send(); //绑定事件 xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; //判断成功的条件 if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123; //成功的状态 resolve(&#123; //配置对象 config: config, //响应体 data: xhr.response, //响应头 headers: xhr.getAllResponseHeaders(), //字符串 parseHeaders // xhr 请求对象 request: xhr, //响应状态码 status: xhr.status, //响应状态字符串 statusText: xhr.statusText &#125;); &#125; else &#123; //失败的状态 reject(new Error(&#x27;请求失败 失败的状态码为&#x27; + xhr.status)); &#125; &#125; &#125; &#125;); &#125; //4. 创建 axios 函数 let axios = Axios.prototype.request.bind(null); axios(&#123; method: &#x27;GET&#x27;, url: &#x27;http://localhost:3000/posts&#x27; &#125;).then(response =&gt; &#123; console.log(response); &#125;);&lt;/script&gt; 拦截器的模拟实现 array.shift()该方法用于把数组的第一个元素从其中删除，并返回第一个元素的值 思路为先将拦截器的响应回调与请求回调都压入一个数组中,之后进行遍历运行 promise = promise.then(chains.shift(), chains.shift()); 通过循环使用promise的then链条得到最终的结果—&gt;等式前面的promise将被最终的结果覆盖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&gt;&lt;!DOCTYPE html&gt;&gt;&lt;html lang=&quot;en&quot;&gt;&gt;&lt;head&gt;&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&gt;&lt;title&gt;拦截器&lt;/title&gt;&gt;&lt;!-- &lt;script src=&quot;./node_modules/axios/dist/mine-axios.js&quot;&gt;&lt;/script&gt; --&gt;&gt;&lt;/head&gt;&gt;&lt;body&gt;&gt;&lt;script&gt; //构造函数 function Axios(config)&#123; this.config = config; this.interceptors = &#123; request: new InterceptorManager(), response: new InterceptorManager(), &#125; &#125; //发送请求 难点与重点 Axios.prototype.request = function(config)&#123; //创建一个 promise 对象 let promise = Promise.resolve(config); //创建一个数组 const chains = [dispatchRequest, undefined]; //处理拦截器 //请求拦截器 将请求拦截器的回调 压入到 chains 的前面 request.handles = [] this.interceptors.request.handlers.forEach(item =&gt; &#123; chains.unshift(item.fulfilled, item.rejected); &#125;); //响应拦截器 this.interceptors.response.handlers.forEach(item =&gt; &#123; chains.push(item.fulfilled, item.rejected); &#125;); // console.log(chains); //遍历 while(chains.length &gt; 0)&#123; //array.shift() promise = promise.then(chains.shift(), chains.shift()); &#125; return promise; &#125; //发送请求 function dispatchRequest(config)&#123; //返回一个promise 队形 return new Promise((resolve, reject) =&gt; &#123; resolve(&#123; status: 200, statusText: &#x27;OK&#x27; &#125;); &#125;); &#125; //创建实例 let context = new Axios(&#123;&#125;); //创建axios函数 let axios = Axios.prototype.request.bind(context); //将 context 属性 config interceptors 添加至 axios 函数对象身上 Object.keys(context).forEach(key =&gt; &#123; axios[key] = context[key]; &#125;); //拦截器管理器构造函数 function InterceptorManager()&#123; this.handlers = []; &#125; InterceptorManager.prototype.use = function(fulfilled, rejected)&#123; this.handlers.push(&#123; fulfilled, rejected &#125;) &#125; //以下为功能测试代码 // 设置请求拦截器 config 配置对象 axios.interceptors.request.use(function one(config) &#123; console.log(&#x27;请求拦截器 成功 - 1号&#x27;); return config; &#125;, function one(error) &#123; console.log(&#x27;请求拦截器 失败 - 1号&#x27;); return Promise.reject(error); &#125;); axios.interceptors.request.use(function two(config) &#123; console.log(&#x27;请求拦截器 成功 - 2号&#x27;); return config; &#125;, function two(error) &#123; console.log(&#x27;请求拦截器 失败 - 2号&#x27;); return Promise.reject(error); &#125;); // 设置响应拦截器 axios.interceptors.response.use(function (response) &#123; console.log(&#x27;响应拦截器 成功 1号&#x27;); return response; &#125;, function (error) &#123; console.log(&#x27;响应拦截器 失败 1号&#x27;) return Promise.reject(error); &#125;); axios.interceptors.response.use(function (response) &#123; console.log(&#x27;响应拦截器 成功 2号&#x27;) return response; &#125;, function (error) &#123; console.log(&#x27;响应拦截器 失败 2号&#x27;) return Promise.reject(error); &#125;); //发送请求 axios(&#123; method: &#x27;GET&#x27;, url: &#x27;http://localhost:3000/posts&#x27; &#125;).then(response =&gt; &#123; console.log(response); &#125;);&gt;&lt;/script&gt;&gt;&lt;/body&gt;&gt;&lt;/html&gt; 请求取消功能模拟实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&gt;&lt;!DOCTYPE html&gt;&gt;&lt;html lang=&quot;en&quot;&gt;&gt;&lt;head&gt;&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&gt;&lt;title&gt;取消请求&lt;/title&gt;&gt;&lt;link crossorigin=&#x27;anonymous&#x27; href=&quot;https://cdn.bootcss.com/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;&gt;rel=&quot;stylesheet&quot;&gt;&gt;&lt;!-- &lt;script src=&quot;./node_modules/axios/dist/mine-axios.js&quot;&gt;&lt;/script&gt; --&gt;&gt;&lt;/head&gt;&gt;&lt;body&gt;&gt;&lt;div class=&quot;container&quot;&gt;&gt;&lt;h2 class=&quot;page-header&quot;&gt;axios取消请求&lt;/h2&gt;&gt;&lt;button class=&quot;btn btn-primary&quot;&gt; 发送请求 &lt;/button&gt;&gt;&lt;button class=&quot;btn btn-warning&quot;&gt; 取消请求 &lt;/button&gt;&gt;&lt;/div&gt;&gt;&lt;script&gt;&gt;//构造函数&gt;function Axios(config) &#123;this.config = config;&gt;&#125;&gt;//原型 request 方法&gt;Axios.prototype.request = function (config) &#123;return dispatchRequest(config);&gt;&#125;&gt;//dispatchRequest 函数&gt;function dispatchRequest(config) &#123;return xhrAdapter(config);&gt;&#125;&gt;//xhrAdapter&gt;function xhrAdapter(config) &#123;//发送 AJAX 请求return new Promise((resolve, reject) =&gt; &#123; //实例化对象 const xhr = new XMLHttpRequest(); //初始化 xhr.open(config.method, config.url); //发送 xhr.send(); //处理结果 xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; //判断结果 if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123; //设置为成功的状态 resolve(&#123; status: xhr.status, statusText: xhr.statusText &#125;); &#125; else &#123; reject(new Error(&#x27;请求失败&#x27;)); &#125; &#125; &#125; //关于取消请求的处理 if (config.cancelToken) &#123; //对 cancelToken 对象身上的 promise 对象指定成功的回调 config.cancelToken.promise.then(value =&gt; &#123; xhr.abort(); //将整体结果设置为失败 reject(new Error(&#x27;请求已经被取消&#x27;)) &#125;); &#125;&#125;)&gt;&#125;&gt;//创建 axios 函数&gt;const context = new Axios(&#123;&#125;);&gt;const axios = Axios.prototype.request.bind(context);&gt;//CancelToken 构造函数&gt;function CancelToken(executor) &#123;//声明一个变量var resolvePromise;//为实例对象添加属性this.promise = new Promise((resolve) =&gt; &#123; //将 resolve 赋值给 resolvePromise resolvePromise = resolve&#125;);//调用 executor 函数executor(function () &#123; //执行 resolvePromise 函数 resolvePromise();&#125;);&gt;&#125;&gt;//获取按钮 以上为模拟实现的代码&gt;const btns = document.querySelectorAll(&#x27;button&#x27;);&gt;//2.声明全局变量&gt;let cancel = null;&gt;//发送请求&gt;btns[0].onclick = function () &#123;//检测上一次的请求是否已经完成if (cancel !== null) &#123; //取消上一次的请求 cancel();&#125;//创建 cancelToken 的值let cancelToken = new CancelToken(function (c) &#123; cancel = c;&#125;);axios(&#123; method: &#x27;GET&#x27;, url: &#x27;http://localhost:3000/posts&#x27;, //1. 添加配置对象的属性 cancelToken: cancelToken&#125;).then(response =&gt; &#123; console.log(response); //将 cancel 的值初始化 cancel = null;&#125;)&gt;&#125;&gt;//绑定第二个事件取消请求&gt;btns[1].onclick = function () &#123;cancel();&gt;&#125;&gt;&lt;/script&gt;&gt;&lt;/body&gt;&gt;&lt;/html&gt; 原作者对于某些问题解答与理解axios同步与异步转换,在外部取值12345678910111213141516171819202122232425262728293031323334const axios = require (&#x27;axios&#x27;); //创建实例对象 const $http = axios.create(&#123; baseURL: &#x27;http://localhost:53000&#x27;, timeout: 11000 //请求超时时间&#125;);let resolveCommon = ()=&gt; &#123; let data=$http(&#123; url:&quot;/test&quot;&#125;) .then(v=&gt;v.data) //等于 `.then(v=&gt;&#123;return v&#125;)` console.log(data) //打印结果: Promise &#123; &lt;pending&gt; &#125; &#125;;let resolveAsync=async ()=&gt; &#123; let data=await $http(&#123; url:&quot;/test&quot;&#125;) .then(v=&gt;v.data) //等于 `.then(v=&gt;&#123;return v&#125;)`,我再then()中返回出去,让外部承接 console.log(data) //获得正确的值 /** * 打印结果&#123; id: 1000,course_name: &#x27;这是请求数据1&#x27;, autor: &#x27;袁明&#x27;, college: &#x27;金并即总变史&#x27;,category_Id: 2&#125; * */ //模拟新增数据,将上一步的结果简单加工一下 data.course_name=data.course_name+1 $http(&#123; url:&quot;/test&quot;, method:&quot;put&quot;, data &#125;).then(v=&gt;&#123; console.log(v) //直接打印了 需要再取出参照上一步 &#125;)&#125;;resolveCommon() //调用普通promise函数resolveAsync() //调用await+async","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://hasuer.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"Promise学习笔记","slug":"Promise学习笔记","date":"2022-02-23T13:58:50.000Z","updated":"2022-02-25T06:57:38.671Z","comments":true,"path":"promise学习笔记/index.html","link":"","permalink":"https://hasuer.github.io/promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html","excerpt":"","text":"笔记转载自这里，有适当改动。 视频教程是尚硅谷Web前端Promise教程从入门到精通 Promise的理解与使用 1、概念: ​ Promise是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。 通俗讲，Promise是一个许诺、承诺,是对未来事情的承诺，承诺不一定能完成，但是无论是否能完成都会有一个结果。 Pending 正在做。。。 Resolved 完成这个承诺 Rejected 这个承诺没有完成，失败了 ​ Promise 用来预定一个不一定能完成的任务，要么成功，要么失败 ​ 在具体的程序中具体的体现，通常用来封装一个异步任务，提供承诺结果 Promise 是异步编程的一种解决方案，主要用来解决回调地狱的问题，可以有效的减少回调嵌套。真正解决需要配合async/await 2、特点: ​ (1)对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。 ​ (2)一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。 3、缺点: ​ (1)无法取消Promise，一旦新建它就会立即执行，无法中途取消。和一般的对象不一样，无需调用。 ​ (2)如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。 ​ (3)当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成） Promise是什么?理解 抽象表达: ​ 1) Promise 是一门新的技术(ES6 规范) ​ 2)Promise 是 JS 中进行异步编程的新解决方案 备注：旧方案是单纯使用回调函数 具体表达: 1) 从语法上来说: Promise 是一个构造函数 2) 从功能上来说: promise 对象用来封装一个异步操作并可以获取其成功/ 失败的结果值 promise 的状态promise 的状态 实例对象中的一个属性 『PromiseState』 pending 未决定的 resolved / fullfilled 成功 rejected 失败 promise 的状态改变 pending 变为 resolved pending 变为 rejected 说明: 只有这 2 种, 且一个 promise 对象只能改变一次 无论变为成功还是失败, 都会有一个结果数据 成功的结果数据一般称为 value, 失败的结果数据一般称为 reason promise的基本流程 promise的基本使用使用 promise 封装基于定时器的异步1234567891011121314151617181920212223242526272829&lt;script &gt; function doDelay(time) &#123; // 1. 创建 promise 对象(pending 状态), 指定执行器函数 return new Promise((resolve, reject) =&gt; &#123; // 2. 在执行器函数中启动异步任务 console.log(&#x27;启动异步任务&#x27;) setTimeout(() =&gt; &#123; console.log(&#x27;延迟任务开始执行...&#x27;) const time = Date.now() // 假设: 时间为奇数代表成功, 为偶数代表失败 if (time % 2 === 1) &#123; // 成功了 // 3. 1. 如果成功了, 调用 resolve()并传入成功的 value resolve(&#x27;成功的数据 &#x27; + time) &#125; else &#123; // 失败了 // 3.2. 如果失败了, 调用 reject()并传入失败的 reason reject(&#x27;失败的数据 &#x27; + time) &#125; &#125;, time) &#125;) &#125;const promise = doDelay(2000)promise.then(// promise 指定成功或失败的回调函数来获取成功的 vlaue 或失败的 reason value =&gt; &#123;// 成功的回调函数 onResolved, 得到成功的 vlaue console.log(&#x27;成功的 value: &#x27;, value) &#125;, reason =&gt; &#123; // 失败的回调函数 onRejected, 得到失败的 reason console.log(&#x27;失败的 reason: &#x27;, reason) &#125;, ) &lt; /script&gt; 使用 promise 封装 ajax 异步请求12345678910111213141516171819202122232425262728293031323334&lt;script &gt; /* 可复用的发 ajax 请求的函数: xhr + promise */ function promiseAjax(url) &#123; return new Promise((resolve, reject) =&gt; &#123; const xhr = new XMLHttpRequest() xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState !== 4) return const &#123; status, response &#125; = xhr // 请求成功, 调用 resolve(value) if (status &gt;= 200 &amp;&amp; status &lt; 300) &#123; resolve(JSON.parse(response)) &#125; else &#123; // 请求失败, 调用 reject(reason) reject(new Error(&#x27;请求失败: status: &#x27; + status)) &#125; &#125; xhr.open(&quot;GET&quot;, url) xhr.send() &#125;) &#125;promiseAjax(&#x27;https://api.apiopen.top2/getJoke?page=1&amp;count=2&amp;type=vid eo &#x27;) .then( data =&gt; &#123; console.log(&#x27;显示成功数据&#x27;, data) &#125;, error =&gt; &#123; alert(error.message) &#125; ) &lt;/script&gt; fs模块使用Promise123456789101112131415161718192021222324252627282930313233343536const fs = require(&#x27;fs&#x27;);//回调函数 形式---------------------------------------------------- fs.readFile(&#x27;./resource/content.txt&#x27;, (err, data) =&gt; &#123; // 如果出错 则抛出错误 if(err) throw err; //输出文件内容 console.log(data.toString()); &#125;);//Promise 形式-----------------------------------------------------------/** * 封装一个函数 mineReadFile 读取文件内容 * 参数: path 文件路径 * 返回: promise 对象 */function mineReadFile(path)&#123; return new Promise((resolve, reject) =&gt; &#123; //读取文件 require(&#x27;fs&#x27;).readFile(path, (err, data) =&gt;&#123; //判断 if(err) reject(err); //成功 resolve(data); &#125;); &#125;);&#125;mineReadFile(&#x27;./resource/content.txt&#x27;).then(value=&gt;&#123; //输出文件内容 console.log(value.toString());&#125;, reason=&gt;&#123; console.log(reason);&#125;); 异常穿透 可以在每个then()的第二个回调函数中进行err处理,也可以利用异常穿透特性,到最后用catch去承接统一处理,两者一起用时,前者会生效(因为err已经将其处理,就不会再往下穿透)而走不到后面的catch 在每个.then()中我可以将数据再次传出给下一个then() 123456mineReadFile(&#x27;./11.txt&#x27;).then(result=&gt;&#123; console.log(result.toString()) return result&#125;,err=&gt;console.log(err)).then(data=&gt;console.log(data,&quot;2222222&quot;)).catch(err=&gt;console.log(&quot;这是catch的&quot;)) util.promisify方法 可以将函数直接变成promise的封装方式,不用再去手动封装 12345678910//引入 util 模块const util = require(&#x27;util&#x27;);//引入 fs 模块const fs = require(&#x27;fs&#x27;);//返回一个新的函数let mineReadFile = util.promisify(fs.readFile);mineReadFile(&#x27;./resource/content.txt&#x27;).then(value =&gt; &#123; console.log(value.toString());&#125;); 为什么要用Promise?指定回调函数的方式更加灵活 旧的: 必须在启动异步任务前指定 promise: 启动异步任务 =&gt; 返回promie对象 =&gt; 给promise对象绑定回调函 数(甚至可以在异步任务结束后指定/多个) 支持链式调用, 可以解决回调地狱问题什么是回调地狱 回调函数嵌套调用, 外部回调函数异步执行的结果是嵌套的回调执行的条件 回调地狱的缺点? 不便于阅读 不便于异常处理 解决方案? promise 链式调用, 用来解决回调地狱问题，但是只是简单的改变格式，并没有彻底解决上面的问题真正要解决上述问题，一定要利用promise再加上await和async关键字实现异步传同步 终极解决方案? promise +async/await Promise中的常用 API 概述 此处列举几个最常用的API的概述,如果想看详细描述的可以继续往下看下方的 Promise方法的具体使用 描述 Promise 构造函数: Promise (excutor) {} (1) executor 函数: 执行器 (resolve, reject) =&gt; {} (2) resolve 函数: 内部定义成功时我们调用的函数 value =&gt; {} (3) reject 函数: 内部定义失败时我们调用的函数 reason =&gt; {} 说明: executor 会在 Promise 内部立即**同步调用**,异步操作在执行器中执行,换话说Promise支持同步也支持异步操作 Promise.prototype.then 方法: (onResolved, onRejected) =&gt; {} (1) onResolved 函数: 成功的回调函数 (value) =&gt; {} (2) onRejected 函数: 失败的回调函数 (reason) =&gt; {} 说明: 指定用于得到成功 value 的成功回调和用于得到失败 reason 的失败回调 返回一个新的 promise 对象 Promise.prototype.catch 方法: (onRejected) =&gt; {} (1) onRejected 函数: 失败的回调函数 (reason) =&gt; {} 说明: then()的语法糖, 相当于: then(undefined, onRejected) (2) 异常穿透使用:当运行到最后,没被处理的所有异常错误都会进入这个方法的回调函数中 Promise.resolve 方法: (value) =&gt; {} (1) value: 成功的数据或 promise 对象 说明: 返回一个成功/失败的 promise 对象,直接改变promise状态 Promise.resolve(value) 用结果 value 创建一个 resolved 的 promise。 如同： 1&gt;let promise = new Promise(resolve =&gt; resolve(value)); 12&gt;let p3 = Promise.reject(new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;OK&#x27;); &#125;)); &gt;console.log(p3); Promise.reject 方法: (reason) =&gt; {} (1) reason: 失败的原因 说明: 返回一个失败的 promise 对象,直接改变promise状态,代码示例同上 Promise.reject(error) 用 error 创建一个 rejected 的 promise。 如同： 1&gt;let promise = new Promise((resolve, reject) =&gt; reject(error)); 实际上，这个方法几乎从未被使用过。 Promise.all 方法: (promises) =&gt; {} promises: 包含 n 个 promise 的数组 说明: 返回一个新的 promise, 只有所有的 promise 都成功才成功, 只要有一 个失败了就直接失败 12345&gt;let p1 = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;成功&#x27;); &#125;)&gt;let p2 = Promise.reject(&#x27;错误错误错误&#x27;);&gt;let p3 = Promise.resolve(&#x27;也是成功&#x27;)&gt;const result = Promise.all([p1, p2, p3]);&gt;console.log(result); Promise.race 方法: (promises) =&gt; {} (1) promises: 包含 n 个 promise 的数组 说明: 返回一个新的 promise, 第一个完成的 promise 的结果状态就是最终的结果状态, 如p1延时,开启了异步,内部正常是同步进行,所以p2&gt;p3&gt;p1,结果是P2 12345678910&gt;let p1 = new Promise((resolve, reject) =&gt; &#123;setTimeout(() =&gt; &#123; resolve(&#x27;OK&#x27;);&#125;, 1000);&gt;&#125;)&gt;let p2 = Promise.resolve(&#x27;Success&#x27;);&gt;let p3 = Promise.resolve(&#x27;Oh Yeah&#x27;);&gt;//调用&gt;const result = Promise.race([p1, p2, p3]);&gt;console.log(result); Promise的几个关键问题如何改变 promise 的状态? (1) resolve(value): 如果当前是 pending 就会变为 resolved (2) reject(reason): 如果当前是 pending 就会变为 rejected (3) 抛出异常: 如果当前是 pending 就会变为 rejected 一个 promise 指定多个成功/失败回调函数, 都会调用吗? 当 promise 改变为对应状态时都会调用,改变状态后,多个回调函数都会调用,并不会自动停止 12345&gt;let p = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;OK&#x27;);&#125;);&gt;///指定回调 - 1&gt;p.then(value =&gt; &#123; console.log(value); &#125;);&gt;//指定回调 - 2&gt;p.then(value =&gt; &#123; alert(value);&#125;); 改变 promise 状态和指定回调函数谁先谁后? (1) 都有可能, 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调 ​ 先指定回调再改变状态(异步):先指定回调—&gt; 再改变状态 —&gt;改变状态后才进入异步队列执行回调函数 ​ 先改状态再指定回调(同步):改变状态 —&gt;指定回调 并马上执行回调 (2) 如何先改状态再指定回调? —&gt;注意:指定并不是执行 ​ ① 在执行器中直接调用 resolve()/reject() —&gt;即,不使用定时器等方法,执行器内直接同步操作 ​ ② 延迟更长时间才调用 then() —&gt;即,在.then()这个方法外再包一层例如延时器这种方法 (3) 什么时候才能得到数据? ​ ① 如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据 ​ ② 如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据 1234567&gt;let p = new Promise((resolve, reject) =&gt; &#123;&gt;//异步写法,这样写会先指定回调,再改变状态&gt;setTimeout(() =&gt; &#123;resolve(&#x27;OK&#x27;); &#125;, 1000);&gt;//这是同步写法,这样写会先改变状态,再指定回调&gt;resolve(&#x27;OK&#x27;); &gt;&#125;);&gt;p.then(value =&gt; &#123;console.log(value);&#125;, reason =&gt; &#123;&#125;) (4) 个人理解—结合源码 ​ 源码中,promise的状态是通过一个默认为pending的变量进行判断,所以当你resolve/reject延时(异步导致当then加载时,状态还未修改)后,这时直接进行p.then()会发现,目前状态还是进行中,所以只是这样导致只有同步操作才能成功. ​ 所以promise将传入的回调函数拷贝到promise对象实例上,然后在resolve/reject的执行过程中再进行调用,达到异步的目的 ​ 具体代码实现看下方自定义promise Ⅳ-promise.then()返回的新 promise 的结果状态由什么决定? (1) 简单表达: 由 then()指定的回调函数执行的结果决定 (2) 详细表达: ​ ① 如果抛出异常, 新 promise 变为 rejected, reason 为抛出的异常 ​ ② 如果返回的是非 promise 的任意值, 新 promise 变为 resolved, value 为返回的值 ​ ③ 如果返回的是另一个新 promise, 此 promise 的结果就会成为新 promise 的结果 123456789101112131415161718&gt;let p = new Promise((resolve, reject) =&gt; &#123;&gt;resolve(&#x27;ok&#x27;);&gt;&#125;);&gt;//执行 then 方法&gt;let result = p.then(value =&gt; &#123;&gt;console.log(value);&gt;// 1. 抛出错误 ,变为 rejected&gt;throw &#x27;出了问题&#x27;;&gt;// 2. 返回结果是非 Promise 类型的对象,新 promise 变为 resolved&gt;return 521;&gt;// 3. 返回结果是 Promise 对象,此 promise 的结果就会成为新 promise 的结果&gt;return new Promise((resolve, reject) =&gt; &#123;&gt;// resolve(&#x27;success&#x27;);&gt;reject(&#x27;error&#x27;);&gt;&#125;);&gt;&#125;, reason =&gt; &#123;&gt;console.warn(reason);&gt;&#125;); promise 如何串连多个操作任务? (1) promise 的 then()返回一个新的 promise, 可以开成 then()的链式调用 (2) 通过 then 的链式调用串连多个同步/异步任务,这样就能用then()将多个同步或异步操作串联成一个同步队列 123456&gt;&lt;script&gt;&gt;let p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123;resolve(&#x27;OK&#x27;); &#125;, 1000); &#125;);&gt;p.then(value =&gt; &#123;return new Promise((resolve, reject) =&gt; &#123; resolve(&quot;success&quot;); &#125;);&#125;)&gt;.then(value =&gt; &#123;console.log(value);&#125;)&gt;.then(value =&gt; &#123; console.log(value);&#125;) // 输出undifined, 因为上面一个调用没有返回值&gt;&lt;/script&gt; promise 异常传透? 当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调 前面任何操作出了异常, 都会传到最后失败的回调中处理 1234567891011121314151617&gt;getJSON(&#x27;./hong.json&#x27;) .then(function(posts) &#123; throw new Error(&#x27;抛出异常&#x27;) &#125;).then(res=&gt;console.log(res),e=&gt;console.log(&#x27;被then的错误回调捕获&#x27;,e) ) .catch(function(error) &#123; // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log(&#x27;错误捕获: &#x27;, error);&#125;);&gt;//执行结果: 被then的错误回调捕获 Error: 抛出异常&gt;/******************** 利用异常穿透 ****************************************/&gt;getJSON(&#x27;./hong.json&#x27;) .then(function(posts) &#123; throw new Error(&#x27;抛出异常&#x27;) &#125;).then(res=&gt;console.log(res) ) //此处差异,不指定 reject 回调,利用异常穿透传到最后 .catch(function(error) &#123; console.log(&#x27;错误捕获: &#x27;, error);&#125;);&gt;//执行结果: 错误捕获: Error: 抛出异常 注:可以在每个then()的第二个回调函数中进行err处理,也可以利用异常穿透特性,到最后用catch去承接统一处理,两者一起用时,前者会生效(因为err已经将其处理,就不会再往下穿透)而走不到后面的catch 中断 promise 链? 在关键问题2中,可以得知,当promise状态改变时,他的链式调用都会生效,那如果我们有这个一个实际需求:我们有5个then(),但其中有条件判断,如当我符合或者不符合第三个then条件时,要直接中断链式调用,不再走下面的then,该如何? (1) 当使用 promise 的 then 链式调用时, 在中间中断, 不再调用后面的回调函数 (2) 办法: 在回调函数中返回一个 pendding 状态的promise 对象 1234567&gt;&lt;script&gt;&gt;let p = new Promise((resolve, reject) =&gt; &#123;setTimeout(() =&gt; &#123; resolve(&#x27;OK&#x27;);&#125;, 1000);&#125;);&gt;p.then(value =&gt; &#123;return new Promise(() =&gt; &#123;&#125;);&#125;)//有且只有这一个方式&gt;.then(value =&gt; &#123; console.log(222);&#125;)&gt;.then(value =&gt; &#123; console.log(333);&#125;)&gt;.catch(reason =&gt; &#123;console.warn(reason);&#125;);&gt;&lt;/script&gt; 5、 Promise的实际应用 举两个栗子 Ⅰ - 加载图片 我们可以将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化。 12345678&gt;const preloadImage = function (path) &#123; return new Promise(function (resolve, reject) &#123; const image = new Image(); image.onload = resolve; image.onerror = reject; image.src = path; &#125;);&gt;&#125;; Ⅱ - Generator 函数与 Promise 的结合 使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个Promise对象。 1234567891011121314151617181920212223242526272829303132&gt;function getFoo () &#123;&gt;return new Promise(function (resolve, reject)&#123;&gt;resolve(&#x27;foo&#x27;);&gt;&#125;);&gt;&#125;&gt;const g = function* () &#123;&gt;try &#123;&gt;const foo = yield getFoo();&gt;console.log(foo);&gt;&#125; catch (e) &#123;&gt;console.log(e);&gt;&#125;&gt;&#125;;&gt;function run (generator) &#123;&gt;const it = generator();&gt;function go(result) &#123;&gt;if (result.done) return result.value;&gt;return result.value.then(function (value) &#123;return go(it.next(value));&gt;&#125;, function (error) &#123;return go(it.throw(error));&gt;&#125;);&gt;&#125;&gt;go(it.next());&gt;&#125;&gt;run(g); 上面代码的 Generator 函数g之中，有一个异步操作getFoo，它返回的就是一个Promise对象。函数run用来处理这个Promise对象，并调用下一个next方法。 Promise API 用法详解 ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。 此部分是对于 Promise API 用法的详解 ,尽量详细地列举其常见用法,所以篇幅较长 基本用法举个创造 Promise 实例的栗子 下面代码创造了一个Promise实例。 1234const promise = new Promise(function(resolve, reject) &#123;if (/* 异步操作成功 */) resolve(value); //将该 Promise 修改为成功且返回else reject(error); //将该 Promise 修改为失败且返回&#125;); Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。 resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 使用 [ then ] 方法分别指定 成功/失败 的回调 Promise实例生成以后，可以用 [ then() ] 方法分别指定resolved状态和rejected状态的回调函数。 12345&gt;promise.then(function(value) &#123;&gt;// 当promise状态返回为resolve 时会执行的回调函数&gt;&#125;, function(error) &#123;&gt;// 当promise状态返回为rejected 时会执行的回调函数&gt;&#125;); [ then ] 方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。 举个 Promise 对象的简单栗子 下面是一个Promise对象的简单例子。 setTimeout的第三个参数是给第一个函数的参数，而且是先于第一个参数(即回调函数)执行的 123456789&gt;function timeout(ms) &#123; //声明一个方法, 传入的 参数ms 为延时器时间&gt;return new Promise((resolve, reject) =&gt; &#123; //这行代码实际效果: 当 [ms] 毫秒后 执行 resolve(&#x27;努力学习的汪&#x27;) setTimeout(resolve, ms, &#x27;努力学习的汪&#x27;); &gt;&#125;);&gt;&#125;&gt;timeout(1000).then((value) =&gt; &#123; console.log(value) &#125;);&gt;//打印结果 : 努力学习的汪 上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，Promise实例的状态变为resolved，就会触发then方法绑定的回调函数。 Promise 新建后就会立即执行 1234567891011121314&gt;let promise = new Promise(function(resolve, reject) &#123;&gt;console.log(&#x27;Promise&#x27;);&gt;resolve();&gt;&#125;);&gt;promise.then(function() &#123;&gt;console.log(&#x27;resolved.&#x27;);&gt;&#125;);&gt;console.log(&#x27;Hi!&#x27;);&gt;// Promise&gt;// Hi!&gt;// resolved //可以发现,明明then是在 Hi 前面,却最后打印 上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。 实际上,这个运行结果相关知识点是 [ 宏任务与微任务 ] ,单独梳理在下方.这里可以先初步理解为: JS是单线程的,至上往下运行,在声明 Promise 时实际上已经执行到了内部方法 为何 resolve() 运行后没有立即打印? JS中用来存储待执行回调函数的队列包含2个不同特定的列队 宏队列:用来保存待执行的宏任务(回调),比如:定时器回调/ajax回调/dom事件回调 微队列:用来保存待执行的微任务(回调),比如:Promise的回调/muntation回调 JS执行时会区别这2个队列: JS执行引擎首先必须执行所有的初始化同步任务代码 每次准备取出第一个宏任务执行前,都要将所有的微任务一个一个取出来执行 举个异步加载图片的栗子 123456789101112131415161718&gt;function loadImageAsync(url) &#123;&gt;return new Promise(function(resolve, reject) &#123;&gt;const image = new Image();&gt;image.onload = function() &#123;&gt;console.log(&#x27;图片加载成功&#x27;)&gt;resolve(image);&gt;&#125;;&gt;image.onerror = function() &#123;&gt;reject(new Error(`无法从 $&#123;url&#125; 中加载图片` ));&gt;&#125;;&gt;image.src = url;&gt;&#125;);&gt;&#125;&gt;loadImageAsync(&#x27;正确的url&#x27;) //打印图片加载成功&gt;loadImageAsync(&#x27;错误的url&#x27;) //抛出异常 上面代码中，使用Promise包装了一个图片加载的异步操作。如果加载成功，就调用resolve方法，否则就调用reject方法。 举个用Promise对象实现的 Ajax 操作的栗子 Ajax知识点不懂的同学要去补一下: 这里可以看原作者梳理的ajax笔记 —&gt; 点我跳转 12345678910111213141516171819202122&gt;const getJSON = function(url) &#123;&gt;const promise = new Promise(function(resolve, reject)&#123;&gt;const handler = function() &#123;&gt;if (this.readyState !== 4) return; //当readyState 为4 时直接返回,不修改 promise 状态&gt;if (this.status === 200) resolve(this.response); //返回状态为 200 时将状态修改为成功,且将响应内容返回&gt;else reject(new Error(this.statusText)); //失败时抛出异常&gt;&#125;;&gt;const client = new XMLHttpRequest(); //实例化xml实例&gt;client.open(&quot;GET&quot;, url); //下面这几行都是对xml实例进行配置,不懂的同学要去补一下ajax知识点&gt;client.onreadystatechange = handler;&gt;client.responseType = &quot;json&quot;;&gt;client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);&gt;client.send();&gt;&#125;);&gt;return promise;&gt;&#125;;&gt;getJSON(&quot;./hong.json&quot;).then(function(json) &#123;&gt;console.log(&#x27;Contents: &#x27; , json);&gt;&#125;, function(error) &#123;&gt;console.error(&#x27;出错了&#x27;, error);&gt;&#125;); 上面代码中，getJSON是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。 小贴士:此处可能有同学想尝试却发现读取本地文件会有跨域问题,这边教一下你们 resolve() 的参数可以是另一个 Promise 实例 如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。 123&gt;const p1 = new Promise(function (resolve, reject) &#123;&#125;);&gt;const p2 = new Promise(function (resolve, reject) &#123; resolve(p1) &#125;) 上面代码中，p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。 注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。 123456789101112&gt;const p1 = new Promise(function (resolve, reject) &#123;&gt;setTimeout(() =&gt; reject(new Error(&#x27;p1的状态改为错误&#x27;)), 0)&gt;&#125;)&gt;const p2 = new Promise(function (resolve, reject) &#123;&gt;setTimeout(() =&gt; resolve(p1), 3000) //将p1 传给p2&gt;&#125;)&gt;p2.then(result =&gt; console.log(result),result=&gt;console.log(&#x27;失败&#x27;))&gt;.catch(error =&gt; console.log(&#x27;catch异常捕获:&#x27;+error))&gt;//首先报错&gt;//运行三秒后打印: 失败 上面代码运行后执行效果: 首先马上会打印一个报错 : “Uncaught (in promise) Error: p1的状态改为错误” (红色报错) 然后等3秒后再打印: ‘失败’ 注意: 如果 p2.then() 中没有写 reject 回调函数(第二个参数),则会被 catch 捕获,变为catch异常捕获:Error: p1的状态改为错误 解释: 首先前面说过,promise定义时就会立即执行,所以刚开始就运行了 p1 的reject(),所以直接控制台报错了 resolve方法返回的是p1。由于p2返回的是另一个 Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态 总结来说,promise返回promise这种嵌套形式,将由最内层的promise决定外层的状态 调用resolve或reject并不会终结 Promise 的参数函数的执行 调用resolve或reject并不会终结 Promise 的参数函数的执行。 12345678&gt;new Promise((resolve, reject) =&gt; &#123;&gt;resolve(1);&gt;console.log(2);&gt;&#125;).then(r =&gt; &#123;&gt;console.log(r);&gt;&#125;);&gt;// 2&gt;// 1 上面代码中，调用resolve(1)以后，后面的console.log(2)还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。 建议在修改状态函数前加return 一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。 12345&gt;new Promise((resolve, reject) =&gt; &#123;&gt;return resolve(1);&gt;// 后面的语句不会执行&gt;console.log(2);&gt;&#125;) 有同学可能就会问了,不加感觉也没啥事啊,反正我在这个函数体内就是要做这些操作,放在 resolve/reject前后好像都不影响啊! 这里我给举个实际场景 不加 return 导致的错误场景举🌰 一般来说,错误发生在 Promise 内,是不会传到外部的,只会在 Promise 内部消化,详见下方API详解部分的 ②Promise.prototype.catch()) 1234567&gt;const promise = new Promise(function (resolve, reject) &#123;&gt;resolve(&#x27;成功了&#x27;); //如果你加了 return , 函数执行到此步就停止了&gt;setTimeout(function () &#123; throw new Error(&#x27;错误错误!!!!!&#x27;) &#125;, 0)&gt;&#125;);&gt;promise.then(function (value) &#123; console.log(value) &#125;);&gt;// ok&gt;// Uncaught Error: 错误错误!!!! 上面代码中，Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。 Ⅱ - API 用法详解 此处将对于所有API进行详细剖析,参照资料为 阮一峰的ES6日志(原作者这里没有给出链接） Promise.prototype.then() Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。 then方法返回的是一个新的Promise实例 then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。 12345&gt;getJSON(&quot;./hong.json&quot;).then(function(json) &#123;&gt;return json.name;&gt;&#125;).then(function(name) &#123;&gt;console.log(`My name is $&#123;name&#125;` )&gt;&#125;); 上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。 采用链式的then, 会等待前一个Promise状态发生改变才会被调用 采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。 123456&gt;getJSON(&quot;./hong.json&quot;)&gt;.then(function(json) &#123; return getJSON(json.name)&#125;)&gt;.then(&gt;function (name) &#123; console.log(&quot;resolved: My name is &quot;, name)&#125;, &gt;function (err)&#123; console.log(&quot;rejected: &quot;, err)&#125;&gt;); 上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为resolved，就调用第一个回调函数，如果状态变为rejected，就调用第二个回调函数。 使用箭头函数简写 如果采用箭头函数，上面的代码可以写得更简洁 (实际代码中基本都是这样写了) 123456&gt;getJSON(&quot;./hong.json&quot;)&gt;.then(json =&gt; getJSON(json.name) )&gt;.then( name =&gt; console.log(&quot;resolved: My name is &quot;, name), &gt;err =&gt; console.log(&quot;rejected: &quot;, err)&gt;); Promise.prototype.catch() Promise.prototype.catch()方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。 基本用法 123456&gt;getJSON(&#x27;./hong.json&#x27;)&gt;.then(function(posts) &#123;&#125;)&gt;.catch(function(error) &#123; // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log(&#x27;发生错误！&#x27;, error); &#125;); 上面代码中，getJSON()方法返回一个 Promise 对象 如果该对象状态变为resolved，则会调用then()方法指定的回调函数； 如果异步操作抛出错误，状态就会变为rejected，就会调用catch()方法指定的回调函数，处理这个错误 另外，then()方法指定的回调函数，如果运行中抛出错误，也会被catch()方法捕获。 被 catch 方法捕获的前提是前方的 then() 方法中没有对 rejected 进行捕获处理(即没有写reject回调函数) 12345&gt;p.then((val) =&gt; console.log(&#x27;指定成功回调:&#x27;, val))&gt;.catch((err) =&gt; console.log(&#x27;在catch中进行 rejected 的处理&#x27;, err));&gt;// 等同于&gt;p.then((val) =&gt; console.log(&#x27;指定成功回调:&#x27;, val))&gt;.then(null, (err) =&gt; console.log(&quot;等同于另起一个then,只指定 rejected 的处理&quot;, err)); reject()方法的作用，等同于抛出错误 1234567&gt;const promise = new Promise(function(resolve, reject) &#123;&gt;throw new Error(&#x27;直接抛出错误&#x27;);&gt;&#125;);&gt;promise.catch(function(error) &#123;&gt;console.log(&#x27;异常捕获: &#x27;,error);&gt;&#125;);&gt;//异常捕获: Error: 直接抛出错误 上面代码中，promise抛出一个错误，就被catch()方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。 1234567891011121314151617181920212223&gt;/****************** 写法一 ***************************************/&gt;const promise = new Promise(function(resolve, reject) &#123;&gt;try &#123;&gt;throw new Error(&#x27;直接抛出错误&#x27;);&gt;&#125; catch(e) &#123;&gt;console.log(&#x27;进入catch,然后再用 reject(e)抛出 &#x27;)&gt;reject(e) &gt;&#125;&gt;&#125;);&gt;promise.catch(function(error) &#123;&gt;console.log(error);&gt;&#125;);&gt;//进入catch,然后再用 reject(e)抛出 &gt;//Error: 直接抛出错误&gt;/****************** 写法二 ***************************************/&gt;const promise1 = new Promise(function(resolve, reject) &#123;&gt;reject(new Error(&#x27;使用 reject() 抛出错误&#x27;));&gt;&#125;);&gt;promise1.catch(function(error) &#123;&gt;console.log(error);&gt;&#125;);&gt;//Error: 使用 reject() 抛出错误 比较上面两种写法，可以发现reject()方法的作用，等同于抛出错误,所以不必用try..catch()去承接后再去抛出了 如果 Promise 状态已经被修改，再抛出错误是无效的 12345678&gt;const promise = new Promise(function(resolve, reject) &#123;&gt;resolve(&#x27;成功了&#x27;); //换成 reject(&#x27;成功了&#x27;) 结果也是一样的&gt;throw new Error(&#x27;成功后扔抛出异常&#x27;);&gt;&#125;);&gt;promise&gt;.then(function(value) &#123; console.log(value) &#125;)&gt;.catch(function(error) &#123; console.log(error) &#125;);&gt;// 成功了 上面代码中，Promise 在resolve/reject语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了(前面有说过) Promise 对象的错误具有 “冒泡” 性质 Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。 123456789&gt;getJSON(&#x27;./hong.json&#x27;) //第一个promise&gt;.then(function(post) &#123; //第二个promise return getJSON(post.commentURL)&#125;)&gt;.then(function(comments) &#123; //第三个promise&#125;)&gt;.catch(function(error) &#123; // 处理前面三个Promise产生的错误&#125;); 上面代码中，一共有三个 Promise 对象(then返回的仍可能是一个Promise对象)：一个由getJSON()产生，两个由then()产生。它们之中任何一个抛出的错误，都会被最后一个catch()捕获。 也是因为这个特性,有了 异常穿透问题 异常穿透问题 当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调 前面任何操作出了异常, 都会传到最后失败的回调中处理 1234567891011121314151617&gt;getJSON(&#x27;./hong.json&#x27;)&gt;.then(function(posts) &#123; throw new Error(&#x27;抛出异常&#x27;) &#125;).then(res=&gt;console.log(res),e=&gt;console.log(&#x27;被then的错误回调捕获&#x27;,e) )&gt;.catch(function(error) &#123; // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log(&#x27;错误捕获: &#x27;, error);&#125;);&gt;//执行结果: 被then的错误回调捕获 Error: 抛出异常&gt;/******************** 利用异常穿透 ****************************************/&gt;getJSON(&#x27;./hong.json&#x27;)&gt;.then(function(posts) &#123; throw new Error(&#x27;抛出异常&#x27;) &#125;).then(res=&gt;console.log(res) ) //此处差异,不指定 reject 回调,利用异常穿透传到最后&gt;.catch(function(error) &#123; console.log(&#x27;错误捕获: &#x27;, error);&#125;);&gt;//执行结果: 错误捕获: Error: 抛出异常 注:可以在每个then()的第二个回调函数中进行err处理,也可以利用异常穿透特性,到最后用catch去承接统一处理,两者一起用时,前者会生效(因为err已经将其处理,就不会再往下穿透)而走不到后面的catch 建议使用 catch() 进行异常处理 一般来说，不要在then()方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。 12345678910&gt;// bad&gt;promise&gt;.then(&gt;data=&gt; console.log(&#x27;成功&#x27;,data),&gt;err=&gt;console.log(&#x27;失败了&#x27;,err));&gt;/********* 好的写法 ********************/&gt;promise&gt;.then( data=&gt; console.log(&#x27;成功&#x27;,data)) //只指定成功回调&gt;.catch( err=&gt;console.log(&#x27;失败了&#x27;,err)); 上面代码中，第二种写法要好于第一种写法: 理由是第二种写法可以捕获前面then方法执行中的错误 也更接近同步的写法（try/catch） 因此, 建议总是使用catch()方法，而不使用then()方法的第二个参数。 与传统 try/catch 代码块的差异 跟传统的try/catch代码块不同的是，如果没有使用catch()方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。 123456789101112&gt;const someAsyncThing = function() &#123;&gt;return new Promise(function(resolve, reject) &#123;&gt;// 下面一行会报错，因为hong 没有声明&gt;resolve( hong );&gt;&#125;);&gt;&#125;;&gt;//Promise 的 then() 处理,但不处理异常&gt;someAsyncThing().then(function() &#123; console.log(&#x27;只指定成功回调,不处理异常错误&#x27;) &#125;);&gt;setTimeout(() =&gt; &#123; console.log(&#x27;努力学习的汪&#x27;) &#125;, 2000);&gt;// Uncaught (in promise) ReferenceError: hong is not defined&gt;// 努力学习的汪 上面代码中，someAsyncThing()函数产生的 Promise 对象，内部有语法错误。 浏览器运行到这一行，会打印出错误提示Uncaught (in promise) ReferenceError: hong is not defined 但是不会退出进程、终止脚本执行, 2 秒之后还是会输出努力学习的汪。 这就是说，Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。 catch()方法后还能跟 then() 方法 一般总是建议，Promise 对象后面要跟catch()方法，这样可以处理 Promise 内部发生的错误。catch()方法返回的还是一个 Promise 对象，因此后面还可以接着调用then()方法。 123456789101112&gt;const someAsyncThing = function() &#123;&gt;return new Promise(function(resolve, reject) &#123;&gt;// 下面一行会报错，因为 hong 没有声明&gt;resolve( hong );&gt;&#125;);&gt;&#125;;&gt;someAsyncThing()&gt;.catch(function(error) &#123; console.log(&#x27;捉到错误咯:&#x27;, error)&#125;)&gt;.then(function() &#123; console.log(&#x27;错误捕获后我还要浪&#x27;) &#125;);&gt;//捉到错误咯: ReferenceError: hong is not defined&gt;//错误捕获后我还要浪 上面代码运行完catch()方法指定的回调函数，会接着运行后面那个then()方法指定的回调函数。 如果没有报错，则会跳过catch()方法。 1234&gt;Promise.resolve(&#x27;硬是成功了&#x27;)&gt;.catch(function(error) &#123; console.log(&#x27;捉错误&#x27;, error) &#125;)&gt;.then(v =&gt; console.log(&#x27;catch后面的then: &#x27;,v) );&gt;//catch后面的then: 硬是成功了 上面的代码因为没有报错，跳过了catch()方法，直接执行后面的then()方法。此时，要是then()方法里面报错，就与前面的catch()无关了。 catch()方法之中，还能再抛出错误 catch()方法之中，还能再抛出错误。 123456789101112131415161718&gt;const someAsyncThing = function() &#123;&gt;return new Promise(function(resolve, reject) &#123;&gt;// 下面一行会报错，因为 hong 没有声明&gt;resolve( hong );&gt;&#125;);&gt;&#125;;&gt;someAsyncThing()&gt;.then(() =&gt; someOtherAsyncThing()) &gt;.catch(function(error) &#123; console.log(&#x27;ctach:&#x27;, error); // 下面一行会报错，因为 sum 没有声明 sum ++;&#125;)&gt;.then(function() &#123; console.log(&#x27;捕获后的then()&#x27;)&#125;);&gt;// ctach: [ReferenceError: hong is not defined]&gt;// Uncaught (in promise) ReferenceError: sum is not defined 上面代码中，catch()方法抛出一个错误，因为后面没有别的catch()方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。 1234567891011&gt;someAsyncThing().then(function() &#123;&gt;return someOtherAsyncThing();&gt;&#125;).catch(function(error) &#123;&gt;console.log(&#x27;catch: &#x27;, error);&gt;// 下面一行会报错，因为 sum 没有声明&gt;sum ++;&gt;&#125;).catch(function(error) &#123;&gt;console.log(&#x27;catch()后的catch: &#x27;, error);&gt;&#125;);&gt;//catch: ReferenceError: hong is not defined&gt;//catch()后的catch: ReferenceError: sum is not defined 上面代码中，第二个catch()方法用来捕获前一个catch()方法抛出的错误。 Promise.prototype.finally() finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。 1234&gt;promise&gt;.then(result =&gt; &#123;···&#125;)&gt;.catch(error =&gt; &#123;···&#125;)&gt;.finally(() =&gt; &#123;···&#125;); 上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。 finally方法的回调函数不接受任何参数， 这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。 这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。 a) finally本质上是then方法的特例 123456789&gt;promise&gt;.finally(() =&gt; &#123;&#125;);&gt;// 等同于&gt;promise&gt;.then(&gt;result =&gt; result ,&gt;error =&gt; throw error&gt;); 上面代码中，如果不使用finally方法，同样的语句需要为成功和失败两种情况各写一次。有了finally方法，则只需要写一次。 它的实现 它的实现也很简单。 1234567&gt;Promise.prototype.finally = function (callback) &#123;&gt;let P = this.constructor;&gt;return this.then(&gt;value =&gt; P.resolve(callback()).then(() =&gt; value),&gt;reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;)&gt;);&gt;&#125;; 上面代码中，不管前面的 Promise 是fulfilled还是rejected，都会执行回调函数callback。 从上面的实现还可以看到，finally方法总是会返回原来的值(传入什么即传出什么) 1234567891011&gt;// resolve 的值是 undefined&gt;Promise.resolve(2).then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;)&gt;// resolve 的值是 2&gt;Promise.resolve(2).finally(() =&gt; &#123;&#125;)&gt;// reject 的值是 undefined&gt;Promise.reject(3).then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;)&gt;// reject 的值是 3&gt;Promise.reject(3).finally(() =&gt; &#123;&#125;) Promise.all() Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 1&gt;const p = Promise.all([p1, p2, p3]); Promise.all()方法接受一个数组作为参数， p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。 另外，Promise.all()方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。 返回的状态由什么决定? p的状态由p1、p2、p3决定，分成两种情况。 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 下面是一个具体的例子。12345678910&gt;// 生成一个Promise对象的数组&gt;const promises = [&#x27;hong&#x27;, 1, 2, 3, 4, 5].map(item &#123;&gt;return getJSON( item+&#x27;.json&#x27;);&gt;&#125;);&gt;Promise.all(promises).then(function (posts) &#123;&gt;// ...&gt;&#125;).catch(function(reason)&#123;&gt;// ...&gt;&#125;); 上面代码中，promises是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态 都 变成fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数。 下面是另一个例子12345678910111213&gt;const databasePromise = connectDatabase(); //假设定义了一个异步方法,此方法能拿到你需要的所有数据&gt;const booksPromise = databasePromise //定义一个方法,在 databasePromise() 执行后寻找其内部书本信息&gt;.then(findAllBooks);&gt;const userPromise = databasePromise //定义一个方法,在 databasePromise() 执行后寻找其内部当前用户信息&gt;.then(getCurrentUser);&gt;Promise.all([&gt;booksPromise,&gt;userPromise&gt;])&gt;.then(([books, user]) =&gt; pickTopRecommendations(books, user)); 上面代码中，booksPromise和userPromise是两个异步操作，只有等到它们的结果都返回了，才会触发pickTopRecommendations这个回调函数。 如果参数中的Promise实例定义了自己的catch方法 ? 注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。 1234567891011121314151617181920&gt;//定义一个状态将为成功的的promise&gt;const p1 = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;hello&#x27;)&#125;)&gt;.then(result =&gt; result)&gt;.catch(e =&gt; e);&gt;//定义一个将抛出错误的promise&gt;const p2 = new Promise((resolve, reject) =&gt; &#123; throw new Error(&#x27;报错了&#x27;) &#125;)&gt;.then(result =&gt; result)&gt;.catch(e =&gt;&#123;&gt;console.log(&#x27;p2自己的catch捕获: &#x27;, e)&gt;return e; //异常获取后原样返回,不做修改&gt;&#125;);&gt;//调用 Promise.all 方法&gt;Promise.all([p1, p2])&gt;.then(result =&gt; console.log(&#x27; Promise.all 方法中的成功回调: &#x27;, result))&gt;.catch(e =&gt; console.log(&quot; Promise.all 方法中的catch&quot;, e));&gt;//p2自己的catch捕获: Error: 报错了&gt;// Promise.all 方法中的成功回调: (2) [&#x27;hello&#x27;, Error: 报错了] 上面代码中， p1会resolved，p2首先会rejected 但是p2有自己的catch方法，该方法返回的是一个新的 Promise 实例，p2指向的实际上是这个实例。 该实例执行完catch方法后，也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved 因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数 如果参数中的Promise实例 没有 定义自己的catch方法 ? 如果p2没有自己的catch方法，就会调用Promise.all()的catch方法。 1234567891011121314&gt;//定义一个状态将为成功的的promise&gt;const p1 = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;hello&#x27;)&#125;)&gt;.then(result =&gt; result)&gt;//定义一个将抛出错误的promise&gt;const p2 = new Promise((resolve, reject) =&gt; &#123; throw new Error(&#x27;报错了&#x27;) &#125;)&gt;.then(result =&gt; result)&gt;//调用 Promise.all 方法&gt;Promise.all([p1, p2])&gt;.then(result =&gt; console.log(&#x27; Promise.all 方法中的成功回调: &#x27;, result))&gt;.catch(e =&gt; console.log(&quot; Promise.all 方法中的catch&quot;, e));&gt;// Promise.all 方法中的catch Error: 报错了 Promise.race() Promise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。 1&gt;const p = Promise.race([p1, p2, p3]); 上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。 Promise.race()方法的参数与Promise.all()方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve()方法，将参数转为 Promise 实例，再进一步处理。 举个简单的🌰 如p1延时,开启了异步,内部正常是同步进行,所以p2&gt;p3&gt;p1,结果是P2 12345678910&gt;let p1 = new Promise((resolve, reject) =&gt; &#123;&gt;setTimeout(() =&gt; &#123;&gt;resolve(&#x27;OK&#x27;);&gt;&#125;, 1000);&gt;&#125;)&gt;let p2 = Promise.resolve(&#x27;Success&#x27;);&gt;let p3 = Promise.resolve(&#x27;Oh Yeah&#x27;);&gt;//调用&gt;const result = Promise.race([p1, p2, p3]);&gt;console.log(result); 举个应用实🌰 下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为reject，否则变为resolve。 12345678910&gt;const p = Promise.race([&gt;fetch(&#x27;https://gitee.com/hongjilin&#x27;),&gt;new Promise(function (resolve, reject) &#123;&gt;setTimeout(() =&gt; reject(new Error(&#x27;请求超时!!!!&#x27;)), 5000)&gt;&#125;)&gt;]);&gt;p&gt;.then(console.log)&gt;.catch(console.error); 上面代码中，如果 5 秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数。 是不是很好用又简单 Promise.allSettled() Promise.allSettled()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。 只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束。 该方法由 ES2020 引入。 举个简单的🌰 12345678&gt;const promises = [&gt;fetch(&#x27;https://gitee.com/hongjilin&#x27;),&gt;fetch(&#x27;https://github.com/Hongjilin&#x27;),&gt;fetch(&#x27;./hong.json&#x27;),&gt;];&gt;loading = true; //请求前将 loading 改为true ; 页面出现滚动加载图标蒙层&gt;await Promise.allSettled(promises);&gt;loading = false; 上面代码对服务器发出三个请求，等到三个请求都结束，不管请求成功还是失败，加载的滚动图标就会消失。 该方法返回的新的 Promise 实例，一旦结束，状态总是fulfilled，不会变成rejected 该方法返回的新的 Promise 实例，一旦结束，状态总是fulfilled，不会变成rejected。状态变成fulfilled后，Promise 的监听函数接收到的参数是一个数组，每个成员对应一个传入Promise.allSettled()的 Promise 实例。 1234567891011121314&gt;const resolved = Promise.resolve(&#x27;返回成功状态的promise&#x27;);&gt;const rejected = Promise.reject(&#x27;返回失败状态的promise&#x27;);&gt;const allSettledPromise = Promise.allSettled([resolved, rejected]);&gt;// Promise.allSettled 得到的新实例状态只会是 `fulfilled`&gt;allSettledPromise.then(function (results) &#123;&gt;console.log(results); //注意,这是 `fulfilled` 的回调函数,只有其状态为成功才能进到这里&gt;&#125;);&gt;/*&gt;[&#123; &quot;status&quot;: &quot;fulfilled&quot;, &quot;value&quot;: &quot;返回成功状态的promise&quot; &#125;,&#123; &quot;status&quot;: &quot;rejected&quot;, &quot;reason&quot;: &quot;返回失败状态的promise&quot; &#125;&gt;]&gt;*/ Promise.allSettled()的返回值allSettledPromise，状态只可能变成fulfilled(注意,是 allSettledPromise 的状态,而不是内部的promise实例) 它的监听函数接收到的参数是数组results。该数组的每个成员都是一个对象，对应的是传入Promise.allSettled()的 Promise 实例。 每个对象都有status属性，该属性的值只可能是字符串fulfilled或字符串rejected。 fulfilled时，对象有value属性，rejected时有reason属性，对应两种状态的返回值。 举个返回值用法的🌰 12345678910&gt;const promises = [ fetch(&#x27;./hong.json&#x27;), fetch(&#x27;https://gitee.com/hongjilin&#x27;) ];&gt;const results = await Promise.allSettled(promises);&gt;// 过滤出成功的请求&gt;const successfulPromises = results.filter(item =&gt; item.status === &#x27;fulfilled&#x27;);&gt;// 过滤出失败的请求，并取得它们的失败原因&gt;const errors = results&gt;.filter(p =&gt; p.status === &#x27;rejected&#x27;)&gt;.map(p =&gt; p.reason); 有时候，我们不关心异步操作的结果，只关心这些操作有没有结束。这时，Promise.allSettled()方法就很有用。如果没有这个方法，想要确保所有操作都结束，就很麻烦。Promise.all()方法无法做到这一点。 123456789&gt;const urls = [ &#x27;https://gitee.com/hongjilin&#x27; ,&#x27;https://github.com/Hongjilin&#x27;];&gt;const requests = urls.map(x =&gt; fetch(x));&gt;//举例用 Promise.all 尝试实现,很明显,难以实现&gt;try &#123;&gt;await Promise.all(requests);&gt;console.log(&#x27;所有请求都成功。&#x27;);&gt;&#125; catch &#123;&gt;console.log(&#x27;至少一个请求失败，其他请求可能还没结束。&#x27;);&gt;&#125; 上面代码中，Promise.all()无法确定所有请求都结束。想要达到这个目的，写起来很麻烦，有了Promise.allSettled()，这就很容易了 Promise.any() ES2021 引入了Promise.any()方法。该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。 与 Promise.race() 方法的区别 Promise.any()跟Promise.race()方法很像，只有一点不同，就是不会因为某个 Promise 变成rejected状态而结束。 1234567891011&gt;const promises = [&gt;fetch(&#x27;https://gitee.com/hongjilin&#x27;).then(() =&gt; &#x27;a&#x27;),&gt;fetch(&#x27;https://github.com/Hongjilin&#x27;).then(() =&gt; &#x27;b&#x27;),&gt;fetch(&#x27;./hong.json&#x27;).then(() =&gt; &#x27;c&#x27;),&gt;];&gt;try &#123;&gt;const first = await Promise.any(promises);&gt;console.log(first);&gt;&#125; catch (error) &#123;&gt;console.log(error);&gt;&#125; 上面代码中，Promise.any()方法的参数数组包含三个 Promise 操作。其中只要有一个变成fulfilled，Promise.any()返回的 Promise 对象就变成fulfilled。如果所有三个操作都变成rejected，那么await命令就会抛出错误。 Promise.any() 抛出的错误 Promise.any()抛出的错误，不是一个一般的错误，而是一个 AggregateError 实例。它相当于一个数组，每个成员对应一个被rejected的操作所抛出的错误。下面是 AggregateError 的实现示例。 123456&gt;new AggregateError() extends Array -&gt; AggregateError&gt;const err = new AggregateError();&gt;err.push(new Error(&quot;first error&quot;));&gt;err.push(new Error(&quot;second error&quot;));&gt;throw err; 捕捉错误时，如果不用try...catch结构和 await 命令，可以像下面这样写。 12345678&gt;Promise.any(promises).then(&gt;(first) =&gt; &#123;&gt;// Any of the promises was fulfilled.&gt;&#125;,&gt;(error) =&gt; &#123;&gt;// All of the promises were rejected.&gt;&#125;&gt;); 再举个🌰 下面是一个例子。 1234567891011&gt;const resolved = Promise.resolve(&#x27;成功&#x27;);&gt;const rejected = Promise.reject(&#x27;失败了&#x27;);&gt;const alsoRejected = Promise.reject(&#x27;太失败了&#x27;);&gt;Promise.any([resolved, rejected, alsoRejected]).then(function (result) &#123;&gt;console.log(result); // 成功&gt;&#125;);&gt;Promise.any([rejected, alsoRejected]).catch(function (results) &#123;&gt;console.log(results); //AggregateError: All promises were rejected&gt;&#125;); 三个Promise中有一个为成功,则总的结果就是成功,三个中全部失败,才会变成失败 Promise.resolve() 有时需要将现有对象转为 Promise 对象，Promise.resolve()方法就起到这个作用。 1&gt;const jsPromise = Promise.resolve($.ajax(&#x27;https://gitee.com/hongjilin&#x27;)); 上面代码将 jQuery 生成的deferred对象，转为一个新的 Promise 对象。 Promise.resolve()等价于下面的写法。 123&gt;Promise.resolve(&#x27;努力学习的汪&#x27;)&gt;// 等价于&gt;new Promise(resolve =&gt; resolve(&#x27;努力学习的汪&#x27;)) Promise.resolve()方法的参数分成四种情况 参数是一个 Promise 实例 如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。 参数是一个thenable对象 thenable对象指的是具有then方法的对象，比如下面这个对象。 12345&gt;let thenable = &#123;then: function(resolve, reject) &#123; resolve(&#x27;成功&#x27;);&#125;&gt;&#125;; Promise.resolve()方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then()方法。 12345678&gt;let thenable = &#123;then: function(resolve, reject) &#123; resolve(&#x27;成功&#x27;) &#125;&gt;&#125;;&gt;let p1 = Promise.resolve(thenable);&gt;p1.then(function (value) &#123;console.log(value); // &#x27;成功&#x27;&gt;&#125;); 上面代码中，thenable对象的then()方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then()方法指定的回调函数，输出 ‘成功’。 参数不是具有then()方法的对象，或根本就不是对象 如果参数是一个原始值，或者是一个不具有then()方法的对象，则Promise.resolve()方法返回一个新的 Promise 对象，状态为resolved。 123456&gt;const p = Promise.resolve(&#x27;努力学习的汪&#x27;);&gt;p.then(function (s) &#123;&gt;console.log(s)&gt;&#125;);&gt;// 努力学习的汪 上面代码生成一个新的 Promise 对象的实例p。 由于字符串 努力学习的汪 不属于异步操作（判断方法是字符串对象不具有 then 方法） 返回 Promise 实例的状态从一生成就是resolved，所以回调函数会立即执行 Promise.resolve()方法的参数会同时传给回调函数作为其参数 不带有任何参数 Promise.resolve()方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。 所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用Promise.resolve()方法。 123&gt;const p = Promise.resolve();&gt;p.then(function () &#123;&#125;); 上面代码的变量p就是一个 Promise 对象。 需要注意的是，立即resolve()的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时 —&gt; 不懂的同学请看 JavaScript笔记中的#4事件循环模型event-loop机制 ,本人在此有进行详细的解析 12345678910111213&gt;setTimeout(function () &#123;&gt;console.log(&#x27;three&#x27;); //这里是新的一轮事件循环&gt;&#125;, 0);&gt;Promise.resolve().then(function () &#123;&gt;console.log(&#x27;two&#x27;); //本轮同步代码结束后,新一轮事件循环前,就执行&gt;&#125;);&gt;console.log(&#x27;one&#x27;);&gt;// one&gt;// two&gt;// three 上面代码中，setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.resolve()在本轮“事件循环”结束时执行，console.log(&#39;one&#39;)则是立即执行，因此最先输出。 Promise.reject() Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。 12345678&gt;const p = Promise.reject(&#x27;出错了&#x27;);&gt;// 等同于&gt;const p = new Promise((resolve, reject) =&gt; reject(&#x27;出错了&#x27;))&gt;p.then(null, function (s) &#123;&gt;console.log(s)&gt;&#125;);&gt;// 出错了 上面代码生成一个 Promise 对象的实例p，状态为rejected，回调函数会立即执行。 Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。 12345&gt;Promise.reject(&#x27;出错了&#x27;)&gt;.catch(e =&gt; &#123;&gt;console.log(e === &#x27;出错了&#x27;)&gt;&#125;)&gt;// true 上面代码中，Promise.reject()方法的参数是一个字符串，后面catch()方法的参数e就是这个字符串。 Promise.try() 实际开发中，经常遇到一种情况：不知道或者不想区分，函数f是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管f是否包含异步操作，都用then方法指定下一步流程，用catch方法处理f抛出的错误。一般就会采用下面的写法。 1&gt;Promise.resolve().then(f) 上面的写法有一个缺点，就是如果f是同步函数，那么它会在本轮事件循环的末尾执行。 12345&gt;const f = () =&gt; console.log(&#x27;now&#x27;);&gt;Promise.resolve().then(f);&gt;console.log(&#x27;next&#x27;);&gt;// next&gt;// now 上面代码中，函数f是同步的，但是用 Promise 包装了以后，就变成异步执行了。 那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？ 写法一 : 用async函数来写 该知识点如果不懂的可以继续往下看,这是ES6的另外一块知识点内容 12345&gt;const f = () =&gt; console.log(&#x27;now&#x27;);&gt;(async () =&gt; f())();&gt;console.log(&#x27;next&#x27;);&gt;// now&gt;// next 上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的async函数，因此如果f是同步的，就会得到同步的结果；如果f是异步的，就可以用then指定下一步，就像下面的写法。 12&gt;(async () =&gt; f())()&gt;.then(...) 需要注意的是，async () =&gt; f()会吃掉f()抛出的错误。所以，如果想捕获错误，要使用promise.catch方法。 123&gt;(async () =&gt; f())()&gt;.then(...)&gt;.catch(...) 写法二 : 使用new Promise() 123456789&gt;const f = () =&gt; console.log(&#x27;now&#x27;);&gt;(&gt;() =&gt; new Promise(&gt;resolve =&gt; resolve(f())&gt;)&gt;)();&gt;console.log(&#x27;next&#x27;);&gt;// now&gt;// next 上面代码也是使用立即执行的匿名函数，执行new Promise()。这种情况下，同步函数也是同步执行的。 Promise.try的引出 鉴于这是一个很常见的需求，所以现在有一个提案，提供Promise.try方法替代上面的写法。 12345&gt;const f = () =&gt; console.log(&#x27;now&#x27;);&gt;Promise.try(f);&gt;console.log(&#x27;next&#x27;);&gt;// now&gt;// next 事实上，Promise.try存在已久，Promise 库Bluebird、Q和when，早就提供了这个方法。 由于Promise.try为所有操作提供了统一的处理机制，所以如果想用then方法管理流程，最好都用Promise.try包装一下。这样有许多好处，其中一点就是可以更好地管理异常。 123456&gt;function getUsername(userId) &#123;&gt;return database.users.get(&#123;id: userId&#125;)&gt;.then(function(user) &#123;&gt;return user.name;&gt;&#125;);&gt;&#125; 上面代码中，database.users.get()返回一个 Promise 对象，如果抛出异步错误，可以用catch方法捕获，就像下面这样写。 123&gt;database.users.get(&#123;id: userId&#125;)&gt;.then(...)&gt;.catch(...) 但是database.users.get()可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用try...catch去捕获。 1234567&gt;try &#123;&gt;database.users.get(&#123;id: userId&#125;)&gt;.then(...)&gt;.catch(...)&gt;&#125; catch (e) &#123;&gt;// ...&gt;&#125; 上面这样的写法就很笨拙了，这时就可以统一用promise.catch()捕获所有同步和异步的错误。 123&gt;Promise.try(() =&gt; database.users.get(&#123;id: userId&#125;))&gt;.then(...)&gt;.catch(...) 事实上，Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码块。 自定义Promise手写 下方的Promise.prototype.then与Promise.resolve为什么一个挂载在prototype而另一个挂载在实例对象上? 解:原因是分别为静态方法与实例方法 —&gt;上面的需要new实例化的时候自动继承实例prototype上的方法和属性,所以用实例对象.then()来调用,而下面的Promise.resolve是静态方法,不用new,是可以直接Promise.resolve()调用 此部分可以跳过不看,类似手撕源码 Promise的实例方法实现初始结构搭建 html引入,该章节后续html大部分重复 除非必要,否则不再放上来 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Promise-封装 | 1 - 初始结构搭建&lt;/title&gt; &lt;script src=&quot;./promise.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; let p = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;OK&#x27;); &#125;); p.then(value =&gt; &#123; console.log(value); &#125;, reason=&gt;&#123; console.warn(reason); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; promise.js —&gt;使用原生写法,最后会改为class写法 123function Promise(executor)&#123;&#125;//添加 then 方法Promise.prototype.then = function(onResolved, onRejected)&#123;&#125; resolve 与 reject构建与基础实现 使用const self = this;保存this执行,使function中可以取得当前实例 ps:可以不使用该方法保存,但是下方function需要改为箭头函数,否则function默认指向是window 之后代码默认使用self保存this,箭头函数方式将在最后改为class写法时使用 默认设置 PromiseState = &#39;pending&#39;以及 PromiseResult = null,这就是promise状态基础 123456789101112131415161718192021222324252627//声明构造函数function Promise(executor) &#123; //添加属性 this.PromiseState = &#x27;pending&#x27;; this.PromiseResult = null; //保存实例对象的 this 的值/* 此处可以不写,但是下面function方法需要改为箭头函数,否则function默认指向是window */ const self = this; //resolve 函数 function resolve(data) &#123;-------------------------------------------- //1. 修改对象的状态 (promiseState) self.PromiseState = &#x27;fulfilled&#x27;; // resolved //2. 设置对象结果值 (promiseResult) self.PromiseResult = data; &#125; //reject 函数 function reject(data) &#123;---------------------------------------------- //1. 修改对象的状态 (promiseState) self.PromiseState = &#x27;rejected&#x27;; // //2. 设置对象结果值 (promiseResult) self.PromiseResult = data; &#125; //同步调用『执行器函数』 executor(resolve, reject);&#125;//添加 then 方法Promise.prototype.then = function (onResolved, onRejected) &#123;&#125; throw 抛出异常改变状态 在2的基础上进行修改:将执行器放入try-catch()中 在catch中使用reject()修改 promise 对象状态为『失败』 1234567try &#123; //同步调用『执行器函数』 executor(resolve, reject); &#125; catch (e) &#123; //修改 promise 对象状态为『失败』 reject(e); &#125; 状态只能修改一次 基于2 3代码中resolve和reject方法进修改 在成功与失败函数中添加判断if(self.PromiseState !== &#39;pending&#39;) return;,如果进入函数时状态不为pending直接退出,这样就能做到状态只能从pending改至其他状态且做到只能改一次 12345678910111213141516171819202122232425262728html调用-------------------------------------------------------- let p = new Promise((resolve, reject) =&gt; &#123; reject(&quot;error&quot;); resolve(&#x27;OK&#x27;); //抛出异常 // throw &quot;error&quot;; &#125;); console.log(p);promise.js修改-------------------------------------------------------- //resolve 函数 function resolve(data)&#123; //判断状态 if(self.PromiseState !== &#x27;pending&#x27;) return; //1. 修改对象的状态 (promiseState) self.PromiseState = &#x27;fulfilled&#x27;;// resolved //2. 设置对象结果值 (promiseResult) self.PromiseResult = data; &#125; //reject 函数 function reject(data)&#123; //判断状态 if(self.PromiseState !== &#x27;pending&#x27;) return; //1. 修改对象的状态 (promiseState) self.PromiseState = &#x27;rejected&#x27;;// //2. 设置对象结果值 (promiseResult) self.PromiseResult = data; &#125; hen 方法执行回调基础实现 修改Promise.prototype.then方法 传入then(成功回调,失败回调),当调用then后,会判断当前this.PromiseState的状态,当其为成功时调用成功回调,失败时调用失败回调 12345678910111213141516html调用------------------------------------------------------------ let p = new Promise((resolve, reject) =&gt; &#123; // resolve(&#x27;OK&#x27;);// reject(&quot;Error&quot;); throw &quot;ERROR&quot;; &#125;); p.then( value =&gt; &#123;console.log(value); &#125;, reason =&gt; &#123;console.warn(reason);&#125; )promise.js修改与实现-----------------------------------------------------//添加 then 方法Promise.prototype.then = function (onResolved, onRejected) &#123; //调用回调函数 PromiseState if (this.PromiseState === &#x27;fulfilled&#x27;) &#123;onResolved(this.PromiseResult);&#125; if (this.PromiseState === &#x27;rejected&#x27;) &#123;onRejected(this.PromiseResult);&#125;&#125; 异步任务 then 方法实现 此处对于5有四处修改,下面上js代码 当我运行异步代码后,我的执行器内部代码还未返回(因为用了定时器,里面的代码进入了异步队列),所以当我下面的.then()运行时:我的p为pending状态,所以根本不会执行resolve与reject方法 解:添加判断pending状态,将当前回调函数保存到实例对象(存到实例上是为了更方便)中,这样后续改变状态时候才调用得到 为什么要将回调保存到实例上而不是直接调用? 理由:因为我的回调函数需要在我的promise状态改变后(成功或者失败),再根据状态选择运行哪个函数所以当你调用then()时却检测到状态为pending,说明这时候的promise在异步队列 不能直接运行成功或者失败函数 解决:因为resolve与reject方法与then()不在同一个作用域中,并不能共享then(成功回调,失败回调)的参数,所以在判断状态为pending时将回调保存到实例对象上.然后将回调函数的调用放在resolve()与reject()中 这样当我代码运行到异步队列的resolve()或reject()时,就可以在这个函数中运行回调函数,实现异步then 此处的then仍有瑕疵,需要继续完善 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849html调用------------------------------------------------------------ //实例化对象 let p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123;reject(&quot;error&quot;); /* resolve(&#x27;OK&#x27;);*/&#125;, 1000); &#125;); p.then(value =&gt; &#123;console.log(value);&#125;,reason =&gt; &#123; console.warn(reason);&#125;); console.log(p);promise.js修改与实现-----------------------------------------------------//声明构造函数function Promise(executor) &#123; this.PromiseState = &#x27;pending&#x27;; this.PromiseResult = null; // 声明属性 this.callback = &#123;&#125;; -----------新添加1 const self = this; //resolve 函数 function resolve(data) &#123; //判断状态 if (self.PromiseState !== &#x27;pending&#x27;) return; self.PromiseState = &#x27;fulfilled&#x27;; self.PromiseResult = data; //调用成功的回调函数 加判断的原因是防止无回调报错 if (self.callback.onResolved) &#123; self.callback.onResolved(data); &#125; ------------新添加2 最重要 &#125; //reject 函数 function reject(data) &#123; if (self.PromiseState !== &#x27;pending&#x27;) return; self.PromiseState = &#x27;rejected&#x27;; self.PromiseResult = data; //执行回调 if (self.callback.onResolved) &#123; self.callback.onResolved(data);&#125; ------------新添加3 &#125; try &#123;executor(resolve, reject);&#125; catch (e) &#123;reject(e);&#125;&#125;//添加 then 方法Promise.prototype.then = function (onResolved, onRejected) &#123; //调用回调函数 PromiseState if (this.PromiseState === &#x27;fulfilled&#x27;) &#123;onResolved(this.PromiseResult);&#125; if (this.PromiseState === &#x27;rejected&#x27;) &#123; onRejected(this.PromiseResult);&#125; //判断 pending 状态 if (this.PromiseState === &#x27;pending&#x27;) &#123; ------------新添加4 //保存回调函数 this.callback = &#123; onResolved: onResolved, onRejected: onRejected &#125; &#125;&#125; 指定多个回调 基于6代码进行修改 只展示修改部分代码 6中保存回调函数的方式有BUG,如果我有多个.then(),后面加载的回调函数会覆盖之前的回调函数,导致最后回调函数有且只有最后一个 解:使用数组的方式进行存储回调函数,调用时也是用数组循环取出 此处的then仍有瑕疵,需要继续完善 1234567891011121314151617181920212223242526272829303132333435363738394041html调用------------------------------------------------------------//实例化对象 let p = new Promise((resolve, reject) =&gt; &#123;setTimeout(() =&gt; &#123;reject(&#x27;No&#x27;);&#125;, 1000);&#125;); p.then(value =&gt; &#123; console.log(value);&#125;, reason=&gt;&#123;console.warn(reason);&#125;); p.then(value =&gt; &#123; alert(value);&#125;, reason=&gt;&#123; alert(reason);&#125;); console.log(p);promise.js修改与实现-----------------------------------------------------Promise.prototype.then = function (onResolved, onRejected) &#123; //resolve 函数 function resolve(data)&#123; ..... //调用成功的回调函数 // if (self.callback.onResolved) &#123; self.callback.onResolved(data); &#125; self.callbacks.forEach(item =&gt; &#123; --------修改1 item.onResolved(data); &#125;); &#125; //reject 函数 function reject(data)&#123; ...... //执行失败的回调 // if (self.callback.onResolved) &#123; self.callback.onResolved(data);&#125; self.callbacks.forEach(item =&gt; &#123; ------修改2 item.onRejected(data); &#125;); &#125; //添加 then 方法Promise.prototype.then = function(onResolved, onRejected)&#123; ........ //判断 pending 状态 if(this.PromiseState === &#x27;pending&#x27;)&#123; //保存回调函数 // this.callback = &#123; onResolved: onResolved, onRejected: onRejected &#125; this.callbacks.push(&#123; --------修改3 onResolved: onResolved, onRejected: onRejected &#125;); &#125;&#125; 同步任务 then 返回结果 在之前的then运行结果中得知,我们使用 [ then ] 后的返回结果是其回调函数的返回结果,而我们需要的返回结果是一个新的promise对象 解:所以我们在then中return new Promise(),使其得到的是一个新的promise对象 在为解决问题1后产生一个新问题:新的promise对象因为没有用rejerect与resolve方法,导致返回的状态一直是pending 解:在新的promise中判断运行回调函数后的返回值是什么,然后根据其不同类型给其赋予不同状态 ​ Ⅰ-if(result instanceof Promise):返回值一个新的②promise对象(因为是新的promise的回调函数返回值,称②promise对象),在返回值(因为是promise对象)的.then()回调函数中使用rejerect与resolve方法,将其自身的状态赋予外层的promise, ​ 即 回调函数中的promise 赋值 给then返回值 , 所以 最终返回状态==回调函数中的新promise状态 ​ Ⅱ-如果返回值是一个非promise对象,返回状态设置为成功 ​ Ⅲ-如果返回值是一个异常,返回状态设置为失败 12345678910111213141516171819202122232425262728293031323334html调用------------------------------------------------------------ //实例化对象 let p = new Promise((resolve, reject) =&gt; &#123;resolve(&#x27;OK&#x27;);&#125;); //执行 then 方法 const res = p.then( value =&gt; &#123; throw &quot;FAIL&quot;;&#125;, reason =&gt; &#123; console.warn(reason);&#125;); console.log(res);promise.js修改与实现-----------------------------------------------------//添加 then 方法Promise.prototype.then = function(onResolved, onRejected)&#123; return new Promise((resolve, reject) =&gt; &#123; //调用回调函数 PromiseState // if(this.PromiseState === &#x27;fulfilled&#x27;)&#123; onResolved(this.PromiseResult);&#125; 未修改时代码 if(this.PromiseState === &#x27;fulfilled&#x27;)&#123; -------修改1 try&#123; //获取回调函数的执行结果 let result = onResolved(this.PromiseResult); //判断 if(result instanceof Promise)&#123;//如果是 Promise 类型的对象,我就将下一个promise结果赋予外层 result.then(v =&gt; &#123; resolve(v); &#125;,r=&gt;&#123;reject(r);&#125;) &#125;else&#123;resolve(result);&#125; //如果返回的不是promise对象,都将其赋予成功状态 &#125;catch(e)&#123; rejerect(e); //如果出错了,则返回失败状态 &#125; &#125; if(this.PromiseState === &#x27;rejected&#x27;)&#123; onRejected(this.PromiseResult);&#125;------此部分修改与修改1一样 //判断 pending 状态 if(this.PromiseState === &#x27;pending&#x27;)&#123; this.callbacks.push(&#123; onResolved: onResolved, onRejected: onRejected&#125;); &#125; &#125;)&#125; 异步任务 then 返回结果 异步任务是修改if(this.PromiseState === &#39;pending&#39;)后面的值,原因参考6,下面代码只举例这部分修改 因为我们需要增加then状态修改,所以在我们保存回调函数这一步我们可以对于回调函数进行加工,添加判断其回调函数的返回值的代码块再存入实例的回调函数中 Ⅰ-声明一个新的函数:其内部功能-&gt;先运行onResolved回调函数,再将其返回值取出,进行判断其返回值(这个过程同8) Ⅱ-加工后存入实例回调函数数组,之后在resolve与reject方法中调用即可(同6) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950html调用------------------------------------------------------------ //实例化对象 let p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123;reject(&quot;Error&quot;);&#125;, 1000)&#125;); // resolve(&#x27;OK&#x27;); //执行 then 方法 const res = p.then(value =&gt; &#123; // return &#x27;oh Yeah&#x27;; //如果有返回,根据其返回值得到相应的状态:字符串为成功,抛出为错误 throw &#x27;error&#x27;; &#125;, reason =&gt; &#123; console.warn(reason, &quot;xx&quot;); //如果只是打印没返回,则实际上时返回一个undefined, //在我们封装js中,undefined会判定为非promise对象,所以状态为成功,结果为undefined return &quot;sss&quot; // throw &#x27;error&#x27;; &#125;); console.log(res);promise.js修改与实现----------------------------------------------------- //判断 pending 状态 if (this.PromiseState === &#x27;pending&#x27;) &#123; //保存回调函数 this.callbacks.push(&#123; onResolved: function () &#123; try &#123; //执行成功回调函数 let result = onResolved(self.PromiseResult); //判断 其结果 if (result instanceof Promise) &#123; result.then( v =&gt; &#123; resolve(v);&#125;, r =&gt; &#123;reject(r);&#125; ) &#125; else &#123;resolve(result);&#125; &#125; catch (e) &#123;reject(e);&#125; &#125;, onRejected: function () &#123; try &#123; //执行成功回调函数 let result = onRejected(self.PromiseResult); //判断 if (result instanceof Promise) &#123; result.then( v =&gt; &#123;resolve(v); &#125;, r =&gt; &#123;reject(r);&#125; ) &#125; else &#123;resolve(result);&#125; &#125; catch (e) &#123; reject(e); &#125; &#125; &#125;); &#125; then方法代码优化 在8、9、10中可以看出,其判断与改变返回结果状态的代码块是基本重复的,所以可以将其抽出 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//添加 then 方法Promise.prototype.then = function (onResolved, onRejected) &#123; const self = this; return new Promise((resolve, reject) =&gt; &#123; 封装函数---------------------------------------------------------------------------- function callback(type) &#123; try &#123; //获取回调函数的执行结果 let result = type(self.PromiseResult); //判断 if (result instanceof Promise) &#123; //如果是 Promise 类型的对象 result.then(v =&gt; &#123; resolve(v); &#125;, r =&gt; &#123; reject(r); &#125;) &#125; else &#123; //结果的对象状态为『成功』 resolve(result); &#125; &#125; catch (e) &#123; reject(e); &#125; &#125; ----------------------------------------------------------------------------------- //调用回调函数 PromiseState if (this.PromiseState === &#x27;fulfilled&#x27;) &#123; callback(onResolved); &#125; if (this.PromiseState === &#x27;rejected&#x27;) &#123; callback(onRejected); &#125; //判断 pending 状态 if (this.PromiseState === &#x27;pending&#x27;) &#123; //保存回调函数 this.callbacks.push(&#123; onResolved: function () &#123; callback(onResolved); &#125;, onRejected: function () &#123; callback(onRejected); &#125; &#125;); &#125; &#125;)&#125; catch 方法与异常穿透与值传递 异常穿透:添加catch 方法,并且需要进行回调函数为undefined的处理 当我then()中只传一个回调或者不传回调函数时,运行代码会报错,因为运行时调用的回调函数是undefined 解:进行回调函数判断,当其为空时,基于默认回调函数内容:直接往外抛出这样下方的then() or catch()就可以承接到异常或者值 12345678910111213141516171819202122html调用------------------------------------------------------------ //实例化对象 let p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123;resolve(&#x27;OK&#x27;); &#125;, 1000); &#125;); //值传递 p.then() .then(value =&gt; &#123;console.log(222);&#125;) .then(value =&gt; &#123;console.log(333);&#125;) .catch(reason =&gt; &#123;console.warn(reason);&#125;);promise.js修改与实现-----------------------------------------------------//添加 then 方法Promise.prototype.then = function (onResolved, onRejected) &#123; ... -----------修改1 if (typeof onRejected !== &#x27;function&#x27;) &#123;onRejected = reason =&gt; &#123; throw reason;&#125;&#125; if (typeof onResolved !== &#x27;function&#x27;) &#123; onResolved = value =&gt; value;&#125; ....&#125;//添加 catch 方法 Promise.prototype.catch = function(onRejected)&#123; ---------------异常穿透 修改2 return this.then(undefined, onRejected);&#125; Promise的静态方法实现Promise.resolve 封装 判断传入的参数是否为promise对象: Ⅰ-如果为promise:将其状态与结果赋值给外层promise对象 Ⅱ-如果为非promise:状态设置为成功 1234567891011121314151617181920html调用------------------------------------------------------------ const p = Promise.resolve(&#x27;OK&#x27;); const p2 = Promise.resolve(new Promise((resolve, reject) =&gt; &#123; reject(&quot;error&quot;);// resolve(&#x27;Success&#x27;); &#125;)); const p3 = Promise.resolve(Promise.resolve(&#x27;Oh Yeah&#x27;)); console.log(p3);promise.js修改与实现-----------------------------------------------------//添加 resolve 方法Promise.resolve = function(value)&#123; //返回promise对象 return new Promise((resolve, reject) =&gt; &#123; if(value instanceof Promise)&#123; value.then( v=&gt;&#123;resolve(v);&#125;, r=&gt;&#123;reject(r);&#125; )&#125;else&#123;resolve(value); &#125;//状态设置为成功 &#125;);&#125; Promise.resolve 封装 不同于resolve,这个方法只要把传入参数再次传出去,并将状态改为失败即可 12345678910111213141516html调用------------------------------------------------------------ //Promise.reject const p = Promise.reject(&#x27;Error&#x27;); const p2 = Promise.reject(new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;OK&#x27;); &#125;)); console.log(p); console.log(p2);promise.js修改与实现-----------------------------------------------------//添加 reject 方法Promise.reject = function (reason) &#123; return new Promise((resolve, reject) =&gt; &#123; reject(reason); &#125;);&#125; Promise.all 封装 遍历传入的promise数组,每当遍历结果是成功,则用计数器记录,当计数器等同于数组长度,则全部成功,这时候可以返回成功状态 如果当数组中任意一个promise的执行结果是reject,直接中断,返回状态为失败 12345678910111213141516171819202122232425262728293031323334html调用------------------------------------------------------------ let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123;resolve(&#x27;OK&#x27;); &#125;, 1000) &#125;) let p2 = Promise.reject(&#x27;Success&#x27;); let p3 = Promise.resolve(&#x27;Oh Yeah&#x27;); //调用 all 方法 let result = Promise.all([p1, p2, p3]); console.log(result);promise.js修改与实现-----------------------------------------------------//添加 all 方法Promise.all = function (promises) &#123; //返回结果为promise对象 return new Promise((resolve, reject) =&gt; &#123; //声明变量 let count = 0; let arr = []; //遍历 for (let i = 0; i &lt; promises.length; i++) &#123; promises[i].then(v =&gt; &#123; //得知对象的状态是成功 //每个promise对象 都成功 count++; //将当前promise对象成功的结果 存入到数组中 arr[i] = v; //判断 if (count === promises.length) &#123;resolve(arr);&#125;//修改状态 &#125;, r =&gt; &#123; reject(r); &#125;); &#125; &#125;);&#125; Promise.race 封装 直接谁先执行就返回谁的运行结果即可 12345678910111213141516171819202122232425html调用------------------------------------------------------------ let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123;resolve(&#x27;OK&#x27;);&#125;); &#125;); let p2 = Promise.reject(&#x27;Success&#x27;); let p3 = Promise.resolve(&#x27;Oh Yeah&#x27;); //调用 race 方法 let result = Promise.race([p1, p2, p3]); console.log(result);promise.js修改与实现-----------------------------------------------------//添加 race 方法Promise.race = function (promises) &#123; return new Promise((resolve, reject) =&gt; &#123; for (let i = 0; i &lt; promises.length; i++) &#123; promises[i].then(v =&gt; &#123; //修改返回对象的状态为 『成功』 resolve(v); &#125;, r =&gt; &#123; //修改返回对象的状态为 『失败』 reject(r); &#125;) &#125; &#125;);&#125; 其他优化回调函数『异步执行』 如果我们运行下面代码,正确顺序是: 111 —&gt; 333 —&gt;444 123456789101112let p1 = new Promise((resolve, reject) =&gt; &#123; reject(&#x27;OK&#x27;); console.log(111); &#125;); p1.then(value =&gt; &#123; console.log(222); &#125;, reason =&gt; &#123; console.log(444); &#125;); console.log(333); 但当我们运行之前封装的 Promise 代码时,结果却是:111 —&gt; 444 —&gt; 333 我们需要将我们的then方法变成异步方法 我们只要在以下四处地方的回调函数调用外层包裹一层定时器(不一定是定时器,开启异步即可),即可做到异步操作 123456789101112131415161718192021&gt;function resolve(data)&#123; setTimeout(() =&gt; &#123; self.callbacks.forEach(item =&gt; &#123; item.onResolved(data); &#125;); &#125;);--修改1 &#125; //reject 函数 function reject(data)&#123; setTimeout(() =&gt; &#123; self.callbacks.forEach(item =&gt; &#123; item.onRejected(data); &#125;); &#125;);---修改2 &#125;&gt;//添加 then 方法&gt;Promise.prototype.then = function(onResolved, onRejected)&#123; return new Promise((resolve, reject) =&gt; &#123; //调用回调函数 PromiseState /* 修改前代码 if (this.PromiseState === &#x27;fulfilled&#x27;) &#123; callback(onResolved); &#125; if (this.PromiseState === &#x27;rejected&#x27;) &#123; callback(onRejected); */ if(this.PromiseState === &#x27;fulfilled&#x27;)&#123;setTimeout(() =&gt; &#123; callback(onResolved);&#125;);&#125; -----修改3 if(this.PromiseState === &#x27;rejected&#x27;)&#123; setTimeout(() =&gt; &#123; callback(onRejected);&#125;); ---修改4 &#125; &#125; 相关原理参照js事件循环机制、宏任务与微任务 class改写promise 其中将self=this保存this指向方式改为箭头函数表示(在上面示例中也有效果) 将其改为class写法 下面为promisedemo.js代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180&gt;class Promise &#123;//构造方法constructor(executor) &#123; //添加属性 this.PromiseState = &#x27;pending&#x27;; this.PromiseResult = null; //声明属性 this.callbacks = []; //保存实例对象的 this 的值 //resolve 函数 let resolve = (data) =&gt; &#123; //判断状态 if (this.PromiseState !== &#x27;pending&#x27;) return; //1. 修改对象的状态 (promiseState) this.PromiseState = &#x27;fulfilled&#x27;; // resolved //2. 设置对象结果值 (promiseResult) this.PromiseResult = data; //调用成功的回调函数 setTimeout(() =&gt; &#123; this.callbacks.forEach(item =&gt; &#123; item.onResolved(data); &#125;); &#125;); &#125; //reject 函数 let reject = (data) =&gt; &#123; //判断状态 if (this.PromiseState !== &#x27;pending&#x27;) return; //1. 修改对象的状态 (promiseState) this.PromiseState = &#x27;rejected&#x27;; // //2. 设置对象结果值 (promiseResult) this.PromiseResult = data; //执行失败的回调 setTimeout(() =&gt; &#123; this.callbacks.forEach(item =&gt; &#123; item.onRejected(data); &#125;); &#125;); &#125; try &#123; //同步调用『执行器函数』 executor(resolve, reject); &#125; catch (e) &#123; //修改 promise 对象状态为『失败』 reject(e); &#125;&#125;//then 方法封装then(onResolved, onRejected) &#123; //判断回调函数参数 if (typeof onRejected !== &#x27;function&#x27;) &#123; onRejected = reason =&gt; &#123; throw reason; &#125; &#125; if (typeof onResolved !== &#x27;function&#x27;) &#123; onResolved = value =&gt; value; //value =&gt; &#123; return value&#125;; &#125; return new Promise((resolve, reject) =&gt; &#123; //封装函数 let callback = (type) =&gt; &#123; try &#123; //获取回调函数的执行结果 let result = type(this.PromiseResult); //判断 if (result instanceof Promise) &#123; //如果是 Promise 类型的对象 result.then(v =&gt; &#123; resolve(v); &#125;, r =&gt; &#123; reject(r); &#125;) &#125; else &#123; //结果的对象状态为『成功』 resolve(result); &#125; &#125; catch (e) &#123; reject(e); &#125; &#125; //调用回调函数 PromiseState if (this.PromiseState === &#x27;fulfilled&#x27;) &#123; setTimeout(() =&gt; &#123; callback(onResolved); &#125;); &#125; if (this.PromiseState === &#x27;rejected&#x27;) &#123; setTimeout(() =&gt; &#123; callback(onRejected); &#125;); &#125; //判断 pending 状态 if (this.PromiseState === &#x27;pending&#x27;) &#123; //保存回调函数 this.callbacks.push(&#123; onResolved: function () &#123; callback(onResolved); &#125;, onRejected: function () &#123; callback(onRejected); &#125; &#125;); &#125; &#125;)&#125;//catch 方法catch (onRejected) &#123; return this.then(undefined, onRejected);&#125;//添加 resolve 方法static resolve(value) &#123; //返回promise对象 return new Promise((resolve, reject) =&gt; &#123; if (value instanceof Promise) &#123; value.then(v =&gt; &#123; resolve(v); &#125;, r =&gt; &#123; reject(r); &#125;) &#125; else &#123; //状态设置为成功 resolve(value); &#125; &#125;);&#125;//添加 reject 方法static reject(reason) &#123; return new Promise((resolve, reject) =&gt; &#123; reject(reason); &#125;);&#125;//添加 all 方法static all(promises) &#123; //返回结果为promise对象 return new Promise((resolve, reject) =&gt; &#123; //声明变量 let count = 0; let arr = []; //遍历 for (let i = 0; i &lt; promises.length; i++) &#123; // promises[i].then(v =&gt; &#123; //得知对象的状态是成功 //每个promise对象 都成功 count++; //将当前promise对象成功的结果 存入到数组中 arr[i] = v; //判断 if (count === promises.length) &#123; //修改状态 resolve(arr); &#125; &#125;, r =&gt; &#123; reject(r); &#125;); &#125; &#125;);&#125;//添加 race 方法static race(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; for (let i = 0; i &lt; promises.length; i++) &#123; promises[i].then(v =&gt; &#123; //修改返回对象的状态为 『成功』 resolve(v); &#125;, r =&gt; &#123; //修改返回对象的状态为 『失败』 reject(r); &#125;) &#125; &#125;);&#125;&gt;&#125; html文件调用 123456789101112131415161718192021222324252627282930&gt;&lt;!DOCTYPE html&gt;&gt;&lt;html lang=&quot;en&quot;&gt;&gt;&lt;head&gt;&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&gt;&lt;title&gt;class版本封装&lt;/title&gt;&gt;&lt;script src=&quot;./promisedemo.js&quot;&gt;&lt;/script&gt;&gt;&lt;/head&gt;&gt;&lt;body&gt;&gt;&lt;script&gt;&gt;let p1 = new Promise((resolve, reject) =&gt; &#123;setTimeout(() =&gt; &#123; // resolve(&quot;OK&quot;); reject(&quot;Erosssr&quot;);&#125;)&gt;&#125;);&gt;p1.then(value =&gt; &#123;console.log(value);&gt;&#125;, reason =&gt; &#123;console.warn(reason);&gt;&#125;);&gt;console.log(Promise.resolve(&#x27;OK&#x27;));&gt;&lt;/script&gt;&gt;&lt;/body&gt;&gt;&lt;/html&gt; Promise+ async + await 1)Promise==&gt;异步2)await==&gt;异步转同步 await 可以理解为是 async wait 的简写。await 必须出现在 async 函数内部，不能单独使用。 await 后面可以跟任何的JS 表达式。虽然说 await 可以等很多类型的东西，但是它最主要的意图是用来等待 Promise 对象的状态被 resolved。如果await的是 promise对象会造成异步函数停止执行并且等待 promise 的解决,如果等的是正常的表达式则立即执行 3)async==&gt;同步转异步 方法体内部的某个表达式使用await修饰，那么这个方法体所属方法必须要用async修饰所以使用awit方法会自动升级为异步方法 4)mdn文档 async await async函数 函数的返回值为 promise 对象 promise 对象的结果由 async 函数执行的返回值决定 await表达式 await 右侧的表达式一般为 promise 对象, 但也可以是其它的值 如果表达式是 promise 对象, await 返回的是 promise 成功的值 如果表达式是其它值, 直接将此值作为 await 的返回值 注意 await 必须写在 async 函数中, 但 async 函数中可以没有 await 如果 await 的 promise 失败了, 就会抛出异常, 需要通过 try…catch 捕获处理 原作者对某些问题理解解答如何在Promise外部使用Promise的结果 用到的本章节知识: 1、axios本质上就是一个promise,所以下面用定时器+Promise模拟axios,效果一样,可以将new Promise(resolve =&gt; &#123;setTimeout(function() &#123; resolve(&quot;promise普通结果&quot;); &#125;, 1000); &#125;)等价于axios(&#123;&#125;) 2、resolve() 与reject()是修改Promise状态并往外抛出的,一个Promise只能改变一次状态,所以一个primise中只能调用一次 3、 上一步抛出后可以在下面 的.then()中获取到 Ⅰ-如果没有用.then(),则值会抛往Promise外部 Ⅱ-如果声明了.then(),则值会被.then()接住,放到里面处理,如果需要再次抛出—某些业务场景需要 ,然后在下一个then()或者外部使用, 则可以 .then(v=&gt;return v) —-前提这个链式调用前曾使用过resolve() 与reject()才用return,不然就用这两个resolve() 与reject() 123456789101112131415161718192021222324252627282930313233&gt;//讲解时写的简单demo&gt;let resolveCommon = ()=&gt; &#123;&gt;let result=&quot;普通promise初始值&quot;&gt;result=new Promise(resolve =&gt; &#123;setTimeout(function() &#123; resolve(&quot;promise普通结果&quot;); &#125;, 1000); &#125;)&gt;console.log(result)&gt;//打印结果: Promise &#123; &lt;pending&gt; &#125; &gt;&#125;;&gt;let resolveAsync=async ()=&gt; &#123;&gt;let result=&quot;await+async的promise初始值&quot;&gt;result=await new Promise(resolve =&gt; &#123; setTimeout(function() &#123; resolve(&quot;这是async+await结果&quot;); &#125;, 1000);&#125;)&gt;console.log(result)&gt;//打印结果: 这是async+await结果 这里就是正确的值,你可以在下一步进行正常使用,也可以用在下一步的promise中&gt;//------------------------------------------------------&gt;//在第二个promise中调用使用&gt;let result2=&quot;&quot;&gt;result2= await new Promise(resolve =&gt; &#123; setTimeout(function() &#123; resolve(result+&quot;+经过第二个promise加工&quot;); &#125;, 1000);&#125;)&gt;.then(v=&gt;&#123;&gt;console.log(&quot;第二个promise的then()中打印并返回:&quot;,v)&gt;return v+&quot;,经过then()加工返回&quot;&gt;&#125;)&gt;console.log(&quot;最终结果:第二个promise外部结果打印,&quot;,result2)&gt;//---------------------------------------------&gt;&#125;;&gt;resolveCommon() //调用普通promise函数&gt;resolveAsync() //调用await+async&gt;/**&gt;运行结果&gt;1.resolveCommon() 运行结果: Promise &#123; &lt;pending&gt; &#125;&gt;2.resolveAsync() 运行结果: &gt;这是async+await结果&gt;第二个promise的then()中打印并返回: 这是async+await结果+经过第二个promise加工&gt;最终结果:第二个promise外部结果打印, 这是async+await结果+经过第二个promise加工,经过then()加工返回&gt;*/ 原因解析: new Promise()是一个异步任务,会加到异步队列中,而正常运行比如console.log()是同步运行的(即从上往下运行),会加到同步队列 所以 Promise()通常是会在同一等级的同步任务之后才得到结果的 所以你得到的是一个挂起的 Promise { } 对象 而await则是让跟在后面的异步任务转为同步任务(效果如此,就通俗来讲,具体概念需要自学),所以result就能得到一个已经修改状态为成功或者失败的值 所以下面的任务就可以使用到这个值 为什么这些操作要放在同一个async fn()=&gt;{} 中? 1)Promise==&gt;异步 2)await==&gt;异步转同步 await 可以理解为是 async wait 的简写。await 必须出现在 async 函数内部，不能单独使用。 await 后面可以跟任何的JS 表达式。虽然说 await 可以等很多类型的东西，但是它最主要的意图是用来等待 Promise 对象的状态被 resolved。如果await的是 promise对象会造成异步函数停止执行并且等待 promise 的解决,如果等的是正常的表达式则立即执行 3)async==&gt;同步转异步 方法体内部的某个表达式使用await修饰，那么这个方法体所属方法必须要用async修饰所以使用awit方法会自动升级为异步方法 宏任务与微任务说明 原理图: 说明: JS中用来存储待执行回调函数的队列包含2个不同特定的列队 宏队列:用来保存待执行的宏任务(回调),比如:定时器回调/ajax回调/dom事件回调 微队列:用来保存待执行的微任务(回调),比如:Promise的回调/muntation回调 JS执行时会区别这2个队列: JS执行引擎首先必须执行所有的初始化同步任务代码 每次准备取出第一个宏任务执行前,都要将所有的微任务一个一个取出来执行 同步任务 —&gt; 微任务 —&gt; 宏任务 Ⅱ-代码与示例 你需要一些栗子来帮助验证自己的想法是否正确,尽量先不看结果去自己思考下打印结果顺序 1、代码示例:a) 首先给出注释的栗子举一个 此处会给出每个打印放入什么队列,加深你的印象 1234567891011121314151617181920212223setTimeout(() =&gt; &#123; console.log(&#x27;timeout callback1（）&#x27;) //立即放入宏队列 Promise.resolve(3).then((value) =&gt; &#123; console.log(&#x27;Promise onResolved3()&#x27;, value) //当这个宏任务执行后 立马放入微队列,所以这个微任务执行完后下个宏任务才能执行 &#125;) &#125;, 0) setTimeout(() =&gt; &#123; console.log(&#x27;timeout callback2（）&#x27;) //立即放入宏队列, &#125;, 0) Promise.resolve(1).then((value) =&gt; &#123; console.log(&#x27;Promise onResolved1()&#x27;, value) //立即放入微队列 setTimeout(() =&gt; &#123; console.log(&#x27;timeout callback3（）&#x27;, value) //立即放入宏任务 &#125;, 0) &#125;) Promise.resolve(2).then((value) =&gt; &#123; console.log(&#x27;Promise onResolved2()&#x27;, value) //立即放入微队列 &#125;)console.log(&#x27;同步代码&#x27;) //同步代码立即执行 结果放在下方,就怕你不小心瞄到 b) 尝试自己思考下 尝试自己脑海中用自己理解 ‘运行’ 一下, 然后把结果写下来,再去下面结果做对比 123456789&gt;setTimeout(() =&gt; console.log(&#x27;代码开始执行&#x27;), 0)&gt;new Promise((resolve, reject) =&gt; &#123; console.log(&#x27;开始for循环&#x27;) for (let i = 0; i &lt; 10000; i++) &#123; i == 99 &amp;&amp; resolve() &#125;&gt;&#125;).then(() =&gt; console.log(&#x27;执行then函数&#x27;))&gt;console.log(&#x27;代码执行结束&#x27;) 2、示例结果:a) 第一个栗子的结果 1234567&gt;&#x27;同步代码&#x27;,&gt;&#x27;Promise onResolved1()&#x27;,&gt;&#x27;Promise onResolved2()&#x27;,&gt;&#x27;timeout callback1（）&#x27;,&gt;&#x27;Promise onResolved3()&#x27;,&gt;&#x27;timeout callback2（）&#x27;,&gt;&#x27;timeout callback3（）&#x27; b) 第二个栗子的结果 PS: 可以忽略undefined这个打印结果, 因为这会加重我们对于宏任务与微任务的理解负担. 当然人都是会好奇的,没有打破砂锅问到底的精神呢也当不了一个好程序员,那我就在下方额外给出解释 五、对浏览器console控制台输出undefined的分析Ⅰ- 出现场景 Ⅱ - 尝试输入其他内容进行分析 那么做个合理推测: 应该是在控制台输入的内容,它的 返回值 会显示出来,这让我们不禁想到JS的 [ eval() ] Ⅲ - eval（string） 其作用是将 接收的 string 字符串作为参数，对其进行JavaScript 表达式或语句 计算，返回得到的值； 如果是没有返回值的表达式或语句，则会返回 undefined ； 如果没有合法的表达式和语句，则会抛出 SyntaxError 异常 。 于是我们可以猜测Console控制台的实质 就是 调用了eval（）函数 Ⅳ - 验证一下 大家都是聪明人,看到这个结果应该就不用我组织语言来解释了吧 Ⅴ - 分析其在宏任务与微任务的打印顺序 首先看图: 可以看到 [ undefined ] 实在微任务完成后,宏任务执行前 打印","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://hasuer.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"Nginx学习笔记","slug":"Nginx学习笔记","date":"2022-02-23T12:37:35.000Z","updated":"2022-02-25T06:01:54.829Z","comments":true,"path":"nginx学习笔记/index.html","link":"","permalink":"https://hasuer.github.io/nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html","excerpt":"","text":"Nginx 简介Nginx概述Nginx (“engine x”)是一个高性能的 HTTP 和反向代理服务器 特点是占有内存少，并发能力强，事实上 nginx 的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用 nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等 Nginx 作为 web 服务器Nginx可以作为静态页面的 web 服务器，同时还支持 CGI 协议的动态语言，比如 pe rl 、 php等。但是不支持 java 。 Java 程序只能通过与 tomcat 配合完成。 Nginx 专为性能优化而开发，性能是其最重要的考量 实现上非常注重效率 ，能经受高负载的考验 有报告表明能支持高达 50,000 个并发连接数。 https://lnmp.org/nginx.html 正向代理Nginx不仅可以做反向代理，实现负载均衡。还能用作正向代理来进行上网等功能。 正向代理：如果把局域网外的Internet 想象成一个巨大的资源库，则局域网中的客户端要访问 Internet ，则需要通过代理服务器来访问，这种代理服务就称为正向代理。 反向代理反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器 IP 地址。 负载均衡客户端发送多个请求到服务器，服务器处理请求，有一些可能要与数据库进行交互，服务器处理完毕后，再将结果返回给客户端。 这种架构模式对于早期的系统相对单一，并发请求相对较少的情况下是比较适合的，成本也低。但是随着信息数量的不断增长，访问量和数据量的飞速增长，以及系统业务的复杂度增加，这种架构会造成服务器相应客户端的请求日益缓慢，并发量特别大的时候，还容易造成服务器直接崩溃。很明显这是由于服务器性能的瓶颈造成的问题，那么如何解决这种情况呢？ 我们首先想到的可能是升级服务器的配置，比如提高CPU执行频率，加大内存等提高机器的物理性能来解决此问题，但是我们知道摩尔定律的日益失效，硬件的性能提升已经不能满足日益提升的需求了。最明显的一个例子，天猫双十一当天，某个热销商品的瞬时访问量是极其庞大的，那么类似上面的系统架构，将机器都增加到现有的顶级物理配置，都是不能够满足需求的。那么怎么办呢？ 上面的分析我们去掉了增加服务器物理配置来解决问题的办法，也就是说纵向解决问题的办法行不通了，那么横向增加服务器的数量呢？这时候集群的概念产生了，单个服务器解决不了，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡 动静分离为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。 Nginx 安装进入 nginx 官网，下载http://nginx.org/ 安装 nginx第一步，安装 pcrewget http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre8.37.tar.gz 解压文件，./configure完成后，回到 pcre 目录下执行 make再执行make install 第二步，安装 openssl第三步，安装 zlibyum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel 第四步,安装 nginx 解压缩 nginx xx.tar.gz 包。 进入解压缩目录 执行 ./configure 。 make &amp;&amp; make install 查看开放的端口号firewall-cmd --list all设置开放的端口号firewall-cmd --add-service=http --permanentsudo firewall-cmd --add -port=80/tcp --permanent重启防火墙firewall-cmd --reload nginx 常用的命令和配置文件nginx 常用的命令 启动命令 在/usr/local/nginx/sbin 目录下执行 ./nginx 关闭命令在/usr/local/nginx/sbin 目录下执行 ./nginx -s stop 重新加载命令在/usr/local/nginx/sbin 目录下执行 ./nginx -s reload nginx.conf 配置文件nginx 安装目录下，其默认的配置文件都放在这个目录的 conf 目录下，而 主配置文件 nginx.conf 也在其中，后续对 nginx 的使用基本上都是对此配置文件进行相应的修改 配置文件中有很多 开头的表示注释内容，我们去掉所有以 # 开头的段落，精简之后的内容如下： 根据上述文件，我们可以很明显的将 nginx.conf 配置文件分为三部分： 第一部分：全局块从配置文件开始到 events 块之间的内容，主要会设置一些影响nginx 服务器整体运行的配置指令，主要包括配置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以及配置文件的引入等。 比如上面第一行配置的： 这是 Nginx 服务器并发处理服务的关键配置，worker_processes 值越大，可以支持的并发处理量也越多，但是会受到硬件、软件等设备的制约 第二部分：events块比如上面的配置： events 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word process 可以同时支持的最大连接数等。 上述例子就表示每个 work process 支持的最大连接数为 1024. 这部分的配置对 Nginx 的性能影响较大，在实际中应该灵活配置。 第三部分：http块 这算是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。 需要注意的是：http 块也可以包括 http全局块、server 块。 http 全局块http全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。 server 块这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。 每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。 而每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。 全局 server 块 最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或IP配置。 location 块 一个 server 块可以配置多个 location 块。 这块的主要作用是基于 Nginx 服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟主机名称（也可以是IP别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。 nginx 配置实例 反向代理反向代理实例一实现效果：使用 n ginx 反向代理，访问 www 123 com 直接跳转到 127.0.0.1:8080 实验代码 启动一个 tomcat ，浏览器地址栏输入 127.0.0.1:8080 ，出现如下界面 通过修改本地 host 文件，将 www. 123 .com 映射到 127.0.0.1 配置完成之后，我们便可以通过www.123.com:8080 访问到第一步出现的 Tomcat初始界面。那么如何只需要输入www.123.com便可以跳转到 Tomcat初始界面呢？便用到 nginx的反向代理。 在 nginx.conf配置文件中增加如下配置 如上配置，我们监听80端口，访问域名为www.123.com，不加端口号时默认为80端口，故访问该域名时会跳转到127.0.0.1:8080路径上。在浏览器端输入 www.123.com 结果如下： 反向代理实例二实现效果：使用 nginx 反向代理， 根据访问的路径跳转到不同端口的服务中nginx 监听端口为 9001访问 http://127.0.0.1:9001/edu/ 直接跳转到 127.0.0.1:8081访问 http://127.0.0.1:9001/vod/ 直接跳转到 127.0.0.1:8082 实验代码第一步，准备两个 tomcat ，一个 8001 端口，一个 8002 端口，并准备好测试的页面第二步，修改 nginx 的配置文件在http 块中添加 server{} location 指令说明该指令用于匹配 URL。 语法如下： 1、= ：用于不含正则表达式的 uri 前，要求请求字符串与 uri 严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求。 2、~：用于表示 uri 包含正则表达式，并且区分大小写。 3、~*：用于表示 uri 包含正则表达式，并且不区分大小写。 4、^~：用于不含正则表达式的 uri 前，要求 Nginx 服务器找到标识 uri 和请求字符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location 块中的正则 uri 和请求字符串做匹配。 注意：如果 url 包含正则表达式，则必须要有 ~ 或者 ~\\ 标识。 nginx 配置实例 负载均衡实现效果： 配置负载均衡 实验代码 首先准备两个同时启动的 Tomcat 在 nginx.conf 中进行配置 随着互联网信息的爆炸性增长，负载均衡（load balance ）已经不再是一个很陌生的话题顾名思义，负载均衡即是将负载分摊到不同的服务单元，既保证服务的可用性，又保证响应足够快，给用户很好的体验。快速增长的访问量和数据流量催生了各式各样的负载均衡产品，很多专业的负载均衡硬件提供了很好的功能，但却价格不菲，这使得负载均衡软件大受欢迎，nginx 就是其中的一个，在 linux 下有 Nginx 、 LVS 、 Haproxy 等等服务可以提供负载均衡服务，而且 Nginx 提供了几种分配方式 策略: 1、轮询（默认）每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。2、weightweight代表权 重默认为 1, 权重越高被分配的客户端越多。指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 例如： 1234upstream server_pool&#123; server 192.168.5.21 weight=10; server 192.168.5.22 weight=10; &#125; 3、ip_hash每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 例如： 12345upstream server_pool&#123; ip_hash; server 192.168.5.21:80; server 192.168.5.22:80; &#125; 4、fair（第三方） 按后端服务器的响应时间来分配请求，响应时间短的优先分配。 12345upstream server_pool&#123; server 192.168.5.21:80; server 192.168.5.22:80; fair; &#125; nginx 配置实例 动静分离Nginx 动静分离简单来说就是把动态跟静态请求分开，不能理解成只是单纯的把动态页面和静态页面物理分离。严格意义上说应该是动态请求跟静态请求分开，可以理解成使用Nginx 处理静态页面，Tomcat处理动态页面。 动静分离从目前实现角度来讲大致分为两种， 一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案； 另外一种方法就是动态跟静态文件混合在一起发布，通过 nginx 来分开。 通过 location 指定不同的后缀名实现不同的请求转发。通过 expires 参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量。具体 Expires 定义：是给一个资源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。此种方法非常适合不经常变动的资源。（如果经常更新的文件，不建议使用 Expires 来缓存），我这里设置 3d，表示在这 3 天之内访问这个 URL，发送一个请求，比对服务器该文件最后更新时间没有变化，则不会从服务器抓取，返回状态码 304，如果有修改，则直接从服务器重新下载，返回状态码 200。 实验代码 项目资源准备 进行 nginx 配置找到 nginx 安装目录，打开 /conf/nginx.conf 配置文件， 添加监听端口、访问名字重点是添加location,最后检查 Nginx 配置是否正确即可，然后测试动静分离是否成功，之需要删除后端 tomcat服务器上的某个静态文件，查看是否能访问，如果可以访问说明静态资源 nginx 直接返回了，不走后端 tomcat 服务器.","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://hasuer.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"AJAX学习笔记","slug":"AJAX学习笔记","date":"2022-02-23T06:53:23.000Z","updated":"2022-02-23T10:33:09.519Z","comments":true,"path":"ajax学习笔记/index.html","link":"","permalink":"https://hasuer.github.io/ajax%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html","excerpt":"","text":"本笔记是视频课程的笔记。【尚硅谷】3小时AJAX入门到精通 笔记转载自这里,做了适当改动。 此部分知识为学习axios预备知识,预备知识链:ajax —&gt; promise —&gt; axios —&gt; react/vue Ajax简介 AJAX 简介 AJAX 全称为 Asynchronous JavaScript And XML，就是异步的 JS 和 XML。 通过 AJAX 可以在浏览器中向服务器发送异步请求，最大的优势：无刷新获取数据。 AJAX 不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式。 XML简介 XML 可扩展标记语言。 XML 被设计用来传输和存储数据。 XML 和 HTML 类似，不同的是 HTML 中都是预定义标签，而 XML 中没有预定义标签， 全都是自定义标签，用来表示一些数据。 比如说我有一个学生数据： name = “孙悟空” ; age = 18 ; gender = “男” ; 123456用 XML 表示：&lt;student&gt; &lt;name&gt;孙悟空&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;gender&gt;男&lt;/gender&gt;&lt;/student&gt; 现在已经被 JSON 取代了。 1&#123;&quot;name&quot;:&quot;孙悟空&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;&#125; Ajax的特点AJAX 的优点 可以无需刷新页面而与服务器端进行通信。 允许你根据用户事件来更新部分页面内容。 Ajax的缺点 没有浏览历史，不能回退 存在跨域问题(同源) SEO (搜索引擎优化）不友好，爬虫无法爬到 HTTP简介 HTTP（hypertext transport protocol）协议『超文本传输协议』，协议详细规定了浏览器和万维网服务器之间互相通信的规则、约定,、规则 请求报文 123456789重点是格式与参数行 POST /s?ie=utf-8 HTTP/1.1 头 Host: atguigu.com Cookie: name=guigu Content-type: application/x-www-form-urlencoded User-Agent: chrome 83空行体 username=admin&amp;password=admin 响应报文 12345678910111213行 HTTP/1.1 200 OK头 Content-Type: text/html;charset=utf-8 Content-length: 2048 Content-encoding: gzip空行 体 &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;尚硅谷&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; Chrome网络控制台查看通信报文 1、Network —&gt; Hearders 请求头 2、Network —&gt; Response 响应体:通常返回的是html 原生Ajax 1、XMLHttpRequest，AJAX 的所有操作都是通过该对象进行的。 2、当你前端想设置自定义的请求头时,需要如此后端设置响应头 123//表示接收任意类型的请求 app.all(&#x27;/server&#x27;, (request, response) =&gt; &#123; //响应头 允许跨域 运行自定义响应头 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;*&#x27;);&#125; 3、ajax请求状态:xhr.readyState 0：请求未初始化，还没有调用 open()。 1：请求已经建立，但是还没有发送，还没有调用 send()。 2：请求已发送，正在处理中（通常现在可以从响应中获取内容头）。 3：请求在处理中；通常响应中已有部分数据可用了，没有全部完成。 4：响应已完成；您可以获取并使用服务器的响应了 Ajax的使用 使用步骤: 1234567891011121314151617181920212223241) 创建 XMLHttpRequest 对象var xhr = new XMLHttpRequest();2) 设置请求信息xhr.open(method, url);//可以设置请求头，一般不设置xhr.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;);3) 发送请求xhr.send(body) //get 请求不传 body 参数，只有 post 请求使用4) 接收响应//xhr.responseXML 接收 xml 格式的响应数据//xhr.responseText 接收文本格式的响应数据xhr.onreadystatechange = function ()&#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; var text = xhr.responseText; console.log(text); &#125;&#125;/*0: 请求未初始化1: 服务器连接已建立2: 请求已接收3: 请求处理中4: 请求已完成，且响应已就绪*/ Get方式12345678910111213141516171819202122232425262728293031//绑定事件btn.onclick = function () &#123; //1. 创建对象 const xhr = new XMLHttpRequest(); //2. 初始化 设置请求方法和 url // 使用&amp;分割参数 xhr.open(&#x27;GET&#x27;, &#x27;http://127.0.0.1:8000/server?a=100&amp;b=200&amp;c=300&#x27;); //3. 发送 xhr.send(); //4. 事件绑定 处理服务端返回的结果 // on when 当....时候 // readystate 是 xhr 对象中的属性, 表示状态 0 1 2 3 4 // change 改变 xhr.onreadystatechange = function () &#123; //判断 (服务端返回了所有的结果) if (xhr.readyState === 4) &#123; //判断响应状态码 200 404 403 401 500 // 2xx 成功 if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123; //处理结果 行 头 空行 体 //响应 // console.log(xhr.status);//状态码 // console.log(xhr.statusText);//状态字符串 // console.log(xhr.getAllResponseHeaders());//所有响应头 // console.log(xhr.response);//响应体 //设置 result 的文本 result.innerHTML = xhr.response; &#125; else &#123;&#125; &#125; &#125;&#125; Post方式12345678910111213141516171819202122232425//绑定事件 result.addEventListener(&quot;mouseover&quot;, function()&#123; //1. 创建对象 const xhr = new XMLHttpRequest(); //2. 初始化 设置类型与 URL xhr.open(&#x27;POST&#x27;, &#x27;http://127.0.0.1:8000/server&#x27;); //设置请求头 xhr.setRequestHeader(&#x27;Content-Type&#x27;,&#x27;application/x-www-form-urlencoded&#x27;) // 下面这个是自定义的头信息，在后端代码中要设置允许所有的请求头，否则失败 xhr.setRequestHeader(&#x27;name&#x27;,&#x27;atguigu&#x27;); //3. 发送 xhr.send(&#x27;a=100&amp;b=200&amp;c=300&#x27;); // xhr.send(&#x27;a:100&amp;b:200&amp;c:300&#x27;); // xhr.send(&#x27;1233211234567&#x27;); //4. 事件绑定 xhr.onreadystatechange = function()&#123; //判断 if(xhr.readyState === 4)&#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123; //处理服务端返回的结果 result.innerHTML = xhr.response; &#125; &#125; &#125; &#125;); 解决ie缓存问题 问题：在一些浏览器中(IE),由于缓存机制的存在，ajax 只会发送的第一次请求，剩余多次请求不会再发送给浏览器而是直接加载缓存中的数据。 解决方式：浏览器的缓存是根据 url地址来记录的，所以我们只需要修改 url 地址 即可避免缓存问题 xhr.open(&quot;get&quot;,&quot;/testAJAX?t=&quot;+Date.now()); 请求超时与网络异常 当你的请求时间过长,或者无网络时,进行的相应处理 1234567891011121314151617181920212223btn.addEventListener(&#x27;click&#x27;, function()&#123; const xhr = new XMLHttpRequest(); //超时设置 2s 设置 xhr.timeout = 2000; //超时回调 xhr.ontimeout = function()&#123; alert(&quot;网络异常, 请稍后重试!!&quot;); &#125; //网络异常回调 xhr.onerror = function()&#123; alert(&quot;你的网络似乎出了一些问题!&quot;); &#125; xhr.open(&quot;GET&quot;,&#x27;http://127.0.0.1:8000/delay&#x27;); xhr.send(); xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4)&#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status&lt; 300)&#123; result.innerHTML = xhr.response; &#125; &#125; &#125; &#125;) 取消请求 在请求发出去后但是未响应完成时可以进行取消请求操作 1234567891011const btns = document.querySelectorAll(&#x27;button&#x27;);let x = null;btns[0].onclick = function()&#123; x = new XMLHttpRequest(); x.open(&quot;GET&quot;,&#x27;http://127.0.0.1:8000/delay&#x27;); x.send();&#125;// abortbtns[1].onclick = function()&#123; x.abort();&#125; 重复请求问题 利用之前取消请求知识点,当我点击时判断之前请求是否在发送中,如果是,则停止请求 123456789101112131415btns[0].onclick = function()&#123; //判断标识变量 if(isSending) x.abort();// 如果正在发送, 则取消该请求, 创建一个新的请求 x = new XMLHttpRequest(); //修改 标识变量的值 isSending = true; x.open(&quot;GET&quot;,&#x27;http://127.0.0.1:8000/delay&#x27;); x.send(); x.onreadystatechange = function()&#123; if(x.readyState === 4)&#123; //修改标识变量 isSending = false; &#125; &#125; &#125; 常见三种Ajax请求方式jQuery发送AJAX请求 jQuery有三种发送请求方法: 当你只是简单的请求数据,可以直接使用前两种方式请求,当你需要设置的东西较多的时候,可以使用$.ajax()方法 $.get()12345$(&#x27;button&#x27;).eq(0).click(function()&#123; $.get(&#x27;http://127.0.0.1:8000/jquery-server&#x27;, &#123;a:100, b:200&#125;, function(data)&#123; console.log(data); &#125;,&#x27;json&#x27;); &#125;); $.post()12345$(&#x27;button&#x27;).eq(1).click(function()&#123; $.post(&#x27;http://127.0.0.1:8000/jquery-server&#x27;, &#123;a:100, b:200&#125;, function(data)&#123; console.log(data); &#125;); &#125;); $.ajax123456789101112131415161718192021222324252627$(&#x27;button&#x27;).eq(2).click(function()&#123; $.ajax(&#123; //url url: &#x27;http://127.0.0.1:8000/jquery-server&#x27;, //参数 data: &#123;a:100, b:200&#125;, //请求类型 type: &#x27;GET&#x27;, //响应体结果 dataType: &#x27;json&#x27;, //成功的回调 success: function(data)&#123; console.log(data); &#125;, //超时时间 timeout: 2000, //失败的回调 error: function()&#123; console.log(&#x27;出错啦!!&#x27;); &#125;, //头信息 headers: &#123; c:300, d:400 &#125; &#125;); &#125;); Axios发送AJAX请求axios.get() axios.get(url,data,params) 1234567891011121314151617181920//配置 baseURL axios.defaults.baseURL = &#x27;http://127.0.0.1:8000&#x27;; btns[0].onclick = function () &#123; //GET 请求 axios.get(&#x27;/axios-server&#x27;, &#123; //url 参数 params: &#123; id: 100, vip: 7 &#125;, //请求头信息 headers: &#123; name: &#x27;atguigu&#x27;, age: 20 &#125; &#125;).then(value =&gt; &#123; console.log(value); &#125;); &#125; axios.post() axios.post(url,data,params) 12345678910111213141516171819 //配置 baseURL axios.defaults.baseURL = &#x27;http://127.0.0.1:8000&#x27;; btns[1].onclick = function () &#123; axios.post(&#x27;/axios-server&#x27;, &#123; username: &#x27;admin&#x27;, password: &#x27;admin&#x27; &#125;, &#123; //url params: &#123; id: 200, vip: 9 &#125;, //请求头参数 headers: &#123; height: 180, weight: 180, &#125; &#125;); &#125; axios() 常用 axios({}) 12345678910111213141516171819202122232425262728293031323334 //配置 baseURL axios.defaults.baseURL = &#x27;http://127.0.0.1:8000&#x27;;btns[2].onclick = function () &#123; axios(&#123; //请求方法 method: &#x27;POST&#x27;, //url url: &#x27;/axios-server&#x27;, //url参数 params: &#123; vip: 10, level: 30 &#125;, //头信息,此部分如果使用自定义的头信息,需要服务端进行相应修改,正常不设置 headers: &#123; a: 100, b: 200 &#125;, //请求体参数 data: &#123; username: &#x27;admin&#x27;, password: &#x27;admin&#x27; &#125; &#125;).then(response =&gt; &#123; //响应状态码 console.log(response.status); //响应状态字符串 console.log(response.statusText); //响应头信息 console.log(response.headers); //响应体 console.log(response.data); &#125;) &#125; Fetch发送AJAX请求 代码示例 1234567891011121314151617btn.onclick = function () &#123; fetch(&#x27;http://127.0.0.1:8000/fetch-server?vip=10&#x27;, &#123; //请求方法 method: &#x27;POST&#x27;, //请求头 headers: &#123; name: &#x27;atguigu&#x27; &#125;, //请求体 body: &#x27;username=admin&amp;password=admin&#x27; &#125;).then(response =&gt; &#123; // return response.text(); return response.json(); &#125;).then(response =&gt; &#123; console.log(response); &#125;); &#125; 跨域与解决 1、什么是跨越？ 一个网页向另一个不同域名/不同协议/不同端口的网页请求资源，这就是跨域。 跨域原因产生：在当前域名请求网站中，默认不允许通过ajax请求发送其他域名。 2、为什么会产生跨域请求？ 因为浏览器使用了同源策略 3、什么是同源策略？ 同源策略是Netscape提出的一个著名的安全策略，现在所有支持JavaScript的浏览器都会使用这个策略。同源策略是浏览器最核心也最基本的安全功能，如果缺少同源策略，浏览器的正常功能可能受到影响。可以说web是构建在同源策略的基础之上的，浏览器只是针对同源策略的一种实现。 同源： 协议、域名、端口号 必须完全相同。 违背同源策略就是跨域。 4、为什么浏览器要使用同源策略？ 是为了保证用户的信息安全，防止恶意网站窃取数据，如果网页之间不满足同源要求，将不能: 1、共享Cookie、LocalStorage、IndexDB 2、获取DOM 3、AJAX请求不能发送 5、跨域的五个解决方式: 1、前端使用jsonp （不推荐使用） 2、后台Http请求转发 3、后台配置同源Cors （推荐） 4、使用SpringCloud网关 5、使用nginx做转发 (推荐) 本课程提到了其中的两种: jsonP 1)JSONP 是什么? JSONP(JSON with Padding)，是一个非官方的跨域解决方案，纯粹凭借程序员的聪明 才智开发出来，只支持 get 请求。 2)JSONP 怎么工作的？ 在网页有一些标签天生具有跨域能力，比如：img link iframe script。 JSONP 就是利用 script 标签的跨域能力来发送请求的。 jsonP的使用1234567891011121314151617181920 // 1. 动态的创建一个 script 标签------------------------------------------------------------ var script = document.createElement(&quot;script&quot;);//2. 设置 script 的 src， 设置回调函数 script.src = &quot;http://localhost:3000/testAJAX?callback=abc&quot;; function abc(data) &#123; alert(data.name); &#125;; // 3. 将 script 添加到 body 中 document.body.appendChild(script); // 4. 服务器中路由的处理------------------------------------------------------ router.get(&quot;/testAJAX&quot;, function (req, res) &#123; console.log(&quot;收到请求&quot;); var callback = req.query.callback; var obj = &#123; ame: &quot;孙悟空&quot;, age: 18 &#125; res.send(callback + &quot;(&quot; + JSON.stringify(obj) + &quot;)&quot;); &#125;); jQuery发送jsonP请求1234567891011121314151617181920212223242526//前端代码-----------------------------------------------------------------------------------$(&#x27;button&#x27;).eq(0).click(function () &#123; $.getJSON(&#x27;http://127.0.0.1:8000/jquery-jsonp-server?callback=?&#x27;, function (data) &#123; $(&#x27;#result&#x27;).html(` 名称: $&#123;data.name&#125;&lt;br&gt; 校区: $&#123;data.city&#125; `) &#125;);&#125;);//服务端代码-----------------------------------------------------------app.all(&#x27;/jquery-jsonp-server&#x27;, (request, response) =&gt; &#123; // response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;); const data = &#123; name: &#x27;尚硅谷&#x27;, city: [&#x27;北京&#x27;, &#x27;上海&#x27;, &#x27;深圳&#x27;] &#125;; //将数据转化为字符串 let str = JSON.stringify(data); //接收 callback 参数 let cb = request.query.callback; //返回结果 // $&#123;&#125; 可以将str转变成对象 response.end(`$&#123;cb&#125;($&#123;str&#125;)`);&#125;); 原作者开发封装的jsonP插件 1、代价:需要前后端联动 2、精髓:自动的由插件生成方法名,并在当前的页面动态的生成函数,然后再生成的函数里头调用用户预留的回调函数 3、插件：自动化的去模拟基于script去实现跨域请求的过程（对用户来说是黑盒子） 4、参数拼接：url已经是带参的。和不带参的 5、id优化 额可以添加一个容器来管理id 1、前端调用测试封装好的jsonP代码 123456789101112//测试调用函数 let test=function () &#123; jsonP.req(&#123; url:&quot;http://localhost:3000/jsonpx&quot;, data:&#123; a:&quot;111&quot; &#125;, callback:function (result) &#123; alert(&quot;成功&quot;+result) &#125; &#125;) &#125; 2、服务端测试代码 12345678router.get(&#x27;/jsonpx&#x27;, async function (req, resp, next) &#123; let callback=req.query.callback; let data=req.query.a; if (!data)&#123; resp.send(`$&#123;callback&#125;(&#x27;洪jl:我是服务端代码&#x27;)`) &#125; resp.send(`$&#123;callback&#125;(&#x27;洪jl:我是服务端代码`+data+`&#x27;)`)&#125;) 3、封装原生代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;script&gt; /**author:@hongjilin * 1.声明一个jsonP插件对象 * 作用：隔开作用域 */ let jsonP = &#123;&#125;; /** *2.在插件对象中创建两个名字备用符数组 */ jsonP.char = &#123; Number: &#x27;0123456789&#x27;, Letter: &#x27;qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM&#x27; &#125; /** * 通过随机数抽取备用字符数组库拼凑函数id * @param charLen * @param numLen */ jsonP.newFunId = function (charLen, numLen) &#123; let id = &#x27;&#x27;; for (let i = 0; i &lt; charLen; i++) &#123; id += this.char.Letter.charAt(Math.random() * 52) &#125; for (let j = 0; j &lt; numLen; j++) &#123; id += Math.floor(Math.random() * 10); &#125; return id; &#125; /** * 拼接路径 * @param url * @param key * @param value */ jsonP.jointUrl = function (url, key, value) &#123; if (url &amp;&amp; key &amp;&amp; value) &#123; let sign = &quot;&amp;&quot; //如果是第一次 if (url.indexOf(&#x27;?&#x27;) == -1) &#123; sign = &#x27;?&#x27; &#125; url += sign + key + &quot;=&quot; + value &#125; return url; &#125; /** 封装err属性方便 */ jsonP.err = function (msg) &#123; console.error(msg) &#125; /** * 发送请求函数 * @param options */ jsonP.req = function (options) &#123; let jsonId=&#123;&#125;; //1.生成方法名 jsonId.funId = this.newFunId(4,8); let Userurl = options.url; let Userdata = options.data; if (!options) &#123; this.err(&quot;输入不能空&quot;) return; &#125; else if (!Userurl) &#123; this.err(&quot;url不能空&quot;) return; &#125; else if (!Userdata) &#123; //如果没有data,初始化 Userdata = &#123;&#125;; &#125; //将函数名赋值给userdata的回调函数属性中 Userdata.callback = jsonId.funId; for (let key in Userdata) &#123; Userurl = this.jointUrl(Userurl, key, Userdata[key]) &#125; let script = document.createElement(&#x27;script&#x27;); script.setAttribute(&quot;id&quot; , jsonId.funId); script.setAttribute(&quot;src&quot; , Userurl); //动态生成函数 let callback=function (result) &#123; console.log(&quot;xxxxxxx&quot;) //业务逻辑回调 if (options.callback)&#123; try &#123; options.callback(result) &#125;catch (e) &#123; this.err(e.message) &#125; &#125; //善后 let tmp=document.getElementById(jsonId.funId) tmp.parentNode.removeChild(tmp); eval(jsonId.funId+&#x27;=null&#x27;) &#125; eval(&quot;window.&quot;+jsonId.funId+&quot;=function(result)&#123; callback(result) &#125;&quot;) document.head.appendChild(script) &#125;&lt;/script&gt; CORS 1、CORS文档链接 2、CORS是什么? CORS（Cross-Origin Resource Sharing），跨域资源共享。CORS 是官方的跨域解决方 案，它的特点是不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持 get 和 post 请求。跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些 源站通过浏览器有权限访问哪些资源 3、CORS是怎么工作的? CORS 是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应 以后就会对响应放行。 代码示例1234567891011app.all(&#x27;/cors-server&#x27;, (request, response) =&gt; &#123; //设置响应头 //响应首部中可以携带一个 Access-Control-Allow-Origin 字段 response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); //Access-Control-Allow-Headers 首部字段用于预检请求的响应。其指明了实际请求中允许携带的首部字 response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &#x27;*&#x27;); //Access-Control-Allow-Methods 首部字段用于预检请求的响应。其指明了实际请求所允许使用的 HTTP response.setHeader(&quot;Access-Control-Allow-Method&quot;, &#x27;*&#x27;); // response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://127.0.0.1:5500&quot;); response.send(&#x27;hello CORS&#x27;);&#125;); HTTP 响应首部字段 本节列出了规范所定义的响应首部字段。上一小节中，我们已经看到了这些首部字段在实际场景中是如何工作的。 Access-Control-Allow-Origin 响应首部中可以携带一个 Access-Control-Allow-Origin 字段，其语法如下: 1Access-Control-Allow-Origin: &lt;origin&gt; | * 其中，origin 参数的值指定了允许访问该资源的外域 URI。对于不需要携带身份凭证的请求，服务器可以指定该字段的值为通配符，表示允许来自所有域的请求。 例如，下面的字段值将允许来自 http://mozilla.com 的请求： 1Access-Control-Allow-Origin: http://mozilla.com 如果服务端指定了具体的域名而非“*”，那么响应首部中的 Vary 字段的值必须包含 Origin。这将告诉客户端：服务器对不同的源站返回不同的内容。 Access-Control-Expose-Headers 译者注：在跨源访问时，XMLHttpRequest对象的getResponseHeader()方法只能拿到一些最基本的响应头，Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。 Access-Control-Expose-Headers 头让服务器把允许浏览器访问的头放入白名单，例如： 1Access-Control-Expose-Headers: X-My-Custom-Header, X-Another-Custom-Header 这样浏览器就能够通过getResponseHeader访问X-My-Custom-Header和 X-Another-Custom-Header 响应头了。 Access-Control-Max-Age Access-Control-Max-Age 头指定了preflight请求的结果能够被缓存多久，请参考本文在前面提到的preflight例子。 1Access-Control-Max-Age: &lt;delta-seconds&gt; delta-seconds 参数表示preflight请求的结果在多少秒内有效。 Access-Control-Allow-Credentials Access-Control-Allow-Credentials 头指定了当浏览器的credentials设置为true时是否允许浏览器读取response的内容。当用在对preflight预检测请求的响应中时，它指定了实际的请求是否可以使用credentials。请注意：简单 GET 请求不会被预检；如果对此类请求的响应中不包含该字段，这个响应将被忽略掉，并且浏览器也不会将相应内容返回给网页。 1Access-Control-Allow-Credentials: true Access-Control-Allow-Methods Access-Control-Allow-Methods 首部字段用于预检请求的响应。其指明了实际请求所允许使用的 HTTP 方法。 1Access-Control-Allow-Methods: &lt;method&gt;[, &lt;method&gt;]* Access-Control-Allow-Headers Access-Control-Allow-Headers 首部字段用于预检请求的响应。其指明了实际请求中允许携带的首部字段。 1Access-Control-Allow-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]* HTTP 请求首部字段 本节列出了可用于发起跨源请求的首部字段。请注意，这些首部字段无须手动设置。 当开发者使用 XMLHttpRequest 对象发起跨源请求时，它们已经被设置就绪。 Origin Origin 首部字段表明预检请求或实际请求的源站。 1Origin: &lt;origin&gt; origin 参数的值为源站 URI。它不包含任何路径信息，只是服务器名称。 Note: 有时候将该字段的值设置为空字符串是有用的，例如，当源站是一个 data URL 时。 注意，在所有访问控制请求（Access control request）中，Origin 首部字段总是被发送 Access-Control-Request-Method Access-Control-Request-Method 首部字段用于预检请求。其作用是，将实际请求所使用的 HTTP 方法告诉服务器。 1Access-Control-Request-Method: &lt;method&gt; Access-Control-Request-Headers Access-Control-Request-Headers 首部字段用于预检请求。其作用是，将实际请求所携带的首部字段告诉服务器。 1Access-Control-Request-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]* 服务端代码示例 配合以上前端代码的服务端代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153//1. 引入expressconst express = require(&#x27;express&#x27;);//2. 创建应用对象const app = express();//3. 创建路由规则// request 是对请求报文的封装// response 是对响应报文的封装app.get(&#x27;/server&#x27;, (request, response) =&gt; &#123; //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); //设置响应体 response.send(&#x27;HELLO AJAX - 2&#x27;);&#125;);//可以接收任意类型的请求 app.all(&#x27;/server&#x27;, (request, response) =&gt; &#123; //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); //响应头 response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;*&#x27;); //设置响应体 response.send(&#x27;HELLO AJAX POST&#x27;);&#125;);//JSON 响应app.all(&#x27;/json-server&#x27;, (request, response) =&gt; &#123; //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;*&#x27;); //响应一个数据 const data = &#123; name: &#x27;atguigu&#x27; &#125;; //对对象进行字符串转换 let str = JSON.stringify(data); //设置响应体 response.send(str);&#125;);//针对 IE 缓存app.get(&#x27;/ie&#x27;, (request, response) =&gt; &#123; //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); //设置响应体 response.send(&#x27;HELLO IE - 5&#x27;);&#125;);//延时响应app.all(&#x27;/delay&#x27;, (request, response) =&gt; &#123; //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;*&#x27;); setTimeout(() =&gt; &#123; //设置响应体 response.send(&#x27;延时响应&#x27;); &#125;, 1000)&#125;);//jQuery 服务app.all(&#x27;/jquery-server&#x27;, (request, response) =&gt; &#123; //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;*&#x27;); // response.send(&#x27;Hello jQuery AJAX&#x27;); const data = &#123; name: &#x27;尚硅谷&#x27; &#125;; // 只能send字符串数据，不能直接发送data，所以这里使用了JSON.stringfy()方法 response.send(JSON.stringify(data));&#125;);//axios 服务app.all(&#x27;/axios-server&#x27;, (request, response) =&gt; &#123; //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;*&#x27;); // response.send(&#x27;Hello jQuery AJAX&#x27;); const data = &#123; name: &#x27;尚硅谷&#x27; &#125;; // 只能send字符串数据，不能直接发送data，所以这里使用了JSON.stringfy()方法 response.send(JSON.stringify(data));&#125;);//fetch 服务app.all(&#x27;/fetch-server&#x27;, (request, response) =&gt; &#123; //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;*&#x27;); // response.send(&#x27;Hello jQuery AJAX&#x27;); const data = &#123; name: &#x27;尚硅谷&#x27; &#125;; // 只能send字符串数据，不能直接发送data，所以这里使用了JSON.stringfy()方法 response.send(JSON.stringify(data));&#125;);//jsonp服务app.all(&#x27;/jsonp-server&#x27;, (request, response) =&gt; &#123; // response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;); const data = &#123; name: &#x27;尚硅谷atguigu&#x27; &#125;; //将数据转化为字符串 let str = JSON.stringify(data); //返回结果 response.end(`handle($&#123;str&#125;)`);&#125;);//用户名检测是否存在app.all(&#x27;/check-username&#x27;, (request, response) =&gt; &#123; // response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;); const data = &#123; exist: 1, msg: &#x27;用户名已经存在&#x27; &#125;; //将数据转化为字符串 let str = JSON.stringify(data); //返回结果 response.end(`handle($&#123;str&#125;)`);&#125;);//app.all(&#x27;/jquery-jsonp-server&#x27;, (request, response) =&gt; &#123; // response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;); const data = &#123; name: &#x27;尚硅谷&#x27;, city: [&#x27;北京&#x27;, &#x27;上海&#x27;, &#x27;深圳&#x27;] &#125;; //将数据转化为字符串 let str = JSON.stringify(data); //接收 callback 参数 let cb = request.query.callback; //返回结果 response.end(`$&#123;cb&#125;($&#123;str&#125;)`);&#125;);app.all(&#x27;/cors-server&#x27;, (request, response) =&gt; &#123; //设置响应头 response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &#x27;*&#x27;); response.setHeader(&quot;Access-Control-Allow-Method&quot;, &#x27;*&#x27;); // response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://127.0.0.1:5500&quot;); response.send(&#x27;hello CORS&#x27;);&#125;);//4. 监听端口启动服务app.listen(8000, () =&gt; &#123; console.log(&quot;服务已经启动, 8000 端口监听中....&quot;);&#125;);","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://hasuer.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"状态压缩dp","slug":"状态压缩dp","date":"2022-02-08T08:34:22.000Z","updated":"2022-03-18T07:22:05.835Z","comments":true,"path":"状态压缩dp/index.html","link":"","permalink":"https://hasuer.github.io/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp/index.html","excerpt":"","text":"旅行商问题（曼哈顿路）题目：有一个商人想要旅行各地并进行贸易。各地之间有若干条单向的通道相连，商人从一个地方出发，想要用最短的路程把所有地区环游一遍，请问环游需要的最短路程是多少？在这题当中，我们假设商人从0位置出发，最后依然回到位置0。 这是一个NP问题，如果采用递归的话会很耗时，总体的复杂度是n!, 如果采用压缩状态dp，总体的时间复杂度是$n^22^n$ 动态规划的问题都是从小规模的问题整合成大规模的问题，对于这道题，小规模的问题是，商人已经走过了除了起点以外所有的点，最后走向起点，完成。假设一共有3个节点，那么采用状压dp就会有8种状态。 图片来自知乎 123456789101112131415161718192021222324252627import mathif __name__ == &quot;__main__&quot;: inf = 1 &lt;&lt; 31 # 邻接矩阵存储边权重 d = [[inf for _ in range(10)] for _ in range(10)] # 测试数据 edges = [[0, 1, 3], [1, 2, 5], [2, 3, 5], [3, 4, 3], [4, 0, 7], [4, 1, 6], [0, 3, 4], [2, 0, 4]] for u, v, l in edges: d[u][v] = l # 初始化成近似无穷大的值 dp = [[inf for _ in range(5)] for _ in range((1 &lt;&lt; 5))] dp[0][0] = 0 # 遍历状态 for s in range(1, (1 &lt;&lt; 5)): for u in range(5): # 遍历决策 # 当我们使用的是dp[0][0]初始化的时候就不需要在对u做限制 for v in range(5): # 必须要求这个点没有去过 if (s &gt;&gt; v) &amp; 1 == 0: continue dp[s][v] = min(dp[s][v], dp[s - (1 &lt;&lt; v)][u] + d[u][v]) print(dp[(1 &lt;&lt; 5) - 1][0]) 注意几点： dp[s][v]表示处于s状态，并且站在v节点时产生的最小路径 在遍历的时候，我们习惯用u表示路径的起点，v表示路径的终点 对于每一个状态（例如，11110)，每一个二进制位表示一个节点，二进制位为1表示节点已经去过，二进制位为0表示节点没有去过。状压Dp从小规模问题合并成大规模问题，小规模问题是(00000)，也就是没有任何一个节点被访问过。 这段代码当中有两个细节，第一个细节是我们没有做u的合法判断，有可能我们u是不合法的，比如我们的集合当中只有2和3两个点，但是我们却枚举了从4到5的策略。这样是没问题的，因为我们开始的时候把所有的状态都设置成了无穷大，只有合法的状态才不是无穷，由于我们希望最后得到的结果越小越好，不合法的状态是不会被用来更新的。 第二个细节稍微隐蔽一些，就是我们在初始化的时候设置了dp[0][0] = 0。这表示我们是从空集开始的，而不是从0点开始的。因为0点已经遍历过的状态对应的数字是1，当然我们也可以设置成0已经访问过了，从0点开始，这样的话由于每个点不能重复访问，所以最后我们是无法回到0点的，要得到正确结果我们还需要加上回到0点需要的消耗。 分析一下会发现第一点是第二点的基础，如果我们在枚举策略的时候都判断一下u点是否也合法，那么这个算法就没有办法执行，因为对于空集而言，所有点都是未访问过的，也都是非法状态，我们就找不到一个访问过的u作为决策的起点。（引用自这里） 输入了一个数（节点个数），路径可以看作是已知的，还需要一个当前所在节点才能确定一个情况，所以是二维的 这道题还有第二种做法，比较容易理解，在我们的我们设置初始状态是dp[1][0]也就是一开始就访问了节点1，由于每一个节点只能访问一次，座椅最后一定是在除了0号节点的某一个节点上，所以最后还要加上回到0号节点的路程，在取最小 123456789101112131415161718dp[1][0] = 0 for s in range(2, (1 &lt;&lt; 5)): for u in range(5): # 严格限制u必须已经遍历过 if (s &gt;&gt; u) &amp; 1 == 0: continue for v in range(5): if (s &gt;&gt; v) &amp; 1 == 0: continue dp[s][v] = min(dp[s][v], dp[s - (1 &lt;&lt; v)][u] + d[u][v]) ans = inf # 最后加上回到0点的距离 for i in range(5): ans = min(ans, dp[(1 &lt;&lt; 5) - 1][i] + d[i][0]) print(ans) 路径（2021蓝桥杯省赛E）蓝桥学院由21栋教学楼组成，教学楼编号1到21。对于两栋教学楼a和b,当a和b互质时，a和b之间有一条走廊直接相连，两个方向皆可通行，否则没有直接连接的走廊。 小蓝现在在第一栋教学楼，他想要访问每栋教学楼正好一次，最终回到第一栋教学楼（即走一条哈密尔顿回路），请问他有多少种不同的访问方案？两个访问方案不同是指存在某个i,小蓝在两个访问方法中访问完教学楼i后访问了不同的教学楼。 1234567891011121314151617181920212223import mathn = int(input())hasRoad = [[0 for _ in range(n)] for _ in range(n)]for i in range(n): for j in range(n): if(i != j): if math.gcd(i+1,j + 1) == 1: #注意这个gcd函数 hasRoad[i][j] = 1 hasRoad[j][i] = 1dp = [[0 for _ in range(n)] for _ in range(1 &lt;&lt; n)]dp[1][0] = 1for s in range(1&lt;&lt;n): # 取状态s for u in range(n): #取起点 if s &amp; (1 &lt;&lt; u) != 0: #节点u以及被遍历，注意这里只能写 !=0 不能写成==1 for v in range(n): # 终点v # 终点v也已经被遍历并且uv之间有道路 if s &amp; (1 &lt;&lt; v) != 0 and hasRoad[u][v]: dp[s][v] += dp[s - (1 &lt;&lt; v)][u]print(sum(dp[(1 &lt;&lt; n) - 1])- dp[(1 &lt;&lt; n) - 1][0]) 根据第一题的第二种解法，我们这里采用上一题的第二种解法。dp[s][v]表示达到状态是s,并且站在节点v上的情况有几种。说明节点v包含在状态v中。由于一开始也是就遍历的节点0，所以需要知道的是，最后会停留在除了0号节点的一个节点，倘若这个节点和0号节点有路（也就是1号楼，根据题目，一号楼和所有的楼都有路），那么就把他们相加，也就是dp[1 &lt;&lt; 21 - 1][1]+ ...dp[1 &lt;&lt; 21 - 1][20] 需要当前状态和所在节点作为指标，所以是二维的 互不侵犯在N×N的棋盘里面放K个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共8个格子。 12345678910111213141516171819202122232425262728293031323334353637383940N = int(input())K = int(input())stateCount = 0state = []oneCountsInState = []#预处理,找到每一个合法的摆放，记为一个状态for i in range(1 &lt;&lt; N): if (i &amp; (i &lt;&lt; 1) == 0): # 如果有两个相邻的位置都是1，那么就不会进入这个循环 oneCount = 0 for j in range(N): if(i &amp; (1 &lt;&lt; j) != 0): oneCount += 1 if(oneCount &lt;= K): oneCountsInState.append(oneCount) state.append(i) stateCount += 1dp = [[[0]*(K+1) for x in range(stateCount)] for y in range(N)]for i in range(len(state)): for j in range(K+1): if(oneCountsInState[i] == j): dp[0][i][j] = 1for i in range(1,N): #遍历每一行 for j in range(len(state)): #遍历第i行每种状态 for k in range(K+1): #遍历到i行为止（包括i）使用了多少国王 if(oneCountsInState[j] &lt;= k): for m in range(len(state)): #遍历第i-1行 #if(oneCountsInState[m] &lt;= k): 这一行加不加都可以 if((state[j] &amp; state[m] ==0) and (state[j] &lt;&lt; 1) &amp; state[m] == 0 and (state[j] &gt;&gt; 1) &amp; state[m] == 0): dp[i][j][k] += dp[i-1][m][k-oneCountsInState[j]]result = 0for i in range(len(state)): result += dp[N-1][i][K]print(result) 对于状压dp,都是1 &lt;&lt; N种情况，所以这里就要考虑到，每种情况其实是对应每一行的状态。 这道题中，对于数据进行了预处理，由于每一行不能有相邻的1,所以要先选出可以被防止在行上的状态，将可以使用的状态放在state数组中，之后采用下标来访问状态。 dp[i][j][k]表示在第i行，防止j号状态的时候，打算一共用k个国王有几种放法 这道题输入了两个参数，N和K,所以这道题的dp是三维的 写的的时候先是写的关系，也就是那个四层循环，然后才是写的初始化部分代码，通过相邻的两层之间的关系推出初始化的值 炮兵阵地12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758m, n = map(int, input().strip().split())states = []nums = [0] * (1 &lt;&lt; n)for i in range(m): list1 = list(input().strip()) num = 0 for j in range(len(list1)): if (list1[j] == &#x27;H&#x27;): num += 2 ** (len(list1) - 1 - j) state = [] for k in range(1 &lt;&lt; n): if (k &amp; num) == 0: # 排除在山地放炮兵的情况 if (k &amp; (k &lt;&lt; 1) == 0 and k &amp; (k &lt;&lt; 2) == 0): # 排除在同一行的炮兵可以打到对方的情况 state.append(k) # 计算状态k中有多少个1 count = 0 for t in range(n): if k &amp; (k &lt;&lt; t) != 0: count += 1 nums[k] = count states.append(state)dp = [[[0] * ((1 &lt;&lt; n) - 1) for y in range(1 &lt;&lt; n)] for x in range(3)]# 如果只有一行if (m == 1): Max = 0 for i in states[0]: Max = max(Max, nums[i]) print(Max)else: # 初始化第一行 for s in states[0]: dp[0][s][0] = nums[s] # 初始化第二行 for s in states[0]: for t in states[1]: if (s &amp; t == 0): dp[1][t][s] = nums[s] + nums[t] for i in range(2, m): # 遍历每一行 for cur in states[i]: # 每一行的当前状态 for pre in states[i - 1]: # 上一行的状态 for prepre in states[i - 2]: # 上上行的状态 if cur &amp; pre == 0 and cur &amp; prepre == 0 and pre &amp; prepre == 0: dp[i % 3][cur][pre] = max(dp[i % 3][cur][pre], dp[(i - 1) % 3][pre][prepre] + nums[cur]) result = 0 for i in states[m - 1]: for j in states[m - 2]: result = max(result, dp[(m - 1) % 3][i][j]) print(result) 原来测了几个都是对的，但是，提交的时候3个过了，剩下的8个全部说是内存超限了，不知道为啥。后来发现是dp太大了，其实要使用滚动数组，也就是dp永远是存储三行。于是有了上面的代码，这样提交发现是4个对，8个左右是错的，也就是Wrong Answer.但是实在找不到哪里错了。同样的逻辑，使用C++就可以AC 此外，之前我一直以为是输入n个数字，dp就是n+1维的，后来发现不是，这道题虽然输入了N,M（地图不算），但是N，M完全可以是一样 的，但是dp仍然是三维的。其实是更具约束定的，上一题（互不侵犯）每一行只和上一行有关，这是一个约束，还有一个就是行号，而这道题，每一行与之前的两行有关，这是两个约束，加上行好的约束，所以是三维的。 P1441 砝码称重方法是一定是正确的，但是时间超限。 dp[i][j]表示在状态i，能否表示重量j，状态i用二进制表示，二进制位是1，表示选取这一位的砝码，例如最低位是1表示选取第一个砝码，最高位是1表示选取最后一个砝码。 1234567891011121314151617181920212223242526272829303132333435363738n, m = map(int, input().strip().split())weight = list(map(int, input().strip().split()))nums = [0] * (1 &lt;&lt; n) # 记录每一个状态有几个砝码allWeight =sum(weight)for i in range(1 &lt;&lt; n): count = 0 for j in range(n): if (i &amp; (1 &lt;&lt; j)) != 0: count += 1 nums[i] = countdp = [[0] * (allWeight + 1) for i in range(1 &lt;&lt; n)]#初始化没有砝码的情况for i in range(allWeight + 1): dp[0][i] = 0numOfWeights = [0] * (1 &lt;&lt; n) #记录每种状态可以计算几种重量for i in range(1, 1 &lt;&lt; n): numOfWeight = 0 for j in range(allWeight + 1): for k in range(n): if (i &amp; (1 &lt;&lt; k)) != 0: w = weight[k] dp[i][w] = 1 dp[i][j] |= dp[i - (1 &lt;&lt;k)][j] dp[i][j] |= dp[i-(1 &lt;&lt;k)][j-w] if(dp[i][j]): numOfWeight += 1 break numOfWeights[i] = numOfWeightremain = n - mres = 0for i in range(1 &lt;&lt; n): if(nums[i] == remain): res = max(res,numOfWeights[i])print(res) 蓝桥杯2019年第十届省赛真题-糖果python 123456789101112131415161718192021# 和下面C++代码逻辑一样，但是时间超限import sysn,m,k = map(int, input().split())dp = [sys.maxsize for _ in range( 1 &lt;&lt; m)]dp[0] = 0f = [0 for _ in range(110)]for i in range(n): list1 = (list(map(int, input().split()))) for j in list1: f[i] = f[i] | (1 &lt;&lt; (j-1)) dp[f[i]] = 1for s in range(1 &lt;&lt; m): for j in range(1, n): dp[s | f[j]] = min(dp[s | f[j]],dp[s] + 1)if(dp[(1 &lt;&lt; m) - 1] == sys.maxsize): print(-1)else: print(dp[(1 &lt;&lt; m) - 1]) C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 最好不要用vector，能用数组就不要用vector#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int n, m, k;vector&lt;vector&lt;int&gt;&gt; options;const int N = 1 &lt;&lt; 21;int dp[N];int f[110];int main()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; const int maxN = (1 &lt;&lt; m) - 1; for (int i = 0; i &lt;= maxN; i++) &#123; dp[i] = 110; &#125; for (int i = 0; i &lt; n; i++) &#123; int temp; for (int j = 0; j &lt; k; j++) &#123; cin &gt;&gt; temp; f[i] |= (1 &lt;&lt; (temp - 1)); &#125; dp[f[i]] = 1; &#125; for (int s = 0; s &lt;= maxN; s++) &#123; for (int j = 1; j &lt; n; j++) &#123; dp[s | (f[j])] = min(dp[s | (f[j])], dp[s] + 1); &#125; &#125; if (dp[maxN] == 110) &#123; cout &lt;&lt; -1; &#125; else &#123; cout &lt;&lt; dp[maxN]; &#125; system(&quot;pause&quot;); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://hasuer.github.io/categories/Algorithm/"}],"tags":[]},{"title":"蓝桥杯","slug":"蓝桥杯","date":"2022-01-30T15:31:37.000Z","updated":"2022-04-12T08:35:27.792Z","comments":true,"path":"蓝桥杯/index.html","link":"","permalink":"https://hasuer.github.io/%E8%93%9D%E6%A1%A5%E6%9D%AF/index.html","excerpt":"","text":"2021蓝桥杯省赛卡片本题总分：5分【问题描述】小蓝有很多数字卡片，每张卡片上都是数字0到9 小蓝准备用这些卡片来拼一些数，他想从1开始拼出正整数，每拼一个，就保存起来，卡片就不能用来拼其它数了。 小蓝想知道自己能从1拼到多少。 例如，当小蓝有30张卡片，其中0到9各3张，则小蓝可以拼出1到10,但是拼11时卡片1已经只有一张了，不够拼出11 现在小蓝手里有0到9的卡片各2021张，共20210张，请问小蓝可以从1拼到多少？ 提示：建议使用计算机编程解决问题。 【string和list的转换】 总结 【字符和整型的转换】 总结 12345678910111213141516num = 1numlist = [2021 for _ in range(10)]while True: flag = True list1 = list(str(num)) for n in list1: numlist[int(n)] -= 1 if(numlist[int(n)]&lt;0): flag = False break if(not flag): break num += 1print(num - 1)# 3181 直线本题总分：5分【问题描述】在平面直角坐标系中，两点可以确定一条直线。如果有多点在一条直线上，那么这些点中任意两点确定的直线是同一条。 给定平面上2×3个整点{ ( x , y ) | 0 ≤ x &lt; 2 , 0 ≤ y &lt; 3 , x ∈ Z , y ∈ Z } , 即横坐标是0到1(包含0和1)之间的整数、纵坐标是0到2(包含0和2)之间的整数的点。这些点一共确定了11条不同的直线。 给定平面上20×21个整点{ ( x , y ) | 0 ≤ x &lt; 20 , 0 ≤ y &lt; 21 , x ∈ Z , y ∈ Z},即横坐标是0到19(包含0和19)之间的整数、纵坐标是0到20(包含0和20)之间的整数的点。请问这些点一共确定了多少条不同的直线。 【暴力求解/set的使用】 123456789101112131415set1 = set()for x1 in range(20): for x2 in range(20): for y1 in range(21): for y2 in range(21): if(x1 != x2 and y1 != y2): k = (y2 - y1) / (x2 - x1) # b = (y1 - ((y2 - y1) / (x2 - x1)*x1)) 不能这这样写，因为y1 - k*x1这样会造成精确度的问题 b = ((y1 * x2) - (y2 * x1))/(x2 - x1) set1.add((k, b)) print(len(set1) + 41)# 40257 货物摆放本题总分：10分【问题描述】小蓝有一个超大的仓库，可以摆放很多货物。 现在，小蓝有n箱货物要摆放在仓库，每箱货物都是规则的正方体。小蓝规定了长、宽、高三个互相垂直的方向，每箱货物的边都必须严格平行于长、宽、高。 小蓝希望所有的货物最终摆成一个大的立方体。即在长、宽、高的方向上分别堆L、W、H的货物，满足n=L×W×H 给定n,请问有多少种堆放货物的方案满足要求。 例如，当n=4时，有以下6种方案：1×1×4、1×2×2、1×4×1、2×1×2、2×2×1、4×1×1 请问，当n=2021041820210418(注意有16位数字)时，总共有多少种方案？ 提示：建议使用计算机编程解决问题。 【计算所有因子的简便方法】 123456789101112131415# 超时n = int(input())list1 = []res =set()# 计算公约数太费劲了for i in range(1, n+1): if (n % i == 0): list1.append(i)for i in list1: for j in list1: for k in list1: if (i * j * k) == n: res.add((i,j,k))print(len(res)) 123456789101112131415161718# 超时n = int(input())list1 = []res =set()# 记住这种方法for i in range(1, int(pow(n,0.5)) + 1): if (n % i == 0): list1.append(i) list1.append(n // i)for i in list1: for j in list1: for k in list1: if (i * j * k) == n: res.add((i,j,k))print(len(res))# 2430 路径本题总分：10分【问题描述】 小蓝学习了最短路径之后特别高兴，他定义了一个特别的图，希望找到图中的最短路径。 小蓝的图由2021个结点组成，依次编号1至2021 对于两个不同的结点a,b,如果a和b的差的绝对值大于21,则两个结点之间没有边相连；如果a和b的差的绝对值小于等于21,则两个点之间有一条长度为a和b的最小公倍数的无向边相连。 例如：结点1和结点23之间没有边相连；结点3和结点24之间有一条无向边，长度为24;结点15和结点25之间有一条无向边，长度为75. 请计算，结点1和结点2021之间的最短路径长度是多少。 提示：建议使用计算机编程解决问题。 【动态规划】 123456789101112131415161718192021import sysimport mathlist1 = [sys.maxsize for _ in range(2021+1)] #list1[i] 表示从1节点到i节点的最短路径list1[0] = 0list1[1] = 0def calBeishu(m,n): if(abs(m-n) &gt; 21): return sys.maxsize return int(m*n/math.gcd(m,n))#当节点i小于22时，1节点到这个节点的最短路径就是1*ifor i in range(2,23): list1[i] = ifor i in range(23, 2022): for j in range(i-21, i): list1[i] = min(list1[i], list1[j] + calBeishu(j,i))print(list1[2021]) # 10266837 回路计算本题总分：15分【问题描述】 蓝桥学院由21栋教学楼组成，教学楼编号1到21。对于两栋教学楼a和b,当a和b互质时，a和b之间有一条走廊直接相连，两个方向皆可通行，否则没有直接连接的走廊。 小蓝现在在第一栋教学楼，他想要访问每栋教学楼正好一次，最终回到第一栋教学楼（即走一条哈密尔顿回路），请问他有多少种不同的访问方案？两个访问方案不同是指存在某个i,小蓝在两个访问方法中访问完教学楼i后访问了不同的教学楼。 提示：建议使用计算机编程解决问题。 【动态规划/状压dp】 更多例题 12345678910111213141516171819202122232425import mathn = int(input())hasRoad = [[0 for _ in range(n)] for _ in range(n)]for i in range(n): for j in range(n): if(i != j): if math.gcd(i+1,j + 1) == 1: #注意这个gcd函数 hasRoad[i][j] = 1 hasRoad[j][i] = 1dp = [[0 for _ in range(n)] for _ in range(1 &lt;&lt; n)]dp[1][0] = 1for s in range(1&lt;&lt;n): # 取状态s for u in range(n): #取起点 if s &amp; (1 &lt;&lt; u) != 0: #节点u以及被遍历，注意这里只能写 !=0 不能写成==1 for v in range(n): # 终点v # 终点v也已经被遍历并且uv之间有道路 if s &amp; (1 &lt;&lt; v) != 0 and hasRoad[u][v]: dp[s][v] += dp[s - (1 &lt;&lt; v)][u]print(sum(dp[(1 &lt;&lt; n) - 1])- dp[(1 &lt;&lt; n) - 1][0])# 881012367360 dp[s][v]表示达到状态是s,并且站在节点v上的情况有几种。说明节点v包含在状态v中。由于一开始也是就遍历的节点0，所以需要知道的是，最后会停留在除了0号节点的一个节点，倘若这个节点和0号节点有路（也就是1号楼，根据题目，一号楼和所有的楼都有路），那么就把他们相加，也就是dp[1 &lt;&lt; 21 - 1][1]+ ...dp[1 &lt;&lt; 21 - 1][20] 时间显示时间限制：1.0s内存限制：256.0MB本题总分：15分 【问题描述】 小蓝要和朋友合作开发一个时间显示的网站。在服务器上，朋友已经获取了当前的时间，用一个整数表示，值为从1970年1月1日00:00:00到当前时刻经过的毫秒数。 现在，小蓝要在客户端显示出这个时间。小蓝不用显示出年月日，只需要显示出时分秒即可，毫秒也不用显示，直接舍去即可。 给定一个用整数表示的时间，请将这个时间对应的时分秒输出。 【输入格式】 输入一行包含一个整数，表示时间。 【输出格式】 输出时分秒表示的当前时间，格式形如HH:MM:SS,其中H表示时，值为0到23,MM表示分，值为0到59,SS表示秒，值为0到59时、分、秒不足两位时补前导0 [样例输入1] 46800999 [样例输出1] 13:00:00 [样例输入2] 1618708103123 [样例输出2] 01:08:23 【time库的使用】 总结 123456# 涉及到时间的题目不需要考虑时区的问题# 正确100import timen = int(input())print(time.ctime(n//1000))print(new_n[11:19]) 杨辉三角时间限制：1.0s内存限制：256.0MB本题总分：20分 【问题描述】 下面的图形是著名的杨辉三角形： 如果我们按从上到下、从左到右的顺序把所有数排成一列，可以得到如下数列： 1,1,1,1,2,1,1,3,3,1,1,4,6,4,1, 给定一个正整数N,请你输出数列中第一次出现N是在第几个数？ 【输入格式】 输入一个整数N. 【输出格式】 输出一个整数代表答案。 【样例输入】 6 【样例输出】 13 【暴力解法】 &lt;span id = “排列组合的计算back’’&gt; 【拓展：排列组合的计算】&lt;/span&gt; 【拓展：排列组合的计算】 总结 12345678910111213141516171819202122# 时间超限45n = int(input())def find_n(n): if n == 1: return 1 res = 3 # 已计算过的个数 li, line = [1, 2], 3 # 将要进行比对的行的元素及其行数 # 奇数行存的是前一半加上中间 # 偶数行存的是前一半加上下一个 while n not in li: res += len(li) * 2 if (line % 2 == 0): res -= 2 else: res -= 1 line += 1 li = [1] + [li[i] + li[i + 1] for i in range(len(li) - 1)] if (line % 2 == 0): li += [li[-1]] return res + li.index(n) + 1print(find_n(n)) 左孩子右兄弟时间限制：1.0s内存限制：256.0MB本题总分：20分 【问题描述】 对于一棵多叉树，我们可以通过“左孩子右兄弟”表示法，将其转化成一棵二叉树。 如果我们认为每个结点的子结点是无序的，那么得到的二叉树可能不唯一。换句话说，每个结点可以选任意子结点作为左孩子，并按任意顺序连接右兄弟。 给定一棵包含N个结点的多叉树，结点从1至N编号，其中1号结点是根，每个结点的父结点的编号比自己的编号小。请你计算其通过“左孩子右兄弟”表示法转化成的二叉树，高度最高是多少。注：只有根结点这一个结点的树高度为0。 例如如下的多叉树： 可能有以下3种(这里只列出3种，并不是全部)不同的“左孩子右兄弟”表示： 其中最后一种高度最高，为4 【输入格式】 输入的第一行包含一个整数N。 以下N-1行，每行包含一个整数，依次表示2至N号结点的父结点编号。 【输出格式】 输出一个整数表示答案。 【样例输入】 51112 【样例输出】 4 12345678910111213141516171819# 时间超限73n = int(input())childList = [[] for _ in range(n + 1)]parentList = [0 for _ in range(n + 1)]for i in range(n-1): parent = int(input()) parentList[i + 2] = parent childList[parent].append(i+2)def cal(n): if(len(childList[n]) == 0): return 0 res = 0 for i in childList[n]: res = max(res,cal(i)) return res + len(childList[n])print(cal(1)) 异或数列时间限制：1.0s内存限制：256.0MB本题总分：20分 【问题描述】 Alice和Bob正在玩一个异或数列的游戏。初始时， Alice和Bob分别有一个整数a和b（a和b初始都为0）,有一个给定的长度为n的公共数列\\pi Alice和Bob轮流操作， Alice先手，每步可以在以下两种选项中选一种：选项1:从数列中选一个X给 Alice的数异或上，或者说令a变为$a⊕X_i$ （其中⊕表示按位异或） 选项2:从数列中选一个X给Bob的数异或上，或者说令b变为$b⊕X_i $ 每个数$X_i$ 都只能用一次，当所有$X_i$ 均被使用后(n轮后)游戏结束。游戏结束时，拥有的数比较大的一方获胜，如果双方数值相同，即为平手。现在双方都足够聪明，都采用最优策略，请问谁能获胜？ 【输入格式】 每个评测用例包含多组询问。询问之间彼此独立。 输入的第一行包含一个整数T,表示询问数。 接下来T行每行包含一组询问。其中第i行的第一个整数$n_i$ 表示数列长度，随后$n_i $ 个整数$X_1 , X_2 , X _3 , . . . , X n i $表示数列中的每个数。 【输出格式】 输出T行，依次对应每组询问的答案。 每行包含一个整数1、0或-1分别表示 Alice胜、平局或败。 【样例输入】 41 11 02 2 17 992438 1006399 781139 985280 4729 872779 563580 【样例输出】1011 【评测用例规模与约定】 对于所有评测用例，1≤T≤200000, $1 &lt;= \\sum_{i=1}^{T}n_i &lt;= 200000 0 &lt;= X_i &lt;= 2^{20}$ 123456789101112131415161718192021222324252627282930313233# 时间超限67n = int(input())for i in range(n): line = input() list1 = line.split() count = int(list1[0]) nums = [0 for _ in range(22)] for j in list1[1:]: for m in range(22): if(int(j) &amp; (1 &lt;&lt; m)) != 0: nums[m] += 1 flag = False for k in range(21,-1,-1): if(nums[k] % 2 == 0): continue # nums[m]是奇数 if(nums[k] == 1): print(&quot;1&quot;) #先手赢 flag = True break if((count - nums[k]) % 2 == 0): # 有偶数个0 ，奇数个1 print(&quot;1&quot;) flag = True break else: # 有奇数个0 ，奇数个1 print(&quot;-1&quot;) flag = True break if(not flag): print(&quot;0&quot;) 网上解答 括号序列时间限制：1.0s内存限制：256.0MB本题总分：25分 【问题描述】 给定一个括号序列，要求尽可能少地添加若干括号使得括号序列变得合法，当添加完成后，会产生不同的添加结果，请问有多少种本质不同的添加结果。两个结果是本质不同的是指存在某个位置一个结果是左括号，而另一个是右括号。 例如，对于括号序列(（（）,只需要添加两个括号就能让其合法，有以下几种不同的添加结果：（）（）（）、（）(（）)、(（）)（）、(（）（）)和(（（）））。 【输入格式】 输入一行包含一个字符串s,表示给定的括号序列，序列中只有左括号和右括号。 【输出格式】 输出一个整数表示答案，答案可能很大，请输出答案除以1000000007(即1 0 9 10^9109 +7)的余数。 【样例输入】 （（（） 【样例输出】 5 【评测用例规模与约定】 对于40%的评测用例，|s|≤200 对于所有评测用例，1≤|s|≤5000 不会做，解法：视频，最后1p讲的就是这道题 2020蓝桥杯省赛门牌制作本题总分：5 分【问题描述】小蓝要为一条街的住户制作门牌号。这条街一共有 2020 位住户，门牌号从 1 到 2020 编号。小蓝制作门牌的方法是先制作 0 到 9 这几个数字字符，最后根据需要将字符粘贴到门牌上，例如门牌 1017 需要依次粘贴字符 1、0、1、7，即需要 1 个字符 0，2 个字符 1，1 个字符 7。请问要制作所有的 1 到 2020 号门牌，总共需要多少个字符 2？ 123456num = 0for i in range(1, 2021): num += str(i).count(&#x27;2&#x27;)print(num)# output: 624 寻找2020本题总分：5 分【问题描述】小蓝有一个数字矩阵，里面只包含数字 0 和 2。小蓝很喜欢 2020，他想找到这个数字矩阵中有多少个 2020 。小蓝只关注三种构成 2020 的方式：• 同一行里面连续四个字符从左到右构成 2020。• 同一列里面连续四个字符从上到下构成 2020。• 在一条从左上到右下的斜线上连续四个字符，从左上到右下构成 2020。例如，对于下面的矩阵：220000000000002202000000000022002020一共有 5 个 2020。其中 1 个是在同一行里的，1 个是在同一列里的，3 个是斜线上的。小蓝的矩阵比上面的矩阵要大，由于太大了，他只好将这个矩阵放在了一个文件里面，在试题目录下有一个文件 2020.txt，里面给出了小蓝的矩阵。请帮助小蓝确定在他的矩阵中有多少个 2020。 【文件输入输出】 总结 12345678910111213141516171819202122f = open(&#x27;2020.txt&#x27;, &#x27;r&#x27;)lists = []for line in f: lists.append(list(line.strip()))num =0 for i in range(len(lists)): for j in range(len(lists[0])-3): if(lists[i][j] == &#x27;2&#x27; and lists[i][j+1] == &#x27;0&#x27; and lists[i][j+2] == &#x27;2&#x27; and lists[i][j+3] == &#x27;0&#x27;): num += 1for i in range(len(lists)-3): for j in range(len(lists[0])): if(lists[i][j] == &#x27;2&#x27; and lists[i+1][j] == &#x27;0&#x27; and lists[i+2][j] == &#x27;2&#x27; and lists[i+3][j] == &#x27;0&#x27;): num += 1 for i in range(len(lists)-3): for j in range(len(lists[0])-3): if(lists[i][j] == &#x27;2&#x27; and lists[i+1][j+1] == &#x27;0&#x27; and lists[i+2][j+2] == &#x27;2&#x27; and lists[i+3][j+3] == &#x27;0&#x27;): num += 1print(num) 跑步训练本题总分：10 分【问题描述】小蓝每天都锻炼身体。正常情况下，小蓝每天跑 1 千米。如果某天是周一或者月初（1 日），为了激励自己，小蓝要跑2千米。如果同时是周一或月初，小蓝也是跑2千米。小蓝跑步已经坚持了很长时间，从2000年1月1日周六（含）到2020年10月1日周四（含）。请问这段时间小蓝总共跑步多少千米？ 【datetime库使用】查看帮助文档 123456789101112131415161718import datetimenum = 0start = datetime.date(2000, 1, 1)end = datetime.date(2020, 10, 2)day = startwhile True: if(day.weekday() == 0): num += 2 elif day.day == 1: num += 2 else: num += 1 day += datetime.timedelta(days=1) if(day == end): breakprint(num)# 8879 1234567891011121314import datetimestart = datetime.date(2000,1,1)end = datetime.date(2020,10,1)days = datetime.timedelta(days=1) # 用以可用于计算的一天 timedelta代表两个时间之间的时间差res = 0while start &lt;= end: if start.day == 1 or start.weekday() == 0: res += 2 else: res += 1 start += daysprint(res)# output: 8879 蛇形填空本题总分：10 分【问题描述】如下图所示，小明用从1开始的正整数“蛇形”填充无限大的矩阵。1 2 6 7 15 …3 5 8 14 …4 9 13 …10 12 …11 ……容易看出矩阵第二行第二列中的数是 5。请你计算矩阵中第 20 行第 20 列的数是多少？ 12# 数学问题，找规律求解，没有编程# 761 排序本题总分：15 分【问题描述】小蓝最近学习了一些排序算法，其中冒泡排序让他印象深刻。在冒泡排序中，每次只能交换相邻的两个元素。小蓝发现，如果对一个字符串中的字符排序，只允许交换相邻的两个字符，则在所有可能的排序方案中，冒泡排序的总交换次数是最少的。例如，对于字符串 lan 排序，只需要 1 次交换。对于字符串 qiao 排序，总共需要 4 次交换。小蓝找到了很多字符串试图排序，他恰巧碰到一个字符串，需要 100 次交换，可是他忘了吧这个字符串记下来，现在找不到了。请帮助小蓝找一个只包含小写英文字母且没有字母重复出现的字符串，对该串的字符排序，正好需要 100 次交换。如果可能找到多个，请告诉小蓝最短的那个。如果最短的仍然有多个，请告诉小蓝字典序最小的那个。请注意字符串中可以包含相同的字符。 1# jonmlkihgfedcba 一段字符串两两交换，使得其成为正序。只有当且仅当其刚好为反序的时候交换次数最多。而通过计算也可以知道当字符串有15个字符且各不相同的时候交换次数为105次，也即：onmlkjighfedecba，当字符串不到15个字符的时候交换次数是绝对到不了100次的。因为题目要求字典序最小的字符串，所以将’j’提至最前刚好满足100次，即答案为：jonmlkihgfedcba。 成绩统计时间限制: 1.0s 内存限制: 512.0MB 本题总分：15 分【问题描述】小蓝给学生们组织了一场考试，卷面总分为 100 分，每个学生的得分都是一个 0 到 100 的整数。如果得分至少是 60 分，则称为及格。如果得分至少为 85 分，则称为优秀。请计算及格率和优秀率，用百分数表示，百分号前的部分四舍五入保留整数。【输入格式】输入的第一行包含一个整数 n，表示考试人数。接下来 n 行，每行包含一个 0 至 100 的整数，表示一个学生的得分。【输出格式】输出两行，每行一个百分数，分别表示及格率和优秀率。百分号前的部分四舍五入保留整数。【样例输入】780925674881000【样例输出】71%43% 【格式化输出】 总结 1234567891011121314#正确100n = int(input())jige = 0youxiu = 0for i in range(n): score = int(input()) if( score &gt;= 60): jige += 1 if(score &gt;= 85): youxiu += 1print(&#x27;&#123;:.0f&#125;%&#x27;.format(jige/n * 100))print(&#x27;&#123;:.0f&#125;%&#x27;.format(youxiu/n * 100))# print(&#x27;%.0f&#x27;%(jige/n * 100)+&#x27;%&#x27;) 这样也可以 单词分析时间限制: 1.0s 内存限制: 512.0MB 本题总分：20 分【问题描述】小蓝正在学习一门神奇的语言，这门语言中的单词都是由小写英文字母组成，有些单词很长，远远超过正常英文单词的长度。小蓝学了很长时间也记不住一些单词，他准备不再完全记忆这些单词，而是根据单词中哪个字母出现得最多来分辨单词。现在，请你帮助小蓝，给了一个单词后，帮助他找到出现最多的字母和这个字母出现的次数。【输入格式】输入一行包含一个单词，单词只由小写英文字母组成。【输出格式】输出两行，第一行包含一个英文字母，表示单词中出现得最多的字母是哪个。如果有多个字母出现的次数相等，输出字典序最小的那个。第二行包含一个整数，表示出现得最多的那个字母在单词中出现的次数。【样例输入】lanqiao【样例输出】a2【样例输入】longlonglongistoolong【样例输出】o6【评测用例规模与约定】对于所有的评测用例，输入的单词长度不超过 1000。 【对象排序】 总结 1234567891011121314# 正确100string = input()maxChar = &#x27;z&#x27;maxNum = 0for i in string: count = string.count(i) if(count &gt; maxNum): maxNum = count maxChar = i if(count == maxNum): if(ord(i) &lt; ord(maxChar)): maxChar = iprint(maxChar)print(maxNum) 数字三角形时间限制: 1.0s 内存限制: 512.0MB 本题总分：20 分【问题描述】上图给出了一个数字三角形。从三角形的顶部到底部有很多条不同的路径。对于每条路径，把路径上面的数加起来可以得到一个和，你的任务就是找到最大的和。路径上的每一步只能从一个数走到下一层和它最近的左边的那个数或者右边的那个数。此外，向左下走的次数与向右下走的次数相差不能超过 1。【输入格式】输入的第一行包含一个整数 N (1 &lt; N ≤ 100)，表示三角形的行数。下面的N 行给出数字三角形。数字三角形上的数都是 0 至 100 之间的整数。【输出格式】输出一个整数，表示答案。【样例输入】573 88 1 02 7 4 44 5 2 6 5【样例输出】27 【动态规划】 123456789101112131415161718192021222324252627# 正确100import mathn = int(input())a = [[] for _ in range(n)]for i in range(n): a[i] = list(map(int, input().split()))dp = [[0 for i in range(n)] for _ in range(n)]dp[0][0] = a[0][0]for i in range(1, n): for j in range(i+1): if(j == 0): # 最左边由右上得来 dp[i][j] = dp[i-1][j] + a[i][j] if(j == i): # 最右边由左上得来 dp[i][j] = dp[i-1][j - 1] + + a[i][j] else: dp[i][j] = max(dp[i-1][j-1], dp[i-1][j]) + a[i][j]if( n % 2 ==0): print(max(dp[n-1][int(n/2) - 1], dp[n-1][int(n/2)])) #下标要取整else: print(dp[n-1][math.floor(n/2)]) 思路分析： 1.循环遍历 遇到金字塔形状数据，先构建二重for循环，遍历每个数，进行求和计算O(∩_∩)O 2.递推公式 求和一共三种情况：元素在 最左边 or 中间 or 最右边 3.打印答案 最后打印需要分类讨论，奇数和偶数。 因为题目中要求：”向左下走的次数与向右下走的次数相差不能超过1“ 按这个规则自己走一下，会发现答案必然落在中间。 如果n为奇数时，最后必然走到倒数第一行中间的数 a[-1][n//2]而如果n为偶数时，则取中间两个数的最大值 max(a[-1][n//2-1],a[-1][n//2]) 平面切分时间限制: 1.0s 内存限制: 512.0MB 本题总分：25 分【问题描述】平面上有 N 条直线，其中第 i 条直线是 y = Ai · x + Bi。请计算这些直线将平面分成了几个部分。【输入格式】第一行包含一个整数 N。以下 N 行，每行包含两个整数 Ai, Bi。【输出格式】一个整数代表答案。【样例输入】31 12 23 3【样例输出】6【评测用例规模与约定】对于 50% 的评测用例，1 ≤ N ≤ 4, −10 ≤ Ai, Bi ≤ 10。对于所有评测用例，1 ≤ N ≤ 1000, −100000 ≤ Ai, Bi ≤ 100000。 思路：初始时一条线只有分为两个部分，之后添加一条线l可能和之前的图形有交点，线l上有n个节点，就增加（n + 1）个部分， 12345678910111213141516171819202122# 正确100k = int(input())res = 1lines = [] #存放已经处理的直线for i in range(k): a1,b1 = map(int, input().split()) if((a1,b1) not in lines): #排除已经出现过的直线 nodes = set() #存放交点 for line in lines: a2 = line[0] #斜率 b2 = line[1] #截距 if(a1 != a2): # 不平行 x = (b2 - b1)/(a1-a2) y = (a1*b2 - a2*b1)/(a1-a2) nodes.add((x,y)) lines.append((a1,b1)) res += (len(nodes) +1) print(res) 装饰珠时间限制: 1.0s 内存限制: 512.0MB 本题总分：25 分【问题描述】在怪物猎人这一款游戏中，玩家可以通过给装备镶嵌不同的装饰珠来获取相应的技能，以提升自己的战斗能力。已知猎人身上一共有 6 件装备，每件装备可能有若干个装饰孔，每个装饰孔有各自的等级，可以镶嵌一颗小于等于自身等级的装饰珠 (也可以选择不镶嵌)。装饰珠有 M 种，编号 1 至 M，分别对应 M 种技能，第 i 种装饰珠的等级为 Li，只能镶嵌在等级大于等于 Li 的装饰孔中。对第 i 种技能来说，当装备相应技能的装饰珠数量达到 Ki 个时，会产生Wi(Ki) 的价值。镶嵌同类技能的数量越多，产生的价值越大，即 Wi(Ki − 1) &lt;Wi(Ki)。但每个技能都有上限 Pi(1 ≤ Pi ≤ 7)，当装备的珠子数量超过 Pi 时，只会产生 Wi(Pi) 的价值。对于给定的装备和装饰珠数据，求解如何镶嵌装饰珠，使得 6 件装备能得到的总价值达到最大。【输入格式】输入的第 1 至 6 行，包含 6 件装备的描述。其中第 i 的第一个整数 Ni 表示第 i 件装备的装饰孔数量。后面紧接着 Ni 个整数，分别表示该装备上每个装饰孔的等级 L(1 ≤ L ≤ 4)。第 7 行包含一个正整数 M，表示装饰珠 (技能) 种类数量。第 8 至 M + 7 行，每行描述一种装饰珠 (技能) 的情况。每行的前两个整数Lj(1 ≤ Lj ≤ 4) 和 Pj(1 ≤ Pi ≤ 7) 分别表示第 j 种装饰珠的等级和上限。接下来Pj 个整数，其中第 k 个数表示装备该中装饰珠数量为 k 时的价值 Wj(k)。【输出格式】输出一行包含一个整数，表示能够得到的最大价值。【样例输入】1 12 1 21 12 2 21 11 331 5 1 2 3 5 82 4 2 4 8 153 2 5 10【样例输出】20【样例说明】按照如下方式镶嵌珠子得到最大价值 18，括号内表示镶嵌的装饰珠的种类编号：1: (1)2: (1) (2)3: (1)4: (2) (2)5: (1)6: (2)4 颗技能 1 装饰珠，4 颗技能 2 装饰珠 W1(4) + W2(4) = 5 + 15 = 20。【评测用例规模与约定】对于 30% 的评测用例，1 ≤ Ni ≤ 10, 1 ≤ M ≤ 20, 1 ≤ Wj(k) ≤ 500；对于所有评测用例，1 ≤ Ni ≤ 50, 1 ≤ M ≤ 10000, 1 ≤ Wj(k) ≤ 10000。 2012填空# 微生物增殖假设有两种微生物 X 和 YX出生后每隔3分钟分裂一次（数目加倍），Y出生后每隔2分钟分裂一次（数目加倍）。一个新出生的X，半分钟之后吃掉1个Y，并且，从此开始，每隔1分钟吃1个Y。现在已知有新出生的 X=10, Y=89，求60分钟后Y的数目。如果X=10，Y=90呢？本题的要求就是写出这两种初始条件下，60分钟后Y的数目。题目的结果令你震惊吗？这不是简单的数字游戏！真实的生物圈有着同样脆弱的性质！也许因为你消灭的那只 Y 就是最终导致 Y 种群灭绝的最后一根稻草！ 12345678910111213x = 10y = 89for i in range(1, 121): if(i % 2 == 1): y -= x if( i % 4 == 0): y *= 2 if(i % 6 == 0): x *= 2print(x ,y)# 10485760 94371840 古堡算式福尔摩斯到某古堡探险，看到门上写着一个奇怪的算式：ABCDE * ? = EDCBA他对华生说：“ABCDE应该代表不同的数字，问号也代表某个数字！”华生：“我猜也是！”于是，两人沉默了好久，还是没有算出合适的结果来。请你利用计算机的优势，找到破解的答案。把 ABCDE 所代表的数字写出来。 1234567891011121314for i in range(10000,100000): temp = str(i) flag =True for j in range(len(temp)): if(temp[j] in temp[:j]): flag =False break if(flag): temp2 = temp[::-1] if(int(temp2) % int(temp) == 0): print(int(temp))# 21978 比酒量题目描述有一群海盗（不多于20人），在船上比拼酒量。过程如下：打开一瓶酒，所有在场的人平分喝下，有几个人倒下了。再打开一瓶酒平分，又有倒下的，再次重复——直到开了第4瓶酒，坐着的已经所剩无几，海盗船长也在其中。当第4瓶酒平分喝下后，大家都倒下了。等船长醒来，发现海盗船搁浅了。他在航海日志中写到：“…昨天，我正好喝了一瓶…奉劝大家，开船不喝酒，喝酒别开船…”请你根据这些信息，推断开始有多少人，每一轮喝下来还剩多少人。如果有多个可能的答案，请列出所有答案，每个答案占一行。格式是：人数，人数，…例如，有一种可能是：20,5,4,2,0 【浮点数比较】 123456789101112for i in range(20,0,-1): for j in range(i-1 ,0 ,-1): for k in range(j-1 , 0 , -1): for n in range(k-1 , 0, -1): if(abs(1 - 1/i - 1/j - 1/k - 1/n) &lt; 0.001): print(i ,j ,k , n , 0) # 20 5 4 2 0# 18 9 3 2 0# 15 10 3 2 0# 12 6 4 2 0 奇怪的比赛题目描述某电视台举办了低碳生活大奖赛。题目的计分规则相当奇怪：每位选手需要回答10个问题（其编号为1到10），越后面越有难度。答对的，当前分数翻倍；答错了则扣掉与题号相同的分数（选手必须回答问题，不回答按错误处理）。每位选手的起步分都是10分，某获胜选手最终得分刚好是100分，如果不让你看比赛过程，你能推断出他（她）哪个题目答对了，哪个题目答错了吗？如果把答对的记为1，答错的记为0，则10个题目的回答情况可用仅含1和0的串来表示，如0010110011就是可能的情况。你的任务是算出所有可能情况，每个答案占一行。 【递归】 12345678910111213141516list1 = [1,2,3,4,5,6,7,8,9,10]res = &quot;&quot;def cal(index, list1, res,n): if(n == 100 and len(res) == 10): print(res) if(index &gt;= len(list1)): return cal(index + 1, list1,res + &quot;0&quot;, n - index-1) cal(index + 1, list1, res + &quot;1&quot;, n*2) cal(0,list1, res,10)# 0010110011# 0111010000# 1011010000 # 方阵转置题目描述对一个方阵转置，就是把原来的行号变列号，原来的列号变行号。例如，如下方阵：1 2 3 45 6 7 89 10 11 1213 14 15 16转置后变为：1 5 9 132 6 10 143 7 11 154 8 12 16但如果是对该方阵顺时针旋转（不是转置），却是如下结果：13 9 5 114 10 6 215 11 7 316 12 8 4下面代码实现的功能就是要把一个方阵顺时针旋转，请推测划线处的代码。 123456789101112131415161718192021222324void rotate(int *x,int rank)&#123; int *y=(int*)malloc(___________________); //填空 for(int i=0;i&lt;rank*rank;i++) &#123; y[___________________]= x[i]; //填空 &#125; for(i=0;i&lt;rank*rank;i++) x[i]=y[i]; free(y);&#125;int main(int argc,char *argv[])&#123; int x[4][4]=&#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;9,10,11,12&#125;,&#123;13,14,15,16&#125;&#125;; int rank=4; rotate(&amp;x[0][0],rank); for(int i=0;i&lt;rank;i++) &#123; for(int j=0;j&lt;rank;j++) printf(&quot;%4d&quot;,x[i][j]); printf(&quot;\\n&quot;); &#125; return 0;&#125; 题目分析第一个填空只需要了解了malloc的用法就能理解，这里找了一篇malloc的用法:malloc的用法.第二个填空处：矩阵的普通的倒置是x[j][i]=x[i][j]; 顺时针倒置是x[j][3-i]=x[i][j]; 此处还要将i转化成两个坐标，使用除法和取余运算，即：x[i]-&gt;x[i/4][i%4] 那么，通过顺时针倒置，则有 x[i%4][3-i/4]=x[i/4][i%4]=x[i] 即：x[(i%4)*4+3-i/4]=x[i]; 2013填空世纪末的星期题目描述曾有邪教称1999年12月31日是世界末日。当然该谣言已经不攻自破。还有人称今后的某个世纪末的12月31日，如果是星期一则会…有趣的是，任何一个世纪末的年份的12月31日都不可能是星期一!!于是，“谣言制造商”又修改为星期日…1999年的12月31日是星期五，请问：未来哪一个离我们最近的一个世纪末年（即xx99年）的12月31日正好是星期天（即星期日）？请回答该年份（只写这个4位整数，不要写12月31等多余信息） 【日期】 1234567891011import datetimeimport timeyear = 2099while True: if(datetime.datetime(year,12,31).weekday() + 1) == 7: print(year) break; year += 100# 2299 振兴中华题目描述小明参加了学校的趣味运动会，其中的一个项目是：跳格子。地上画着一些格子，每个格子里写一个字，如下所示：（也可参见p1.jpg）从我做起振我做起振兴做起振兴中起振兴中华比赛时，先站在左上角的写着“从”字的格子里，可以横向或纵向跳到相邻的格子里，但不能跳到对角的格子或其它位置。一直要跳到“华”字结束。要求跳过的路线刚好构成“从我做起振兴中华”这句话。请你帮助小明算一算他一共有多少种可能的跳跃路线呢？答案是一个整数，请通过浏览器直接提交该数字。注意：不要提交解答过程，或其它辅助说明类的内容。 【动态规划】 1234567891011dp = [[0 for _ in range(5)] for _ in range(4)]for i in range(5): dp[0][i] = 1for i in range(4): dp[i][0] = 1for i in range(1,4): for j in range(1,5): dp[i][j] = (dp[i][j-1] + dp[i-1][j])print(dp[3][4])# 35 梅森素数题目描述如果一个数字的所有真因子之和等于自身，则称它为“完全数”或“完美数”例如：6 = 1 + 2 + 328 = 1 + 2 + 4 + 7 + 14早在公元前300多年，欧几里得就给出了判定完全数的定理：若 2^n - 1 是素数，则 2^(n-1) (2^n - 1) 是完全数。 其中 ^ 表示“乘方”运算，乘方的优先级比四则运算高，例如：2^3 = 8， 2 2^3 = 16, 2^3-1 = 7但人们很快发现，当n很大时，判定一个大数是否为素数到今天也依然是个难题。因为法国数学家梅森的猜想，我们习惯上把形如：2^n - 1 的素数称为：梅森素数。截止2013年2月，一共只找到了48个梅森素数。 新近找到的梅森素数太大，以至于难于用一般的编程思路窥其全貌，所以我们把任务的难度降低一点：1963年，美国伊利诺伊大学为了纪念他们找到的第23个梅森素数 n=11213，在每个寄出的信封上都印上了“2^11213-1 是素数”的字样。 2^11213 - 1 这个数字已经很大(有3000多位)，请你编程求出这个素数的十进制表示的最后100位。 12345n = pow(2,11213) - 1res = str(n)print(res[-100: -1] + res[-1])# 8586718527586602439602335283513944980064327030278104224144971883680541689784796267391476087696392191 颠倒的价牌题目描述小李的店里专卖其它店中下架的样品电视机，可称为：样品电视专卖店。其标价都是4位数字（即千元不等）。小李为了标价清晰、方便，使用了预制的类似数码管的标价签，只要用颜色笔涂数字就可以了（参见p1.jpg）。这种价牌有个特点，对一些数字，倒过来看也是合理的数字。如：1 2 5 6 8 9 0 都可以。这样一来，如果牌子挂倒了，有可能完全变成了另一个价格，比如：1958 倒着挂就是：8561，差了几千元啊!! 当然，多数情况不能倒读，比如，1110 就不能倒过来，因为0不能作为开始数字。有一天，悲剧终于发生了。某个店员不小心把店里的某两个价格牌给挂倒了。并且这两个价格牌的电视机都卖出去了!庆幸的是价格出入不大，其中一个价牌赔了2百多，另一个价牌却赚了8百多，综合起来，反而多赚了558元。请根据这些信息计算：赔钱的那个价牌正确的价格应该是多少？答案是一个4位的整数，请通过浏览器直接提交该数字。注意：不要提交解答过程，或其它辅助说明类的内容。 123456789101112131415161718192021222324252627282930list1 = [1, 2, 5, 6, 8, 9, 0]list2 = [1, 5, 2, 9, 8, 6, 0]set1 = set()set2 = set()def cal(n): a = n // 1000 b = n // 100 % 10 c = n // 10 % 10 d = n % 10 return cal2(d) * 1000 + cal2(c) * 100 + cal2(b) * 10 + cal2(a)def cal2(n): return list2[list1.index(n)]for m in range(6): for n in range(7): for j in range(7): for k in range(6): num1 = 1000*list1[m] + 100*list1[j] + 10 * list1[n] + list1[k] num2 = 1000*list2[k] + 100*list2[n] + 10 * list2[j] + list2[m] if(200&lt;=abs(num1-num2)&lt;300): set1.add(max(num1,num2)) # 这里一开始写成了min if(800&lt;=abs(num1-num2)&lt;900): set2.add(min(num1,num2)) # 这里一开始写成了maxfor num1 in set1: for num2 in set2: if(abs(num2 - cal(num2)) - abs(num1 - cal(num1)) == 558): print(num1, num2)# 9088 三部排序题目描述一般的排序有许多经典算法，如快速排序、希尔排序等。但实际应用时，经常会或多或少有一些特殊的要求。我们没必要套用那些经典算法，可以根据实际情况建立更好的解法。比如，对一个整型数组中的数字进行分类排序：使得负数都靠左端，正数都靠右端，0在中部。注意问题的特点是：负数区域和正数区域内并不要求有序。可以利用这个特点通过1次线性扫描就结束战斗!!以下的程序实现了该目标。 1234567891011121314151617181920212223242526 static void sort(int[] x) &#123; int p = 0; int left = 0; int right = x.length-1; while(p&lt;=right)&#123; if(x[p]&lt;0)&#123; int t = x[left]; x[left] = x[p]; x[p] = t; left++; p++; &#125; else if(x[p]&gt;0)&#123; int t = x[right]; x[right] = x[p]; x[p] = t; right--; &#125; else&#123; _________________________; //代码填空位置 &#125; &#125; &#125;// p++ 马虎的算式题目描述小明是个急性子，上小学的时候经常把老师写在黑板上的题目抄错了。有一次，老师出的题目是：36 x 495 = ? 他却给抄成了：396 x 45 = ?但结果却很戏剧性，他的答案竟然是对的！！因为 36 495 = 396 45 = 17820 类似这样的巧合情况可能还有很多，比如：27 594 = 297 54 假设 a b c d e 代表1~9不同的5个数字（注意是各不相同的数字，且不含0）能满足形如： ab cde = adb ce 这样的算式一共有多少种呢？请你利用计算机的优势寻找所有的可能，并回答不同算式的种类数。满足乘法交换律的算式计为不同的种类，所以答案肯定是个偶数。答案直接通过浏览器提交。注意：只提交一个表示最终统计种类数的数字，不要提交解答过程或其它多余的内容。 12345678910111213141516171819202122232425262728res = 0for a in range(1, 10): temp1 = str(a) for b in range(1, 10): if(str(b) in temp1): continue temp2 = temp1 + str(b) for c in range(1 , 10): if(str(c) in temp2): continue temp3 = temp2 + str(c) for d in range(1, 10): if(str(d) in temp3): continue temp4 = temp3 + str(d) for e in range(1, 10): if(str(e) in temp4): continue num1 = 10*a + b num2 = 100 * c + 10 * d + e num3 = 100 * a + 10 * d + b num4 = 10 * c + e if(num1 * num2 == num3 * num4): res += 1print(res)# 142 【看】黄金连分数题目描述黄金分割数0.61803… 是个无理数，这个常数十分重要，在许多工程问题中会出现。有时需要把这个数字求得很精确。对于某些精密工程，常数的精度很重要。也许你听说过哈勃太空望远镜，它首次升空后就发现了一处人工加工错误，对那样一个庞然大物，其实只是镜面加工时有比头发丝还细许多倍的一处错误而已，却使它成了“近视眼”!!言归正传，我们如何求得黄金分割数的尽可能精确的值呢？有许多方法。比较简单的一种是用连分数： 1 黄金数 = --------------------- 1 1 + ----------------- 1 1 + ------------- 1 1 + --------- 1 + ... 这个连分数计算的“层数”越多，它的值越接近黄金分割数。 请你利用这一特性，求出黄金分割数的足够精确值，要求四舍五入到小数点后100位。小数点后3位的值为：0.618小数点后4位的值为：0.6180小数点后5位的值为：0.61803小数点后7位的值为：0.6180340（注意尾部的0，不能忽略）你的任务是：写出精确到小数点后100位精度的黄金分割值。注意：尾数的四舍五入！ 尾数是0也要保留！显然答案是一个小数，其小数点后有100位数字，请通过浏览器直接提交该数字。注意：不要提交解答过程，或其它辅助说明类的内容。 【deciaml】 总结 12345678910111213from decimal import *getcontext().prec=101a=1for i in range(3000): a=Decimal(1/(1+a)) print(a)# 0.6180339887498948482045868343656381177203091798057628621354486227052604628189024497072072041893911375 高斯日记题目描述大数学家高斯有个好习惯：无论如何都要记日记。他的日记有个与众不同的地方，他从不注明年月日，而是用一个整数代替，比如：4210后来人们知道，那个整数就是日期，它表示那一天是高斯出生后的第几天。这或许也是个好习惯，它时时刻刻提醒着主人：日子又过去一天，还有多少时光可以用于浪费呢？高斯出生于：1777年4月30日。在高斯发现的一个重要定理的日记上标注着：5343，因此可算出那天是：1791年12月15日。高斯获得博士学位的那天日记上标着：8113请你算出高斯获得博士学位的年月日。提交答案的格式是：yyyy-mm-dd, 例如：1980-03-21 123456789import datetimeimport timestart = datetime.date(1777, 4, 30)for i in range(8112): start += datetime.timedelta(days = 1)print(start)# 1799-07-16 【看】排它平方数题目描述小明正看着 203879 这个数字发呆。原来，203879 * 203879 = 41566646641这有什么神奇呢？仔细观察，203879 是个6位数，并且它的每个数上的数字都是不同的，并且它平方后的所有数位上都不出现组成它自身的数字。具有这样特点的6位数还有一个，请你找出它！再归纳一下筛选要求： 6位正整数 每个数位上的数字不同 其平方数的每个数位不含原数字的任何组成数位答案是一个6位的正整数。 12345678910111213141516171819for j in range(100000,1000000): temp = str(j) flag = True for i in range(6): if(temp[i] in temp[:i]): flag = False break; if(flag): temp1 = str(j * j) flag2 = True for m in temp1: if(m in temp[:]): flag2 = False break; if(flag2): print(j) # 203879# 639172 【看】第39级台阶题目描述小明刚刚看完电影《第39级台阶》，离开电影院的时候，他数了数礼堂前的台阶数，恰好是39级！站在台阶前，他突然又想着一个问题：如果我每一步只能迈上1个或2个台阶，先迈左脚，然后左右交替，最后一步是迈右脚，也就是说一共要走偶数步。那么，上完39级台阶，有多少种不同的上法呢？请你利用计算机的优势，帮助小明寻找答案。要求提交的是一个整数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# 递归def cal(n, bushu): if(n == 0 and bushu % 2 == 0): return 1 if(n &lt; 0): return 0 return cal(n-1, bushu + 1,res) + cal(n - 2, bushu + 1,res)print(cal(39,0))# 这样递归不可以res = 0def cal(n, bushu,res): if(n == 0 and bushu % 2 == 0): res += 1 if(n &lt; 0): return cal(n-1, bushu + 1,res) cal(n - 2, bushu + 1,res)cal(39,0,res)print(res)# 会返回0，因为Python对象分为可变对象(list,dict,set等)和不可变对象(number,string,tuple等)，当传递的参数是可变对象的引用时，因为可变对象的值可以修改，因此可以通过修改参数值而修改原对象，这类似于C语言中的引用传递；当传递的参数是不可变对象的引用时，虽然传递的是引用，参数变量和原变量都指向同一内存地址，但是不可变对象无法修改，所以参数的重新赋值不会影响原对象，这类似于C语言中的值传递。# 改写# 根据上述准则，可以把变量存在list里面list1 = [0]def cal(n, bushu, list1): if(n == 0 and bushu % 2 == 0): list1[0] += 1 if(n &lt; 0): return cal(n-1, bushu + 1, list1) cal(n - 2, bushu + 1, list1)cal(39,0, list1)print(list1[0])# 动态规划dp = [[0 for _ in range(2)] for _ in range(39)]# arr[a][b]的含义分为arr[a][0] 左脚踏上第a阶的方案数，# arr[a][1]为右脚踏上第a阶的方案数dp[0][0] = 1dp[0][1] = 0dp[1][0] = 1dp[1][1] = 1for i in range(2, 39): dp[i][1] = dp[i-1][0] + dp[i-2][0] dp[i][0] = dp[i-1][1] + dp[i-2][1]print(dp[38][1])# 51167078 2014填空猜年龄题目描述小明带两个妹妹参加元宵灯会。别人问她们多大了，她们调皮地说：“我们俩的年龄之积是年龄之和的6倍”。小明又补充说：“她们可不是双胞胎，年龄差肯定也不超过8岁啊。”请你写出：小明的较小的妹妹的年龄。 1234567for n in range(1, 100): for m in range(n,n + 9): if(n*m % (n + m) == 0 and n * m // (n + m) == 6): print(n ,m)# 10 15 应该是10# 12 12 相同了 李白打酒题目描述话说大诗人李白，一生好饮。幸好他从不开车。一天，他提着酒壶，从家里出来，酒壶中有酒2斗。他边走边唱：无事街上走，提壶去打酒。逢店加一倍，遇花喝一斗。这一路上，他一共遇到店5次，遇到花10次，已知最后一次遇到的是花，他正好把酒喝光了。请你计算李白遇到店和花的次序，可以把遇店记为a，遇花记为b。则：babaabbabbabbbb 就是合理的次序。像这样的答案一共有多少呢？请你计算出所有可能方案的个数（包含题目给出的）。注意：通过浏览器提交答案。答案是个整数。不要书写任何多余的内容。 【和去年的“第39级台阶”有点像】 123456789101112131415# 倒数第二次还有一斗酒list1 = [0]def cal(dian, hua, res,jiu,list1): if(dian &lt; 0): return if(hua &lt; 0): return if(dian == 0 and hua == 0 and jiu == 1): list1[0] += 1 cal(dian - 1, hua , res + &quot;a&quot;,jiu * 2,list1) cal(dian, hua - 1,res + &quot;b&quot;, jiu - 1,list1)cal(5,9,&quot;&quot;, 2,list1)print(list1[0])# 14 【看】神奇算式题目描述由4个不同的数字，组成的一个乘法算式，它们的乘积仍然由这4个数字组成。比如：210 x 6 = 12608 x 473 = 378427 x 81 = 2187都符合要求。如果满足乘法交换律的算式算作同一种情况，那么，包含上边已列出的3种情况，一共有多少种满足要求的算式。请填写该数字，通过浏览器提交答案，不要填写多余内容（例如：列出所有算式）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344res = 0def cal(num1, num2,temp): p = str(num1 * num2) set1 = set() for k in p: set1.add(k) flag = True for k in p: if(k not in temp): flag = False break if(flag and len(set1) == 4):## print(num1, num2) return 1 return 0# 一开始错在temp,temp1,temp2,temp3没有区分，都是用temp代替，这是错误的for i in range(1, 10): temp = str(i) for j in range(0,10): if(str(j) in temp): continue temp1 = temp + str(j) for m in range(0,10): if(str(m) in temp1): continue temp2 = temp1 + str(m) for n in range(0,10): if(str(n) in temp2): continue temp3 = temp2 + str(n) num1 = i num2 = 100*j + 10* m + n num3 = 10*i + j num4 = 10*m + n num5 = 100*i + 10*j + m num6 = n res += cal(num1, num2,temp3) res += cal(num3, num4,temp3) res += cal(num5, num6,temp3)print(res // 2) # 12 武功秘籍题目描述小明到X山洞探险，捡到一本有破损的武功秘籍（2000多页！当然是伪造的）。他注意到：书的第10页和第11页在同一张纸上，但第11页和第12页不在同一张纸上。小明只想练习该书的第81页到第92页的武功，又不想带着整本书。请问他至少要撕下多少张纸带走？这是个整数，请通过浏览器提交该数字，不要填写任何多余的内容。 12# 口算# 7 切面条题目描述一根高筋拉面，中间切一刀，可以得到2根面条。如果先对折1次，中间切一刀，可以得到3根面条。如果连续对折2次，中间切一刀，可以得到5根面条。那么，连续对折10次，中间切一刀，会得到多少面条呢？答案是个整数，请通过浏览器提交答案。不要填写任何多余的内容。 12345678list1 = [0 for i in range(11)]list1[0] = 2for i in range(1,11): list1[i] = 2 * list1[i-1] - 1print(list1[10]) # 1025 【看】猜字母题目描述把abcd…s共19个字母组成的序列重复拼接106次，得到长度为2014的串。接下来删除第1个字母（即开头的字母a），以及第3个，第5个等所有奇数位置的字母。得到的新串再进行删除奇数位置字母的动作。如此下去，最后只剩下一个字母，请写出该字母。答案是一个小写字母，请通过浏览器提交答案。不要填写任何多余的内容。 1234567891011121314dp = &quot;abcdefghijklmnopqrs&quot; * 106temp = list(dp)while len(temp) &gt; 1: length = len(temp)## print(temp) for i in range(length - 1, - 1, -1): if((i+1) % 2 == 1): temp.pop(i) print(temp[0])# q 啤酒和饮料题目描述啤酒每罐2.3元，饮料每罐1.9元。小明买了若干啤酒和饮料，一共花了82.3元。我们还知道他买的啤酒比饮料的数量少，请你计算他买了几罐啤酒。 123456for i in range(1, 36): if abs((82.3 - i * 2.3) % 1.9) &lt; 0.0001: print(i, (82.3 - i * 2.3) / 1.9 )# 11 2015填空熊怪吃核桃题目描述森林里有一只熊怪，很爱吃核桃。不过它有个习惯，每次都把找到的核桃分成相等的两份，吃掉一份，留一份。如果不能等分，熊怪就会扔掉一个核桃再分。第二天再继续这个过程，直到最后剩一个核桃了，直接丢掉。有一天，熊怪发现了1543个核桃，请问，它在吃这些核桃的过程中，一共要丢掉多少个核桃。 1234567891011n = 1543res = 0while(n != 1): if(n % 2 == 0): n = n // 2 else: n = (n - 1) // 2 res +=1print(res + 1)# 5 星系炸弹题目描述在X星系的广袤空间中漂浮着许多X星人造“炸弹”，用来作为宇宙中的路标。每个炸弹都可以设定多少天之后爆炸。比如：阿尔法炸弹2015年1月1日放置，定时为15天，则它在2015年1月16日爆炸。有一个贝塔炸弹，2014年11月9日放置，定时为1000天，请你计算它爆炸的准确日期。 请填写该日期，格式为 yyyy-mm-dd 即4位年份2位月份2位日期。比如：2015-02-19请严格按照格式书写。不能出现其它文字或符号。 123456789excel# 2017-08-05import datetimestart = datetime.date(2014,11,9)for i in range(1000): start += datetime.timedelta(days = 1)print(start) 九数分三组题目描述1~9的数字可以组成3个3位数，设为：A,B,C, 现在要求满足如下关系：B = 2 AC = 3 A 请你写出A的所有可能答案，数字间用空格分开，数字按升序排列。 注意：只提交A的值，严格按照格式要求输出。 1234567891011121314151617181920212223242526272829303132333435363738394041424344for a in range(1,10): temp1 = str(a) for b in range(1,10): if(str(b) in temp1): continue temp2 = temp1 + str(b) for c in range(1,10): if(str(c) in temp2): continue temp3 = temp2 + str(c) for d in range(1,10): if(str(d) in temp3): continue temp4 = temp3 + str(d) for e in range(1,10): if(str(e) in temp4): continue temp5 = temp4 + str(e) for f in range(1,10): if(str(f) in temp5): continue temp6 = temp5 + str(f) for g in range(1,10): if(str(g) in temp6): continue temp7 = temp6 + str(g) for h in range(1,10): if(str(h) in temp7): continue temp8 = temp7 + str(h) for i in range(1,10): if(str(i) in temp8): continue num1 = 100*a + 10 * b + c num2 = 100*d + 10 * e + f num3 = 100*g + 10 * h + i if(num2 == 2* num1 and num3 == 3 * num1): print(num1) 192219273327 三角形面积题目描述如图1所示。图中的所有小方格面积都是1。那么，图中的三角形面积应该是多少呢？请填写三角形的面积。不要填写任何多余内容或说明性文字。 1# 小学数学 立方变自身题目描述观察下面的现象,某个数字的立方，按位累加仍然等于自身。1^3 = 18^3 = 512 5+1+2=817^3 = 4913 4+9+1+3=17… 请你计算包括1,8,17在内，符合这个性质的正整数一共有多少个？ 123456789101112131415161718for i in range(1, 1 &lt;&lt; 64): n = pow(i,3) res = 0 list1 = list(map(int,str(n))) for num in list1: res += num if(res == i): print(i)1817182627这6个 其他2579 1234567891011121314151617181920212223242526272829n , m = map(int, input().split())list1 = [0 for _ in range(n+1)]weight = [0 for _ in range(n+1)]for i in range(n + 1): list1[i] = ifor i in range(m): a,b,c = map(int, input().split()) if(a ==1): if(b &gt; c): d = b b = c c = d list1[c] = b while(list1[list1[c]] != list1[c]): list1[c] = list1[list1[c]] else: cate = list1[b] for i in range(1, n + 1): if(list1[i] == cate): weight[i] += c for i in range(1, n+1): if(i == n): print(weight[i],end = &quot;&quot;) else: print(weight[i],end = &quot; &quot;) 总结1083 输入输出 看解答的 1234567import syswhile True: line = sys.stdin.readline() if not line: break for _ in line.split(): print(chr(int(_)),end=&#x27;&#x27;) 1094 输入输出 自己写的 12345678910111213import sysn = int(input())while(n): line = sys.stdin.readline() n-=1 print(line)while True: line = sys.stdin.readline().strip() if not line: break a = line.split() for i in a: print(i,end=&quot;\\n\\n&quot;) 最大值最小值 1234import sysmax_value = sys.maxsizemin_value = -sys.maxsize - 1 1096 创建二维数组 自己写的 1234567891011121314151617181920212223242526272829303132333435import sysx = [-1, 0, 1, 1, 1, 0, -1, -1]y = [-1,-1,-1,0,1,1,1,0]time = 1while True: a,b = map(int, input().strip().split()) if(a == 0 and b == 0): break matrix = [] output = [[&#x27;0&#x27;] * b for _ in range(a)] for i in range(0, a): matr = [] line = sys.stdin.readline().strip() for j in range(0, len(line)): matr.append((line[j])) matrix.append(matr) for i in range(0,a): for j in range(0, b): if(matrix[i][j] == &#x27;*&#x27;): output[i][j] = &#x27;*&#x27; else: for k in range(0, 8): m = i + x[k] n = j + y[k] if( m in range(0, a) and n in range(0 ,b)): if(matrix[m][n] == &#x27;*&#x27;): output[i][j] = chr(ord(output[i][j]) + 1) print(&quot;Field #&quot; + str(time) + &quot;:&quot;) time += 1 for i in range(0,a): print(&#x27;&#x27;.join([str(x) for x in output[i]])) print() 1434 列表逆序：reverse()方法改变原有的数组，没有副本，使用切片可以解决 点击这里 1117 解答 文件输入输出12345678910111213# 适合读取一行操作一行f = open(&#x27;2020.txt&#x27;, &#x27;r&#x27;)lists = []for line in f: lists.append(list(line.strip()))# 适合查看内容#以 utf-8 的编码格式打开指定文件f = open(&quot;my_file.txt&quot;,encoding = &quot;utf-8&quot;)#输出读取到的数据print(f.read())#关闭文件f.close() readlines() 函数用于读取文件中的所有行，它和调用不指定 size 参数的 read() 函数类似，只不过该函数返回是一个字符串列表，其中每个元素为文件中的一行内容。 和 readline() 函数一样，readlines() 函数在读取每一行时，会连同行尾的换行符一块读取。 readlines() 函数的基本语法格式如下： file.readlines() 12345# 适合一下子读取所有的内容，存在数组中f = open(&quot;my_file.txt&quot;,&#x27;rb&#x27;)byt = f.readlines()print(byt)#[&#x27;PDF24664D1A723646BB\\n&#x27;, &#x27;PDFD7F97D56644290DB\\n&#x27;, &#x27;PDFC5826A0764EE9B4C\\n&#x27;, &#x27;PDFE178C770A33F9EA1\\n&#x27;, &#x27;PDF4FF9B92C273F1D01\\n&#x27;, &#x27;PDFFF70075838B3AAFE\\n&#x27;, &#x27;PDF9B1CA4EB63B2B7B4\\n&#x27;, &#x27;PDF32A1C6DB7CB3562F&#x27;] back String 和 list转换 str转换成list 123456789101112str1 = &#x27;abcde&#x27;str2 = &#x27;a b c d e&#x27;str3 = &#x27;a, b, c, d, e&#x27;result1 = list(str1)result2 = str2.split()result3 = str3.split(&#x27;, &#x27;)print(result1)print(result2)print(result3)# [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]# [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]# [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;] list转化为str 当list中存放的数据是字符串时，一般是通过str中的join函数进行转换： 1234567891011list = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;]str1 = &#x27;&#x27;.join(list)str2 = &#x27; &#x27;.join(list)str3 = &#x27;.&#x27;.join(list)list1 = list(map(int, list(input()))) # 把输入的数字字符串，变成整型数组print(str1)print(str2)print(str3)# abcd# a b c d# a.b.c.d 但是当list中存放的数据是整型数据或者数字的话，需要先将数据转换为字符串再进行转换： 12345678910list = [1, 2, 3, 4]str1 = &#x27;&#x27;.join([str(x) for x in list])str2 = &#x27; &#x27;.join([str(x) for x in list])str3 = &#x27;.&#x27;.join([str(x) for x in list])print(str1)print(str2)print(str3)# 1234# 1 2 3 4# 1.2.3.4 back 字符和整型的转换 Python内置ord函数 用来将字符转化成ASCII码 用法为： 123print(&#x27;字符0 的ASCII码表示为&#x27;,ord(&#x27;0&#x27;))# 字符0 的ASCII码表示为 48 Python内置chr函数 用来将ASCII码化成字符 用法为： 123print(&#x27;ASCII码为97对应的字符为&#x27;,chr(97))# ASCII码为97对应的字符为 a back 【time库的使用】 查看这里 back 排列组合计算 组合数：math.comb(m, n) 排列数：math.comb(m,n) * math.factorial(m) back 格式化输出 1234567891011121314151617181920212223242526272829####格式化浮点数print(&#x27;%f&#x27; % 1.11) # 默认保留6位小数 # 1.110000 print(&#x27;%.1f&#x27; % 1.11) # 取1位小数 # 1.1 print(&#x27;%e&#x27; % 1.11) # 默认6位小数，用科学计数法 # 1.110000e+00 print(&#x27;%.3e&#x27; % 1.11) # 取3位小数，用科学计数法 # 1.110e+00 print(&#x27;%g&#x27; % 1111.1111) # 默认6位有效数字 # 1111.11 print(&#x27;%.7g&#x27; % 1111.1111) # 取7位有效数字 # 1111.111 print(&#x27;%.2g&#x27; % 1111.1111) # 取2位有效数字，自动转换为科学计数法 # 1.1e+03 # 百分比显示小数点后2位：print(&#x27;percent: &#123;:.2f&#125;%&#x27;.format(42/50*100))# percent: 84.00%显示小数点后1位：print(&#x27;percent: &#123;:.1f&#125;%&#x27;.format(42/50*100))# percent: 84.0%只显示整数位：print(&#x27;percent: &#123;:.0f&#125;%&#x27;.format(42/50*100))# percent: 84% back 进制转换123456789101112n,k = map(int, input().split())res = 0for i in range(1 &lt;&lt; n): binary = str(bin(i)) print(binary) count = binary[2:].count(&quot;1&quot;) if(count == k): if(check(int(binary,2))): res += 1print(res)https://www.luogu.com.cn/problem/P1036 这里 对象排序 python1234567891011121314151617181920212223242526272829303132class Person(object): def __init__(self, name, age): self.name = name self.age = ageif __name__ == &#x27;__main__&#x27;: a = (0, 8, 2, 6, 3) b = [(&#x27;a&#x27;, 12), (&#x27;b&#x27;, 12), (&#x27;c&#x27;, 1), (&#x27;d&#x27;, 13), (&#x27;e&#x27;, 2)] person_list = [Person(&#x27;q&#x27;, 2), Person(&#x27;w&#x27;, 1), Person(&#x27;e&#x27;, 3), Person(&#x27;r&#x27;, 6)] a.sort(cmp=None, key=None, reverse=True) # reverse 参数为 True 时逆向排序 print a b.sort(key=lambda x: x[1]) #正序 b.sort(key=lambda x: -x[1]) #逆序 b.sort(key=lambda x: (x[1],-x[0]) #先按照下标1正序，相同，按照第一个元素递减 print b person_list.sort(key=lambda x: x.age) #这里 for i in person_list: print i.age # 如果要实现部分排序，并且数组不是numpy数组，使用sorted b[i:j] = b.sorted(b[i:j], key=lambda x: x[1]) # 高阶自定义排序import functoolsa = [3,8,14,6,7]def compare_personal(x,y): return x%7-y%7a.sort(key=functools.cmp_to_key(compare_personal))b = sorted(a,key=functools.cmp_to_key(compare_personal))print(a)print(b) 对象排序 C++数组+单元素12345678910111213141516171819202122232425262728// 升序#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int a[7] = &#123;1,4,2,8,5,3,0&#125;; sort(a, a + 7); for(int i = 0 ; i &lt; 7; i ++)&#123; cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; &#125; return 0;&#125;// 降序#include &lt;bits/stdc++.h&gt;using namespace std;bool cmp(int x, int y)&#123; return x &gt; y;&#125;int main() &#123; int a[7] = &#123;1,4,2,8,5,3,0&#125;; sort(a, a + 7,cmp); for(int i = 0 ; i &lt; 7; i ++)&#123; cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 数组 + 结构体1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;struct node &#123; int num; int val;&#125; a[6];bool cmp(const node &amp;a, const node&amp;b) &#123;// return a.num &lt; b.num; // 按照num升序// return a.num &gt; b.num; // 按照num降序// return a.val &gt; b.val; // 按照val降序 return a.val &lt; b.val; // 按照val升序&#125;int main() &#123; a[0].num = 3; a[0].val = 10; a[1].num = 4; a[1].val = 8; a[2].num = 1; a[2].val = 2; a[3].num = 6; a[3].val = 4; a[4].num = 2; a[4].val = 7; a[5].num = 9; a[5].val = 1; sort(a, a + 6,cmp); for(int i = 0 ; i &lt; 6; i ++) &#123; cout &lt;&lt; a[i].num &lt;&lt; &quot; &quot; &lt;&lt; a[i].val &lt;&lt; endl; &#125; return 0;&#125; vector + 单元素123456789101112131415161718192021222324252627// 升序#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; vector&lt;int&gt; a = &#123;2,7,4,3,9,1&#125;; sort(a.begin(), a.end()); for(int i = 0 ; i &lt; 6; i ++) &#123; cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; &#125; return 0;&#125;// 降序#include &lt;bits/stdc++.h&gt;using namespace std;bool cmp(int x,int y)&#123; return x &gt; y; // 降序 &#125;int main() &#123; vector&lt;int&gt; a = &#123;2,7,4,3,9,1&#125;; sort(a.begin(), a.end(),cmp); for(int i = 0 ; i &lt; 6; i ++) &#123; cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; &#125; return 0;&#125; vector + 结构体123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;struct node &#123; int num; int val;&#125;;bool cmp(const node &amp;a, const node&amp;b) &#123; return a.num &lt; b.num; // 按照num升序// return a.num &gt; b.num; // 按照num降序// return a.val &gt; b.val; // 按照val降序// return a.val &lt; b.val; // 按照val升序&#125;int main() &#123; vector&lt;node&gt; a; a.push_back(&#123;3,10&#125;); a.push_back(&#123;4,8&#125;); a.push_back(&#123;1,2&#125;); a.push_back(&#123;6,4&#125;); a.push_back(&#123;2,7&#125;); a.push_back(&#123;9,1&#125;); sort(a.begin(), a.end(),cmp); for(int i = 0 ; i &lt; 6; i ++) &#123; cout &lt;&lt; a[i].num &lt;&lt; &quot; &quot; &lt;&lt; a[i].val &lt;&lt; endl; &#125; return 0;&#125; priority_queue + 单元素1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;// 默认降序 priority_queue&lt;int&gt; a;int main() &#123; a.push(1); a.push(7); a.push(2); a.push(0); a.push(9); a.push(4); a.push(6); while(!a.empty()) &#123; cout &lt;&lt; a.top() &lt;&lt;endl; a.pop(); &#125; return 0;&#125;priority_queue&lt;int&gt; q;//默认是从大到小priority_queue&lt;int, vector&lt;int&gt; ,less&lt;int&gt; &gt;q;//从大到小排序priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;q;//从小到大排序 priority_queue + 结构体12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;struct node &#123; int num; int val; bool operator&lt;(const node&amp; b) const &#123;// return num &lt; b.num; // 按照num降序// return num &gt; b.num; // 按照num升序// return val &lt; b.val; // 按照val降序 return val &gt; b.val; // 按照val升序 &#125;&#125;;priority_queue&lt;node&gt; a;int main() &#123; a.push(&#123;3,10&#125;); a.push(&#123;4,8&#125;); a.push(&#123;1,2&#125;); a.push(&#123;6,4&#125;); a.push(&#123;2,7&#125;); a.push(&#123;9,1&#125;); while(!a.empty()) &#123; cout &lt;&lt; a.top().num &lt;&lt; &quot; &quot; &lt;&lt; a.top().val &lt;&lt; endl; a.pop(); &#125; return 0;&#125; back 整除问题有一个序列，序列的第一个数是 ，后面的每个数是前一个数整除 2，请输出这个序列中值为正数的项。 12345678910import mathn = int(input())while( n != 0 and n &gt; 0): if(n == 1): print(n ,end=&quot;&quot;) else: print(n,end=&quot; &quot;) n //= 2 # 注意不能使用（floor(n/2),浮点数有精度问题） 关于日期2571 123456789101112131415161718192021222324252627282930313233343536import datetimen = input()year = int(n[0:4])if(n[4] == &#x27;0&#x27;): month = int(n[5])else: month = int(n[4:6])if(n[6] == &#x27;0&#x27;): day = int(n[7])else: day = int(n[6:8])now = datetime.date(year,month,day)##print(now.year)##print(now.month)##print(now.day)##print(str(now))find1 = Falsefind2 =Falsehuiwen = &quot;&quot;ABhuiwen = &quot;&quot;while True: now = now + datetime.timedelta(days = 1) daystr = str(now)[0:4] + str(now)[5:7] + str(now)[8:10] if(daystr == daystr[::-1] and not find1): huiwen = daystr find1 = True if(not find2 and daystr[0] == daystr[2] == daystr[5]== daystr[7] and daystr[1] == daystr[3] == daystr[4] == daystr[6] and daystr[0] != daystr[1]): ABhuiwen = daystr find2= True if(find1 and find2): breakprint(huiwen)print(ABhuiwen) 字符串求子串题目 思路 123456789str1 = input()res = 0for i in range(len(str1)): pre = str1.rfind(str1[i],0,i) nextIndex = str1.find(str1[i],i + 1, len(str1) + 1) if(nextIndex == -1): nextIndex = len(str1) res += (i-pre)*(nextIndex - i)print(res) Decimal12345678910#需要导入这个库from decimal import*#设置精度getcontext().prec=6a=Decimal(1)/Decimal(7)print(a)print(type(a))# 0.142857# &lt;class &#x27;decimal.Decimal&#x27;&gt; back 使用reverse会改变原来，使用replace 不会改变原来 字符串操作index() 空格包括回车和制表符！！读入字符串一定要去收尾空格！https://www.luogu.com.cn/problem/P1308 https://www.luogu.com.cn/problem/P3741 删除前后零 https://www.luogu.com.cn/problem/P1553 高精度乘 https://www.luogu.com.cn/problem/P1303 全局变量的使用 https://www.luogu.com.cn/problem/P1518 字符串展开 https://www.luogu.com.cn/problem/P1098 计算2**n 的长度，n很大的时候不能使用len，会超限 https://www.luogu.com.cn/problem/P1045 C++中用find找字符串中的子串，找不到会返回一个诡异的数字（反正比字符串长），dev C++中不能使用 string:npos 输出限制场宽全排列问题123456789101112131415161718192021222324252627282930313233# include &lt;bits/stdc++.h&gt;using namespace std;int a[10];int main () &#123; int n; cin &gt;&gt; n; for (int i =1; i &lt; n+1; i ++)&#123; a[i] = i; &#125; do&#123; for (int i =0; i &lt; n; i ++)&#123; printf(&quot;%5d&quot;,a[i]); &#125; cout &lt;&lt; endl; &#125;while(next_permutation(a+1,a+n+1)); return 0;&#125;import itertoolsnums = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]for num in itertools.permutations(nums, 3): a = num[0] + num[1] + num[2] print(a) abc 输出：abcacbbacbcacabcba` 以固定场宽输出https://pintia.cn/problem-sets/994805046380707840/problems/994805135224455168 C++与其类似 1printf(&quot;%5d&quot;, a[s][i]); 取整问题","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://hasuer.github.io/categories/Algorithm/"}],"tags":[]},{"title":"马斯克的冒险人生","slug":"马斯克的冒险人生","date":"2022-01-12T13:27:14.000Z","updated":"2022-02-23T06:56:46.477Z","comments":true,"path":"马斯克的冒险人生/index.html","link":"","permalink":"https://hasuer.github.io/%E9%A9%AC%E6%96%AF%E5%85%8B%E7%9A%84%E5%86%92%E9%99%A9%E4%BA%BA%E7%94%9F/index.html","excerpt":"","text":"","categories":[{"name":"阅读笔记","slug":"阅读笔记","permalink":"https://hasuer.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"人物传记，企业管理","slug":"人物传记，企业管理","permalink":"https://hasuer.github.io/tags/%E4%BA%BA%E7%89%A9%E4%BC%A0%E8%AE%B0%EF%BC%8C%E4%BC%81%E4%B8%9A%E7%AE%A1%E7%90%86/"}]},{"title":"10. Pattern Two Heaps","slug":"10. Pattern Two Heaps","date":"2021-11-25T14:48:49.000Z","updated":"2024-03-22T03:32:55.324Z","comments":true,"path":"10-pattern-two-heaps/index.html","link":"","permalink":"https://hasuer.github.io/10-pattern-two-heaps/index.html","excerpt":"","text":"IntroductionIn many problems, where we are given a set of elements such that we can divide them into two parts. To solve the problem, we are interested in knowing the smallest element in one part and the biggest element in the other part. This pattern is an efficient approach to solve such problems. This pattern uses two Heaps to solve these problems; A Min Heap to find the smallest element and a Max Heap to find the biggest element. Let’s jump onto our first problem to see this pattern in action. Find the Median of a Number Stream (medium)leetcode 295 Problem StatementDesign a class to calculate the median of a number stream. The class should have the following two methods: insertNum(int num): stores the number in the class findMedian(): returns the median of all numbers inserted in the class If the count of numbers inserted in the class is even, the median will be the average of the middle two numbers. Example 1: 12345671. insertNum(3)2. insertNum(1)3. findMedian() -&gt; output: 24. insertNum(5)5. findMedian() -&gt; output: 36. insertNum(4)7. findMedian() -&gt; output: 3.5 Try it yourselfTry solving this question here: 1# 不会 SolutionAs we know, the median is the middle value in an ordered integer list. So a brute force solution could be to maintain a sorted list of all numbers inserted in the class so that we can efficiently return the median whenever required. Inserting a number in a sorted list will take O(N) time if there are ‘N’ numbers in the list. This insertion will be similar to the Insertion sort. Can we do better than this? Can we utilize the fact that we don’t need the fully sorted list - we are only interested in finding the middle element? Assume ‘x’ is the median of a list. This means that half of the numbers in the list will be smaller than (or equal to) ‘x’ and half will be greater than (or equal to) ‘x’. This leads us to an approach where we can divide the list into two halves: one half to store all the smaller numbers (let’s call it smallNumList) and one half to store the larger numbers (let’s call it largNumList). The median of all the numbers will either be the largest number in the smallNumList or the smallest number in the largNumList. If the total number of elements is even, the median will be the average of these two numbers. The best data structure that comes to mind to find the smallest or largest number among a list of numbers is a Heap). Let’s see how we can use a heap to find a better algorithm. We can store the first half of numbers (i.e., smallNumList) in a Max Heap. We should use a Max Heap as we are interested in knowing the largest number in the first half. We can store the second half of numbers (i.e., largeNumList) in a Min Heap, as we are interested in knowing the smallest number in the second half. Inserting a number in a heap will take O(logN), which is better than the brute force approach. At any time, the median of the current list of numbers can be calculated from the top element of the two heaps. Let’s take the Example-1 mentioned above to go through each step of our algorithm: insertNum(3): We can insert a number in the Max Heap (i.e. first half) if the number is smaller than the top (largest) number of the heap. After every insertion, we will balance the number of elements in both heaps, so that they have an equal number of elements. If the count of numbers is odd, let’s decide to have more numbers in max-heap than the Min Heap. insertNum(1): As ‘1’ is smaller than ‘3’, let’s insert it into the Max Heap. Now, we have two elements in the Max Heap and no elements in Min Heap. Let’s take the largest element from the Max Heap and insert it into the Min Heap, to balance the number of elements in both heaps. findMedian(): As we have an even number of elements, the median will be the average of the top element of both the heaps -&gt; (1+3)/2 = 2.0(1+3)/2=2.0 insertNum(5): As ‘5’ is greater than the top element of the Max Heap, we can insert it into the Min Heap. After the insertion, the total count of elements will be odd. As we had decided to have more numbers in the Max Heap than the Min Heap, we can take the top (smallest) number from the Min Heap and insert it into the Max Heap. findMedian(): Since we have an odd number of elements, the median will be the top element of Max Heap -&gt; 3. An odd number of elements also means that the Max Heap will have one extra element than the Min Heap. insertNum(4): Insert ‘4’ into Min Heap. findMedian(): As we have an even number of elements, the median will be the average of the top element of both the heaps -&gt; (3+4)/2 = 3.5(3+4)/2=3.5 CodeHere is what our algorithm will look like: 12345678910111213141516171819202122232425262728293031323334353637383940414243from heapq import *class MedianOfAStream: maxHeap = [] # 存储小的一半的数字 minHeap = [] # 存储大的一半的数字 def insert_num(self, num): if not self.maxHeap or -self.maxHeap[0] &gt;= num: # heapq默认是小顶堆，所以要实现大顶堆的时候，就要取反 heappush(self.maxHeap, -num) else: heappush(self.minHeap, num) # maxheap的个数和minheap的个数最多相差1 if len(self.maxHeap) &gt; len(self.minHeap) + 1: heappush(self.minHeap, -heappop(self.maxHeap)) elif len(self.minHeap) &gt; len(self.maxHeap): heappush(self.maxHeap, -heappop(self.minHeap)) def find_median(self): if len(self.maxHeap) == len(self.minHeap): return (-self.maxHeap[0] + self.minHeap[0]) / 2 return -self.maxHeap[0]def main(): median_of_stream = MedianOfAStream() median_of_stream.insert_num(3) median_of_stream.insert_num(1) res = median_of_stream.find_median() print(str(res)) median_of_stream.insert_num(5) res = median_of_stream.find_median() print(str(res)) median_of_stream.insert_num(4) res = median_of_stream.find_median() print(str(res))if __name__ == &#x27;__main__&#x27;: main() Time complexityThe time complexity of the insertNum() will be O(logN) due to the insertion in the heap. The time complexity of the findMedian() will be O(1) as we can find the median from the top elements of the heaps. Space complexityThe space complexity will be O(N) because, as at any time, we will be storing all the numbers. *Sliding Window Median (hard)leetcode 480 Problem StatementGiven an array of numbers and a number ‘k’, find the median of all the ‘k’ sized sub-arrays (or windows) of the array. Example 1: Input: nums=[1, 2, -1, 3, 5], k = 2Output: [1.5, 0.5, 1.0, 4.0]Explanation: Lets consider all windows of size ‘2’: [1, 2, -1, 3, 5] -&gt; median is 1.5 [1, 2, -1, 3, 5] -&gt; median is 0.5 [1, 2, -1, 3, 5] -&gt; median is 1.0 [1, 2, -1, 3, 5] -&gt; median is 4.0 Example 2: Input: nums=[1, 2, -1, 3, 5], k = 3Output: [1.0, 2.0, 3.0]Explanation: Lets consider all windows of size ‘3’: [1, 2, -1, 3, 5] -&gt; median is 1.0 [1, 2, -1, 3, 5] -&gt; median is 2.0 [1, 2, -1, 3, 5] -&gt; median is 3.0 Try it yourselfTry solving this question here: 1# 只会排序窗口然后取mediam SolutionThis problem follows the Two Heaps pattern and share similarities with Find the Median of a Number Stream. We can follow a similar approach of maintaining a max-heap and a min-heap for the list of numbers to find their median. The only difference is that we need to keep track of a sliding window of ‘k’ numbers. This means, in each iteration, when we insert a new number in the heaps, we need to remove one number from the heaps which is going out of the sliding window. After the removal, we need to rebalance the heaps in the same way that we did while inserting. CodeHere is what our algorithm will look like: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from heapq import *import heapqclass SlidingWindowMedian: def __init__(self): self.maxHeap = [] # 存储小的一半的数字 self.minHeap = [] # 存储大的一半的数字 def find_sliding_window_median(self, nums, k): result = [] for i in range(len(nums)): if not self.maxHeap or nums[i] &lt;= -self.maxHeap[0]: heappush(self.maxHeap, -nums[i]) else: heappush(self.minHeap, nums[i]) self.balance_heaps() if i + 1 - k &gt;= 0: # 有至少k个元素了 if len(self.maxHeap) == len(self.minHeap): result.append((-self.maxHeap[0] + self.minHeap[0]) / 2) else: result.append(-self.maxHeap[0]) remove_element = nums[i + 1 - k] if remove_element &lt;= -self.maxHeap[0]: self.remove(self.maxHeap, -remove_element) else: self.remove(self.minHeap, remove_element) self.balance_heaps() return result def balance_heaps(self): # maxheap的个数和minheap的个数最多相差1 if len(self.maxHeap) &gt; len(self.minHeap) + 1: heappush(self.minHeap, -heappop(self.maxHeap)) elif len(self.minHeap) &gt; len(self.maxHeap): heappush(self.maxHeap, -heappop(self.minHeap)) def remove(self, heap, remove_element): idx = heap.index(remove_element) # heap[idx] = heap[0] # heap.pop() heap[idx] = heap[-1] del heap[-1] # 使用heapify这是O(n)，如果你希望你可以在O(log(n))中做同样的事情，使用_siftup / _siftdown if idx &lt; len(heap): heapq._siftup(heap, idx) heapq._siftdown(heap, 0, idx)def main(): sliding_window_median = SlidingWindowMedian() res = sliding_window_median.find_sliding_window_median([1, 2, -1, 3, 5], 2) print(str(res)) res = sliding_window_median.find_sliding_window_median([1, 2, -1, 3, 5], 3) print(str(res))if __name__ == &#x27;__main__&#x27;: main() Time complexityThe time complexity of our algorithm is O(N\\K)* where ‘N’ is the total number of elements in the input array and ‘K’ is the size of the sliding window. This is due to the fact that we are going through all the ‘N’ numbers and, while doing so, we are doing two things: Inserting/removing numbers from heaps of size ‘K’. This will take O(logK) Removing the element going out of the sliding window. This will take O(K) as we will be searching this element in an array of size ‘K’ (i.e., a heap). Space complexityIgnoring the space needed for the output array, the space complexity will be O(K) because, at any time, we will be storing all the numbers within the sliding window. Maximize Capital (hard)leetcode 502 Problem StatementGiven a set of investment projects with their respective profits, we need to find the most profitable projects. We are given an initial capital and are allowed to invest only in a fixed number of projects. Our goal is to choose projects that give us the maximum profit. We can start an investment project only when we have the required capital. Once a project is selected, we can assume that its profit has become our capital. Example 1: Input: Project Capitals=[0,1,2], Project Profits=[1,2,3], Initial Capital=1, Number of Projects=2Output: 6Explanation: With initial capital of ‘1’, we will start the second project which will give us profit of ‘2’. Once we selected our first project, our total capital will become 3 (profit + initial capital). With ‘3’ capital, we will select the third project, which will give us ‘3’ profit. After the completion of the two projects, our total capital will be 6 (1+2+3). Example 2: Input: Project Capitals=[0,1,2,3], Project Profits=[1,2,3,5], Initial Capital=0, Number of Projects=3Output: 8Explanation: With ‘0’ capital, we can only select the first project, bringing out capital to 1. Next, we will select the second project, which will bring our capital to 3. Next, we will select the fourth project, giving us a profit of 5. After selecting the three projects, our total capital will be 8 (1+2+5). Try it yourselfTry solving this question here: 12345678910111213141516171819202122232425262728293031# 按照solution写的 用例过了,但是是有问题的from heapq import *import heapqdef find_max_capital(capital, profits, project_num, initial_capital): min_capital_heap = [] max_profit_heap = [] for i in range(len(profits)): # 默认小顶堆，而且按照第一个元素排列 heappush(min_capital_heap, (capital[i], i)) available_capital = initial_capital for _ in range(project_num): while min_capital_heap and min_capital_heap[0][0] &lt;= available_capital: capital, index = heappop(min_capital_heap) heappush(max_profit_heap, (-profits[index], index)) available_capital += -heappop(max_profit_heap)[0] return available_capitaldef main(): res = find_max_capital([0, 1, 2], [1, 2, 3], 2, 1) print(str(res)) res = find_max_capital([0, 1, 2, 3], [1, 2, 3, 5], 3, 0) print(str(res))if __name__ == &#x27;__main__&#x27;: main() SolutionWhile selecting projects we have two constraints: We can select a project only when we have the required capital. There is a maximum limit on how many projects we can select. Since we don’t have any constraint on time, we should choose a project, among the projects for which we have enough capital, which gives us a maximum profit. Following this greedy approach will give us the best solution. While selecting a project, we will do two things: Find all the projects that we can choose with the available capital. From the list of projects in the 1st step, choose the project that gives us a maximum profit. We can follow the Two Heaps approach similar to Find the Median of a Number Stream. Here are the steps of our algorithm: Add all project capitals to a min-heap, so that we can select a project with the smallest capital requirement. Go through the top projects of the min-heap and filter the projects that can be completed within our available capital. Insert the profits of all these projects into a max-heap, so that we can choose a project with the maximum profit. Finally, select the top project of the max-heap for investment. Repeat the 2nd and 3rd steps for the required number of projects. CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233from heapq import *import heapqdef find_max_capital(capital, profits, project_num, initial_capital): min_capital_heap = [] max_profit_heap = [] for i in range(len(profits)): # heapq默认创建小顶堆，而且按照第一个元素排列 heappush(min_capital_heap, (capital[i], i)) available_capital = initial_capital for _ in range(project_num): while min_capital_heap and min_capital_heap[0][0] &lt;= available_capital: capital, index = heappop(min_capital_heap) # push相反数来实现大顶堆 heappush(max_profit_heap, (-profits[index], index)) # 如果没有可以负担得起的项目，那就break，不然下面的会报错 if not max_profit_heap: break available_capital += -heappop(max_profit_heap)[0] return available_capitaldef main(): res = find_max_capital([0, 1, 2], [1, 2, 3], 2, 1) print(str(res)) res = find_max_capital([0, 1, 2, 3], [1, 2, 3, 5], 3, 0) print(str(res))if __name__ == &#x27;__main__&#x27;: main() Time complexitySince, at the most, all the projects will be pushed to both the heaps once, the time complexity of our algorithm is O(NlogN + KlogN), where ‘N’ is the total number of projects and ‘K’ is the number of projects we are selecting. Space complexityThe space complexity will be O(N) because we will be storing all the projects in the heaps. Problem Challenge 1leetcode 436 Next Interval (hard)Given an array of intervals, find the next interval of each interval. In a list of intervals, for an interval ‘i’ its next interval ‘j’ will have the smallest ‘start’ greater than or equal to the ‘end’ of ‘i’. Write a function to return an array containing indices of the next interval of each input interval. If there is no next interval of a given interval, return -1. It is given that none of the intervals have the same start point. Example 1: Input: Intervals [[2,3], [3,4], [5,6]]Output: [1, 2, -1]Explanation: The next interval of [2,3] is [3,4] having index ‘1’. Similarly, the next interval of [3,4] is [5,6] having index ‘2’. There is no next interval for [5,6] hence we have ‘-1’. Example 2: Input: Intervals [[3,4], [1,5], [4,6]]Output: [2, -1, -1]Explanation: The next interval of [3,4] is [4,6] which has index ‘2’. There is no next interval for [1,5] and [4,6]. Try it yourselfTry solving this question here: 1// 不会 SolutionA brute force solution could be to take one interval at a time and go through all the other intervals to find the next interval. This algorithm will take O(N^2) where ‘N’ is the total number of intervals. Can we do better than that? We can utilize the Two Heaps approach. We can push all intervals into two heaps: one heap to sort the intervals on maximum start time (let’s call it maxStartHeap) and the other on maximum end time (let’s call it maxEndHeap). We can then iterate through all intervals of the `maxEndHeap’ to find their next interval. Our algorithm will have the following steps: Take out the top (having highest end) interval from the maxEndHeap to find its next interval. Let’s call this interval topEnd. Find an interval in the maxStartHeap with the closest start greater than or equal to the start of topEnd. Since maxStartHeap is sorted by ‘start’ of intervals, it is easy to find the interval with the highest ‘start’. Let’s call this interval topStart. Add the index of topStart in the result array as the next interval of topEnd. If we can’t find the next interval, add ‘-1’ in the result array. Put the topStart back in the maxStartHeap, as it could be the next interval of other intervals. Repeat the steps 1-4 until we have no intervals left in maxEndHeap. CodeHere is what our algorithm will look like: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586from heapq import *import heapqclass Interval: def __init__(self, start, end): self.start = start self.end = enddef find_next_interval(intervals): n = len(intervals) max_start_heap = [] max_end_heap = [] result = [0 for _ in range(n)] for end_index in range(n): heappush(max_start_heap, (-intervals[end_index].start, end_index)) heappush(max_end_heap, (-intervals[end_index].end, end_index)) for _ in range(n): # let&#x27;s find the next interval of the interval which has the highest &quot;end&quot; top_end, end_index = heappop(max_end_heap) result[end_index] = -1 # default to be -1 if -max_start_heap[0][0] &gt;= -top_end: top_start, start_index = heappop(max_start_heap) # find the interval that has the closest start while max_start_heap and -max_start_heap[0][0] &gt;= -top_end: top_start, start_index = heappop(max_start_heap) result[end_index] = start_index # put the interval back as it could be the next interval of another intervals heappush(max_start_heap, (top_start, start_index)) return resultdef main(): res = find_next_interval([Interval(2, 3), Interval(3, 4), Interval(5, 6)]) print(str(res)) res = find_next_interval([Interval(3, 4), Interval(1, 5), Interval(4, 6)]) print(str(res))if __name__ == &#x27;__main__&#x27;: main() # 看了solution之后受启发，把两个heap都作为小顶堆，也过了leetcode436from heapq import *import heapqclass Interval: def __init__(self, start, end): self.start = start self.end = enddef find_next_interval(intervals): n = len(intervals) min_start_heap = [] min_end_heap = [] result = [0 for _ in range(n)] for end_index in range(n): heappush(min_start_heap, (intervals[end_index].start, end_index)) heappush(min_end_heap, (intervals[end_index].end, end_index)) for _ in range(n): top_end, end_index = heappop(min_end_heap) result[end_index] = -1 # default to be -1 while min_start_heap and min_start_heap[0][0] &lt; top_end: heappop(min_start_heap) if min_start_heap: top_start, start_index = heappop(min_start_heap) result[end_index] = start_index heappush(min_start_heap, (top_start, start_index)) return resultdef main(): res = find_next_interval([Interval(2, 3), Interval(3, 4), Interval(5, 6)]) print(str(res)) res = find_next_interval([Interval(3, 4), Interval(1, 5), Interval(4, 6)]) print(str(res))if __name__ == &#x27;__main__&#x27;: main() Time complexityThe time complexity of our algorithm will be O(NlogN), where ‘N’ is the total number of intervals. Space complexityThe space complexity will be O(N) because we will be storing all the intervals in the heaps.","categories":[],"tags":[]},{"title":"人工智能基础课堂笔记","slug":"人工智能基础课堂笔记","date":"2021-09-13T07:30:20.000Z","updated":"2021-09-13T07:30:20.553Z","comments":true,"path":"人工智能基础课堂笔记/index.html","link":"","permalink":"https://hasuer.github.io/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%9F%BA%E7%A1%80%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/index.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Git学习笔记","slug":"Git学习笔记","date":"2021-07-07T12:59:22.000Z","updated":"2022-02-23T12:42:59.056Z","comments":true,"path":"git学习笔记/index.html","link":"","permalink":"https://hasuer.github.io/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html","excerpt":"","text":"Git命令行操作本地库初始化进入文件夹 12git init注意：生成的 .git 目录中存放的是本地库相关文件，不要删除 设置签名这里设置的签名和GitHub中的用户，密码没有关系。 项目(仓库)级别仅在当前本地库有效 12git config user.name tom #设置用户名tomgit config user.email liu@qq.com #设置用户邮箱 系统用户级别仅在当前登录的操作系统用户有效 12git config --global user.name tomgit config --global user.email liu@qq.com 仅仅加了一个 --global 优先级别：项目级别 &gt; 系统级别 项目级别的作用范围更小，类似于局部变量 &gt; 全局变量。二者必须要有其一。 信息保存位置：~/.gitconfig 文件 查看方式：cat .git/config 查看当前用户（global）配置 git config --global --list查看当前仓库配置信息 git config --local --list 基本操作状态查看1git status #查看工作区、暂存区状态 添加1234git add fileName #指定文件git add . #所有说明：将工作区的文件添加到暂存区git rm --cached filename #将暂存区的文件撤销 提交12git commit -m &#x27;commit message&#x27; fileName说明：将暂存区内容提交到本地库 查看历史记录12345git log git reflog #常用，说明：HEAD@&#123;移动到当前版本需要多少步&#125;git log --greph #图形显示,更直观git log --pretty=oneline #漂亮一行显示git log --oneline #简洁显示 前进后退 基于索引值推荐 12git reset --hard 指针位置例子：git reset --hard a6ace91 #回到这个状态 使用 ^ 符号只能后退 1git reset --hard HEAD^例子：git reset --hard HEAD^^注意：几个 ^ 表示后退几步 使用 ~ 符号只能后退 1git reset --hard HEAD~n例子：git reset --hard HEAD~3 reset的三个参数比较123456soft: - 仅本地库移动HEAD 指针mixed： - 在本地库移动HEAD指针 - 重置暂存区hard： - 在本地库移动HEAD指针 - 重置暂存区 - 重置工作区 删除文件并找回 相当于建立一个快照，虽然删除了，但只要添加到暂存区，就能找回 如果文件删除之后已经commit了，那么在log里就有有一条记录，这时，使用git reset --hard 指针位置来还原。 如果删除文件之后只是add,没有commit，那么log中没有新的记录，使用git reset --hard HEAD来刷新工作区。 文件差异比较123git diff 文件名 #工作区文件和暂存区比较git diff 哈希值 文件名 #工作区文件和本地库历史记录比较git diff #不带文件名，则比较多个文件 分支管理什么是分支管理 在版本控制中，使用推进多个任务 分支的好处 同时并行推进多个功能开发，提高开发效率 某一分支开发失败，不会对其它分支有任何影响 分支操作 创建分支 1git branch 分支名 查看分支 12git branchgit branch -v 切换分支 12git checkout 分支名git checkout -b 分支名 #创建分支并直接切换到该分支 合并分支相当于把修改了的文件拉过来 第一步：切换到接收修改的分支名上 git checkout [分支名] 第二步：执行merge命令 git merge [分支名] 删除分支 1git branch -d 分支名 解决冲突 冲突的表现 冲突的解决 第一步：编辑，删除特殊标记&lt;&lt;&lt; === 第二步：修改到满意位置，保存退出 第三步：添加到缓存区 git add 文件名 第四步：提交到本地库git commit -m &#39;日志信息&#39; 注意：后面一定不能带文件名 Git 结合Github创建远程库地址别名1234git remote -v #查看远程地址别名git remote add 别名 远程地址 例子：git remote add origin https://xx 这里的 origin 是别名的意思 推送开发修改完把本地库的文件推送到远程仓库 前提是提交到了本地库才可以推送 123git push 别名 分支名git push -u 别名 分支名 #-u指定默认主机 例子：git push origin master 克隆完整的把远程库克隆到本地`克隆下来后不要在主分支里面做开发 `clone进行一次，从无到有的过程，更新用pull 12git clone 远程地址 例子：git clone https://xx 常见建立仓库方式 建立仓库 —&gt; 打开空文件夹（还没有项目） —&gt; 克隆下来 建立仓库 —&gt; 打开项目文件夹（已经有项目）—&gt; 初始化仓库 —&gt; 设置remote仓库链接 拉取pull = fetch + merge 把远程库中的内容拉取到本地库，但是在本地库没有 被更新，这个时候当前分支（本地库）是看不到变化的，只有进入origin/分支名才能看到变化。这个时候在本地的分支执行merge命令之后才能在本地的分支看到变化。 本地存在clone下来的文件 就用pull更新 1234pull = fetch + merge git fetch [远程地址别名] [分支名] git merge [远程地址别名] [分支名] git pull [远程地址别名] [分支名] 解决冲突注意：解决冲突后的提交是不能带文件名的 如果不是基于GitHub 远程库的最新版所做的修改，不能推送，必须先拉取。 拉取下来后如果进入冲突状态，则按照“分支冲突解决”操作解决即可。 rebase提交记录简洁不分叉 没学懂，感觉有点鸡肋 混眼熟 1git rebase -i 索引号git rebase -i HEAD~3 #合并最近三条记录说明：在vim编辑里面改成s beyond compare用软件解决冲突 11.安装 ： beyond compare 2.配置： git config --local merge.tool bc3 #合并名称 git config --local mergetool.path &#x27;/usr/local/bin/bcomp&#x27; #软件路径 git config --local mergetool.keepBackup false #False不用保存备份3.应用： git mergetool说明：--local指只在当前操作系统有效 跨团队合作代码review之后合并 适用于个人 邀请成员:Settings —&gt; Collaborators —&gt;填写用户名 —&gt;打开链接接受邀请 企业 创建一个组织 方便管理 review 组织做review 通过Pull request 给开源社区共享代码 点击别人仓库的fork 到自己的仓库 — &gt; 然后clone下来 修改后推送到远程库 —&gt; 点击Pull Request请求 —&gt; Create pull request发消息 Tag标签为了清晰的版本管理，公司一般不会直接使用commit提交 1git tag -a v1.0 -m &#x27;版本介绍&#x27; #创建本地tag信息git tag -d v1.0 #删除taggit push origin --tags #将本地tag信息推送到远程库git pull origin --tags #拉取到本地git checkout v.10 #切换taggit clone -b v0.1 地址 #指定tag下载代码 SSH 免密登录 进入当前的家目录 1$ cd ~ 删除.ssh目录 1$ rm -rvf .ssh 运行命令生成SSH密钥目录 123$ ssh-keygen -t rsa -C [Github邮箱]或者 $ ssh-keygen (会让你设置SSH的登录密码，可以不输入，一直Enter) 进入.ssh目录查看文件列表 12$ cd .ssh$ ls -la 查看id_rsa.pub的内容 1$ cat id_rsa.pub 在GitHub上建立SSH Key, 把刚刚生成的ssh密钥填进去。 保证本地库对应的远程库是SSH方式的。 如果没有： 1git add remote origin_ssh[(这是别名) [SSH地址] 然后就可以愉快的push啦~~ 123git push [别名] [分支名]# 这里要注意，如果你在本地库只建立了一个远程地址，# 那么不用使用[别名]和[分支名]。如果有多个才要使用。 Git工作流概念1在项目开发过程中使用Git的方式 分类集中式工作流像SVN一样，集中式工作流有一个中央仓库，所有的修改都提交到了Master分支上 GitFlow工作流 *主干分支master 开发分支develop 修复分支hotfix 预发布分支release 功能分支feature GitFlow 有独立的分支，让发布迭代过程更流畅。 Forking 工作流在 GitFlow 基础上， 充分利用了 Git 的 Fork 和 pull request 的功能以达到代码审核的目的。 安全可靠地管理大团队的开发者","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://hasuer.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"C++ Sort()","slug":"C++ Sort()函数","date":"2021-07-02T14:58:35.000Z","updated":"2021-07-02T15:08:32.881Z","comments":true,"path":"c-sort/index.html","link":"","permalink":"https://hasuer.github.io/c-sort/index.html","excerpt":"","text":"sort()基本使用方法 sort()函数可以对给定区间所有元素进行排序。它有三个参数sort(begin, end, cmp)，其中begin为指向待sort()的数组的第一个元素的指针，end为指向待sort()的数组的最后一个元素的下一个位置的指针，cmp参数为排序准则，cmp参数可以不写，如果不写的话，默认从小到大进行排序。如果我们想从大到小排序可以将cmp参数写为greater()就是对int数组进行排序，当然&lt;&gt;中我们也可以写double、long、float等等。如果我们需要按照其他的排序准则，那么就需要我们自己定义一个bool类型的函数来传入。比如我们对一个整型数组进行从大到小排序： 123456789101112#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int num[10] = &#123;6,5,9,1,2,8,7,3,4,0&#125;; sort(num,num+10,greater&lt;int&gt;()); for(int i=0;i&lt;10;i++)&#123; cout&lt;&lt;num[i]&lt;&lt;&quot; &quot;; &#125;//输出结果:9 8 7 6 5 4 3 2 1 0 return 0;&#125; 自定义排序基本类型的其他需求这里指的是，待排序类型的数据是基本类型，但是不希望是从小到大排序的，比如说我们按照每个数的个位进行从大到小排序，我们就可以根据自己的需求来写一个函数作为排序的准则传入到sort()中。 我们可以这样实现：123bool cmp(int x,int y)&#123; return x % 10 &gt; y % 10;&#125; 完整代码： 12345678910111213141516#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;bool cmp(int x,int y)&#123; return x % 10 &gt; y % 10;&#125;int main()&#123; int num[10] = &#123;65,59,96,13,21,80,72,33,44,99&#125;; sort(num,num+10,cmp); for(int i=0;i&lt;10;i++)&#123; cout&lt;&lt;num[i]&lt;&lt;&quot; &quot;; &#125;//输出结果：59 99 96 65 44 13 33 72 21 80 return 0;&#125; 对于结构体和类进行排序方法一写cmp函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Interval &#123; public: int start = 0; int end = 0; Interval(int start, int end) &#123; this-&gt;start = start; this-&gt;end = end; &#125;&#125;;bool cmp(Interval a, Interval b) &#123; return a.start &lt; b.start; &#125;//实现这个函数并且调用class MergeIntervals &#123; public: static vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) &#123; vector&lt;Interval&gt; mergedIntervals; // todo sort(intervals.begin(), intervals.end(), cmp); for(auto interval : intervals)&#123; mergedIntervals.push_back(interval); &#125; return mergedIntervals; &#125;&#125;;int main() &#123; vector&lt;Interval&gt; input = &#123;&#123;1, 3&#125;, &#123;2, 5&#125;, &#123;7, 9&#125;&#125;; cout &lt;&lt; &quot;Merged intervals: &quot;; for (auto interval : MergeIntervals::merge(input)) &#123; cout &lt;&lt; &quot;[&quot; &lt;&lt; interval.start &lt;&lt; &quot;, &quot; &lt;&lt; interval.end &lt;&lt; &quot;]&quot;; &#125; cout &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 方法二1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Interval &#123; public: int start = 0; int end = 0; Interval(int start, int end) &#123; this-&gt;start = start; this-&gt;end = end; &#125;&#125;;class MergeIntervals &#123; public: static vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) &#123; vector&lt;Interval&gt; mergedIntervals; // todo sort(intervals.begin(), intervals.end(), [](const Interval&amp; a, const Interval&amp; b)&#123;return a.start &lt; b.start;&#125;); //这里的第三个参数用了这个方法 for(auto interval : intervals)&#123; mergedIntervals.push_back(interval); &#125; return mergedIntervals; &#125;&#125;;int main() &#123; vector&lt;Interval&gt; input = &#123;&#123;1, 3&#125;, &#123;2, 5&#125;, &#123;7, 9&#125;&#125;; cout &lt;&lt; &quot;Merged intervals: &quot;; for (auto interval : MergeIntervals::merge(input)) &#123; cout &lt;&lt; &quot;[&quot; &lt;&lt; interval.start &lt;&lt; &quot;, &quot; &lt;&lt; interval.end &lt;&lt; &quot;]&quot;; &#125; cout &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://hasuer.github.io/categories/Algorithm/"}],"tags":[]},{"title":"人类简史读后感","slug":"人类简史读后感","date":"2021-05-19T02:35:51.000Z","updated":"2022-02-23T06:58:16.009Z","comments":true,"path":"人类简史读后感/index.html","link":"","permalink":"https://hasuer.github.io/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E8%AF%BB%E5%90%8E%E6%84%9F/index.html","excerpt":"","text":"人类简史读后感 ——猩球崛起：进化 书中从四个方面按照时间顺序来阐述了人类从诞生到最后成为主宰世界的主人这一过程，那么到底是什么使得原来是猿人的我们最终成为超过了曾经和我们一样的动物，掌控了世界？ 我们在一开始的时候，总是会从个体上去分析自己和大猩猩有什么区别。人们总是专注在自己和大猩猩有什么区别，但是如果想象一下，把一个普通人和一只大猩猩放在一座孤岛上，人没有办法活的像大猩猩一样的好，这看起来是一件十分正常的事情，个体生存能力如此薄弱，还能成为世界的主宰？估计这也是我们的祖先想不到的。 人类和其他动物的最大的不同就是人们的集体能力。不可否认，动物中也有集体能力极强的生物，一个蜂群的合作能力极强，但是不够灵活，如果一个蜂群遇到了突然的变故，没有什么办法能够让蜜蜂之间迅速得到一个高效的解决办法。他们不可能去杀死蜂后来建立一个共和国，也不能建立一个以工蜂为主体的社会。与此相对，大猩猩之间的合作已经十分接近人们了，但是很不幸，他们之间的合作只能够建立在小范围之间。因为大猩猩之间的合作必须是建立在大家都相互了解的基础上的，这也就决定了他们和合作网络不会很大。社会学研究指出，借由八卦来为维持的最大”自然”团体大约是150人。即使到了今天，人类的团体还是继续受这个神奇的数字的影响，大猩猩也是如此。 人类是世界上唯一一个能够同时具备在大范围内灵活合作的种群了。这也就是我们为什么能够成为世界的主宰的重要原因之一。我们能够迅速的改变行为，并将新的行为传给下一代。比如不生育的精英阶层就是一个很好的例子。你一定难以想象一万只黑猩猩聚集在天安门广场的景象，而这个地方却能容纳远多于一万多人。这正是由于人类之间能够遵守规则，灵活合作。 人类和其他动物的合作的不同还在于，人类之间的合作是有好有坏的，比较典型的例子像“战争”，“集中营”等，这些的本质也是合作，然而这些合作创伤了人类的内心世界。当然，诸如像家庭，学校这样的合作关系能够让人的心智走向成熟。人类是如何能够进行如此大规模的合作呢？是因为人们相信一个共同的准则，这个准则是一种虚构的机制体系。由于大规模的人类合作是以虚构的故事作为基础， 只要改变所讲的故事，就能改变人类的合作方式。所以人类的合作方式是十分灵活的。 人类的生活在自己虚构的故事当中，而且当所有人都相信这个故事的时候，那么就会有神奇的事情发生，人们就能够产生稳定的合作网络，而且不需要像大猩猩一样要将合作建立在相互认识的基础上。这些故事遍布在我们的身边，从宗教、经济到政治都有他们的声音。 在宗教中，西方人大多都相信，这个世界上存在上帝，上帝总是在看着自己的所作所为。然而上帝是一个由牧师之类的人员虚构出来并且广为传播的一个故事，当大家都想相信了这个故事，也就有了宗教，不同的故事带来了不同的宗教和信仰，使得信仰同一个宗教的人们能够很好的合作，即使他们之前没有见过；在政治上，这样的概念也数不胜数，“国家”，“民族“，”人权“等等。这些东西同样是看不见摸不着的，是人们所创造出来更好的管理这个世界的。这也体现出人类和其他动物的很大的不同，你一定没有听说过哪一个除了人类的生物想要通过和种群之间的联系来建立起一个帝国，进而掌控这个时间。人类十分善于编造故事，为了使得”国家“这个虚构的故事更加可信，人们又构建出了身份证号，家庭，企业这些虚构概念，复杂了人们之间的合作网络，也就是使得关系更加具有粘性；在经济上，人们最伟大的发明就是货币了，货币作为一种信用体系，货币本身没有任何的使用价值，因为无法直接满足人们的基本需求，它不能吃，也没有观赏价值。这个时候，经济学家来告诉你这张有数字的纸和10个香蕉的价值等效，更加有意思的是，所有的人都相信这个故事，无一例外。于是我们可以拿着这个有数字的纸，走到超市，把钱给一个素不相识的店员就能够得到真正能来果腹的食物。人类的交易方式是最灵活可靠的，其他动物当然也有自己的交易方式，但是他们的交易的东西一定是有直接价值的，用香蕉换取桃子之类，而智人是唯一能够使用货币的动物，这也是人们相信虚拟故事的结果。使得我们能够站上世界权力的顶峰。 此外还有很多已经被我们习以为常的认为是非虚构的。我们没有经历过历史上那些风云人物经历过的事情，我们只是从书本上，人们口口相传得到的这样的讯息，从某种程度上来讲，我们知道的历史也是一种虚构的故事。但是人类对待事件的态度也是严谨的，所以才会有历史学家不断的考证历史。 人类经历的认知革命，农业革命，开始统一世界，最后发展出了科学革命。在这个过程中，人类发明出了很多能看见的，看不见的。 从认知革命以来，智人就一直生活在一种双重的现实之中。一方面，我们有像是河流，树木这种确实存在的客观现实；另一方面，我们也有像是神国家和企业这种想象中的现实。其他动物只是生活在客观世界中，他们的客观世界包含的是客观实体。人类能够主宰世界就是因为我们生活在这样的双重世界中，不仅有客观实体，还建立了由虚拟实体来构建的现实。并且随着历史的发展，我们所创造出的虚拟实体越来越强大，人们也无法摈弃，即使这些实体只是存在于自己的想象中。","categories":[{"name":"阅读笔记","slug":"阅读笔记","permalink":"https://hasuer.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"少有人走的路-M.Scott Peck","slug":"少有人走的路","date":"2021-05-17T13:12:04.000Z","updated":"2022-02-23T06:57:56.070Z","comments":true,"path":"少有人走的路-m-scott-peck/index.html","link":"","permalink":"https://hasuer.github.io/%E5%B0%91%E6%9C%89%E4%BA%BA%E8%B5%B0%E7%9A%84%E8%B7%AF-m-scott-peck/index.html","excerpt":"","text":"文章在一开篇就提出了：几乎人人都有心理问题，只不过是程度不同而已；几乎人人都有不同程度的心理疾病，只不过得病的时间不同。只有直面自己的问题，心智才能变得成熟；如果逃避问题，心智就会停滞不前。 心智成熟的旅程不但是一项既复杂又艰巨的任务，而且是毕生的任务，其过程十分的漫长。 自律自律是解决人生问题最主要的工具，也是消除人生痛苦最重要的方法。 作者在一开篇就告诉我们 人生苦难重重。只要我们能够真正理解并且接受这个事实，就可以从苦难中解脱出来。然而，大多数人都不愿意正视苦难，抱怨外界。当这些人面对困难的时候，大家的表现常常是：回避痛苦；拖延，希望痛苦自己消失；视而不见，假装不存在；用药物和毒品来麻醉自己。 解决困难最重要的方法就是自律，自律的程度决定了你解决问题的多少。自律有四大原则：推迟满足感、承担责任、忠于事实、保持平衡。而自律的原动力就是爱。 推迟满足感不贪图暂时的安逸，先苦后甜。在充满问题和痛苦的人生中，推迟满足感是唯一可行的方法。比如先完成棘手的工作，或者是先把玩具让给其他的小伙伴，对待家庭作业的次序等等，将此培养成为习惯，内化于心，外化于行。 当父母自律的时候才能够让自己的孩子也变得自律。”照我的话去做，但是不要学我”。之前提到自律的源动力是爱，爱是需要时间的付出的。所以要培养孩子学会自律，就需要投入足够的时间。聪明的父母在问题发生之前，他们就会花时间了解孩子，对症下药。 当孩子面临痛苦的抉择的时候，如果父母真心实意的和孩子一起承受痛苦和折磨，孩子一定能感受到。也许不会表现出来，但是可以提醒自己：“既然爸爸妈妈愿意陪着我忍受痛苦，痛苦也不见得那么可怕，而且也未必是太坏的事情。我也应该承担责任，面对属于自己的痛苦”——自律的起点。 对于自我价值的认可是自律的基础，因为当一个人觉得自己很有价值的时候，就会采取一切必要的措施来照顾自己。 让孩子养成推迟满足感的习惯，就必须要让与他们学会自律。要让他们学会自律的，对于安全感产生信任，不仅需要父母真心投入，还需要父母表里如一的爱和持之以恒的照顾。 忽视问题的存在，反映出人们不愿意推迟满足感的心理。现在承受痛苦，将来就有可能获得更大的满足感；而现在不谋求解决问题，将来的痛苦就会更大，持续的时间也越长。 在孩子成长的过程中，恰当的给予指导和帮助，多了解他们的问题，必然是有益的事情。问题托的越久，越是积重难返，解决起来自然就更加艰难了。 承担责任如果不能及时解决自己的问题，问题就会像山一样横亘在在我们的心中，自己的问题只有自己才能解决。 神经官能症：为自己强加责任 人格失调症：不愿意承受原本就属于自己的责任 你不能解决问题，你就会成为问题 作者在年轻的时候把自己的日程表安排的很满，然后觉得很累。在像自己的上司请教了之后，上司只是告诉他：这是你时间管理的问题，不是我的问题。这让年轻的作者十分生气。过了几个月之后，作者发现了：同事们选择了和我不同的工作方式，我就心怀不满，因为我完全可以像他们一样去安排时间。憎恨他们的自由自在，其实是在憎恨我自己的选择，可是这本是我引以为豪的一个选择。当他想通了之后，对于那些比他早下班的同时也就不在嫉妒。虽然他还是像以前一样工作，但是心态发生了本质的变化。对个人行为承担责任，难处在于它会带来痛苦，而我们却想要躲开这种痛苦。作者请求上司替我安排时间，其实是在逃避长时间工作的痛苦，而这正是我选择努力工作的必然结果。我向主任求助，是希望增加她对我的权利，我是在请求她，请为我负责吧，既然你是我的上司，力图把责任推给别人或是组织，就意味着我们甘愿处于附属的地位。把权力和自由拱手交给命运，社会政府，独裁者和上司。为了躲开责任带来的痛苦，数不清的人甘愿放弃权力，实则是在逃避自由。[为什么就是逃避自由T_T]? 忠于事实 个人认为这一个部分写的很棒，用地图做比喻简直绝了。而且所有的的话语一针见血，直至核心。 我们越是了解事实，处理问题就越是得心应手，对于事实了解的越少,思维就越是混乱。 我们对于现实的观念就是一个地图。地图会被不断的修订。只有地图准确我们才能了解人生的地形，沟壑，指引自己的前进的道路。我们不是在一出生的时候就带着地图，我们需要努力绘制自己的地图。而大多数人一旦过完青春期就放弃了对于自己的地图的绘制。这样的地图狭小、粗略而且肤浅，从而导致对于现实的认知过于狭隘和偏激。大多数人过了中年，就认为自己的地图完美无缺，世界观没有任何的瑕疵，甚至自认为神圣不可侵犯，而对于新的信息和资讯缺乏兴趣。只有极少数的幸运者能够继续努力，他们不停地探索，扩大和更新自己对于世界的认知，直到生命终结。 人生苦短，我们只想一帆风顺，我们由儿童成长为青年人，中年人乃至老年人，付出了不懈的努力，才会成了现在这幅关于人生观和世界观的地图，似乎各个方面都完美无缺。一旦新的信息与过去的观念发生冲突，需要对地图大幅修正，我们就会感到恐惧，宁可对于新的信息视而不见。我们的态度也变得十分奇特，不仅抗拒新的信息，甚至指责新的信息，混淆是非，说他们是异端邪说。我们想控制周围的一切，使之完全符合我们的地图。我们花费大量时间和精力去捍卫陈腐的观念。其消耗的时间与精力远比修订地图本身多的多，这是一件多么可悲的事情啊。 这里提出了移情的概念：把产生和适用于童年时期的那些感知世界、对于世界做出反应的方式，照搬到成年之后的环境中，尽管这些方式已经不在适用于新的环境。 我们必须忠于事实，尽管这会带来暂时的痛苦，但是远比沉湎于虚假的舒适中要好，要让心灵或者获得成长，心智走线成熟，就要竭尽全力。不惜一切代价。完全忠于事实。 如何做到？完全忠于事实的生活意味着我们要不间断的严格地反省自己。自我反省带来的快乐，甚至远远大于痛苦。 完全忠于事实的生活还意味着我们要敢于接受外界的挑战和质疑。当发现外界开始质疑我们的地图的时候，意味着我们的地图可能已经需要重绘制了，而接受挑战和质疑是重绘地图的最好的方法。 完全忠于事实还意味着我们要一辈子保持诚实。区别两种谎言： 白色谎言：本身或许能反应事实，但是有意隐瞒大部分真相。 黑色谎言：彻头彻尾的说谎，所说的和事实完全不符。 在日常交往中，我们有时候要开诚布公，有的时候要抑制表达想法和感觉的欲望。 如何不违背忠于事实的自律精神 永远不要说假话，避免黑色谎言。 要牢牢记住，除非是迫不得已，或者出于重大道德因素的考虑，否则不说出全部真相就等于说谎！ 不可因为个人自私自利的欲望，例如满足权力欲，刻意讨上司的欢心，逃避修订心灵地图的挑战等等，而将部分真相隐瞒下来。 只有在对对方确有好处的情况下，才能有选择的隐瞒部分真相。 尽可能忠实的评估对方的需要，这是一件极为复杂的工作，只有以真爱为出发点，才能做出恰当的评判和选择。 评估的要点在于，对方能否借助我们提供的事实获得心灵的成长。 需要铭记在心的是，我们通常会低估，而不是高估别人运用事实使心灵获得成长的能力。 保持平衡我们既要以追求诚实为己任，又要隐瞒部分事实和真相。 我们既要承担责任，也要拒绝不该承担的责任。 我们既要学会推迟满足感，先苦后甜，也要把眼光放得长远，同时尽可能过好当前生活。 所以保持平衡十分重要。 保持平衡的最高原则就是放弃。失去平衡远比放弃更加痛苦。放弃是一种必须要掌握的技能，我们将他称为 兼容并包。得到的永远比放弃的多，自律的过程就是自我发展，自我完善的过程。放弃的痛苦是死亡的痛苦，但是旧事物的死亡带来的是新事物的重生。 爱什么是爱是什么能够让我们自己愿意通过自我约束来承受人生的痛苦呢？是爱。爱是自律的原动力。 作者将爱定义为:爱是一种为了促进自己和他人心智成熟，而不断拓展自我的界限，实现自我完善的一种意愿。 爱与非爱最重要的区别就在于当事人意识和潜意识是否一致。 爱是长期的，渐进的，双向的。我们付出的爱，不仅能让他人心智成熟，也会让自己获益。 真正意义上的爱，是爱自己也是爱别人。随着时间的推进，两者不但越来越近，其界限最后甚至会模糊不清，乃至完全泯灭。 爱要付出努力。努力不断拓展自我和他人界限的过程。 爱是要有实际行动的。爱一个人却没有付诸行动，就等于没有爱过。 人们对于爱的荒谬的认识把男女之爱当作坠入情网当作是爱，或者是一种爱的表现，这是不正确的。因为人们之所以坠入情网，是因为他们在潜意识里有一种性的冲动。其次，坠入情网的爱不会持久。 想要避免呆在一起之后，两个人出现矛盾和冲突的状态，两个人就要面对现实，学会真正的相知和相爱。 而坠入情网不算真正的爱原因如下： 坠入情网不是出于主观上的意愿，不是有计划，有意识的选择。 坠入情网不是自我界限的扩展，而是自我界限部分的暂时的奔溃——认为自己和他人融为一体。当最初的激情褪去的时候，自我界限也就恢复了。留下的只有失落和幻想，所以心灵不会成长。而真正的爱，才能让自己的界限得到扩展，让心灵得到成长和完善，而且不在恢复原状。 坠入情网唯一的作用是消除寂寞，而不是有目的地促进心灵的成长。坠入情网会让自己觉得自己生活在了幸福的巅峰，以为人生无与伦比，开始对于对方的缺点视而不见（或者说觉得算不上什么），会觉得心智的成熟不那么重要，重要的是满足当前的满足感。而事实是：我们和爱人的心智都还不成熟。 坠入情网的本质是什么？作者认为和人的性欲有关，是人类内在性需求和外在刺激发生作用产生的典型的生理和心理反应。坠入情网是人类原始基因对于人类理性的征服。 人们坠入情网往往会给我们给我们创造“爱情是永恒的”这一个幻觉，大多来源于那些浪漫的神话故事。 坠入情网不是爱。作者在阐述这一观点到时候，给出了自我界限这一概念。作者认为真正的爱是一种拓展自我的体验，被自我界限之外的对象吸引，促使我们产生冲动，想把一切都献给对方（这种状态心理学家称之为“精神贯注”）。对于自我界限，我的理解是，自我界限是自己生活体验的总和，包含了自己的所见所闻，所思所感。而当我们遇到那些能够给我们带来没有经历过的体会的人的时候，或者这个人能够给我们带来自己一直想要拥有的体验的时候，我们就会开始坠入情网，我们尝到了自我界限消失的快乐，在这种坠入情网的激情退散之后，我们仍然会陶醉于这种感受，这会成为我们追寻真爱的诱因。坠入情网本身不是爱，但是却是爱的神秘架构中的最重要的一环。 把依赖当成爱这种情感会出现在哪些人身上？ 情感失意而又十分沮丧的患者身上 幼年时期没有得到持续的爱（亲密关系一书中提到，没有得到持续性的爱，就会称为痴迷型人格） 把对于他人的依赖当成的爱和真正的爱有几个区别： 依赖产生的爱不在乎依赖的对象是谁，只需要有一个人能够填补自己的内心的空缺就可以了。而真正的爱是从一而终的，也是一种自由的选择，真正相爱的人不一定要生活在一起，只是选择生活在了一起。 对于他人依赖产生的爱，只是从他人那里汲取爱，自己却无法给予对方爱，是一种单向的自我满足。而真正的爱是双方都有值得被对方爱的地方，这种爱是相互的，存在的意义是扩展双方的自我界限，而不是只是对于自己的空虚的心灵的填补。 过分依赖的人只关注自己的需要和滋养，只在乎自己的感受，他们不关心自己的心智的成熟，也不关心别人的心智的成熟，哪怕是他们依赖的对象。 精神关注在之前提到“精神关注”是一种被自我界限之外的对象吸引，促使我们产生冲动，想把一切都献给对方的体验。但是不是所有 精神关注都是爱，那些不能促进心智成长的，不能给心灵带来任何滋养的”精神关注“，都不是真正意义上的爱。 比如有的人爱金钱，有的人爱名利，他们愿意为了这些东西，把自己的一切都献给对方，产生了精神贯注的体验，但是金钱的积累，权力的巩固，不能意味着自己能够获得真正的拓展和完善（但是怎么知道自己是不是获得了真正的拓展和完善了呢？。所以此爱非彼爱。爱的唯一目标是促进心智的成熟和人性的进步。但是倘若人们爱金钱，爱名利的终极目标不是这些爱不见摸不着的东西，而是人。比如有的人投身政治，用自己的影响力来为人们谋求幸福。有的人努力赚钱，只是为了供子女上大学，或者用金钱来换取时间和自由，这样才有条件去学习。对于这些人来说，通过权力和金钱，未必不能实现爱的目标。 本章中对于爱的定义是基于人的。大多数爱宠物，给他们最好的照顾，食物。一旦他们生病了，就可能放下一切的事情，带他们去看医生。但是人和人的关系与人和宠物之间的关系是不同的。首先，我们和宠物的沟通是有限的。我们总是把自己的想法和感受投射到他们的身上。其次，我们喜欢宠物的原因是，它们表现乖巧，任人摆布。但是对于人而言不是这样，我们容许人有自己的想法，而且爱一个人，就会容许这个人有自己的想法。最后，我们爱宠物是希望他们不要长大，希望宠物对自己有依赖性。 真正的爱，不是单纯的给予，还包括适当的拒绝，及时的赞美，得体的批评，适当的争论，必要的鼓励，温柔的安慰和有效的敦促。 自我牺牲一个牧师由于在自己小的时候受到了父亲的虐待和不关心，所以他希望自己要做一个和父亲完全不一样的人。对于自己的妻儿有求必应，尽管自己不喜欢这样，自己美其名曰是对于妻儿的爱，但是事实上他只是为了维护自己是一个好丈夫，好父亲的形象，树立这一目的的动机是出于自己对于父亲的恨，而不是爱。 过分的爱还不如不爱，该拒绝的时候却一味的给予，不是仁慈，而是伤害。越俎代庖地去照顾本来有能力照顾自己地人，只会使对方产生更大的依赖，这就是对爱的滥用。 很多时候，我们自称为了别人着想，可能只是为了逃避某种责任，满足自己的愿望：我们所作的一切都是出于个人的意愿，核心动机是满足自我的需求；不管为了别人做了什么，真正的原因都是为了自己。真正的爱能够使人发生改变，在本质上是一种自我拓展，而不是自我牺牲。 爱不是感觉。 真正的爱不是忘乎所以，而是深思熟虑，是奉献全部身心的重大决定。它出自于自我意愿，只能依靠行动来证明。 到这里为止，作者提出了几个会被误以为是爱的东西，比如依赖，精神贯注，自我牺牲，爱的感觉等等。所以，接下来，进一步讨论一下爱究竟是什么？我们知道，自我拓展和实现自我完善是爱的目的。爱，最重要的体现形式，就是关注，而体现关注最常见，最重要的方式是努力倾听。 对于不同的人，要采用不同的倾听方式。一个6岁大孩子，很多时候只是自言自语，没有明确的意图，所以不一定需要倾听；有时6岁大的孩子渴望和父母亲近，与父母之间的亲密感大于了语言交流，这时可以假装倾听，而找到其中的平衡点很难。 在真正的倾听中，倾听者需要把暂时把自己的想法和欲望放在一边，努力去体会说话人的内心世界和感受。倾听是表达关注的最重要的形式，而其他形式的关注也同样重要，比如和孩子一起玩游戏，看电影，外出野餐，开车兜风，出门旅行，看球赛等等。这些关注都一个重要的特征：必须在孩子身上花足够多的时间。 对他人付出自己的关注和注意力，认真体会对方的问题和感受，这一切可能会枯燥乏味，让你感到不自在，甚至要花很大的精力，但是有一点是值得肯定的——着意味着真正的爱。 爱也有风险爱意味着自我界限的拓展，也就是让自我拓展到未知的，全新的领域，再塑造一个不同的，崭新的自己，这一过程就是自我完善的过程。再拓展到未知的领域的过程中，我们会遇到很多陌生的人、事务和活动，都会让我们产生恐惧，这个时候我们最需要的就是勇气。在拓展自我的过程中，除了痛苦和悲伤，也会收获幸福和快乐。完整的人生一定伴随着痛苦，而其中最大的痛苦之一就是心爱之人或心爱之物的逝去。如果想要避免其中的痛苦，恐怕只有完全脱离现实，去过完全没有任何意义的生活。 投入的爱越多，经受的风险也就越大，成长、独立就是其中之一。成长，意味着心智的成熟，而这也是爱的表现结果之一。心智的成熟需要突破自我的界限，还需要学会自尊自爱。尊重自我的个性和愿望，敢于冒险进入未知的领域，才能活得自由自在，使得心智不断的成熟，体验到爱的至高境界。 如果童年时没有从父母那里得到爱，就会产生极大的不安全感，到了成年，就会出现一种特殊的心理疾病——他们总是先发制人的“抛弃对方”。 家长对于孩子的投入，其风险不仅在于投入的状态本身，也在于可能经历意想不到的挑战，甚至要对于以往的认识做大幅的修正。聆听子女的新生，满足他们的需要，而不是盲目坚守权威，颐指气使，才能有助于家长拓展自我，走向成熟，这对于双方都是有很大益处的。 爱的最大风险就是发生冲突时的职责和假谦虚。我们常常以爱的名义去指责所爱的人。富有爱心的人，经常出于两难境地——既要尊重对方的独立性，渴望给予对方爱的指导。勤于自省才能走出这样的境地，自我反省的基本前提之一就是诚实和谦逊的态度。 经过反省，认为自己可能时正确的，在对他人提出批评，这个时候更加可能成功，不会有灾难性的后果。父母爱孩子，就必须指出孩子的错误，而且要采取谨慎而又积极的态度，他们也要允许子女指出自己的错误。 爱和自律自律的原动力来自于爱，而爱的本质是一种意愿。自律是将爱转换为实际行动的具体方法。所有的爱，都离不开自律，必然懂得自我约束。 爱和自律结合起来，才能体验到快乐的极致。真正的爱，会同时促进双方的心智成熟，体验到的快乐和幸福感也会更加从持久。 爱与独立爱者和被爱者都不是双方的附属品，每一个人都是一个独立的个体。在家庭中，家长也要将孩子看一个独立的个体，不能因为顾及自己的名利去要求孩子干一些事情。 不能接收所爱之人的独立性，就会给亲情和爱情带来危害。夫妻双方，只有更加独立，保持各自的情操和特性，而不是合二为一，才能够使婚姻生活更加美满。 成长与信仰信仰与世界观通常，人们对于信仰的定义十分的狭隘。我们认为，拥有某种信仰，就意味着要相信神灵，加入某个信徒组织，举行某个宗教仪式。 在孩子的心目中，父母就像是神和上帝，父母的处理事情的方式，就是宇宙间的之高法则。孩子们对于神性的了解，往往来自于父母的人性——父母充满爱心，悲天悯人，孩子就会相信这个世界充满爱心。这样，即使到了成年，在他们的心中，世界任然和同年一样，充满爱和温暖。 科学与信仰只有学习和进步，才能摆脱昔日的经验的限制。本书之之前提到过，爱的本质是拓展自我，而爱的风险之一就是就似乎必须进入未知的领域。所以我们要对于过去的信仰提出疑问，主动探索陌生的领域，挑战某些被视为真理的结论。我们要逐步以科学为信仰来代替父母发信仰。 有关科学的关键词有“真实”，“观察”，“知识”，“怀疑”，“经验”等。科学是以怀疑为基础的信仰，我们必须怀疑自以为了解的一切。 对于别人交给我们的一切，包括通常的文焕观念以及一切陈规旧习，采取冷静和怀疑的态度，才是心智成熟不可或缺的元素。 恩典恩典其实是一种普遍存在的现象，并且再一定程度上是可以预测的。 潜意识的奇迹要让心智成熟，我们要聆听潜意识的声音，让意识中对自己的认识更加接近真实的自己。 心灵的成长，心智的成熟需要不断努力，而且必然是艰苦的过程，他必须与自然法则对抗。但是遗憾的是，我们却习惯于保持原状，热衷于使用陈旧的地图与陈旧的方法；我们习惯于走平坦的道路，害怕路上荆棘遍布。 人们为了解释恩典与进化的奇迹，假设了上帝不仅存在，而且是爱我们的，希望我们成长的。这看上去很天真和简单，但是我们没有别的解释，我们不能因为无法解释就忽略显而易见的事实，绝不是正确的态度。 熵与原罪知道目前为止我们在讨论心智的成熟，那么究竟是什么阻碍了心智的成熟呢？其中最大的障碍就是懒惰，我们只要克服了懒惰，其他阻力就能迎刃而解。我们总是想要必要的痛苦，习惯于选择平坦的道路，这是惰性使然，懒惰是爱的对立面，很多人的爱是虚假的爱，因为他们不愿意承受自我拓展和自我完善的痛苦。 所有人都是懒惰的，只是程度和表现的方向不一样。懒惰是我们内心熵的力量，在心灵进化的过程中，他始终与我们对抗着，阻止我们的心智走向成熟。懒惰的一个重要特征就是就x是恐惧感，并非所有的恐惧都等于懒惰，但是绝大部分恐惧都与懒惰有关。人们接收的新的信息是有威胁的（让我们感到恐惧），如果我们新收到的信息属实，我们就要花费大量的幸苦工作来修改自己的地图。我们对本能的抗拒，因为我们懒得去做大量的辛苦工作。 邪恶的问题邪恶是运用一切影响力组织他人心智成长和自我完善的行为。邪恶的人极力摧毁光明，善良和爱，以此来逃避面对觉醒的良知的痛苦。至少在目前，人类进化到这个阶段，邪恶是不可避免的。熵是一种强大的力量，是人性的恶的体现，然而在人类进化的巨大历史框架中，邪恶永远处于弱势地位。 邪恶之手曾把耶稣送上十字架，结果却使得人们从很远的地方就能看到耶稣的身影，从此团结一心，纷纷加入 对抗邪恶的战斗，邪恶本身也成为了推动人类心智成熟的一种有效的方式。 意识的进化我们的潜意识里蕴含着丰富的知识，潜意识知道的事情永远比意识多得多。我们获得的新的真理和启示，其实是意识和潜意识达成一致，获得了共同的认知。意识的成长和进步，意味着它开始认同潜意识里所熟识的一切。不妨把潜意识假想成是埋藏在地下的广袤根系，意识则是地面上矮小的枝干，吸收潜意识提供的养分。 力量的本质力量分为心灵力量和政治力量。政治的力量是以公开或者隐秘的方式，去强迫别人遵守自己的意愿。而心灵的力量是在意识基础上做出决定的力量，也就是意识的力量。 心灵汲取到足够强大的力量，固然令人感到愉快，同时也可能使人恐惧。一个人知道的越多，就越难采取行动。心灵力量的不断积累还会带来另一个问题就是孤独感。心智成熟度度接近顶峰的人，就像是一呼百应，权倾天下的王者。他们不可能推卸责任和过错，也没有人告诉他们应该怎么办。他们没有和自己处境和感受相当的人，以便容许自己释放压力，发泄痛苦。","categories":[{"name":"阅读笔记","slug":"阅读笔记","permalink":"https://hasuer.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"心理学","slug":"心理学","permalink":"https://hasuer.github.io/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"},{"name":"成长","slug":"成长","permalink":"https://hasuer.github.io/tags/%E6%88%90%E9%95%BF/"},{"name":"心智","slug":"心智","permalink":"https://hasuer.github.io/tags/%E5%BF%83%E6%99%BA/"}]},{"title":"亲密关系","slug":"亲密关系","date":"2021-05-15T15:20:39.000Z","updated":"2023-08-01T13:05:00.235Z","comments":true,"path":"亲密关系/index.html","link":"","permalink":"https://hasuer.github.io/%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB/index.html","excerpt":"","text":"1. 人际关系的构成1.1 亲密关系的性质和重要性 亲密关系和泛泛之交至少在一下六点不同： 了解，如果人们认为自己的伴侣了解、理解并欣赏自己，其亲密程度就会增加 关心，这意味着他们认同双方在生活上的融合，自称为“我们”，而不是“我”和“他/她” 相互依赖性， 相互一致性， 信任， 承诺。 在亲密关系中，包含有人的归属需要，如果这种需要得不到满足，就会发生各种各样的问题。 1.2 文化的影响 随着时代的发展未婚先孕的比例，结婚的年龄和离婚的比例都在增加。 目前婚前同居的人们的想法是希望能够考察彼此是否真正能和睦相处。但是数据表明，如果两个人没有切实的结婚计划，未婚同居不能确保随后的婚姻幸福美满；相反，同居增加了夫妻离婚的危险。即使伴侣之间已经订婚，未婚同居还是会有一定的危害性。所以尽管同居很流行，但是越来越来的人去结婚。 影响亲密关系的根源 西方文化中的 个人主义。当他们对婚姻不满意的时候，就会理直气壮的结束婚姻生活。 高科技（人工授精，体外受孕）等。 性别比率：每100位女性对应多少男性。高性别比率的社会，偏向于男主外，女主内，更加保守。在性生活上也如此。而在低性别比率的社会则更倾向于颠覆传统，更加宽容。 有关系专家认为这种文化波动不是偶然。他认为社会规范的演变是用来满足强势的人群（男性）。所以当性别比例发生变化的时候，总会朝着有利于男性的方向发展。 当性比例高的时候，女性少。男性得到女性芳心之后就愿意长相厮守 鼓励女子成为家庭主妇，在经济上依赖丈夫 反对离婚（20世纪60年年代） 当性比例低的时候，妇女多，男人不太像被一个女人拴住。 妇女工作，推迟结婚 1.3 个体经历的影响人机关系还受到个体经历和经验的影响，最好的例子就是对于人际关系总体取向有重大影响的 依恋类型 儿童的三种依恋类型： 当婴儿哭喊的时候，慈爱的照料者如约而至，得到此种呵护的宝贝就能舒心的依赖他人，觉得他人可以信任，从别人那里获得安全和友善。发展成安全型：快乐的与他人交往，很容易发展出轻松信任的人际关系。 如果大人对于孩子的照顾无法预测也不持续。孩子就会对他人产生焦虑复杂的情绪。发展成为 焦虑矛盾型由于不确定照顾者何时会来，与他人的关系就会表现出紧张和依赖，表现出对于他人的渴求。 如果大人在照顾孩子的时候有拒绝或者敌对的态度，孩子就会发展出回避型依恋。 成人有四种依恋类型 我们不会被动的受到童年经验的束缚，既然依恋关系是可以习得的，也就可以改变。但是一旦确立的以后，既稳定又持久。 1.4 个体差异的影响个体的差异对于人际关系也有影响，这里将探讨四种个体差异： 性别差异 通过研究得出来一下三点结论：两性差异存在但是非常小；同性之间的差异远大于两性之间的平均差异；由于两性性别的行为和观点在正态分布上有很大的差异，以至于即使是平均得分低的性别中也有不少人的得分高于另一性别的平均得分。所以在不同性别中的相似性其实大于差异性，性别差异在个体差异中的权重其实没有那么大。 性认同差异 性认同差异是由教育和文化引起的两性在社会性和生理上的差异，是后天形成的，而性别差异是源于自身的自然天性。性别角色是诠释性认同差异的一个不错的例子，指的是社会文化期待男性应该更加具有工具性（自信，独立，有抱负，领导力，果敢），而期待女性更加有表达性（热情，温柔，有同情心，仁慈，敏感）。但是一切都表明，幸福，适应力强、有效率和心理健康的人士通常同时拥有二者。人们也更加偏向于拥有双性化特质的伴侣。 人格差异 人格影响人际关系的程度远大于人际关系印象人格的程度。注意上图中排序是按照重要程度由低到高排序的。 自尊差异 我们对于自己的认识来自于与他人的人际关系，并影响着人际关系的后续发展。 如果他人不喜欢我们，我们要喜欢自己非常困难，久而久之就会产生低自尊，这样的人有时就会低估伴侣对于他们的爱，以致于损害亲密关系。 1.5 人类本性的影响探讨人类本性对于人际关系的影响，提出了三个演化心理学的基本假设。 性选择（sexual selection）使人类成为今天这样的物种 演化心理学认为两性之所以存在差异，只是因为某种程度上他们在过去面临着不同的繁殖困境 文化影响决定了演化形成的行为模式是否具有适应性——并且文化的变化比演化快得多 人际关系对于人类有价值，但是也有代价。 2. 吸引力奖赏是吸引力的基础，人们为什么会被吸引？因为在和他人进行交往的时候会产生直接奖赏或者是间接利益。多数情况下，人们提供的直接奖赏越多，对我们的吸引力就越强。初次之外还有其他的因素会影响他人对于我们的吸引力。 2.1 喜欢身边的人首先，人们会更加倾向于喜欢和自己临近的人。空间上的临近决定了我们是否会相遇。重复的接触他人会增加我们对他们的喜欢程度，而不会导致厌烦。 原因之一是如果他人在我们身边，我们很容易得到他们提供的各种奖赏 空间上的临近也使两个人更可能相遇，彼此变得更加熟悉。 因为临近常常能导致熟识，而熟识又引起喜欢，所以与他人频繁的接触不仅能使交往更方便，而且会使对方看起来更有吸引力 我们往往更喜欢身边的人，然而如果他们令我们厌烦，那么临近只会雪上加霜。 2.2 喜欢长得可爱的人 当然，长相吸引力也是很重要的一环。一般来说，我们倾向于认为外贸俊美的人更讨人喜欢，更好相处。研究表明，即使是新生儿也偏好成人认为漂亮的面孔。对于女性而言，大眼睛，小鼻子，尖下巴和丰满的双唇更加有吸引力。而男性的吸引力就比较复杂。拥有结实下颚和宽阔前额的男性——看上去坚强而有主宰力会被认为是帅哥；稍微有一点女性化的男性也很有吸引力。当女性处有排卵前的受孕期，会绝对不修边幅，有男子特征的面孔更加有吸引力；在其他时间更加喜欢青春型、具有孩子气特征的男性面孔。 越平均和对称的脸更加会影响到面孔的美丽。平均化的面孔就是更加有吸引力。对于身材而言，腰臀比例为0.7和姚胸比例为0.75的女性更加会吸引男性。然而对于男性而言，光有好的身材并不能吸引女性，除非他还有其他资源；只有当他能挣一份体面的薪水的时候，他的身材才会影响女性对他的评价。从身高来说，162的男性每年必须多赚221000美元才能和186的男性一样吸引女生的注意。长发的女性比短发的女性更加有吸引力。最后，男女两性都认为传红色衣服的约会对象更加有吸引力。 红色的衣服更加吸引人，红色的衬衫和红色的裙子。 文化在吸引力的方面也有作用，比如只有在全世界都富足的情况下，人们才会认为苗条的女子更加迷人。 美丽：交织着代价和收益。俊美之人常常能和他人愉快的交往，但是不如长相平庸的人那么信任别人。因为他人的表扬也许具有不确定性。如果你非常有吸引力，你或许永远无法确定别人赞美你是因为欣赏你的能力还是喜欢你的长相。 长相吸引力的匹配。已确定爱情关系的伴侣，他们的长相吸引力往往是类似的；即他们的容貌是相匹配的。这种现象称为匹配 2.3 喜欢那些喜欢我们的人对于未来伴侣的期望值 = 伴侣外表的吸引力 ✖伴侣接纳自己的可能性。 我们期望伴侣接纳自己的可能性大小很大程度上和自己的适配价值即作为生殖伙伴的综合吸引力有关。被他人拒绝和接纳的经历教会我们在接近新的恋爱对象时所应有的期望。 研究表明，对于男性而言，最好的搭讪女生的方式就是简单的问好，而不是用一些看似幽默的话来搭讪。而男性喜欢女性先主动示好，不会在乎女人只用什么样的开场白，这就使得他们会反过来高估女人对幽默开场白的喜欢程度。 人们会更加愿意接触那些有接纳自己和喜欢自己可能性的人。当我们不太确定他人是否会接纳我们时，大多数人都不愿意去冒被拒绝的风险。 最好接纳那些挑剔讲究的恋爱对象，对于每个人都表露出愿意接纳的人，最后成功的概率并不高。所以，有选择的故作清高——也就是说，除了你想吸引的人之外，任何人想要得到你都是遥不可及的。 2.4 喜欢那些与我们相似的人人类吸引最基本的准则之一：相类似的人彼此吸引对方。 首先就是在年龄、性别、种族、教育程度、宗教信仰和社会地位等人口统计学上的相似，态度和价值观的相似以及性格的相似。 即使相像达到一定程度之后，吸引力并不会下降，所以“共同点太多”并没有什么危险 相异并不相吸。我们已经认识到人们倾向于和那些长相相像的人配成一对。但另一方面，长相明显不般配的情况有时也会发生。名望、财富、健康、才能和长相等等都像商品一样，能用来吸引心仪的伴侣。 2.5 障碍：得不到的就喜欢最后一个影响吸引力的因素是人们努力克服障碍以实现期望的基本倾向。 罗密欧与朱丽叶效应：父母越是干涉子女的恋爱自由，他们彼此之间就会更加相爱。 打烊效应：在酒吧快要打烊，所有人都准备回家，如果这个时候在寻找一个约会对象，你会发现潜在的对象越来越有吸引力。 2.6 两性期望的理想伴侣在寻找短期的情人的时候，大家都不会过多的苛求什么。然而在彼此都在谋求一个相伴一生的伴侣的时候： 女人往往确保丈夫至少有点金钱会让前途，然后再来寻找尽可能多的热情，友善，诚实，坦率，稳定，幽默智慧等等。金钱和财富是女人所渴求的，但是不如高水平的热情和忠诚重要，长相排在第三位。 男人往往首先确保妻子有普通的长相，然后再来寻找尽可能多的热情，友善，诚实，坦率，稳定，幽默智慧等等。绝世美颜是男人所渴求的，但是不如高水平的热情和忠诚重要，社会资源和经济资源屈居第三位。 3. 社会认知同一个事实可以有很多不同的解释。但不论你选择何种解释，你的判断都可能非常重要。其结果是你的认知既可能巩固也可能损害你们之间的关系。 本章我自始至终都会强调人们对同伴关系知觉和解释的重要性：认知决定了人们的感受和行动。 社会认知指的是我们理解社会现象的知觉和判断过程。 3.1 第一印象极其影响人们对于不同类型的人群都持有刻板化的第一印象。根据刻板印象做出的判断往往非常不准确，但却又很难避免影响，甚至有时还意识不到他们的存在。只要与他人交往，我们就会不断的妄下结论。 人们对于他人的判断受到首因效应的影响，从而使最先获得的信息印象深刻，即时影响和刻板印象一起，塑造出他人的整体印象。第一印象会微妙的影响人们选择和使用后来获得的信息。人们常常会表现出验证者偏差，会去寻找那些能够证明自己的正确信息，而不是那些证明自己错误证据。 随着时间的增加和经验的积累，对伴侣的了解会加深。亲密程度的标志之一就是对伴侣私人情况的了解，随着伴侣彼此熟悉程度的增加，第一印象肯定会发生变化。 人们对于自己的人际关系的知觉并不像自己认为的那样超然客观，准确无误。并且不管这种认知是对是错，对于后来的亲密关系中的情感和行为都有相当大的影响。并且人们不能准确的知道自己解释行为的原因，比如对于同一个人，参与者双手拿的饮料的温度也会左右他们的判断。 3.2 知觉的力量人们很少意识到自己持有的观点往往都是通过选择而采纳的，这种选择进而会促进或妨碍亲密关系的满足。 伴侣的理想化现实中和理想中的人总是有一些差距的，我们要如何与自己的恋人快乐相处？ 方法1: 建立对伴侣善意和大度的认知，突出他们的美德而缩小他们的缺陷。以积极错觉来评价对方，尽可能用积极的眼光来表述伴侣。但是同时也要注意积极错觉与现实不符合的程度会决定这种积极错觉是否会带来危险。随着对于对方的理解越来越深入，不断的调整自己对于理想伴侣的期望，这样伴侣期望的标准就能够契合伴侣的现状。当我们以积极错觉来评价对方的时候，对方也能够感受到，同时也积极错觉来评价我们，实现双赢。 归因过程人们的喜怒哀乐还受到解释伴侣行为时所选择理由的影响。归因（attribution）就是指人们对事情发生的原因（特别是指人为什么要做或者不做某件事情）提出的解释。 人际关系的归因研究发现三个普遍存在的现象。 伴侣之间随着深入的了解，仍然会受到行动者/观察者效应的强烈影响。他们对自己行为的解释，与对观察到的伴侣的类似行为的解释完全两样，即便是在同样的环境下，也总是会将自己的行为归结为外部压力，而把对方的行为归结为对方自己的原因。比如在吵架的时候都会认为是对方的原因，并且觉得对返回也是这么想的，这种归因的差异是很难被意识到的。如果伴侣有意识地去努力了解对方的观点，行动者/观察者效应就会减少，但是不会完全消失。所以及时交换看法是十分重要的，因为即使是最亲密的伴侣也很少能够真正理解你所有行为的原因。 尽管伴侣之间有真爱，但是依然会存在自我服务偏差，欣然把成功归因于自己，而极力推脱自己在失败中的罪责。但是如果伴侣认为他们非常亲密，彼此的自我服务偏差就比与其他人相处要少得多。这一现象有意思的地方是，人们都能估计到他人存在自我服务偏差，而看不到自己也存在。大多数人都能轻易地认识到别人对功劳过分的自居，对失败苍白的托词；但却认为自己类似的自我服务偏差明智而准确。这部分地是因为即使在自己的善良意图没有实现的情况下，人们仍能清醒地意识到它，并给予充分的肯定；而判断别人则仅仅依据他们的行为，完全无视他们行动的意图。所以对于没有实现的善举不要居功自傲，但是也要时常明确表现出自己的好心好意，让对方感受到。 伴侣双方总的归因模式能决定亲密关系的满意程度。幸福的爱人对伴侣行为都是能改善关系的。认为伴侣的积极行动都是刻意的，习惯的，还能据此推断伴侣在其他情境下的行为。幸福的配偶对彼此的积极行为都通常给以内部的，稳定的，普遍的归因。他们也倾向于淡化彼此的过失，认为他们是偶然的，特殊的和局部的。因而，消极的行为都通过外部的、易变的、特定的归因而得到谅解。 关系信念 浪漫信念 浪漫信念中的一些不好的观念： 争吵具有破坏性。争吵就表明伴侣爱自己还不够深。如果彼此深深相爱，就不会发生任何争执。 “读心术”很重要。真正彼此关爱的伴侣仅凭直觉就能知道对方的需要和偏好，根本不需要告知对方自己的所思所想。如果必须告诉伴侣自己的想法和愿望，那只能说明伴侣爱自己还不够深。 伴侣是不会发生改变的。一旦亲密关系变糟，就无法得到改善。如果爱人曾伤害过你，毫无疑问还会一而再，再而三地伤害你。 每一次的性生活都应该是完美的。只要爱情是忠贞的，每一次的性生活都应该是神奇美妙、令人满足的。伴侣应该经常渴望并为性生活做好准备。 男人和女人就是不一样。男人和女人的性格和需要非常不同，很难真正理解对方。 美好姻缘天注定。根本无需努力来维护美满的夫妻关系。夫妻要么彼此脾性相投、快乐到老，要么格格不入、争执一生。 具有这种观点的人只会更加的愿意结束不幸福的亲密关系而不是努力的修复亲密关系。 宿命信念：认为伴侣要么是天造地设的一对，婚姻生活注定幸福美满；要么不是冤家不聚头，婚姻生活注定痛苦悲惨。这样的爱情往往出现在电影里。 成长信念：假定幸福的亲密关系乃是辛勤维护的结果。幸福的关系是努力和付出的回报，如果伴侣一起努力战胜挑战、克服困难，良性的亲密关系就能逐渐建立起来。其基本假设是：只要努力付出，几乎任何亲密关系都能取得成功。 3.3 印象管理不论我们是否能意识到，我们总是在进行着印象管理，试图影响别人对我们的印象。有时我们会仔细地选择自己的动作、言语、穿着和背景，企图给他人留下精心策划的好印象；甚至会仔细挑选自己的好友以呈现某种公共形象。 印象管理策略 逢迎讨好策略：寻求他人的接纳和喜欢，尽量显得自己充满魅力，讨人喜欢。这种印象管理策略在恋人中是常用的。 自我推销策略：希望自己的能力得到他人的认可和尊重，描述自己的成就，公开展示自己的技能。在职场中常用。在求职面试中，逢迎讨好策略和自我推销策略一起使用是效果最好的。 恐吓策略：把自己描绘成无情、危险和凶恶的形象，以使他人顺从自己。这样的行为令人反感，会使人避而远之。 恳求的策略：人们看上去显得无能或体弱，以逃避责任或求取他人的帮助和支持。 如果你曾经做出姿态，让伴侣知道你对某事很生气或者伤心，以此来达到自己的目的，就分别用到了恐吓或恳求策略 亲密关系中的印象管理亲密关系中的印象管理有两个特点： 人们管理印象的动机存在个体差异，这种差异具有重要的影响。 尽管我们给好友和恋人营造的印象比为熟人或陌生人营造的更为重要，但是为了维持良好的形象，我们在前者所花的心思通常不如后者。 人们在谈恋爱时，凭借优雅的举止赢得浪漫伴侣的爱情后，却再也不肯努力在爱人面前保持风度（这或许是许多亲密关系中存在的重大问题，在第6章相互依赖我们会详细探讨）。 4. 沟通我们常常认识不到，传递者的意图和对接受者产生的影响并不相同，这就是我们所面临的人际隔阂。 4.1 非言语沟通非语言沟通的功能： 非语言沟通的组成 面部表情 即使人们试图控制自己的表情，仍然会泄露真实的情绪。 注视行为 居于支配地位的人在交往中会坚持，“我跟你说话时要看着我！”，但通常不会反过来也给予对方同样多的视觉注意。 身体动作 身体的姿势或动作传达的信息虽不太明确，却仍很有用。 身体接触 人际距离 人际距离都是测定人际交往亲密程度的巧妙手段，甚至能用来间接衡量人际关系的质量：不幸福的配偶比满意的配偶保持的人际距离更大。 副语言 副语言指除了言语过程中的词语之外，个体发出的各种声音特征，如节奏、音调、音量和速度，比如说话时气喘、嗓子沙哑或者尖溜、哧哧笑、整句话带鼻音、某个字音拉得很长、结结巴巴说话不连贯等等。 非言语的敏感性非言语沟通不良的夫妻往往对婚姻不太满意。而且如果出现这类问题，一般都是丈夫的过错。 4.2 言语沟通自我表露向他人透露个人信息的过程就是自我表露，它是亲密程度的指标之一：如果两个人彼此之间不共同拥有一些相对秘密的私人信息，他们的关系就称不上亲密。 两个人要变得亲近，必须满足三个条件： 首先，他们必须进行有意义的自我表露 其次，他们必须对彼此的个人信息有兴趣和同理心，在异性恋的关系中如果男性能做到这一点尤其有价值（Mitchell et al.，2008） 最后一点很重要，双方必须都认识到另一方具有应答性。 即使人际关系变得非常亲密，人们也可能保留一些只属于自己的秘密。亲密的自我表露和选择性地保留一些秘密都能促成婚姻的美满。 亲密关系中禁忌话题越多，伴侣间的满意度就越低，除非他们认为避开敏感话题能改善和保护他们的亲密关系因为怯懦或能力不足而逃避讨论，会降低伴侣的满意度，但有礼貌地一起努力维持伴侣关系很少有什么不好的影响。 言语沟通中的性别差异至此我们还没有发现男女两性的言语沟通存在巨大的差异。但这里有个差异很重要：在已确立的人际关系中，女性比男性表现出更多的自我表露。男性对女性较为开放，女性彼此之间也较为开放，但男性不怎么对其他男性进行自我表露。 4.3 沟通障碍及其应对沟通不良 首先，不幸福的伴侣在表述意图上表现得很糟糕。如果他们抱怨某事，很少能准确到位；相反，他们倾向于数怨并诉。 其次，不幸福的伴侣在彼此倾听方面也表现得很糟糕。 不幸福的伴侣还会进行反向抱怨，避开对方关注的问题，只用自己的抱怨来应对伴侣的抱怨，而不是对伴侣所说的话表示关注。 最后，不幸福的伴侣在交谈时常常表现出消极情感。他们常常对伴侣的抱怨报以讽刺挖苦，贬低和鄙视伴侣的人格。 如果我们感到愤怒、憎恨或焦虑，或许会发现自己正在进行反向抱怨、数怨并诉或者其他诸如此类的行为。如何避免这些沟通陷阱呢？这要根据情境而定，我们或许需要表达更为清楚、不太有火药味的信息，更好地倾听，保持冷静和礼貌，有时这三条都需要做好。 精确表述尽可能清楚明白、详细具体地指出惹怒我们的特定行为，伴侣间的沟通就会变得更为明智、准确。这样不仅能告诉伴侣自己的想法，还能把谈话重点集中在可处理的、单独的某个行为上，而行为比人格更容易改变。 积极倾听在沟通中当我们接受到他人的信息时，有两个重要的任务要完成。第一是要准确地理解对方话语所表达的意思，第二是要向对方传达关注和理解，让他知道我们对他的话是在意的。这两个任务都可以通过复述接受到的信息而完成，即用自己的话重复对方的意思，让信息的传递者有机会肯定那就是他真正想要表达的意思。 守礼而镇定幸福的伴侣偶尔也有这样的行为——大多数的亲密关系中都可能会发生尖酸刻薄的蔑视——但是他们比起不幸福的伴侣能更快地摆脱这些恶性循环。 实际上，在争吵不断升级之初就进行化解是非常有益的，但却不太容易做到。因而，在被伴侣激怒的时候能保持清醒，在开始生气的时候能冷静下来，都是非常可贵的技能。 当然，人在被激怒的时候很难保持平静，镇定地思考。所以只要有可能就应该事先允诺与伴侣彼此以礼相待，这也是（试着）减少使人愤怒的事件的好方法。 尊重和确认的力量良好的沟通包括很多构成要素：有意识地努力传递清晰、直接的信息，认真倾听，即使出现争执仍保持礼貌和克制等等。但最关键的要素却是明确地表现我们对伴侣观点的关心和尊重。对伴侣的确认，即承认他们观点的合理性，表达对他们立场的尊重，一直是亲密交往中值得拥有的目标。 确认并不需要你一定与伴侣观点一致。即使与伴侣的观点相左，你也能对其观点表示适当的尊重和认可。 5. 相互依赖5.1 社会交换相互依赖理论认为，人们就像购物那样在人际商厦里浏览。所有人都在寻找最合意的商品。我们在寻求以最小代价获取能提供最大奖赏价值的人际交往，我们只会与那些能提供足够利益的伴侣维持亲密关系。不过，由于每个人都这样做，所以亲密关系中的伴侣双方都必须满足自己的利益，否则亲密关系不可能持续下去。 奖赏和代价人际交往中的奖赏指的是，我们与他人接触时所获得的令人高兴的经验和物品。交往中所有令人沮丧或苦恼的后果都是代价。 某一特定的人际交往所带来的奖赏和代价之和就是结果，即：结果=奖赏-代价 相互依赖理论的一个深刻的观点就认为，人际交往的结果是正还是负并不重要，重要的是我们评价结果的两个标准。第一个标准是我们的期望，第二个标准是假如没有现在的伴侣，我们认为自己会过得怎样。 人际关系的期望收益相互依赖理论假定每个人都有一个与众不同的比较水平（CL），并且是建立在过去经验的基础之上，是测量我们对关系满意程度的标准。如果人们曾有过奖赏价值很高的伴侣关系，就可能有较高的CL，表明他们现在还期望并觉得自己理应得到非常好的交往结果。相反，如果过去经历过困难重重的亲密关系，那么他们的期望和CL都会很低。 结论： 即使你在与他人的交往中仍有所收益，如果这一收益没有大到足够满足你的期望，你仍不会感到幸福。 满意度来自交往结果和比较水平之差，即：结果- CL =满意度 人际关系的替代收益对亲密关系的满意程度并不是决定我们要保持或离开关系的主要因素，这一观点是相互依赖理论的最有趣最深刻的发现之一。 相互依赖理论的另一个重要假设是，满意度并不是唯一的、甚至也不是决定亲密关系持续与否的最主要的影响因素。无论我们是否乐意，我们都会用到第二个标准，即替代的比较水平（comparison level for alternative，$CL_{alt}$ ). $CL_{alt}$是指如果我们抛弃目前的亲密关系，而转投可以选择的更好的伴侣或情境，所能得到的交往结果。 可以把 $CL_{alt}$视为亲密关系的全部结果，即个体认为把所有因素考虑在内，更换伴侣所产生的净盈亏。如果结束当前的伴侣关系、投入新的替代关系的整个过程有希望获得更好的结果，个体就会放弃原来的亲密关系。这只是经济学的常理。 问题是要算清这些盈亏非常困难. 比如对现有亲密关系的投入，也就是亲密关系结束的时候个体会失去的事物，包括有形的物品也有无形的心理收益，比如他人的关爱和尊重。此外， $CL_{alt}$作为主观的产物，个人的自尊，习得性无助等等也会有所影响。人们如果不喜欢自己或者过去在一段不好的亲密关系，那么就会低估自己和伴侣的相处的前景。 所以，我们应该记住，计算 $CL_{alt}$是个复杂的评判过程，包括离开亲密关系的代价——如投入的损失——和他人产生的诱惑，这样就得到： 结果 - $CL_{alt}$ =依赖度 总结来说：人们在交往中得到的净盈亏就是他们关系的结果。如果他们的结果超过期望，或者CL，他们就感到满意；然而如果现有的亲密关系结果不如他们的期望（即结果低于CL），他们就不满意。此外，如果人们当前的结果好于从别处能得到的结果（即他们的结果超过他们的$CL_{alt}$），他们就依赖于现在的伴侣，不太可能离开。然而，如果他们从现在的伴侣处得到的结果比他们从别处能获得的结果更差（他们的结果降到$CL_{alt}$以下），他们就会倾向独立，很可能离开当前的伴侣。 人际关系的四种类型 与时俱变的比较水平因为比较水平是建立在我们过去经验的基础上，所以它往往会随着我们得到的关系结果而不断波动。当我们最初得到非常好的关系结果时，我们会非常愉悦，但随着我们开始把这些好处视为理所当然，CL开始升高时，我们的愉悦感会渐渐地减少。这样一来，即使没有任何改变（除了我们的期望），具有奖赏意义的亲密关系也会逐渐变得越来越不满意。 文化的变化也会增加我们的$CL_{alt}$水平。女性更多地参与到劳动大军中，一方面可以接触到有趣的同事，另一方面拥有一定的经济资源，从而能让她们更容易离开不幸福的亲密关系。加上反对离婚的法律、宗教和社会障碍正在逐渐消除，大多数情况下人们有更多的选择机会，有更多可得到的替代伴侣，同时离婚的代价在不断下降。 5.2 亲密关系的经济论相互依赖理论把浪漫的亲密关系功利化了。亲密关系中的奖赏和代价不是亲密关系中的一切，过于在意奖赏和代价会使我们忽视其他影响伴侣关系成败的重要因素。 计算亲密关系的奖赏和代价，能为关系的现状和未来提供非同寻常的信息。亲密关系中的负面行为比相同数量的正面行为有着更大的心理影响力。实际上，要保持满意的亲密关系，我们或许需要保持至少5:1的奖赏-代价比率。 所以，奖赏和代价对亲密关系的满足和稳定都有重要影响，要想亲密关系兴旺繁荣，需要更多的奖赏而不是减少代价。不过伴侣可能不认为对方做的意图良好的事情是特别体贴的，也有可能对方没有注意到他们的爱人的表达爱心和温情的行为。研究发现发现两性对其伴侣所说的正面行为的注意还不到四分之一。 奖赏的作用不同于代价奖赏和代价对亲密关系的影响是各自独立，彼此相异的。寻求奖赏时，我们企图满足自己喜好体验的欲望，即接近动机。我们渴望逃避代价的是另一种不同的驱力，即回避动机 关注亲密关系这两种动机的理由： 这两种动机时相互独立的，所以这两种动机的满足于不满足会产生四种伴侣关系，可以参照上图。 强烈的、回避代价的动机会使人们注意到伴侣所做的所有烦心之事，而接近奖赏的动机却会使人们关注伴侣采取的所有体贴和慷慨之举。具有强烈接近动机的人（很少有孤独感，容易感到满足）愿意追求和伴侣更多的亲密感；他们对自己的行动感觉良好，其亲密关系也就能获益。相形之下，具有回避动机的人会努力避开冲突；他们很吝啬，不愿意做出些许牺牲，其亲密关系也就会受损。 如果想要亲密关系兴旺繁荣，快乐充实，我们需要做的不仅仅是避开痛苦的冲突和其他代价。我们还要还要克服沉闷的亲密关系：必须尽力满足他们的接近目标，为伴侣提供快乐的、有趣的、兴奋的经验。这一结论也是人类动机的自我延伸模型的核心思想。该理论认为，能扩展我们的兴趣、技能和经验的伴侣关系就能吸引我们。所以伴侣熟络起来之后也要寻求新奇的活动和挑战，保持快乐的关键是创造性地发现持续你个人成长的方法，从而消除关系的沉闷。 与时俱变的奖赏和代价 成功的亲密关系在熬过动荡的过渡期后，伴侣作为配偶的新身份得到了认可。随着亲密关系继续发展，满意度开始重新但却缓慢地增加。 能区分婚姻幸福和欢乐减少的夫妻的因素有很多，不过主要的是幸福的配偶会控制其欲望，所以他们的CL不会太高。如果你求全责备，期望过高，就很难得到满足。对亲密关系之未来保守而慎重的期望远比浪漫的理想主义更明智和理性。因为人们通常不能维持步入婚姻时的那种亲密关系结果。理由如下： 缺少努力。进入亲密关系之后人们就不会在努力取保持风度翩翩。 相互依赖的放大镜作用。我们花了大量的时间与亲密伴侣共处，依赖对方以得到独特的、宝贵的奖赏，这就意味着他们肯定会比其他任何人带给我们更多的挫折感——即使是出于无心的。 对敏感信息武器的了解。亲密意味着伴侣了解你的秘密、缺点和劣势。如果发生冲突，这些就是伴侣用来嘲笑和伤害我们的武器。 不受欢迎的意外。 第一种是了解了那些我们自以为已知事情的真相。结婚之初你知道甚至乐见自己的爱人爱好玩乐、天真率直，但在婚后数年当你要疲于应付抵押贷款、养育孩子时，爱人同样的行为就显得不负责任、轻浮多变和不可信赖。 第二种是获悉了那些你根本不知道的令人讨厌的事情。比如孩子出生之后，冲突会增多，对婚姻的满意度会减少。 不现实的期望。亲密关系与我们想象中的快乐无忧、亲密无间的田园似的婚姻生活相去甚远。 5.3 亲密关系中的贪婪相互依赖的实质根据相互依赖理论，人们都想以最小的代价获得最大的奖赏，总是想得到最好的人际交易。相互依赖理论认为，在追求美满的关系结果时，个体应经常对自己所依赖的人宽容大度，因为这样做合乎情理（而且很有价值）。如果伴侣双方都想亲密关系持续，双方都应该深思熟虑地保护和维持对方的幸福。 交换关系与共有关系交换关系：由外在的公平交换规范调节。人们为他人付出期望得到同等的回报。交换关系多为陌生人或一般熟人之间的关系，其典型的特征是肤浅、短暂、很大程度上是任务导向的。 共有关系：伴侣特别关注对方的幸福，彼此不期望任何回报地支持和关照对方。在共有的亲密关系中，人们常会为伴侣做出一些小牺牲，彼此帮对方的大忙，结果是他们享受到更高质量的亲密关系。 由于我们信任伴侣并预期关系将持续，所以我们也能等待更长时间以得到奖赏。在这个意义上来看，交换和共有的伴侣关系都是“交换”的关系，人们都期望自己得到的利益能配得上自己的付出；只不过在共有关系中交换的形式不同，表现得更不明显而已。 公平关系公平理论扩展了社会交换的理论框架。根据公平理论，只有在伴侣贡献较多而同时也得到较多时，亲密关系才是公平的。 承诺的本质令人欣慰的是，对亲密伴侣的幸福依赖可以孕育承诺，即持续亲密关系的意图。 把承诺视为一种复杂的决策过程，这一做法是与著名的承诺理论,即投入模型相一致的投入模型认为在以下三种情况下人们希望与现有的伴侣保持亲密：感到幸福（满意水平）；没有其他更好的选择（替代伴侣的质量）；离开的代价太高（投入数量）。 投入模型将承诺视为整体单一的概念。不过社会学家迈克尔·约翰逊就宣称实际上存在三种类型的承诺： 个人承诺（通常是最强烈的），即人们受到伴侣的吸引、亲密关系令人满意，而希望关系继续时表现出的承诺。 强迫承诺，即因为离开关系的代价过高，人们觉得不得不继续现有关系时表现出的承诺。 第三种道德承诺来自对伴侣或者亲密关系的道德责任感。 承诺引起的后果承诺的特征之一是指向长期发展，这能减少亲密关系遭遇坎坷时产生的痛苦。如果人们认为他们的亲密关系会长久发展，就能很好地容忍一时出现的低奖赏和高代价。 不过，承诺引起的最重要的结果可能是，它会使人们采取行动以保护和维持亲密关系，即使这样做的代价很高。 承诺会促进顺应性行为。具有顺应性的人能容忍伴侣的破坏性行为而不还击；他们吞下侮辱、嘲讽或自私的恶果而不报复。 承诺的人还表现出更大程度的牺牲意愿。 承诺会改变人们对伴侣关系的认知。详而言之，他们认为在亲密关系中比别人享有更多的奖赏、付出更少的代价。认为自己的亲密关系比别人的要好。 6. 友谊6.1 友谊的本质如果配偶和朋友都在身边，那将是最美好的时光。但如果两者只能择一，朋友带来的快乐和兴奋往往比配偶带来的要多。 友谊的属性深厚的友谊虽然不如爱情充满激情，但仍然具有奖赏价值，包含着亲密关系的所有其他组成部分。下面我们就来看看友谊的这些成分。 尊重 最亲密的朋友往往是我们尊重的人。当我们自信地认为朋友会仁慈地对待我们，无私地考虑我们最大的利益时，我们就对他们产生了信任。 资本化 在资本化的交往模式中，我们常常能和朋友分享好消息，得到有益于紧密关系的热烈而有价值的反应。 具有资本化特征的人际关系通常比资本化不足的人际关系更令人满意、持续的时间也更长。 社会支持 我们获得的援助或社会支持有4种。表现为关爱、接纳和安慰等形式的感情支持；表现为拥抱或搂抱的身体安慰；表现为资讯和指导形式的建议支持；和表现为金钱或物品的物质支持或有形援助。 友谊的规则虽然我们通常不会在内心详细阐述朋友的含义，但大多数人都会有一套人际关系的规则（rules for relationships），这种规则即是朋友应（或不应）履行某些行为的共同文化信念。 6.2 友谊的毕生变化社会情绪选择理论的观点认为，随着有生之年变得越来越屈指可数，老年人交际的目标指向友谊的质量而非数量；他们更注重精选出的深厚友情，不愿发生冲突，而让更普通的朋友关系自然消失。 该理论预测：任何人，只要认为自己的未来不长久，就会花更多的时间与少数几个亲密好友相处，而不是把时间用来和各种各样的普通朋友交往。 6.3 友谊的差异友谊不仅在整个生命周期中有变化，在不同的个体之间和伙伴之间也存在差异。 同性友谊中的个体差异女性的友谊是“面对面”，而男性的友谊则是“肩并肩”。女性之间的友谊往往比男性更亲切、紧密。最终结果是，女性在爱情关系之外仍会向朋友寻求敏感、体贴的理解和支持，而男性常常做不到这点。为什么男性之间的友谊不如女性那样亲密？社会对这种男性同性亲密的接纳程度远低于女性，所以他们不会这样做。传统的教养鼓励男性应该具有工具性而非表达性的特质。 友谊的个体差异除了性别效应之外，还存在其他影响友谊的个体差异。其一就是我们在第4章中谈到的自我监控。高自我监控者在友谊中的投入往往比低自我监控者更少；低自我监控者的朋友数量较少，但彼此有着更多的共同点，他们的友谊一般看来更加亲密。 另一个影响社交网络的个体特征是性取向。。只有约六分之一的异性恋者（知道他们）有朋友是GLB，但80%的GLB有亲密的异性恋朋友。 6.4 友谊发展的障碍羞怯几乎任何人都会不时地受到羞怯的困扰。当我们置身于陌生的环境，第一次见到有魅力、地位高的陌生人时，很容易产生羞怯，但是当我们在熟悉的环境下与老友交往时，则不太可能会感到羞怯。 与坦荡的人相比，他们具有三个特征。首先，惯常羞怯者害怕别人的负面评价。其次，他们倾向于怀疑自我。最后，在与人交往的过程中，他们会感到自己能力不足，有时还能找到充分的理由。 具有讽刺意味的是，无论人们的羞怯是暂时性或习惯性的，只要他们胆怯畏缩，就会给人留下负面印象，而这恰恰是他们与人交往时希望避免的。 孤独孤独与独处并不是一回事；在完全独处的状态我们通常也能感到满足。 孤独有着不同的层面。其一是社会隔离，指的是我们不满于缺少朋友和熟人的社交网络而引起的孤独；其二是情感隔离，指的是我们缺乏深厚的人际关系而引起的孤独。 要克服孤独，我们就应该寻求新的友谊，而不是爱情，尽力使自己显得友好。 7. 爱情在20世纪末，西方文化下的年轻人还坚持认为浪漫爱情是婚姻的必须条件。不过现在人们都会觉得爱情是婚姻比不不可少的一部分，也就是如今大部分人们会拒绝与自己并不爱恋但是各个方面都完美的伴侣结婚。 7.1 爱情简史许多年来，人们对爱情的态度体验至少在以下四个方面有所变化： 文化价值：爱情是值得拥有的还是可有可无的情感体验？ 性欲：爱情应该有性行为还是与性无关？ 性取向：异性之间和同性之间都能相爱吗？ 婚姻状况：爱情只专属于婚姻，还是可以保留给第三者？ 在古希腊，人们认为，爱情是一种疯狂；爱情与婚姻几乎没有关系；最完美的爱情发生在同性之间。 在古埃及，人们认为爱情并不需要有性接触。 在12世纪的欧洲，人们认为爱情是高贵的精神追求。 在12-17世纪，人们认为爱情是注定要破灭的。 在17-19世纪，欧洲人认为爱情可以是幸福美满的。 在今天，世界上局部人会认为爱情和婚姻相伴相随。 7.2 爱情类型罗伯特·斯腾伯格认为各种不同的爱情都能由三个构成成分组合而成： 亲密，包括热情、理解、沟通、支持和分享等爱情关系中常见的特征。 激情，其主要特征为性的唤醒和欲望。 承诺，指投身于爱情和努力维护爱情的决心。 如果三角理论对浪漫爱情的描述是正确的，则浪漫之爱的主要成分之一——高水平的激情——可能难以持续。不过要想知道爱情是否能持续，还需考虑许多因素。 在生理学的角度看，费希尔认为存在三种既相互联系又截然不同的生物系统控制着爱情成分。","categories":[{"name":"阅读笔记","slug":"阅读笔记","permalink":"https://hasuer.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"心理学","slug":"心理学","permalink":"https://hasuer.github.io/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"},{"name":"人际关系","slug":"人际关系","permalink":"https://hasuer.github.io/tags/%E4%BA%BA%E9%99%85%E5%85%B3%E7%B3%BB/"},{"name":"情感","slug":"情感","permalink":"https://hasuer.github.io/tags/%E6%83%85%E6%84%9F/"}]},{"title":"长沙之旅","slug":"长沙之旅","date":"2021-05-06T01:21:49.000Z","updated":"2021-05-30T13:22:34.657Z","comments":true,"path":"长沙之旅/index.html","link":"","permalink":"https://hasuer.github.io/%E9%95%BF%E6%B2%99%E4%B9%8B%E6%97%85/index.html","excerpt":"","text":"以此片来纪念一下长沙之旅。 2021/5/1-2021/5/5 一号早上10点49分的高铁，我从津南和他们回合。放张合照，懒得一一介绍了。 一切都很顺利，直到中午12点左右，高铁停了一会，当时天真善良的我们还没有意识到事情的严重性。直到广播里面响起了熟悉的提示音，但是紧接的不是“尊敬的旅客您好，本次列车是绿色车厢……”，而是“由于天气原因，本次列车晚点30min，全体车组人员对给您带来的不便表示诚挚的歉意。”然后噩梦开始了， “由于天气原因，本次列车晚点60min…” “本次列车晚点95min…” “晚点两个小时” ”三个小时“ 没错，最后晚点了三个小时，原本在晚上六点半就该到站的，结果到了晚上11点才到站。 到了酒店收拾了一下就去吃饭了。在八碗湘吃的，第一个上的菜是爆炒肥肠，没想到这个菜是接下来几个菜里面最辣的。还有就似乎不得不说，感觉湘菜里面的肉都切的好小，不过瘾，但是入味。要是我烧菜放这么多辣椒一定会被认为是富家子弟吧\\^_\\^​ 5/2 早上吃米粉 橘子洲 无中饭，去了7mall吃了一盏灯 晚上ktv 早上10点起床去楼下吃了粉条，有点小贵，而且味道一般。但是谁吃的最香就不用我多说了吧:dog: [假装有一张粉的照片] 吃过早饭以后，阿皮就去排茶颜悦色了。 感谢阿皮在30+的温度下排了一个多小时的队伍，终于喝到了第一杯茶颜悦色呜呜呜~ 然后就是去橘子洲啦~ 真的走了好长好长好长。到了之后合完影在亭子里面休息到大概4 5点吧，吃着从墨茉点心局买的糕点，唠嗑。在进橘子洲的入口还看到了婚礼哎，妙:frog: 一盏灯的晚饭~ 也没有想象中的那么辣，可能是我们没有点很辣的，我们点的最辣的也就是一颗星的辣度。 testword","categories":[{"name":"随笔","slug":"随笔","permalink":"https://hasuer.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]},{"title":"PostgreSQL ALTER TABLE中改变数据类型时USING的用法","slug":"PostgreSQL ALTER TABLE中改变数据类型时USING的用法","date":"2021-04-20T09:07:28.000Z","updated":"2021-04-20T09:09:40.949Z","comments":true,"path":"postgresql-alter-table中改变数据类型时using的用法/index.html","link":"","permalink":"https://hasuer.github.io/postgresql-alter-table%E4%B8%AD%E6%94%B9%E5%8F%98%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%97%B6using%E7%9A%84%E7%94%A8%E6%B3%95/index.html","excerpt":"","text":"原文链接 在修改表字段类型的时候使用Using来进行显示的转换类型。 原文说明： SET DATA TYPE This form changes the type of a column of a table. Indexes and simple table constraints involving the column willbe automatically converted to use the new column type by reparsing the originally supplied expression. The optional COLLATE clause specifies a collation for the new column; if omitted, the collation is the default for the new column type. The optional USING clause specifies how to compute the new column value from the old; if omitted, the default conversion is the same as an assignment cast from old data type to new. A USING clause must be provided if there is no implicit or assignment cast from old to new type. 大致意思是：转换类型的时候有隐含类型转换的时候，会自动转换，如果没有，那么就必须使用using指定一下转换规则。 1. 建表 1create table 101(id integer); 2. 插入数据 1insert into tb10 select generate_series(1,5); 3. 把id的int变为varchar 12postgres=# alter table tb101 alter id type varchar;ALTER TABLE 因为int转varchar有隐式的转换，故可以自动转换过去。 12345postgres=# \\d tb101 Table &quot;public.tb101&quot; Column | Type | Modifiers --------+-------------------+----------- id | character varying | 4. 把id的varchar变为int 123postgres=# alter table tb101 alter id type int;ERROR: column &quot;id&quot; cannot be cast automatically to type integerHINT: Specify a USING expression to perform the conversion. 在没有隐式的转换下，就需要指定Using来显示的转换。 5. 使用Using进行类型转换 1234567postgres=# alter table tb101 alter id type int using id::int;ALTER TABLEpostgres=# \\d tb101 Table &quot;public.tb101&quot; Column | Type | Modifiers --------+---------+----------- id | integer | id::int 也可以使用cast(id as int)","categories":[],"tags":[]},{"title":"KMP","slug":"KMP","date":"2021-04-11T12:25:33.000Z","updated":"2022-02-23T07:00:01.057Z","comments":true,"path":"kmp/index.html","link":"","permalink":"https://hasuer.github.io/kmp/index.html","excerpt":"","text":"KMP算法简介定义： 在串中寻找字串（第一个字符）在串中的位置。 注意： 在这个算法中有两个问题要考虑： 这个位置是指索引（下标）还是小标加一（位置）。 字符串的第一个位置，也就是S[0]是否要存放长度。 KMP算法S[0]表示字符串长度12345678910111213141516171819202122int Index_Kmp(SString S, SString T, int pos) &#123; // S表示原串 // T表示模式串 // pos表示索引，这个算法中S[0]表示的是字符串的长度 // 所以如果pos是5，那么是这个字符串的第4个元素 // 第一个元素从S[1]开始存储 // 返回的是在S中的位置，也就是第几个元素。比如返回4，表示是S中的第四个元素，由于S[0]是长度，所以其实是S中索引为4的位置，排在第5个。 int i = pos; int j = 1; while (i &lt;= S[0] &amp;&amp; j &lt;= T[0]) &#123; if (j == 0 || S[i] == T[j]) &#123; i++; j++; &#125; else &#123; j = next[j]; &#125; &#125; if (j &gt; T[0]) return i - T[0]; else return 0;&#125; S[0]不表示字符串长度123456789101112131415161718192021int Index_Kmp(String S, String T, int pos) &#123; // S表示原串 // T表示模式串 // pos表示S中的索引，这个算法中S[0]不表示字符串的长度 // 这里的pos和上一个代码中的pos意义一样 // 第一个元素从S[1]开始存储s int i = pos; signed int j = 0; while (i &lt; s.length() &amp;&amp; j &lt; (signed)t.length()) &#123; if (j == -1 || s[i] == t[j]) &#123; i++; j++; &#125; else &#123; j = nextval[j]; &#125; &#125; if (j &gt;= t.length()) return i - t.length(); else return -1;&#125; get_nextS[0]表示字符串长度1234567891011121314void get_next(SString S, int next[]) &#123; int i = 1; // S的第二个元素，也就是字符串的第一个元素 next[1] = 0; // 第一个位置 int j = 0; while (i &lt; S[0]) &#123; if (j == 0 || S[i] == S[j]) &#123; i++; j++; next[i] = j; &#125; else &#123; j == next[j]; &#125; &#125;&#125; S[0]不表示字符串长度这种中，next数组从下标0开始存储，存的也是对应的下标，而不是想上面一个算法，next从1开始存，存的是位置。 1234567891011121314void get_next(String S, int next[]) &#123; int i = 0; // S的第二个元素，也就是字符串的第一个元素, next[0] = 0; // 第一个位置 int j = -1; while (i &lt; S.length()) &#123; if (j == -1 || S[i] == S[j]) &#123; i++; j++; next[i] = j; &#125; else &#123; j == next[j]; &#125; &#125;&#125; get_nextvalS[0]表示字符串长度123456789101112131415161718void get_next(String S, int nextval[]) &#123; int i = 1; // S的第二个元素，也就是字符串的第一个元素, nextval[1] = 0; // 第一个位置 int j = 0; while (i &lt; S.length()) &#123; if (j == 0 || S[i] == S[j]) &#123; i++; j++; if (S[i] != S[j]) &#123; nextval[i] = j; &#125; else &#123; nextval[i] = nextval[j]; &#125; &#125; else &#123; j == nextval[j]; &#125; &#125;&#125; S[0]不表示字符串长度123456789101112131415161718void get_next(String S, int nextval[]) &#123; int i = 0; // S的第二个元素，也就是字符串的第一个元素, nextval[0] = -1; // 第一个位置 int j = -1; while (i &lt; S.length()) &#123; if (j == -1 || S[i] == S[j]) &#123; i++; j++; if (S[i] != S[j]) &#123; nextval[i] = j; &#125; else &#123; nextval[i] = nextval[j]; &#125; &#125; else &#123; j == nextval[j]; &#125; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://hasuer.github.io/categories/Algorithm/"}],"tags":[]},{"title":"穷查理宝典","slug":"穷查理宝典","date":"2021-03-30T09:27:07.000Z","updated":"2022-02-23T06:58:41.534Z","comments":true,"path":"穷查理宝典/index.html","link":"","permalink":"https://hasuer.github.io/%E7%A9%B7%E6%9F%A5%E7%90%86%E5%AE%9D%E5%85%B8/index.html","excerpt":"","text":"查理思考问题总是从逆向开始。 想要明白人生如何获得幸福，就去研究人生如何变得痛苦。 找出你最擅长的事情，然后持之以恒，乐此不疲的把它做好。 获取普世的智慧，并相应的调整你的行为。即使你的特立独行让你在人群中不受欢迎，那就随他们去吧。 芒格的生活、学习和决策方法 凡事往简单处想，往认真处行 我们的经验往往会验证一个长久以来的观念：只要做好准备，在人生中抓好几个机会，迅速的采取适当的行动，去做简单而合乎逻辑的事情，这辈子的财富就会得到极大的增长。 上面提到的这种机会很少，他们通常会落在不断寻找和等待、充满求知欲望而又热衷于对各种不同的可能性做出分析的人头上。 这样的机会来临之后，如果获胜的几率极高，那么动用过去的谨慎和耐心的来的资源，重重地压下堵住就可以了。 简单是长期努力的结果而不是起点 ——弗里德里曼·麦可兰德 就确定未来而言，没有比历史更好的老师，一本三十美元的历史书里隐藏着价值数亿美元的答案。 给你带来麻烦的不是坏主意，而是好主意。因为如果一件事情是一个坏主意，你一定不会做过头。但是如果一件事情是一个好主意，你往往会做过头。——查理·芒格 为什么芒格投资哲学的文章极其关注”何时买“而极少关注”何时卖“的原因？ ”我们偏向于把大量的钱投放在我们不在用另外决策的地方。如果你因为一样东西被低估而购买了它，那么当它的价格上涨到你预期的水平的时候，你就必须要考虑卖掉它，那很难（参照上一条说的好事情）。但是，如果你能购买几个伟大的公司，那么你就可以安坐下来啦，这是很好的事情。 能力会让你到达巅峰，但是只有品德会让你停留在那里 ——林肯 投资和决策检查清单 风险：所有投资评估应该从测量风险（尤其是信用的风险）开始 测算合适的安全边际； 避免和道德品质有问题的人交往； 坚持为预定的风险要求合适的补偿； 永远记住通货膨胀和利率的风险； 避免犯下大错； 避免资本金持续亏损。 独立：“惟有在童话中，皇帝才会被告知自己没穿衣服” 客观和理性的态度需要独立思考； 记住，你是对是错，并不取决于别人同意你还是反对你——唯一重要的是你的分析和判断是否正确； 随大流只会让你往平均值靠近（只能获得中等的业绩）； 准备：“唯一的获胜方法是工作、工作、工作、工作，并希望拥有一点洞察力。” 通过广泛的阅读把自己培养成一个终生自学者； 培养好奇心，每天努力使自己聪明一点点； 比求胜的意愿更重要的是做好准备的意愿； 熟练地掌握各大学科的思维模型； 如果你想要变得聪明，你必须不停地追问的问题是“为什么，为什么，为什么”。 谦虚：承认自己的无知是智慧的开端 只在自己明确界定的能力圈内行事； 辨认和核查否定性的证据； 抵制追求虚假的精确和错误的确定性的欲望； 最重要的是，别愚弄你自己，而且要记住，你是最重要被自己愚弄的人。 严格分析：使用科学方法和有效的检验清单能够最大限度地减少错误和疏忽 区分价值和价格、过程和行动、财富和规模； 记住浅显的好过掌握深奥的； 成为一名商业分析家，而不是市场、宏观经济或者证券分析家； 考虑总体的风险和效益，永远关注潜在的二阶效应和更高层次的影响； 要朝前想、往后看——反过来想、总是反过来想。 配置：正确地配置资本是投资者最重要的工作 记住，最好的用途总是由第二好的用途衡量出来的（机会成本）； 好主意特别少——当时机对你有利时，狠狠地下赌注吧（配置资本）； 别“爱上”投资项目——即使你投入巨大心血，也要依情况而定，照机会而行。 耐心：克制人类天生爱行动的偏好 “复利是世界第八大奇迹”（爱因斯坦），不到必要的时候，别去打断它； 避免多余的交易税和摩擦成本，永远别为了行动而行动； 幸运来临时要保持头脑清醒； 享受结果，也享受过程，因为你活在过程当中。 决心：当合适的时机出现时，要坚决地采取行动 当别人贪婪时，要害怕；当别人害怕时，要贪婪； 机会来临的次数不多，所以当它来临时，抓住它； 机会只眷顾有准备的人：投资就是这样的游戏。 改变：在生活中要学会改变和接受无法消除的复杂性 认识和适应你身边的世界的真实本质，别指望它来适应你； 不断地挑战和主动地修正你“最爱的观念”； 正视现实，即使你并不喜欢它——尤其当你不喜欢它的时候。 专注：别把事情搞复杂，记住你原来要做的事 记住，声誉和正直是你最有价值的财产——而且能够在瞬间化为乌有； 避免妄自尊大和厌倦无聊的情绪； 别因为过度关系细节而忽略了显而易见的东西； 千万要排除不需要的信息 直面你的大问题，别把它们藏起来 终身学习 就算沃伦·巴菲特也不得不成为一部不断学习的机器。层次较低的生活也有同样的要求，我不断地看到有些人在生活中越过越好，他们不是最聪明的，甚至不是最勤奋的，但他们是学习机器，他们每天夜里睡觉时都比那天早晨聪明一点点。 再拿沃伦·巴菲特来说，如果你们拿着计时器观察他，会发现他醒着的时候有一半时间是在看书。他把剩下的时间大部分用来跟一些非常有才干的人进行一对一的交谈，有时候是打电话，有时候是当面，那些都是他信任且信任他的人。 芒格主义：查理的即使谈话","categories":[{"name":"阅读笔记","slug":"阅读笔记","permalink":"https://hasuer.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"投资","slug":"投资","permalink":"https://hasuer.github.io/tags/%E6%8A%95%E8%B5%84/"},{"name":"思维","slug":"思维","permalink":"https://hasuer.github.io/tags/%E6%80%9D%E7%BB%B4/"},{"name":"人生哲学","slug":"人生哲学","permalink":"https://hasuer.github.io/tags/%E4%BA%BA%E7%94%9F%E5%93%B2%E5%AD%A6/"}]},{"title":"被讨厌的勇气","slug":"被讨厌的勇气","date":"2021-03-15T11:31:41.000Z","updated":"2022-02-23T06:58:04.446Z","comments":true,"path":"被讨厌的勇气/index.html","link":"","permalink":"https://hasuer.github.io/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94/index.html","excerpt":"","text":"第一夜：我们的不幸是谁的错​ 在第一夜，年轻人认为每个人都期待改变，但是想要改变也无法改变。然而哲学家认为，人人都可以改变，并且获得幸福。 ​ 弗洛伊德式的原因论认为，人现在的状态是由过去的经历所所赋予的，但是阿德勒的心理学认为，决定我们自身的不是过去的经历，而是我们赋予自己经历的意义。直接来说，也就是，是我们自己选择了自己的生活，而不是由别人所赋予的。 ​ 有人也许会反驳这句话，比如“我们的出身，国家，周围环境都不是自己选择的，这是既定的。而且，这些都具有十分强大的影响力，我们也许会对这有不满，会羡慕他人的生活。很多人有时候其实相信自己的人身是由自己所决定的，但是一想到自己的起跑线和别人的不一样，或者差太多，会开始抱怨自己要付出更多的努力才能够赶上别人。在不断的抱怨中，没有付出努力，或者不愿意付出更多的努力。比如当你看到同学打游戏，看电视的时候，你也许会想，我都学习了一天了，也可以放松了，但是发现自己的起跑线落后于别人。这个时候如果你开始犹豫是娱乐还是继续学习，说明你还没有真正了解自己想要什么。 ​ 人们之所以无法改变，是因为自己下了“不改变”的决心。即使人们有着各种的不满意，但是还是认为保持现状更加轻松，更加安心。 ​ 所以一个人的不幸不是因为过去或者环境，更不是因为能力不足，只不过是缺乏勇气，缺乏 获得幸福的勇气。之前的人生发生过什么，都对于今后的人生没有影响。 第二夜：一切的烦恼都来自人际关系​ 人为什么会讨厌自己？哲人给出的理由是，因为自己 下定了“不要喜欢自己”的决心， 因为这对于那个人来说是一种“善”。不喜欢自己怎么会变成一种善呢？正是由于这个决心，为了达到不喜欢自己的目的，人才会只看到自己的缺点而不是优点。 ​ 不喜欢自己怎么会变成一种善呢？首先要明确的是，这种“善”只是对于个体而言的。当一个人下定决心不喜欢自己的时候，就会找到自己的缺点。由于人是社会性的动物，只要涉入人际关系就会或大或小的受伤，也会伤害别人，而这个青年找到自己的缺点以后，就会认为自己被人讨厌是因为这个缺点，如果没有这个缺点，我就会……他就开始生活在这个幻想之中，因为他不想接受当自己改正了自己的缺点之后，还是会被一些人讨厌的事实。而在这个幻想之中，他可以为所欲为，不用想这么多，所以这对于来说是一种善 ​ 再比如考生会想“如果考中的话，我的人生就会一片光明” 如果他为了逃避即使自己考上了前途也不一定会光明的事实，那他也许就会一直不付出行动，努力考上。这样的话一切就会归咎于，“如果我考上了….我就…..”这样的幻想中。 ​ 阿德勒心理学的一个基本概念是：人的烦恼来源于人际关系 ​ 当人们感到自卑的时候，其实是和他人的比较产生的，这种比较的基础就是你要是社会的“个人”，是社会关系的一个组成。此外，哲人认为自卑感都是由于自己主观臆造出来的。比如身高，身高矮很多人看来不好，但是换一个角度，小个子会降低对于他人的威胁感，能够更好的在社会中建立网络。我们无法改变客观事实，但是我们可以改变主观解释。 ​ 这里还要区别自卑感和自卑情结。人人都有自卑感，但是自卑感并不是坏事，它能够敦促人们进步。人生来是一种无力的状态，为了摆脱这种无力的状态，人们会有追求，当自己没有达到既定的目标或者做的没有别人好的时候就会产生自卑。自卑情结和自卑感没有过多的联系，自卑情结是指把自己的自卑感当作某种借口使用的状态。比如“我因为学历低所以无法成功”，“我不好看所以没有对象”等等。 ​ 不得否认的是“学历高有更大的成功的机会”，“长得好看，有更多的求偶机会”。在阿德勒看来，这是一种外部因果律：将原本没有任何因果关系的事情解释成似乎由重大的因果关系一样。当人们认为自己无法成功的时候，那不是“无法成功”，而是“不想成功”。也就是害怕前进或者不想真正的努力，不愿意为了改变自己而牺牲目前所享受的快乐——比如玩乐或者休闲时间。也就是拿不出改变的勇气。 ​ 自卑情结有时候会演变成为优越情结，”要不是我学历低，我就会成功，我只是被埋没的天才，真正的我其实很很优秀。”当人们有了自卑感，但是拿不出改变的勇气的时候，就会产生自卑情结，这个时候人们会想出比拥有改变的勇气更加简单的方法，就是优越情结：表现得自己很优秀，继而继续沉浸在一种虚假的优越感之中。 ​ 如果有人骄傲自大，一定是因为他有自卑感。 ​ 追求优越性是指不和其他人竞争，只要自己不断前进。有时我们会根据他人的和自己的差距来调整自己的目标，但是事实上，自己的目标还是理想中的自己，而不是别人。健全的自卑感不是来自于与别人的比较，而是与”理想的自己“作比较。哲人认为我们要把别人当作”伙伴“，而不是”竞争对手“，竞争对手之后会不知不觉的演变成为”敌人“，当你和他人是竞争的关系的时候，你会真心祝福比你幸福的人幸福吗？不太可能，因为这个时候，你就把自己放在了失败者的地位上。但是现实中，很多地方都存在竞争，比如企业之间的竞争，我们还常常提到良性竞争。我个人认为竞争存在是正常的，只不过不要生活在竞争中，所以我们常常说竞争伙伴，这也许和哲人说的有一点相通吧，但也不尽相同。 ​ 在人际关系中的权力之争中，无论认为自己多么正确，也不要一次为理由去责难对方。在人机关系中，一旦相信“我是正确的”，那就已经步入了权力之争 ​ 当人能够感觉到“与这个人在一起的时候可以无拘无束”的时候，才能够体会到爱。 我们讨厌一个人不是因为无法容忍一个人的缺点而讨厌他，而是你先有讨厌A的这个目的，之后找到了符合的缺点。 比如在恋爱或者夫妻关系中，过了某个时期之后，有时候对方的任何行为都会让你生气。吃饭的方式让你不满意，在房间里的散漫姿态让你生厌，甚至就连对方睡眠时候的呼吸声都让你生气，尽管几个月前还不是这样。这是因为那个人已经下定决心要“结束这段关系”，继而正在收集结束关系的证据，才会有那样的感觉。对方其实没有任何变化，只是自己的目的改变了。 第三夜：让干涉你生活的人见鬼去​ 自由是什么？是不再寻求认可吗？阿德勒心理学否定寻求他人的认可。这也就引申出我们是否要生活在他人的期待之中。 ​ 人们为什么要寻求他人的认可？其实，很多情况下都是受到赏罚教育的影响，阿德勒严厉批判这种赏罚式的教育。这样会产生一种错误的生活方式：“如果没有人表扬我，我就不去做好事，如果没有人惩罚我，我也可以做坏事。” ​ 要将课题分离，不要随意的干涉他人的课题。如何判断这是谁的课题呢?考虑一下这种选择带来的后果由谁来承担。 ​ 这一节讲到：关于自己的人生能够做的就是”选择自己认为最好的道路。另一方面，“别人如何评价你的选择，那是别人的课题，我们没有办法左右”.这里举了一个例子，父母对于你的工作，学习等等十分不顺心，对你大发雷霆，哲人的建议是不用去管这些事情，说的在直白一点就是，无论父母多么伤心都没有关系。这一点我看到的时候有点不太认同。 ​ 选择了不自由的生活方式的大人看着自由活在当下的年轻人就会批判他是享乐主义。当然这只是为了让自己接受不自由生活而捏造出的一种人生谎言 ​ 自由就是被人讨厌。获得幸福的勇气也包括被讨厌的勇气 第四夜：被讨厌的勇气​ 人际关系的起点是“课题分离”，终点是“共同体感觉”。共同体感觉是指“把他人看成朋友，并在其中能够感受到有自己的位置。 ​ 活在关系害怕的恐惧之中，那是为他人而活的不自由的生活方式。 ​ 阿德勒心理学反对体罚，也不认可表扬。因为当一个人对另一个人提出表扬的时候，无意之中营造出了一种上下级的关系，这是一种有能力者对于无能力者的评价。 ​ 阿德勒心理学反对一切“纵向关系”， 提倡把所有的人际关系都看作“横向关系”。人们为什么会有干涉他人生活的意愿？这是因为把人际关系看成了纵向关系，把对方看的比自己低，所以才会去干涉。 ​ 阿德勒心理学主张既不表扬也不批评。把这种基于横向关系的援助称为“鼓励”。被表扬会形成自己没有能力的潜意识。 ​ 用平等的关系来表达自己对于伙伴帮助的喜悦。或者用“我很高兴”这样的话来表达自己的喜悦。重要的是不要去评价他人。况且判断某种行为是好是坏是以他人的标准，如果渴望得到表扬，就相当于活在他人的期待之中。 前几天刚刚和四五岁的小侄女视频通话，她画了两幅画，是那种颜料涂满了画纸的，很用心。我说“你真棒”。现在看了这个章节以后，我在想这样说是否有点不妥？因为这样的表扬在生活中太常见了。我在想，如果我不这样说，我或许可以这样说：“画画的时候开心嘛？你觉得你画的怎么样呀？我看到你画画也很高兴!”这样的言语中没有评价，是在表达自己的喜悦之情，或许会好一点嘛？ ​ 但别人听到感谢之词的时候就会知道自己能够对别人有贡献。 ​ 书上说：人只有感觉自己有价值的时候才可以获得勇气。但是这是什么勇气呢？我还不太明白 ​ 哲人说：我们不要用”行为“标准而要用”存在”标准来看待他人。也就是说，当一个人存在的时候，他就是有价值的。即使是卧病在床的老人，他只要还活着就能让你感到舒心，这就是一种价值。 ​ 哲人说：我们在看带他人的时候，会先虚构一个对于自己来说的理想形象，然后在想做减法一样的去评价。例如，父母希望孩子学习，运动样样满分，考上好大学，进入好公司。和这样的理想孩子孩子相比，就会对自己的孩子产生种种不满。不要这样，不要将自己的孩子和其他人做比较。即使是一个在家中什么也不干的孩子，也要说谢谢。（没错，这是哲人的原话）如果孩子自己洗碗，你说“这种事就算了，还是去上学吧”，这就是按照理想的孩子去比较了。反而会挫伤孩子的勇气。对于这个，青年认为这是一种伪善，没有人能够做到。阿德勒对此的回应是：”必须得有人开始，即使其他人不合作，也和你没有关系。 ​ 我发现，当我在写“哲人说”的时候，好像就表示我对于这一部分的观点不太认同，要么是我还没有接受，要么是和我自己所接受的价值观有冲突，让我为难。 ​ 人与人之间要建立起横向的关系，纵向的关系会让自己不自觉的去纵向把握所有的人际关系。这里的横向关系，指的是相互平等，在意识上平等以及坚持自己的想法。 第五课：认真的人生”活在当下“​ 人们常常会受自我意识的羁绊，不能无拘无束的生活。原因在于人们不想在人际关系中被嘲笑，被瞧不起。但是自己一个人的时候，就不会有这种感觉。 ​ 也就是说不是本真的自我不存在，而是无法在人面前展露出来。 ​ 解决办法就是：把对于自己的执着，转换称为对于他人的关心，建立起共同体感觉。 ​ 具体方式是三点：自我接纳， 他者信赖， 他者贡献。 ​ 自我接纳：区别自我肯定和自我接纳。自我肯定是指：明明做不到但是还是暗示自己说“我可以”，“我能行”，这是一种容易导致优越情结的想法，是对自己撒谎的生活方式。自我接纳是指：假如做不到就诚实的接受这个做不到的事实，然后朝着能够做到的方向去努力。 ​ 要分清“能够改变”和“不能改变”的。 ​ 上帝，请赐予我平静，去接受我无法改变的；给予我勇气，去改变我能够改变的；赐我智慧，分辨这两者的区别。 ​ 他者信赖：区别信用和信赖。信赖是指相信他人的时候没有任何的附加条件。阿德勒心理学认为：信赖他人是你的事情，但是背叛与否是对方的课题，你只需要考虑“我该怎么做”。无条件信赖是搞好人际关系和构建横向关系的一种手段。如果不想和某个人搞好关系，就没有必要无条件信赖。 ​ 如果不敢去信赖别人，那最终就会与任何人都建立不了联系。 ​ 如何克服被他人背叛的恐惧感？自我接纳，知道自己什么能够改变，什么不可以。 ​ 他者贡献： 他者贡献并不是舍弃“我”而为他人效劳，他反而是为了能够体会到“我”的价值而采取的一种手段。 ​ 三者关系： ​ 正是因为接受了真实的自我，也就是自我接纳，才能够不惧背叛的做到他者信赖，而且正因为对他人给予无条件的信赖，并能够使他人为自己的伙伴才能够做到他者贡献。同时，正因为对他人有所贡献，才能够体会到我对他人有用，进而接受真实的自己，做到自我接纳。 ​ 对于人而言，最大的不幸就是不喜欢自己。 ​ 幸福就是贡献感，如果一个人不幸福就是没有获得幸福感。 ​ 在第三课中，我们提到“不可以寻求认可”。人们为什么想要寻求认可呢？人们想要喜欢自己，想要觉得自己有价值，为此就要拥有“我对他人有用”的贡献感，而获得贡献感的常见手段就是寻求他人认可。如果获得幸福感的常见手段一旦变成了“被他人认可”，最终就不得不按照他人的愿望来过自己的人生。通过认可欲获得的贡献感没有价值。因为我们选择在追求自由的同时追求贡献感。 ​ 哲人认为：如果能够真正获得贡献感，那就不在需要他人的认可。因为即使不特意去寻求他人的认可，也可以体会到“我对他人有用”。有了共同体感觉，认可欲求就会消失。 ​ 青年说：人生仅仅凭借他人贡献就能够感受到自己的价值吗？他认为人在这个世界上要留下一点什么。证明“我是独一无二的我”。他提出了自我实现式的幸福。哲人说，阿德勒心理学十分重视“甘于平凡的勇气”，没有必要特意炫耀自己的优越性。 ​ 哲人说，把人生当作登山的人其实把自己的人生看作了“一条线”。但是不要把人生看作一条线，而是点的连续。人生是连续的刹那。“一条线”是指自己的人生别规划昊了。看起来很有道理，但是哲人说：计划式的人生不是没有必要，而是不可能完成。因为人没有办法预料到自己的人生途上会发生什么。 ​ 青年认为哲人这是否认了人生的计划性。哲人说,人生就像是在每个瞬间不停旋转起舞的连续的刹那。只要跳着舞的此时此刻充实就够了。 潜在性人生：青年说的有目的的人生。也就是在没有达到目的的时候，人生都是不完整的。 现实性人生：把过程也看作结果的人生。比如旅行是从跨出家门就开始了的。每一个瞬间都是旅行。 ​ 之前提到过去的没有办法改变，现在哲人又提出现实性人生否定了计划性。青年看来这样的人生看不到过去，也看不到未来。哲人说，在舞台上，如果聚光灯很强的打在脸上，你会看不清第一排的人，如果灯光很弱，观众都能看得清楚。类比过来就是，如果你十分认真的活在当下，就是会看不到过去和将来。 ​ 认真的过好此时此刻，这本身就是在跳舞。 ​ 人生的最大的谎言就是不活在”此时此刻“ 【完结】","categories":[{"name":"阅读笔记","slug":"阅读笔记","permalink":"https://hasuer.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"心理学","slug":"心理学","permalink":"https://hasuer.github.io/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"},{"name":"心灵成长","slug":"心灵成长","permalink":"https://hasuer.github.io/tags/%E5%BF%83%E7%81%B5%E6%88%90%E9%95%BF/"},{"name":"哲学","slug":"哲学","permalink":"https://hasuer.github.io/tags/%E5%93%B2%E5%AD%A6/"}]},{"title":"刷题漏洞","slug":"刷题漏洞","date":"2021-03-14T03:13:48.000Z","updated":"2021-07-02T14:59:36.728Z","comments":true,"path":"刷题漏洞/index.html","link":"","permalink":"https://hasuer.github.io/%E5%88%B7%E9%A2%98%E6%BC%8F%E6%B4%9E/index.html","excerpt":"","text":"vector的sort方法123vector&lt;int&gt; test(n);sort(test.begin(), test.end()); // 正序sort(test.rbegin(), test.rend()); // 倒序 java中建立List 操作 Code 新建： List&lt;type&gt; fruit = new ArrayList&lt;type&gt;()；&lt;br /&gt;List&lt;type&gt; fruit = new LinkedList&lt;type&gt;()； 增 fruit.add(“Apple”);&lt;br /&gt;fruit.add(“Pear”); 删 fruit.remove(0); // 按照索引删、或者按照内容删除；&lt;br/&gt;fruit.remove(“Apple”); 改 fruit.set(1,”Banana”); 查 fruit.contains(“Pear”); Fruit.containsAll(fruit2); // Listfruit2 = new ArrayList&lt;&gt;(); fruit2.add(“Banana”); fruit2.add(“Apple”); java中sort用法点击查看链接 java 迭代器点击查看链接 java List 中取元素1234567List&lt;Interval&gt; interval = new ArrayList&lt;&gt;();interval.add((1,2));interval.add((2,3));interval.add((3,4));interval.add((4,5));int i = 0;Interval aa = interval.get(i); java 中 List 和 Array相互转换List -&gt; ArrayList 提供了toArray的接口，所以可以直接调用转为object型数组 12List&lt;String&gt; list = new ArrayList&lt;String&gt;();Object[] array=list.toArray(); 上述方法存在强制转换时会抛异常，下面此种方式更推荐：可以指定类型 1String[] array=list.toArray(new String[list.size()]); ​ 比如，我定义了一个Intervals的类： 123456789101112131415161718class Interval &#123; int start; int end; public Interval(int start, int end) &#123; this.end = end; this.start = start; &#125;&#125;public class IntervalsIntersection &#123; public static Interval[] merge(Interval[] arr1, Interval[] arr2) &#123; List&lt;Interval&gt; intervalsIntersection = new ArrayList&lt;&gt;(); return intervalsIntersection.toArray(new Interval[intervalsIntersection.size()]); &#125; // mian函数&#125; Array -&gt; List运用ArrayList的构造方法是目前来说最完美的作法，代码简洁，效率高： 1List&lt;String&gt; list = new ArrayList&lt;String&gt;(Arrays.asList(array)); ​ 比如，我定义了一个Intervals的类： 1234567891011121314151617181920212223class Interval &#123; int start; int end; public Interval(int start, int end) &#123; this.end = end; this.start = start; &#125;&#125;public class IntervalsIntersection &#123; public static Interval[] merge(Interval[] arr1, Interval[] arr2) &#123; List&lt;Interval&gt; intervalsIntersection = new ArrayList&lt;&gt;(); // List -&gt; Array return intervalsIntersection.toArray(new Interval[intervalsIntersection.size()]); &#125; public static void main(String[] args) &#123; // Array -&gt; List Interval[] input1 = new Interval[]&#123;new Interval(2, 3), new Interval(5, 6), new Interval(7, 9)&#125;; List&lt;Interval&gt; array = new ArrayList&lt;Interval&gt;(Arrays.asList(input1)); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://hasuer.github.io/categories/Algorithm/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hasuer.github.io/tags/Interview/"}]},{"title":"非暴力沟通","slug":"非暴力沟通","date":"2021-02-27T10:45:03.000Z","updated":"2022-02-23T06:58:56.818Z","comments":true,"path":"非暴力沟通/index.html","link":"","permalink":"https://hasuer.github.io/%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A/index.html","excerpt":"","text":"使用暴力的人是因为他们内心的宁静遭到了破坏，所以才会用暴力的方式来维护或寻求内心的和平 让爱融入生活 非暴力沟通使得我们不再条件反射地反映，而是去明了自己的观察，感受和愿望，有意识的使用语言。 非暴力沟通的四个要素：观察、感受、需要、请求 一位母亲对儿子说，“我看到咖啡桌下的脏袜子，我不太高兴，因为我看重整洁。””你是否愿意把袜子拿到房间或者是洗衣机。 是什么蒙蔽了爱 有些语言的表达方式虽然在致力于满足某种愿望，但是却忽视了人的感受和需要（异化的沟通方式） 有些沟通方式难以让人体会到爱 比如道德评判的沟通方式：如果一个人的行为不符合我们自己的价值观，我们就认为他是不道德的或者是邪恶的。这种道德评判的沟通方式实际上反映了自己的需要和价值观。 | 价值判断 | 道德评判 || —————————————————————————————— | —————————————— || 对于使用暴力来解决问题，我很担心，我主张通过其他方式来解决。（反映了自己的信念——生命需要怎样才能得到最好的满足。 | 暴力是不好的。杀人者是邪恶的 | 大多数暴力的根源在于人们忽视了彼此的需要 在哈佛大学的公开课 Justice中的第六讲提到了康德的道德观，康德认为真正的道德行为是纯粹基于义务而做的行为，而为实现某一个个人功利目的而做事情就不能被认为是道德的行为。 我们对于自己的思想、情感和行动负有责任。但是人们往往使用“不得不”或者“上级的要求”来回避责任。这个时候我们把自己看作是上级完成任务的一种手段。这种状态在康德看来是不自由的，因为我们没有尊重自己的基本权力，没有按照自己的意志来行动。（哈佛大学的公开课 Justice中的第六讲） 区分观察和评论 观察是非暴力沟通的第一要素. 不带评论的观察是人类智力的最高形式. 将观察和评论混为一谈,人们就会更加倾向于听到批评,并且反驳我们. 体会和表达感受 区分感受和想法:吉他弹得不好是想法,作为吉他手,我很失落,郁闷,厌烦 是 感受. 当我们在说”我觉得”的时候,我们更加表达出来的是想法,当我们把”我觉得“换成”我认为“也许会更好. 非暴力沟通的第二个因素是感受.通过建立表达感受的词汇表,从而使得沟通更加顺畅.在表达感受的时候,示弱有助于解决冲突. 简单来说,在表达感受的时候,我们要使用一些描述心情的词语.高兴,害怕等等. 感受的根源 听到不中听的话的四种选择： 责备自己 指责他人 体会自己的感受和需要 体会他人的感受和需要 对于他人的指责、批评、评论及分析反映了我们的需要和价值观。如果我们通过批评来提出自己的主张，对方往往会申辩或者反击，所以最好的方法就是直接说出自己的感受和需要。 当我们想利用对方的内疚时，我们通常会把自己不愉悦的感受归咎于对方。父母对孩子说:“你成绩不好，让爸爸妈妈伤心透了。”孩子看到了自己导致了父母的痛苦，出于愧疚，孩子会做出行为来迎合，但这不是出于热爱学习。 非暴力沟通强调，感受的根源在我们自己。所以我们可以通过“我（感到）……因为我……” 这种表达方式来认识感受和自身的关系。 “看到公司海报出现拼写错误，我很不高兴，因为我重视公司的形象。” “你没把饭吃完，妈妈感到失望。因为妈妈希望你能健康成长。” 但是社会环境一般不鼓励我们说出自己的需要。对妇女来说，尤其如此。因为她们的形象往往和无私奉献联系在一起—这可能也受到传统文化的影响。但是在我看来，即便社会文化不太鼓励，但是女性还是要说出自己的需要，因为这是个体的权利，当自己说出了自己的需要的时候，他人才更有可能满足你。 对于大多数人来说，个人的成长一般会分为三个阶段。 情感的努力：我们认为自己有义务使他人快乐 面目可憎时期：我们发现牺牲自己去迎合他人代价很大，所以这时我们拒绝考虑他人的感受和需要。 生活的主人：虽然我们对于自己的感受和意愿负有完全的责任和义务，但是我们无法为他人负责，也无法通过牺牲自己来满足他人。这个时候，我想作者是认为我们没有必要去迎合他人，但是也不能像 面目可憎时期去拒绝他人的感受和需要，这时应该既要充分表达自己的需要，也要理解他人的需要，并且组织语言，来找到平衡点。感觉就是，不要刻意的迎合他人，也要直接表达出自己的需要。 请求帮助 用什么样的方式提出请求容易得到积极的回应？ 提出具体的请求，当我们提出的请求不具体的或者请求他人不要干什么的时候，他人反而不会了解我们要什么，甚至会引起他人的反感（因为大多数人都会更加倾向于积极的回应要做什么，而不是不要做什么）。 不要使用经常这种不能界定发频率词语，具体到一周一次之类的。 比如妻子对丈夫说“我希望你每周有一天晚上在家陪我和孩子” 而不是说 “我希望你不要放太多时间在工作上” 比如在辩论前，“我”告诉自己“不要太激动” — 这只是告诉自己要避免什么，没有告诉自己要主动做什么。 如何区分请求和命令： 请求没有得到满足的时候，提出请求的人如果批评和指责，那就是命令 如果像利用对方的内疚来达到目的，也是命令。 一个例子：当母亲对孩子说：“当我看到你没有答应做你答应做的家务的时候，我十分失望。因为我希望回家以后有一个干净整洁的环境。”但是孩子什么都没有干，这时，母亲说“像你这样懒惰的人不会有什么大成就的” 由于我们所要表达的意思与别人的理解有可能不一致，所以我们要请求他人的反馈。否则，讨论可能会没有任何的用处。 当人们认为不答应我们的请求的时候就会受到惩罚，他们就会把我们的请求看作是命令。如果我们清楚的表达我们无意强人所难，也许大家就会认为我们提出的是请求而不是命令。 用全身心倾听 为了倾听他人，我们要先放下已有的想法和判断，全神贯注的体会对方。 然而，用全身心的倾听他人并不容易 如果一个人想要被人了解他的处境，听到的确实安慰和建议，那么，他就有可能感觉不舒服。 有哪些行为回妨碍我们体会他人的处境 建议：“我想你应该……” 比较：”这算不了什么，你听听我的经历……” 说教：“如果你这样做……你将回得到很大的益处” 安慰：“这不是你的错；你已经尽最大努力了……” 回忆：”这让我们想起，，“ 否定：”高兴一点，不要那么难过。“ 同情：”哦，你这个可怜的人……” 询问：”这种情况是什么时候开始的？“ 辩解：”我原想早点打电话给你，但是昨晚……” 纠正：“事情的经过不是那样的” 我们常常认为，当亲友感到痛苦的时候，我们应该想办法使他们好受一点。然而，急于采取行动使我们无法充分的体会到他们的状况。 倾听他人意味着放下自己所有的想法和判断，一心一意的体会他人。 要体会他人的感受和需要 “你感到不高兴，是因为你觉得我不理解你？”（这是在关心对方的想法） “你感到不高兴，是因为你需要得到理解？”（这是体会对方的需要） 在倾听他人的观察，感受，需要和请求以后，我们要主动表达我们的理解来确认是否理解了对方。 保持关注：也就是不断的给出反馈，是对方不断的表达自己的感受。当对方得到了充分的倾听的时候，我们将体会到气氛变得轻松，他也会停止谈话。 当我们痛苦的无法倾听他人的时候，我们需要： 体会自己的感受和需要 大声的提出请求 换一个环境 倾听的力量 如果有人倾听你，不对你评头论足，不替你担惊受怕，也不像改变你，这该多好啊。 在一个生气的人面前，永远不要用“不过”， “可是”， “但是”之类的词语。 当别人说“不”的时候，我们常常感觉自己受到了伤害。然而，如果我们能够体会他人的感受和需要，我们就能发现是什么使得他们无法答应我们的请求。 让谈话变得有趣：提醒说话的人留意自己的感受和需要。 打断别人比假装在听，更符合对方的愿望。所有人都希望自己的话对人有益，而不像被人当作负担。 爱自己 之前的章节都是在讲如何使用非暴力共同来完善和他人之间的关系。然而，非暴力沟通最重要的应用也许在于——爱护自己。 当我们给予自己负面评价或者习惯于将自己视为工具的时候——一个充满各种缺陷的工具，自我憎恨还奇怪吗？ 如何培养对于自己的爱？转变自我评价的方式 当我们表现的不完美的时候，我们会自责，让自己陷于自我憎恨之中。而无法从失误中获益 —— 失误揭示我们的局限性，并引导我们的成长。自责是尚未满足需要的可悲的表达 作者希望我们的改变是出于对于生命的爱，而不是出于愧疚或内疚这些具有负面影响的心理。 在外面的语言中，“应该”这个词常常引起我们的内疚和羞愧。“我应该早点知道” “我不应该在这样“ 当我们开始痛骂自己的时候，我们要注意到的是，自己有什么需要没有满足。要知道需要没有满足，这种遗憾在人生中是难免的，我没有必要责备自己。一旦专注于没有满足的需要，我们就要像办法去满足它。反之，如果用苛刻的语言指责自己，我们不仅难以找到解决的办法，也容易陷入自我惩罚的痛苦之中。 爱惜自己的关键之一是同时包容两个不同的我： 一方面是包容 对于过去行为感到后悔的我 一方面是包容 采取那种行动的我 当我们开始自责的时候，或许可以选择原谅自己。我们要意识到，尽管过去的选择不理想，但是它也是为了实现自己内心的渴望。 如果我们致力于满足他人及自己健康成长的需要，那么，即使艰难的工作也不乏乐趣。反之，如果我们的行为是出于义务，职责，恐惧，内疚和羞愧。那么即使是有意义的事情也会变得没有乐趣。 用”选择做”代替“不得不” 第一步：在生活中，你觉得哪些事情没有意思，但是又不得不去做，把他们写下来，记在纸上。 第二步：在每一件事的前面加上，我 我选择做。 第三步：解释原因。我选择做……，是因为我想要…… 做了上面的实验之后，在进一步深入了理解我们的动机是什么。一般来说动机如下，但是这些动机是不太健康 的。 为了钱。在非暴力沟通中，钱并不被认为是一种“需要”；他只是被用来满足某一种需要的无数种策略中的一种。 为了得到赞同。我们小时候，家长总会因为我们做了好事而又奖励，做了坏事，就要受到惩罚。于是，等到我们长大之后，我们就会误认为生命的意义就是为了获得奖励，渴望得到他人的赞赏。为了得到赞赏，我们会委曲求全。实际上，如果我们的行为都是出于对于生命的热爱，人们自然会感激，这时我们体会到的快乐是无与伦比的。 为了逃避惩罚。文中举的例子是纳税，但是目前我还没有这个顾虑哈哈哈。 不想感到羞愧 为了避免内疚不做一些事情，我们担心没有办法满足其他人的期待。 为了履行职责“不得不，应当，必须，不能” 当我们评价自己的行为的时候，我们专注于自己尚未满足的需要，这样我们就不会因为羞愧沮丧来寻求改变。 充分表达愤怒 当我们生气的时候，不要自己生气归咎于他人，这样我们就难免会去指责他人。然而，实际情况是我们的心情并不取决于他人。 当我们生气的时候，是因为我们的需要没有满足。当我们约会的时候，对方来晚了，如果你看重的是诚实守信，那你可能会开始生气了，但是如果这个时候你刚好想要休息一会，你也许就不会感到生气了。 愤怒的核心是自己的需要没有得到满足。 愤怒驱使我们去惩罚他人而不是去满足需要。 用 我生气是因为我需要…… 来代替 我生气是因为他们做了什么….. 表达愤怒的四个步骤： 停下来，除了呼吸，什么都别做 想一想是什么想法使我们生气了 体会自己的感受和需要 表达感受和尚未满足的需要 在3 和 4中要先倾听别人。 运用强制力避免伤害 我们运用强制力是出于防卫的目的，而不是出于惩罚他人的目的。 在实际生活中，惩罚往往加强了对方的敌意和抵触心理，使双方的关系更加疏远。 体罚的类型： 肢体暴力：打屁股 语言暴力：骂自私等等 体罚从某种程度上来讲是，是在鼓励孩子可以使用暴力解决问题。 惩罚的代价：就是让我们树立敌人，当我们被认为是施暴者的时候，我们就很难得到友善的回应。 重获生活的热情 一般来说，我们的文化倾向于把个人需要看作是消极的，具有破坏性的。如果一个人公开表达自己的需要，就很有可能被认为是自私的，非暴力沟通帮助我们认识倒是社会文化对于个体的消极影响。一旦认识到社会文化的局限性，我们就有可能突破他的束缚，至少，我们迈出了关键的一步。 很多时候，我们感到沮丧是因为我们出于激烈的内心冲突之中。一种声音告诉自己“我要这样做”，另一种声音说“不， 你不应该这样做。”。沮丧意味着我不知道自己想要什么，自己的需要到底是什么？ 小结：当情绪低落的时候，我们也许会怨天尤人。然而，无论我们以苛刻的态度对人对己，自己的心情也不会有所改变。我们要发现自己的需要，并且采取积极的行动。（好抽象的感觉） 表达感激 很多时候，在赞扬他人的时候，我们很少揭示内心活动，而是把自己放在了裁判的位置。所以，作者认为，赞扬并不总是有助于升华彼此的联系。 看到这句话的时候，我豁然开朗。之前在一段感情的时候，我总是会认为赞扬她做的每一件事是好的，即使有时候我不了解她做的事情或者是我不太喜欢，不太认可的时候。我没有说出自己内心真实的想法，而是用赞扬代替了。 非暴力沟通表达感激的三要素： 对方做了什么事情使得我们的生活得到改善（心灵上也可以） 我们有哪些需要得到了满足 我们的心情怎么样 当别人向你表达很笼统的感激的时候（你真了不起，你聪明过人），我们可以用上面的三个要素来问对方为何给出这样的评价。 听到对方的感激的时候，我们有时候会觉得变扭，因为我们不知道自己是都真的这么好。甚至，我们还会对自己有所期待。 当我们听到别人对于自己的表扬的时候，我们常常有两种反映： 自我膨胀，认为自己比别人优秀 假谦虚，否定别人的赞赏，说”哦，这没什么“ 我们听到赞扬之后，我们可以和对方一起庆祝生命之美——不自大，也不要假谦虚。 时刻提醒自己不要假谦虚：当代作家玛丽安威廉斯说：”我们最大 的恐惧不是我们不够完美，我们最大的恐惧而是我们无比强大，缩小自己，好让周边的人不会觉得不自在，这不明智。因为我们生下来就是为了能够彰显内在的光芒。当我们让自己的光芒闪耀的时候，无意之中也允许了他人散发光芒。” 所有人对于渴望感激，但是很多时候，人们往往会记住别人对于自己的抱怨而不是感激。 这大概是我唯一记录下的这本书中的一个例子，看完之后很有感触，但是说不出来： 有一位老师的学生，因为没有做好考试准备，在一次考试中写上名字交了白卷。当卷子发下来的时候，学生很惊讶，他发现他自己得了14分（满分100）。于是他问老师：“我怎么会有14分呢？” 老师回答说：“整洁”。 很多时候，人们往往会记住别人对于自己的抱怨而不是感激。如果老师看到的只是空白而十分生气，把孩子教训了一顿，于事无补，孩子可能还会对于学习没有热情，或者是出于内疚学习，这不是出于真正的热爱。但是老师这样说，我相信这个孩子会发自内心开始好好复习，下次不会发生这样的事情。","categories":[{"name":"阅读笔记","slug":"阅读笔记","permalink":"https://hasuer.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"心理学","slug":"心理学","permalink":"https://hasuer.github.io/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"},{"name":"人际关系","slug":"人际关系","permalink":"https://hasuer.github.io/tags/%E4%BA%BA%E9%99%85%E5%85%B3%E7%B3%BB/"},{"name":"沟通","slug":"沟通","permalink":"https://hasuer.github.io/tags/%E6%B2%9F%E9%80%9A/"}]},{"title":"富爸爸穷爸爸","slug":"富爸爸穷爸爸","date":"2021-02-18T08:21:30.000Z","updated":"2022-02-23T06:59:12.079Z","comments":true,"path":"富爸爸穷爸爸/index.html","link":"","permalink":"https://hasuer.github.io/%E5%AF%8C%E7%88%B8%E7%88%B8%E7%A9%B7%E7%88%B8%E7%88%B8/index.html","excerpt":"","text":"课程 今天，您所给孩子的最坏的建议就是：去学校，好好念书，然后找一个安全的工作。这是旧的建议，而且是坏的建议。 鼓励孩子成为雇员，就是建议你的孩子在他的一生中缴纳超过他们应付的份额的税，只是得到很少而不确定的养老金。 穷人和破产者的区别是：破产时暂时的，而贫穷是永久的 穷人和中产阶级为钱而工作，富人让钱为他们工作 资产是把钱拿到你口袋了里的东西，而负债是把钱从口袋拿出来的 剑：武器；宝石：财富；镜子：自知 穷爸爸 富爸爸 找一个安稳的工作 学会钱的运作规律 富人买入资产，穷人只有支出，中产阶级买入他们以为是资产的负债 几种资产： 不需要我到场也可以运营的业务。 股票，债券，基金，房地产，专利 做一个努力工作的雇员，确保你的工作，但是要不断构筑资产 奢侈品是对于投资和资产收入的奖励。而不是用自己的血汗钱去买。 税最初只是针对富人。纳税的方法是由大众制定的并经多数人同意，它要让穷人和中产阶级看到税收是为了惩罚有钱人，因此，大众投了赞同票，并将依法纳税写入了宪法。而初衷是惩罚有钱人的税收，在现实中却惩罚了对它投赞同票的中产阶级和穷人。 风险无处不在，要学会驾驭风险，而不是一味的回避。 有一个古老的格言:“工作就是比破产强一点” 穷爸爸希望我有所专长，但是富爸爸希望我能够“培养”自己 克服困难 当人们有了财务知识的时候也许还是无法积累资产，原因如下： 恐惧心理：还怕失去金钱 方法：早点积累自己的钱 富爸爸经常告诉我和迈克，在财务上不能获得成功的最大原因是大部分人的做法过于安全。“人们因为太害怕失败,所以才会失败。”这是他常说的话。 胜利意味着不害怕失败 在我的生活中，我注意到失败常常伴随着成功。在我最终学会骑自行车之前,我曾经跌倒过许多次，我从来没有遇到过不曾打丢球的高尔夫球手,也从未见过不曾伤心过的恋人更未曾见过从不损失金钱的富人。 人人都想上天堂，但是没有人想死 成功者在最初都不是追求平衡的，如果一开始就追求平衡，那么就是原地踏步。 积聚资产项目非常容易,这就好比是玩一场低智能游戏,不需要受到很多教育,五年级数学水平就够了。然而,将资产用于投资却是一种高智商游戏,它需要胆量、耐心和对待失败的良好态度。失败者回避失败,而失败本来是可以使失败者转变为成功者的。 克服愤世嫉俗的心理 愤世嫉俗：意思是有正义感的人对黑暗的现实社会和不合理的习俗表示愤恨、憎恶。 当自己感到不安还害怕的时候就会开始怀疑自己 愤世嫉俗者从来不会赢，未证实怀疑和恐惧会产生愤世嫉俗者，愤世嫉俗者抱怨现实，而成功者分析现实 懒惰 方法：要“贪婪”一点，勇敢追求自己想要的生活。问自己，我应该得到什么？ 习惯 富爸爸总是最后在月末付账单，先投资自己，这样迫于压力就不得不找更多的方式去赚钱。 傲慢，傲慢是无知的另一面 很多人用傲慢来掩饰自己的无知 在资金、金融和投资领域，有许多人完全不知道自已在谈论什么。财经行业的大部分人喜欢滔滔不绝地夸夸其谈，其实他们并没有什么真才实学。 如果你知道自己在某一问题上欠缺知识，不要试图掩饰,因为那是在欺骗你自己,你应该做的是去找一位这一领域的专家或者找一本有关这一问题的书,马上开始教育自己。 开始行动 十种方法唤醒自己的理财天赋： 一个超现实的理由 — 精神的力量 “想要”和“不想要”的结合 我不想一生都工作，不想一直是一个打工仔；想要周游世界，想要财务自由等等 给自己强有力的理由 选择的力量 事实上我们每天都应该进行一个选择:即选择如何利用自己的时间、自己的金钱以及我们头脑里所学到的东西去实现我们的目标，这就是选择的力量。 当你是一个穷人时，你唯一拥有的资产就是自己的大脑。 骄傲自大和吹毛求疵的人往往是缺乏自信和不敢冒险的人。 慎重的选择朋友 财务情况不是交友的唯一标准，三人行必有我师 但是要注意，不要听胆小的人的话，否则你也会变得杞人忧天 在积累财富的过程中，最困难的事莫过于坚持自己的选择而不盲目从众。 掌握一种模式，然后再学习一种新的模式 在今天这个快速变化的世界中，并不要求你去学太多的东西，因为当你学到时往往已经过时了，问题在于你学得有多快，也就是我前面所说的要具备快速学习的能力,这种技能是无价之宝。如果你想赚到钱,寻找一条捷径是非常关键的。为金钱而工作是人类在穴居时代产生的一个公式,它早已过时了。 投资自己：自律的力量 是否缺乏自律是富人，穷人和中产阶级区分开来的首要因素。 再支付每月支出之前，先把钱安排在自己的资产项目上。 当我偶尔资金短缺时,我仍然首先支付自己。我宁愿让债权人和政府高声喊叫，他们越着急我越高兴。为什么?因为这些人在为我摇旗呐喊，他们在激励我出去挣更多的钱。 不要背上数额过大的债务包袱。要使自己的支出保持低水平。首先增加自己的资产，然后，再用自己的资产中产生的现金流购买大房子或好车子。 当你资金短缺时，去承受外在压力而不要动用你的储蓄或投资,利用这种压力来激发你的财务天赋,想出新办法挣到更多的钱，然后再支付账单。这样做,不但能提高你赚钱的能力,还能提高你的财商。 穷人有不好的习惯，一全普遍的坏习惯是随便“动用储蓄”。富人知道储蓄只能用于创造更多的钱,而不是用来支付账单。 致富不以牺牲舒适生活为代价，用储蓄支付账单。 给你的经纪人优厚的报酬 我们生活在信息时代，信息是无价的。一位好的经纪人应该给你提供信息,同时还应花时间来教育你。 做一个“印第安给予者“ 投资 $\\rightarrow$ 盈利 $\\rightarrow$ 撤回本金$\\rightarrow$继续盈利 要学会止盈，不要贪婪，要自律 资产用来购买奢侈品 奢侈品是对自己的奖励 对英雄的崇拜 读相关领域中优秀者的书籍，并且在相关领域刻意模仿。 先付出再收获：给予的力量 一些事情 对于要开始付出实践的人的，有几点建议： 停下手中的活：放弃无效的事情 寻找新思想：去找新的思想，并且付出行动 找一个做过你想做的事的人，找他共进午餐 参加辅导班并购买相关磁带 提供多个报价：寻找 $\\rightarrow$ 报价 $\\rightarrow$ 还价 $\\rightarrow$ 谈判 $\\rightarrow$ 拒绝或接受 在合同上写“需要我的商业伙伴同意”，即使你没有商业伙伴。这样当他人接受了你的报价以后，可以方便你拒绝（当你反悔的时候） 消费者总是穷人：哪些在超市打折的时候冲进去买东西的人往往在股市下跌的时候下车。 行动者总会击败不行动者。 结束语 金钱是一种思想，如果你想要钱，只要改变自己的思想。","categories":[{"name":"阅读笔记","slug":"阅读笔记","permalink":"https://hasuer.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"投资理财","slug":"投资理财","permalink":"https://hasuer.github.io/tags/%E6%8A%95%E8%B5%84%E7%90%86%E8%B4%A2/"},{"name":"财商","slug":"财商","permalink":"https://hasuer.github.io/tags/%E8%B4%A2%E5%95%86/"},{"name":"思维模式","slug":"思维模式","permalink":"https://hasuer.github.io/tags/%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%BC%8F/"}]},{"title":"latex转换markdown","slug":"latex转换markdown","date":"2021-02-14T13:04:11.000Z","updated":"2021-02-14T13:05:52.788Z","comments":true,"path":"latex转换markdown/index.html","link":"","permalink":"https://hasuer.github.io/latex%E8%BD%AC%E6%8D%A2markdown/index.html","excerpt":"","text":"首先安装pandoc install pandoc into your system到你的电脑 以windows为例输入如下指令 12cd tex文件所属的目录pandoc -s tex文件名.tex -o md的文件名.md","categories":[{"name":"tips","slug":"tips","permalink":"https://hasuer.github.io/categories/tips/"}],"tags":[]},{"title":"人类简史","slug":"人类简史","date":"2021-02-14T11:57:18.000Z","updated":"2022-02-23T06:59:19.112Z","comments":true,"path":"人类简史/index.html","link":"","permalink":"https://hasuer.github.io/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2/index.html","excerpt":"","text":"","categories":[{"name":"阅读笔记","slug":"阅读笔记","permalink":"https://hasuer.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"社会","slug":"社会","permalink":"https://hasuer.github.io/tags/%E7%A4%BE%E4%BC%9A/"},{"name":"人类史","slug":"人类史","permalink":"https://hasuer.github.io/tags/%E4%BA%BA%E7%B1%BB%E5%8F%B2/"},{"name":"历史","slug":"历史","permalink":"https://hasuer.github.io/tags/%E5%8E%86%E5%8F%B2/"}]},{"title":"改变vscode默认代码格式","slug":"改变vscode默认代码格式","date":"2021-01-23T14:25:51.000Z","updated":"2021-04-23T14:31:29.580Z","comments":true,"path":"改变vscode默认代码格式/index.html","link":"","permalink":"https://hasuer.github.io/%E6%94%B9%E5%8F%98vscode%E9%BB%98%E8%AE%A4%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F/index.html","excerpt":"","text":"本文主要解决了vscode 默认代码格式大括号换行的问题 打开Vscode setting 搜索clang,并做如下修改：","categories":[{"name":"Vscode tips","slug":"Vscode-tips","permalink":"https://hasuer.github.io/categories/Vscode-tips/"}],"tags":[]},{"title":"Matlab_plot","slug":"Matlab_plot","date":"2021-01-22T05:52:17.000Z","updated":"2021-01-22T05:58:32.667Z","comments":true,"path":"matlab-plot/index.html","link":"","permalink":"https://hasuer.github.io/matlab-plot/index.html","excerpt":"","text":"Matlab 画柱状图、饼图、折线图12345678910111213141516171819202122232425262728293031323334353637383940414243TBdata = [1990 4889 16.4; 1991 5273 17.4; 1992 5382 17.4; 1993 5173 16.5;1994 4860 15.4; 1995 4675 14.7; 1996 4313 13.5; 1997 4059 12.5;1998 3855 11.7; 1999 3608 10.8; 2000 3297 9.7; 2001 3332 9.6;2002 3169 9.0; 2003 3227 9.0; 2004 2989 8.2; 2005 2903 7.9;2006 2779 7.4; 2007 2725 7.2];measles = [38556 24472 14556 18060 19549 8122 28541 7880 3283 4135 7953 1884]&#x27;;mumps = [20178 23536 34561 37395 36072 32237 18597 9408 6005 6268 8963 13882]&#x27;;chickenPox = [37140 32169 37533 39103 33244 23269 16737 5411 3435 6052 12825 23332]&#x27;;years = TBdata(:, 1);cases = TBdata(:, 2);rate = TBdata(:, 3);% Create the pie chart in position 1 of a 2x2 gridfiguresubplot(2, 2, 1)pie([sum(measles) sum(mumps) sum(chickenPox)], &#123;&#x27;Measles&#x27;, &#x27;Mumps&#x27;, &#x27;Chicken Pox&#x27;&#125;)title(&#x27;Childhood Diseases&#x27;)% Create the bar chart in position 2 of a 2x2 gridsubplot(2, 2, 2)bar(1:12, [measles/1000 mumps/1000 chickenPox/1000], 0.5, &#x27;stack&#x27;)xlabel(&#x27;Month&#x27;)ylabel(&#x27;Cases (in thousands)&#x27;)title(&#x27;Childhood Diseases&#x27;)axis([0 13 0 100])set(gca, &#x27;XTick&#x27;, 1:12)% Create the stem chart in position 3 of a 2x2 gridsubplot(2, 2, 3)stem(years, cases)xlabel(&#x27;Years&#x27;)ylabel(&#x27;Cases&#x27;)title(&#x27;Tuberculosis Cases&#x27;)axis([1988 2009 0 6000])% Create the line plot in position 4 of a 2x2 gridsubplot(2, 2, 4)plot(years, rate)xlabel(&#x27;Years&#x27;)ylabel(&#x27;Infection Rate&#x27;)title(&#x27;Tuberculosis Cases&#x27;)axis([1988 2009 5 20])","categories":[{"name":"Matlab","slug":"Matlab","permalink":"https://hasuer.github.io/categories/Matlab/"}],"tags":[]},{"title":"PA3实验报告","slug":"PA3实验报告","date":"2021-01-16T05:48:27.000Z","updated":"2021-01-18T03:20:19.517Z","comments":true,"path":"pa3实验报告/index.html","link":"","permalink":"https://hasuer.github.io/pa3%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/index.html","excerpt":"","text":"实验进度 序号 是否已完成 必做任务1 √ 必做任务2 √ 必做任务3 √ 必做任务4 √ 选做任务1 √ 选做任务2 √ 选做任务3 √ 思考题1GDT有多大？ 段寄存器中用作GDT表下标的位段宽度是13位，所以GDT中可以有2^13=8192个描述项。 每个进程都要在全局段描述表GDT中占据两个表项 每个进程的局部段描述表LDT都作为一个独立的段而存在，在全局段描述表GDT中要有一个表项指向这个段的起始地址，并说明该段的长度以及其他一些 参数。除上之外，每个进程还有一个TSS结构(任务状态段)也是一样。所以，每个进程都要在全局段描述表GDT中占据两个表项。 思考题2GDTR中存放的GDT首地址可以是虚拟地址吗？ 不可以，因为GDT的转换规则就是在GDRT中读出段的首地址，根据段寄存器中的选择符index位在表中进行索引 位在表中进行索引 , 找到一个段描述符 。在段描述符中读出的基地址和虚拟地址相加 , 得出线性地址 。 虚拟地址就是需要通过GDT进行转换来映射到物理地址，所以GDT的首地址一定要是物理地址，不然在不同的工作环境中就使用相同的GDT机制的出来的结果是不相同的。 思考题３如何提高寻找段描述符的效率? 在段寄存器中保存基地址，之后在进行访问的时候采用映射的方法，基地址加上偏移量找到。 思考题４段式存储管理的缺点 段的体积大，在内存中无法做到连续存储，容易形成外碎片，降低内存利用率。 思考题５页式存储管理的优点 分页式管理便于进行内存调度，可以有自己的调度算法 并且没有外碎片，内碎片不超过页的大小 思考题６问题1： 因为低12位是页内偏移，可以直接根据虚拟地址给出，不需要进行转换。 问题2： 是必须的。和问题2一样，CR3是用于物理地址转换的，如果它也是虚拟地址就没有什么可以转换CR3的线性地址了。 问题3 一级页表有占用内存过多的缺点。多级页表能够有效的减少内存的占用，虽然看上去消耗内存反而增大了，但是实际上很多对应页表没有用到，并没有实际创建因而减小了内存。 思考题７空指针真的是空的吗？ 空指针并不是空的，只是指向的地址是０，属于操作系统无法访问。 思考题８在扁平模式下如何访问？ 在页表项中有权限位，进行地址转换时首先检查权限位，倘若没有权限就无法访问，也就不会有地址转换的步骤了。 思考题９ 第一个矩形表示的是虚拟地址，虚拟地址中包含了页内偏移和页号，在通过页号来找到对应页表项，在页表项中读取出页框号，将页框号和页内偏移合并到一起成为了实际地址。 思考题10示例代码哪里错了？ 原本的最后 ptable 会到负数，ptable [-1]。 思考题11问题１ 因为这里定义的ｘ生成的地址是虚拟地址，超过了物理地址的界限，报错说 0xc014a000 outside of the physical memory.而kvm.c 中的虚拟地址都经过了 va_to_pa 的转换，在物理地址范围之内 问题2 两个虚拟地址指向同一个物理地址是因为在 0xc0100000 上的在 init 中作为今后访问内核的虚拟地址 问题3 两个虚拟地址指向同一个物理地址是因为在 0xc0100000 上的在 init 中作为今后访问内核的虚拟地址，另一份在 updir 没有正常使用时让虚拟地址得以正常转换。 问题4 出现了 present = 0 的错误。因为开启 paging 位之后，所有地址都需要进行虚拟地址转换，而 esp 还是使用开始的物理地址发现这个虚拟地址下并没有使用。 问题5 出现的问题和上面相同，使用 init_cond () 会先 push 再 jmp, 之后又会通过 ret 进行返回。通过调试得到是在 loader 中出现问题的，而在 lnaddr_read 和 lnaddr_write 处监视发现对应栈的位置也只读写了一次。只能推测是因为将地址压入栈导致栈溢出 心得体会 这个实验中包含了考试周，所以在内容的衔接上有点不流畅，在本学期的操作系统课程中也正好学习了分页分段。 在这个实验中，对于分页和分段的代码实现有了更加深刻的理解。 此外就是nemu实在太难了，有一些代码抄了都不是很懂，哎，菜是原罪。 出bug不可怕，如果能通过debug的过程对框架代码和计算机系统的原理有更深刻的理解，。","categories":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://hasuer.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"NEMU实验","slug":"NEMU实验","permalink":"https://hasuer.github.io/tags/NEMU%E5%AE%9E%E9%AA%8C/"}]},{"title":"MIT 6.828 Homework_BigFilesForXV6","slug":"MIT 6.828 Homework_BigFilesForXV6","date":"2020-12-29T03:12:06.000Z","updated":"2020-12-29T11:20:23.661Z","comments":true,"path":"mit-6-828-homework-bigfilesforxv6/index.html","link":"","permalink":"https://hasuer.github.io/mit-6-828-homework-bigfilesforxv6/index.html","excerpt":"","text":"实验指导书 MIT 6.828 Operating System Engineering Big Files实验目的在这个作业中，您将增加xv6文件的最大大小。目前，xv6文件被限制为140个扇区，或71680个字节。这个限制来自于这样一个事实:xv6 inode包含12个“直接”块号和一个“单间接”块号，即一个块最多可以包含128个块号，总共是12+128=140。您将修改xv6文件系统代码，以支持每个inode中的“双间接”块，它包含128个单间接块的地址，每个块最多可以包含128个数据块的地址。结果是，一个文件将能够包含16523个扇区(或大约8.5兆字节)。 实验内容修改你的Makefile中的cpu定义，使其如下: cpu: = 1 add QEMUEXTRA = -snapshot right before QEMUOPTS 当xv6创建大文件时，以上两个步骤极大地加快了qemu的速度。 实验步骤 修改 param.h将#define FSSIZE 1000 // size of file system in blocks 修改为#define FSSIZE 20000 // size of file system in blocks 添加 big.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &quot;types.h&quot;#include &quot;stat.h&quot;#include &quot;user.h&quot;#include &quot;fcntl.h&quot;intmain()&#123; char buf[512]; int fd, i, sectors; fd = open(&quot;big.file&quot;, O_CREATE | O_WRONLY); if(fd &lt; 0)&#123; printf(2, &quot;big: cannot open big.file for writing\\n&quot;); exit(); &#125; sectors = 0; while(1)&#123; *(int*)buf = sectors; int cc = write(fd, buf, sizeof(buf)); if(cc &lt;= 0) break; sectors++; if (sectors % 100 == 0) printf(2, &quot;.&quot;); &#125; printf(1, &quot;\\nwrote %d sectors\\n&quot;, sectors); close(fd); fd = open(&quot;big.file&quot;, O_RDONLY); if(fd &lt; 0)&#123; printf(2, &quot;big: cannot re-open big.file for reading\\n&quot;); exit(); &#125; for(i = 0; i &lt; sectors; i++)&#123; int cc = read(fd, buf, sizeof(buf)); if(cc &lt;= 0)&#123; printf(2, &quot;big: read error at sector %d\\n&quot;, i); exit(); &#125; if(*(int*)buf != i)&#123; printf(2, &quot;big: read the wrong data (%d) for sector %d\\n&quot;, *(int*)buf, i); exit(); &#125; &#125; printf(1, &quot;done; ok\\n&quot;); exit();&#125; 修改 Makefile在UPROGS中添加一行_big\\ inode 数据结构在Xv6系统中，每一个文件都有一个对应的inode。 可以看出，一个inode有12个direct指针，它们指向磁盘中的数据块，还有一个indirect指针指向另一个indirect block，这个indirect有BSIZE / sizeof(uint) = 128个指针指向数据块。因此，一个inode可以指向12+128 = 140个数据块。也就是运行了big命令后输出的140 sectors。 修改 fs.c修改bmap()函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657static uintbmap(struct inode *ip, uint bn)&#123; uint addr, *a, *indirect, *double_indirect,indirect_idx, double_indirect_idx; struct buf *bp, *bp2; if(bn &lt; NDIRECT)&#123; if((addr = ip-&gt;addrs[bn]) == 0) ip-&gt;addrs[bn] = addr =balloc(ip-&gt;dev); return addr; &#125; bn -= NDIRECT; if(bn &lt; NINDIRECT)&#123; // Load indirect block, allocating ifnecessary. if((addr = ip-&gt;addrs[NDIRECT]) == 0) ip-&gt;addrs[NDIRECT] = addr =balloc(ip-&gt;dev); bp = bread(ip-&gt;dev, addr); a = (uint*)bp-&gt;data; if((addr = a[bn]) == 0)&#123; a[bn] = addr = balloc(ip-&gt;dev); log_write(bp); &#125; brelse(bp); return addr; &#125; bn -= NINDIRECT; if (bn &lt; NINDIRECT*NINDIRECT) &#123; // Load first indirect block, allocating ifnecessary. if((addr = ip-&gt;addrs[NDIRECT + 1]) == 0) ip-&gt;addrs[NDIRECT + 1] = addr =balloc(ip-&gt;dev); bp = bread(ip-&gt;dev, addr); indirect = (uint *) bp-&gt;data; indirect_idx = bn / NINDIRECT; if ((addr = indirect[indirect_idx]) == 0) &#123; addr = indirect[indirect_idx] =balloc(ip-&gt;dev); log_write(bp); &#125; bp2 = bread(ip-&gt;dev, addr); double_indirect = (uint *) bp2-&gt;data; double_indirect_idx = bn % NINDIRECT; if((addr = double_indirect[double_indirect_idx]) == 0) &#123; addr =double_indirect[double_indirect_idx] = balloc(ip-&gt;dev); log_write(bp2); &#125; brelse(bp2); brelse(bp); return addr; &#125; panic(&quot;bmap: out of range&quot;); 修改 fs.h将#define NDIRECT 12 修改为#define NDIRECT 11 将uint addrs[NDIRECT+1]; // Data block addresses 修改为uint addrs[NDIRECT+2]; // Data block addresses 将#define MAXFILE (NDIRECT + NINDIRECT) 修改为#define MAXFILE (NDIRECT + NINDIRECT + NINDIRECT * NINDIRECT) 结果","categories":[],"tags":[]},{"title":"MIT 6.828 Homework_Locking","slug":"MIT 6.828 Homework_Locking","date":"2020-12-29T02:50:47.000Z","updated":"2020-12-29T11:20:11.740Z","comments":true,"path":"mit-6-828-homework-locking/index.html","link":"","permalink":"https://hasuer.github.io/mit-6-828-homework-locking/index.html","excerpt":"","text":"[实验指导书]https://pdos.csail.mit.edu/6.828/2018/homework/xv6-lock.html) MIT 6.828 Operating System Engineering Locking实验目的在这个作业中，你将探索中断和锁定之间的一些交互。 实验内容锁的结构阅读 spinlock.h ，锁的结构如下： 12345678910// Mutual exclusion lock.struct spinlock &#123; uint locked; // Is the lock held? // For debugging: char *name; // Name of lock. struct cpu *cpu; // The cpu holding the lock. uint pcs[10]; // The call stack (an array of program counters) // that locked the lock.&#125;; spinlock 结构体中 locked 作为标识位， locked = 1 则为上锁，否则已经释放锁 阅读 xv6 下 spinlock.c，知道 xv6 提供 acquire() 用于获取锁， release() 用于释放锁 acquire()中首先通过pushcli()关闭中断并记录关闭中断次数：获取当前eflags中IF位，并保存到mycpu()-&gt;intena中；随后增加中断次数mycpu()-&gt;ncli 一般而言需要先通过判断锁的状态然后再上锁，由于上面两个步骤不是同时进行，假设线程 P 执行到 while 循环，锁没被占用，此时在没改变锁状态下发生调度切换，线程 Q 也执行到 while 循环，也可以占用锁，会造成两个线程获取同一个锁的情况，所以通过 xchg() 保证原子操作实现锁 __sync_synchronize() 主要为了避免编译器把指令顺序打乱，禁止编译器乱序内存操作。 getcallerpcs() 用于为调试而保存调用栈的信息 release() 主要用于释放锁，主要通过 asm volatile(&quot;movl $0, %0&quot; : &quot;+m&quot; (lk-&gt;locked) : ); 解锁，这句话能原子操作 Don’t do this注意不要写如下代码，会造成死锁： 1234struct spinlock lk;initlock(&amp;lk, &quot;test lock&quot;);acquire(&amp;lk);acquire(&amp;lk); Interrupts in ide.c 根据要求修改 ide.c:iderw() 123456789101112131415161718192021222324252627282930313233343536373839//PAGEBREAK!// Sync buf with disk.// If B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.// Else if B_VALID is not set, read buf from disk, set B_VALID.voididerw(struct buf *b)&#123; struct buf **pp; if(!holdingsleep(&amp;b-&gt;lock)) panic(&quot;iderw: buf not locked&quot;); if((b-&gt;flags &amp; (B_VALID|B_DIRTY)) == B_VALID) panic(&quot;iderw: nothing to do&quot;); if(b-&gt;dev != 0 &amp;&amp; !havedisk1) panic(&quot;iderw: ide disk 1 not present&quot;); acquire(&amp;idelock); //DOC:acquire-lock sti(); // Append b to idequeue. b-&gt;qnext = 0; for(pp=&amp;idequeue; *pp; pp=&amp;(*pp)-&gt;qnext) //DOC:insert-queue ; *pp = b; // Start disk if necessary. if(idequeue == b) idestart(b); // Wait for request to finish. while((b-&gt;flags &amp; (B_VALID|B_DIRTY)) != B_VALID)&#123; sleep(b, &amp;idelock); &#125; cli(); release(&amp;idelock);&#125; Interrupts in file.c获取 file_table_lock() 锁在打开中断后没有 panic 的原因：中断发生后没有再次使用共享数据 xv6 lock implementation若不这样执行，在执行完lk-&gt;locked置零后，可能另一进程将获取锁，并将lk-&gt;pcs[0]置为该进程相关的信息，然后当前进程再执行清空lk-&gt;pcs[0]的动作，发生了冲突，导致lk-&gt;pcs[0]信息不正确。 12345678910111213141516// Release the lock.voidrelease(struct spinlock *lk)&#123; if(!holding(lk)) panic(&quot;release&quot;); lk-&gt;pcs[0] = 0; lk-&gt;cpu = 0; __sync_synchronize(); asm volatile(&quot;movl $0, %0&quot; : &quot;+m&quot; (lk-&gt;locked) : ); popcli();&#125; lk-&gt;pcs[0] = 0; lk-&gt;cpu = 0; 在释放锁前面的原因： 若在释放锁后面，会发生： 锁释放， lk-&gt;pcs[0] 跟 lk-&gt;cpu 未清除 另一个 CPU 尝试获取锁并成功，设置 lk-&gt;pcs[0] 跟 lk-&gt;cpu 当前 CPU 清除 lk-&gt;pcs[0] 跟 lk-&gt;cpu 从而导致锁的信息不正确","categories":[],"tags":[]},{"title":"MIT 6.828 Homework_xv6CPUAlarm","slug":"MIT 6.828 Homework_xv6CPUAlarm","date":"2020-12-29T02:08:13.000Z","updated":"2020-12-29T11:20:58.892Z","comments":true,"path":"mit-6-828-homework-xv6cpualarm/index.html","link":"","permalink":"https://hasuer.github.io/mit-6-828-homework-xv6cpualarm/index.html","excerpt":"","text":"实验指导书 MIT 6.828 Operating System Engineering CPU Alarm实验目的在本练习中，您将向xv6添加一个特性，当进程使用CPU时间时，该特性会定期向进程发出警报。对于想要限制占用CPU时间的计算绑定进程，或者想要进行计算但又想采取某些周期性操作的进程，这可能很有用。更一般地说，您将实现用户级中断/错误处理程序的基本形式;例如，您可以在应用程序中使用类似的方法来处理页面错误。 实验内容 您应该添加一个新的alarm(interval, handler)系统调用。如果一个应用程序调用alarm(n, fn)，那么在程序每消耗n个“节拍”的CPU时间后，内核将导致应用程序函数fn被调用。当fn返回时，应用程序将恢复它停止的地方。在xv6中，tick是一个相当任意的时间单位，由硬件计时器产生中断的频率决定。 实验步骤添加测试命令新建一个文件 alarmtest.c 并将实验指导书中的实例代码写在里面： 1234567891011121314151617181920212223#include &quot;types.h&quot;#include &quot;stat.h&quot;#include &quot;user.h&quot;void periodic();int main(int argc, char *argv[])&#123; int i; printf(1, &quot;alarmtest starting\\n&quot;); alarm(10, periodic); for (i = 0; i &lt; 250 * 500000; i++) &#123; if ((i % 250000) == 0) write(2, &quot;.&quot;, 1); &#125; exit();&#125;void periodic()&#123; printf(1, &quot;alarm!\\n&quot;);&#125; 为了将 alarmtest.c 编译成Xv6的用户程序，需要修改 Makefile ，在 UPROGS 中加入下面这一行： 1_alarmtest\\ 添加系统调用在 user.h 中添加： 1int alarm(int ticks, void(*hander)()); 在 usys.S 中添加： 1SYSCALL(alarm) 在 syscall.h 中添加： 1#define SYS_alarm 23 在 syscall.c 中添加： 12345678910... extern int sys_alarm(void);... //static int (*syscalls[])(void) = &#123; ... [SYS_alarm] sys_alarm,//&#125;; 在 proc.h 的结构体 proc 中添加： 123int alarmticks;int curalarmticks;void (*alarmhandler)(); 在 sysproc.c 中添加： 123456789101112131415// cpu alarmintsys_alarm(void)&#123; int ticks; void (*handler)(); if(argint(0, &amp;ticks) &lt; 0) return -1; if(argptr(1, (char**)&amp;handler, 1) &lt; 0) return -1; myproc()-&gt;alarmticks = ticks; myproc()-&gt;alarmhandler = handler; return 0;&#125; 以上，系统调用 alarm 就添加完成了。 下面，要添加中断处理： 中断处理打开文件 trap.c ，在函数 void trap(struct trapframe *tf)&#123;&#125; 中修改 case T_IRQ0 + IRQ_TIMER ： 123456789101112131415161718192021case T_IRQ0 + IRQ_TIMER: if(cpuid() == 0)&#123; acquire(&amp;tickslock); ticks++; wakeup(&amp;ticks); release(&amp;tickslock); &#125; if(myproc() &amp;&amp; (tf-&gt;cs &amp; 3) == 3)&#123; myproc()-&gt;curalarmticks++; if(myproc()-&gt;alarmticks == myproc()-&gt;curalarmticks)&#123; // 到达了周期 myproc()-&gt;curalarmticks = 0; //下面两句将eip压栈 tf-&gt;esp -= 4; *((uint *)(tf-&gt;esp)) = tf-&gt;eip; // 将alarmhandler复制给eip，准备执行 tf-&gt;eip =(uint) myproc()-&gt;alarmhandler; &#125; &#125; lapiceoi(); break; 至此，所有修改都已经完成了。 在Ubuntu下编译运行： 12$ make CPUS=1 qemu-nox1 其中， CPUS=1 是为了将执行速度变慢，以观察系统中断的执行 运行Xv6后，输入命令： 1$ alarmtest 输出结果如下： 实验总结与心得体会实现用户级中断/错误处理程序的基本形式。例如，在应用程序中使用类似的方法来处理页面错误。","categories":[{"name":"操作系统实验","slug":"操作系统实验","permalink":"https://hasuer.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"MIT OS","slug":"MIT-OS","permalink":"https://hasuer.github.io/tags/MIT-OS/"}]},{"title":"MIT 6.828 Homework_LazyPageAllocation","slug":"MIT 6.828 Homework_LazyPageAllocation","date":"2020-12-28T17:09:18.000Z","updated":"2020-12-29T02:23:56.674Z","comments":true,"path":"mit-6-828-homework-lazypageallocation/index.html","link":"","permalink":"https://hasuer.github.io/mit-6-828-homework-lazypageallocation/index.html","excerpt":"","text":"实验指导书 MIT 6.828 Operating System Engineering Lazy Page Allocation实验目的O/S可以使用页表硬件的许多巧妙技巧之一是延迟分配堆内存。Xv6应用程序使用sbrk()系统调用向内核请求堆内存。在我们提供的内核中，sbrk()分配物理内存并将其映射到进程的虚拟地址空间。有些程序可以分配内存，但从不使用它，例如实现大型稀疏数组。复杂的内核延迟每个内存页的分配，直到应用程序尝试使用该页——这是由页面错误发出的信号。也就是说，sbrk()不分配物理内存，只是记住分配了哪些地址。当进程第一次尝试使用任何给定的内存页时，CPU会生成一个页错误，内核通过分配物理内存、将其归零并映射它来处理该错误。在本练习中，您将向xv6添加这种延迟分配特性。 实验内容Part One您的第一个任务是从sbrk(n)系统调用实现(即sysproc.c中的sys_sbrk()函数)中删除页面分配。sbrk(n)系统调用将进程的内存大小增加n个字节，然后返回新分配的区域的开始部分(即旧的大小)。新的sbrk(n)应该只将进程的大小(myproc()-&gt;sz)增加n，并返回原来的大小。它不应该分配内存——因此您应该删除对growproc()的调用(但您仍然需要增加进程的大小!) Part Two修改trap.c中的代码，通过在错误地址映射新分配的物理内存页，然后返回到用户空间，让进程继续执行，从而响应用户空间中的页面错误。您应该在生成“pid 3 sh: trap 14”消息的cprintf调用之前添加代码。你的代码不需要覆盖所有的极端情况和错误情况;它只需要足够好，让sh运行简单的命令，如echo和ls。 实验步骤 修改sbrk(n)，本来是将进程的内存大小增加n个字节，然后返回新分配区域的开始；改成只需将进程的大小(myproc()-&gt;sz)增加n不分配区域，并返回原来的大小。 123456789101112131415//将进程的大小(myproc()-&gt;sz)增加n不分配区域，其中n为用户传入的参数intsys_sbrk(void)&#123; int addr; int n; if(argint(0, &amp;n) &lt; 0) return -1; addr = myproc()-&gt;sz; /*if(growproc(n) &lt; 0) return -1;*/ myproc()-&gt;sz += n; return addr;&#125; 改之前 改之后 “addr 0x4004”表示导致页面错误的虚拟地址是0x4004。“pid 3 sh: trap…”消息来自trap.c中的内核陷阱处理程序。它捕获了一个页面错误(trap 14，或T_PGFLT)，所以为什么发生这个错误？ 12//traps.h中#define T_PGFLT 14 // page fault 这个错误肯定是因为代码改成了只增加大小，不分配物理区域导致找不到虚拟地址对应的物理页引发报错。但我有个疑问，echo hi只是把hi输出而已，需要用到物理页吗？还是说hi作为参数存在argv[1]中，也就是需要物理页保存。 Part Two将新分配的物理内存页映射到故障地址然后返回到用户空间，让进程继续执行。 1234567891011121314151617181920Hint: look at the cprintf arguments to see how to find the virtual address that caused the page fault.(找到引起错误的虚拟地址)Hint: steal code from allocuvm() in vm.c, which is what sbrk() calls (via growproc()).Hint: use PGROUNDDOWN(va) to round the faulting virtual address down to a page boundary.(4k对齐)Hint: break or return in order to avoid the cprintf and the myproc()-&gt;killed = 1.(及时返回防止再次输出那段提示)Hint: you&#x27;ll need to call mappages(). In order to do this you&#x27;ll need to delete the static in the declaration of mappages() in vm.c, and you will need to declare mappages() in trap.c. Add this declaration to trap.c before any call to mappages(): int mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm);Hint: you can check whether a fault is a page fault by checking if tf-&gt;trapno is equal to T_PGFLT in trap(). //#define T_PGFLT 14 // page fault//将引发缺页异常的线性地址保存在address变量里面 __asm__(&quot;movl %%cr2,%0&quot;:&quot;=r&quot; (address)); 让程序继续执行缺的是什么，如何让程序返回用户空间？ 12345678910111213141516171819202122232425262728293031323334353637default: if(myproc() == 0 || (tf-&gt;cs&amp;3) == 0)&#123; // In kernel, it must be our mistake. cprintf(&quot;unexpected trap %d from cpu %d eip %x (cr2=0x%x)\\n&quot;, tf-&gt;trapno, cpuid(), tf-&gt;eip, rcr2()); panic(&quot;trap&quot;); &#125; char *mem; uint a; a = PGROUNDDOWN(rcr2()); //将引起错误的虚拟地址向下4K对齐 for(; a &lt; myproc()-&gt;sz; a += PGSIZE)&#123; //从a开始对大小为myproc()-&gt;sz-a的区域分配并映射物理页 mem = kalloc(); //分配物理页 if(mem == 0)&#123; cprintf(&quot;allocuvm out of memory\\n&quot;); //这里的 myproc()-&gt;tf-&gt;eax瞎写的，我以为sys_sbrk()返回值即oldsz存在tf-&gt;eax中 deallocuvm(myproc()-&gt;pgdir, myproc()-&gt;sz, myproc()-&gt;tf-&gt;eax); return; &#125; memset(mem, 0, PGSIZE); //初始化物理页 if(mappages(myproc()-&gt;pgdir, (char*)a, PGSIZE, V2P(mem), PTE_W|PTE_U) &lt; 0)&#123; //映射刚分配的物理页到虚拟地址失败 cprintf(&quot;allocuvm out of memory (2)\\n&quot;); deallocuvm(myproc()-&gt;pgdir, myproc()-&gt;sz, myproc()-&gt;tf-&gt;eax); kfree(mem); return; &#125; &#125; break; // In user space, assume process misbehaved. cprintf(&quot;pid %d %s: trap %d err %d on cpu %d &quot; &quot;eip 0x%x addr 0x%x--kill proc\\n&quot;, myproc()-&gt;pid, myproc()-&gt;name, tf-&gt;trapno, tf-&gt;err, cpuid(), tf-&gt;eip, rcr2()); myproc()-&gt;killed = 1; &#125; 实验总结与心得体会经过本次实验，对于线性地址的理解更为深入了，对Unix的分页机制以及地址方面的知识了解到了更多。","categories":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"https://hasuer.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"MIT OS","slug":"MIT-OS","permalink":"https://hasuer.github.io/tags/MIT-OS/"}]},{"title":"MIT 6.828 Homework_SystemCall","slug":"MIT 6.828 Homework_SystemCall","date":"2020-12-28T12:46:23.000Z","updated":"2020-12-28T17:10:59.242Z","comments":true,"path":"mit-6-828-homework-systemcall/index.html","link":"","permalink":"https://hasuer.github.io/mit-6-828-homework-systemcall/index.html","excerpt":"","text":"实验指导书 MIT 6.828 Operating System Engineering xv6 System Call实验目的 理解系统调用的工作流程和实现系统调用 修改xv6内核从而打印出每一个系统调用，只需打印出系统调用和他的返回值，不需要打印出参数。 在已有的基础上增加上一个系统调用，当用户键入date的时候能够打印出当前的时间。 实验内容Part One: System call tracingYour first task is to modify the xv6 kernel to print out a line for each system call invocation. It is enough to print the name of the system call and the return value; you don’t need to print the system call arguments. When you’re done, you should see output like this when booting xv6: 1234567...fork -&gt; 2exec -&gt; 0open -&gt; 3close -&gt; 0$write -&gt; 1 write -&gt; 1 That’s init forking and execing sh, sh making sure only two file descriptors are open, and sh writing the $ prompt. (Note: the output of the shell and the system call trace are intermixed, because the shell uses the write syscall to print its output.) Hint: modify the syscall() function in syscall.c. Optional challenge: print the system call arguments. Part Two: Date system callYour second task is to add a new system call to xv6. The main point of the exercise is for you to see some of the different pieces of the system call machinery. Your new system call will get the current UTC time and return it to the user program. You may want to use the helper function, cmostime() (defined in lapic.c), to read the real time clock. date.h contains the definition of the struct rtcdate struct, which you will provide as an argument to cmostime() as a pointer. You should create a user-level program that calls your new date system call; here’s some source you should put in date.c: 123456789101112131415161718#include &quot;types.h&quot;#include &quot;user.h&quot;#include &quot;date.h&quot;intmain(int argc, char *argv[])&#123; struct rtcdate r; if (date(&amp;r)) &#123; printf(2, &quot;date failed\\n&quot;); exit(); &#125; // your code to print the time in any format you like... exit();&#125; In order to make your new date program available to run from the xv6 shell, add _date to the UPROGS definition in Makefile. Your strategy for making a date system call should be to clone all of the pieces of code that are specific to some existing system call, for example the “uptime” system call. You should grep for uptime in all the source files, using grep -n uptime *.[chS]. When you’re done, typing date to an xv6 shell prompt should print the current UTC time. Write down a few words of explanation for each of the files you had to modify in the process of creating your date system call. Optional challenge: add a dup2() system call and modify the shell to use it. 实验步骤Part One: System call tracing打开文件：syscall.c 在文件前面添加编号和系统调用名称相互对应的数组： 12345678910111213141516171819202122static char SYS_call_names[][6] = &#123; [SYS_fork] &quot;fork&quot;, [SYS_exit] &quot;exit&quot;, [SYS_wait] &quot;wait&quot;, [SYS_pipe] &quot;pipe&quot;, [SYS_read] &quot;read&quot;, [SYS_kill] &quot;kill&quot;, [SYS_exec] &quot;exec&quot;, [SYS_fstat] &quot;fstat&quot;, [SYS_chdir] &quot;chdir&quot;, [SYS_dup] &quot;dup&quot;, [SYS_getpid] &quot;getpid&quot;, [SYS_sbrk] &quot;sbrk&quot;, [SYS_sleep] &quot;sleep&quot;, [SYS_uptime] &quot;uptime&quot;, [SYS_open] &quot;open&quot;, [SYS_write] &quot;write&quot;, [SYS_mknod] &quot;mknod&quot;, [SYS_unlink] &quot;unlink&quot;, [SYS_link] &quot;link&quot;, [SYS_mkdir] &quot;mkdir&quot;, [SYS_close] &quot;close&quot;&#125;; 然后在函数：syscall 中添加对应的输出命令： 1234567891011121314151617181920void syscall(void)&#123; int num; struct proc *curproc = myproc(); num = curproc-&gt;tf-&gt;eax; if (num &gt; 0 &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123; curproc-&gt;tf-&gt;eax = syscalls[num](); // add begin cprintf(&quot;%s\\t -&gt; %d\\n&quot;, SYS_call_names[num], num); //add end &#125; else &#123; cprintf(&quot;%d %s: unknown sys call %d\\n&quot;, curproc-&gt;pid, curproc-&gt;name, num); curproc-&gt;tf-&gt;eax = -1; &#125;&#125; 修改完成，测试结果： 1$ make qemu 运行结果如下： Part Two: Date system call第二步，我们要添加一个系统调用函数，使其可以返回当前系统时间。 在 syscall.h 中最后一行添加系统调用编号 1#define SYS_date 22 在 syscall.c 中添加系统调用函数的外部声明 12345678910... [SYS_mkdir] &quot;mkdir&quot;, [SYS_close] &quot;close&quot;,// 以下为添加内容 [SYS_date] &quot;date&quot;&#125;;// 以上为添加内容// User code makes a system call with INT T_SYSCALL.// System call number in %eax.... 12345678910...extern int sys_write(void);extern int sys_uptime(void);// 以下为添加内容extern int sys_date(void);// 以上为添加内容static int (*syscalls[])(void) = &#123; [SYS_fork] sys_fork,... 123456789101112... [SYS_mkdir] sys_mkdir, [SYS_close] sys_close, // 以下为添加内容 [SYS_date] sys_date, // 以上为添加内容 &#125;; void syscall(void) &#123; int num; ... 在 user.h 中添加用户态函数的定义 12345678910...int sleep(int);int uptime(void);// 以下为添加内容int date(struct rtcdate*);// 以上为添加内容// ulib.cint stat(char*, struct stat*);... 在 usys.S 中最后一行添加用户态函数的实现 1SYSCALL(date) 在 sysproc.c 中最后一行添加系统调用函数的实现 123456789// return current dateintsys_date(struct rtcdate *r)&#123; if (argptr(0, (void *)&amp;r, sizeof(*r)) &lt; 0) return -1; cmostime(r); //从cmos中获取时间 return 0;&#125; 至此，就完成了添加系统调用函数 date() 最后，我们需要添加使用这个系统调用函数的方法 新建文件 date.c ，并添加一下内容： 123456789101112131415161718#include &quot;types.h&quot;#include &quot;user.h&quot;#include &quot;date.h&quot;int main(int argc, char *argv[])&#123; struct rtcdate r; if (date(&amp;r)) &#123; printf(2, &quot;date failed\\n&quot;); exit(); &#125; // your code to print the time in any format you like... printf(1, &quot;%d-%d %d %d:%d:%d\\n&quot;, r.month, r.day, r.year, r.hour, r.minute, r.second); exit();&#125; 在 Makefile 中添加 UPROGS 对应命令的定义： 至此，所有文件就修改完成了。 为了防止第一部分的输出影响我们时间的显示格式，可以先将 syscall.c 中的static char SYS_call_names[][6]注释掉. 编译运行： 1$ make qemu 然后输入命令 date： 实验分析Part One所有的系统调用的编号都在 syscall.h文件中，所以如果我们要增加一个系统调用，我们也需要在这个文件及其对应的.c文件中做修改。 12345678910111213141516171819202122// System call numbers#define SYS_fork 1#define SYS_exit 2#define SYS_wait 3#define SYS_pipe 4#define SYS_read 5#define SYS_kill 6#define SYS_exec 7#define SYS_fstat 8#define SYS_chdir 9#define SYS_dup 10#define SYS_getpid 11#define SYS_sbrk 12#define SYS_sleep 13#define SYS_uptime 14#define SYS_open 15#define SYS_write 16#define SYS_mknod 17#define SYS_unlink 18#define SYS_link 19#define SYS_mkdir 20#define SYS_close 21 这里面定义了系统调用的名称和对应的序号，我们要在终端上显示的就是上面这些对应的名字和编号。 Part Two在说明中已经给出了大致要完成的步骤。 lapic.c 中定义了函数 cmostime() 来读取时钟时间。 12void cmostime(struct rtcdate *r) &#123;&#125;1 date.h 中定义了 rtcdate 结构体，作为参数提供给函数 cmostime() 。 12345678struct rtcdate &#123; uint second; uint minute; uint hour; uint day; uint month; uint year;&#125;; 实验结论及心得体会 理解系统调用的工作流程和实现系统调用 修改xv6内核从而打印出每一个系统调用，只需打印出系统调用和他的返回值，不需要打印出参数。 在已有的基础上增加上一个系统调用，当用户键入date的时候能够打印出当前的时间。","categories":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"https://hasuer.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"MIT OS","slug":"MIT-OS","permalink":"https://hasuer.github.io/tags/MIT-OS/"}]},{"title":"MIT 6.828 Assignment_Barriers","slug":"MIT 6.828 Assignment_Barriers","date":"2020-11-15T15:05:35.000Z","updated":"2020-11-15T15:53:24.328Z","comments":true,"path":"mit-6-828-assignment-barriers/index.html","link":"","permalink":"https://hasuer.github.io/mit-6-828-assignment-barriers/index.html","excerpt":"","text":"实验指导书 MIT 6.828 Operating System Engineering 分析这个实验是要我们去实行barrier,也就是屏障，只有当所有的线程都到了这个地方以后才会继续一起执行下一步。 1234567891011121314static void *thread(void *xa)&#123; long n = (long) xa; long delay; int i; for (i = 0; i &lt; 20; i++) &#123; int t = bstate.round; printf(&quot;i = %d, t = %d&quot;, i, t); assert (i == t); barrier(); usleep(random() % 100); &#125;&#125; 在代码中（不在上面列出的部分）定义了两个全局变量，分别是nthread和round。第一个nthread是存储你输入的线程个数，在主函数中被赋值。第一个静态全局变量不知道是干什么的，因为在源代码中也没有看到使用了这个变量。 这个代码的大致思路是： 假设输入的是./a.out 2，表示我要创建两个线程。在每一个线程中，运行上面粘贴出来的代码。在这个代码块的for循环中，循环20次，表示每一个线程要被重复执行20次，并且由于barrier函数的存在（暂时还没有实现），我们希望当所有的线程都完成了第一循环以后再开始第二次循环，都完成第二次循环以后一起开始第三次，以此类推，指导都完成了20次循环。 所以主要问题就是： You have to deal with a succession of barrier calls, each of which we’ll call a round. bstate.round records the current round. You should increase bstate.round when each round starts. You have to handle the case in which one thread races around the loop before the others have exited the barrier. In particular, you are re-using bstate.nthread from one round to the next. Make sure that a thread that leaves the barrier and races around the loop doesn’t increase bstate.nthread while a previous round is still using it. 翻译过来就是： 要完成连续的barrier()函数的调用，也就是循环执行20次，每一次调用成为一个round，bstate.round记录的是当前round，当每一个round开始的时候，可以将bstate.round加1. 要解决barrier问题。对于barrier.round我们是循环使用的，从一个round到下一个round。要保证当一个线程离开barrier或者在这个barrier中sleep的时候，barrier.round不会增加。 在barrier()函数中做修改（实验指导书上说这要在这里做修改） 12345678910111213141516static void barrier()&#123; pthread_mutex_lock(&amp;bstate.barrier_mutex);//访问互斥量 bstate.nthread++;//已进入barrier的线程个数加1 if (bstate.nthread == nthread) &#123; //表示已经进入线程的个数等于自己设置的线程数 //已实现的round加1， nthread清空为下一次计数做准备 bstate.round++; bstate.nthread = 0; pthread_cond_broadcast(&amp;bstate.barrier_cond);//唤醒 &#125; else &#123; pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);//睡眠 &#125; pthread_mutex_unlock(&amp;bstate.barrier_mutex);//释放互斥量&#125; 辨析倘若不去更改barrier函数，而是对thread函数做如下修改： 1234567891011121314151617181920212223static void *thread(void *xa)&#123; long n = (long) xa; long delay; int i; pthread_mutex_lock(&amp;bstate.barrier_mutex ); if (bstate.round != 0) &#123; pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex); &#125; for (i = 0; i &lt; 20000; i++) &#123; int t = bstate.round; // The assert triggers, because one thread leaves the barrier before the other thread has reached the barrier. assert (i == t); printf(&quot;thread %d\\n&quot;, i); barrier(); usleep(random() % 100); &#125; bstate.round = 0; pthread_cond_broadcast(&amp;bstate.barrier_cond); pthread_mutex_unlock(&amp;bstate.barrier_mutex );&#125; 这样的话也能通过，那和上面的有什么不同吗？ 答案是，下面这种写法，在if中，如果bstate.round != 0，不等于零就意味着它不是第一个进程线程，因为第一个线程已经将bstate.round加1了。所以下面的这个代码实现的是线程的轮流执行，也就起不到并行的效果了。","categories":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"https://hasuer.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"MIT OS","slug":"MIT-OS","permalink":"https://hasuer.github.io/tags/MIT-OS/"}]},{"title":"PA2实验报告","slug":"PA2实验报告","date":"2020-11-10T14:48:27.000Z","updated":"2021-01-18T03:19:58.824Z","comments":true,"path":"pa2实验报告/index.html","link":"","permalink":"https://hasuer.github.io/pa2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/index.html","excerpt":"","text":"序号 是否完成 必做任务1 是 必做任务2 是 必做任务3 是 必做任务4 是 必做任务5 是 选作任务1 是 选作任务2 是 思考题1【问题】 main函数返回到哪里？查看testcase的相关代码，你知道用户程序从main函数返回以后会跳转到哪里吗？如果用户程序在GNU/Linux中运行，问题的答案又是什么？ 【我的解答】 程序从主函数执行以后会回到ui_mainloop中继续执行下一条指令，从而达到循环执行的效果 在Linux中，用户程序执行完main函数会回到类似的地方，叫做_libc_start_main 思考题2【问题】 比较 FLOAT 和 float。FLOAT和float类型的数据都是32位, 它们都可以表示2^32个不同的数, 但由 于表示方法不一样, FLOAT 和 float 能表示的数集是不一样的。思考一下, 我们 用 来模拟表示 float , 这其中隐含着哪些取舍? 【我的解答】 float能表示的数值范围更大，而FLOAT的范围小，但是速度快。 思考题3【问题】 消失的符号。我们在 add.c 中定义了宏 NR_DATA, 同时也在 add()函数中定义了局部变量 c 和形参 a, b, 但你会发现在符号表中找不到和它们对应的表项, 为什么会这 样?思考一下, 什么才算是一个符号(symbol)? 【我的解答】 符号表中所存储的内容包括全局的静态变量，函数的调用，外部引用等。我们在add.c中定义的宏和局部变量，局部变量是存储在stack中，而宏定义会在预处理阶段被替换，不在作为不好存储。 思考题4【问题】 堆和栈在哪里?我们提到了代码和数据都在可执行文件里面, 但却没有提到堆(heap)和栈 (stack)。为什么堆和栈的内容没有放入可执行文件里面?那程序运行时刻用到 的堆和栈又是怎么来的? 【我的解答】 程序在运行的时候会自动分配堆栈的大小。堆由程序员管理，栈由系统管理。 如图，栈是向下生长，堆是向上生长，两者都是动态分配。 思考题5【问题】 如何识别不同格式的可执行文件?如果你在GNU/Linux下执行一个从Windows拷过来的可执行文件, 将会报告” 格式错误”。思考一下, GNU/Linux 是如何知道”格式错误”的? 【我的解答】 每个文件都有一个扩展名，windows就是靠扩展名来识别不同类型的文件，并以此来决定用哪种程序打开这种文件。 如果是exe等可执行程序，则是直接执行它（实际上不是，我们可以这样来理解），如果是其它的文件，如是.txt,就调用notepad.exe这个程序，并且打开那个txt文件。并且右键菜单也会因为文件类型不同而不同。 对于Linux来说，文件的头部会有相应的信息，和windows类似。 思考题6【问题】 冗余的属性?使用 readelf 查看一个 ELF 文件的信息, 你会看到一个 segment 包含两个大小 的属性, 分别是 FileSiz 和 MemSiz, 这是为什么? 再仔细观察一下, 你会发现 FileSiz 通常不会大于相应的 MemSiz, 这又是为什么? 【我的解答】 这是因为，在ELF中需要存储全局变量的初始值，而由于.bss没有初始值，默认被初始化为0，所以不会在ELF中存储，使得变量在文件中占用的大小（FileSiz）小于运行时占用的内存空间（MemSiz）。在加载到内存中时，使用这个特征判断是否到达了最后一个segment。 同时，可以注意到两个LOAD之间的虚拟地址（即加载到虚拟内存中时的偏移量，上文中的VirtAddr）差距很大，这是因为想要尽量保证可执行的部分与不可执行的部分相差尽可能大，从而最小化溢出时可能造成的写掉.text的风险，","categories":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://hasuer.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"NEMU实验","slug":"NEMU实验","permalink":"https://hasuer.github.io/tags/NEMU%E5%AE%9E%E9%AA%8C/"}]},{"title":"MIT 6.828 Assignment_ThreadsandLocks","slug":"MIT 6.828 Assignment_ThreadsandLocks","date":"2020-11-06T14:37:38.000Z","updated":"2020-11-06T15:04:32.831Z","comments":true,"path":"mit-6-828-assignment-threadsandlocks/index.html","link":"","permalink":"https://hasuer.github.io/mit-6-828-assignment-threadsandlocks/index.html","excerpt":"","text":"实验指导书 MIT 6.828 Operating System Engineering 【思路】 代码首先创建了10000个小的node，用每一个node（在代码中名字是entry）来表示一个线程，然后通过平均分配的方法来把这些线程分配给各个进程。 put函数用来将每一个线程加入链表。然后将这个node的对应信息记录到哈希表：struct entry *table[NBUCKET]中。 get函数得到一个node（也就是一个线程）。同时这也表示这次线程的结束。 这样不断通过put 和get来实现并行程序。 产生错误的原因：当我们在使用put函数的时候，不小心造成两个新的node同时插入链表时（也就是同时使用内存），我们的哈希表只能记录下其中的一个表头，而失去了另外一个node的表头，所以造成了get的时候丢失了node。 【步骤】 声明锁变量数组 在main()函数中初始化锁变量数组 当进行insert操作是加锁保护，修改put()函数如下 再次运行","categories":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"https://hasuer.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"MIT OS","slug":"MIT-OS","permalink":"https://hasuer.github.io/tags/MIT-OS/"}]},{"title":"打印多个hello","slug":"打印多个hello","date":"2020-11-03T13:37:49.000Z","updated":"2020-11-03T14:33:22.816Z","comments":true,"path":"打印多个hello/index.html","link":"","permalink":"https://hasuer.github.io/%E6%89%93%E5%8D%B0%E5%A4%9A%E4%B8%AAhello/index.html","excerpt":"","text":"打印多个hello这个问题在网上没有找到代码，于是我自己对着代码的运行结果，尝试着去理解，所以不一定对。 【问题描述：】 假定下面的C语言程序在 UNIX 系统上运行，并且所有调用都能成功完。其 中pthread_create(&amp;t, NULL, bar, NULL);的功能是创建一个新线程来执行函数bar，并返回线程对象标识 t。pthread_join(t,NULL );的功能是等待线程结束。试问此程序在运行过中会打印出多少个 “hello” ？需要说明分析过程。 12345678910111213141516171819202122232425262728#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;static int counter = 1;static void* bar(void* ingore)&#123; counter --; if(counter == 0)&#123; fork(); printf(&quot;hello1\\n&quot;); &#125; return NULL;&#125;static void foo()&#123; pthread_t t; if(fork() == 0)&#123; fork(); pthread_create(&amp;t, NULL, bar, NULL); printf(&quot;hello2\\n&quot;); pthread_join(t, NULL); &#125;&#125;int main()&#123; foo(); printf(&quot;hello3\\n&quot;); return 0;&#125; 在Ubantu 18.04版本上运行的结果如下: 【我的分析：】 这个程序的运行结果很迷，每次的执行结果的顺序是不一样的，比如我重新运行一下： 这个是什么原因我也不知道。 但是每次打印出来的结果都有9个hello，并且是4个hello1, 2个hello2， 3个hello3。这是不会变的。 下面是我的思路： main进入foo()以后就fork了，假设先运行父进程（父进程1），由于fork返回给父进程的值是子进程（子进程1）的pid(不为0)，所以foo()执行完了，回到main，打印出hello3. 在子进程（子进程1）中又fork了，这是原来的子进程（子进程1）是新创建出来的子进程（子进程2）的父进程（子进程1），在这个父进程（子进程1）中，创建了一个线程运行bar,在bar中fork以后，在新创建出来的子进程（子进程3）和原来的子进程（子进程1）各打印一个hello1. 在子进程2中的结果和上面步骤2是一样的。 【注意：】 每次fork以后产生的子进程是一个进程，两个进程间的全局变量是copy on write，也就是说，一开始是一个，或者说只读的时候是一个，但是一旦有人想要修改它，就立刻变成两个。在foo中fork以后，创建了线程，由于线程中要对于全局变量counter进行修改，所以就变成了两个counter，初值都是1，所以两个进程都能进入bar的if 语句再次fork。 进入bar的if以后的fork,这是创建出来的子进程的counter全局变量也是0，但是，子进程直接接着这个fork后面运行呀，所以对于counter就没有什么要求了，直接答应出hello啦！","categories":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"https://hasuer.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"进程管理","slug":"进程管理","permalink":"https://hasuer.github.io/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"}]},{"title":"PV题","slug":"PV题","date":"2020-10-31T05:11:00.000Z","updated":"2020-11-21T06:43:31.960Z","comments":true,"path":"pv题/index.html","link":"","permalink":"https://hasuer.github.io/pv%E9%A2%98/index.html","excerpt":"","text":"除了前两道题是老师给了答案的，后面是自己做的，不能保证正确率。 读者写者问题【问题描述】 读者-写者问题为数据库访问建立了一个模型。例如,一个系统,其中有许多竞争的进程试图读写其中的数据,多个进程同时读是可以接受的,但如果一个进程正在更新数据库,则所有的其他进程都不能访问数据库，即使读操作也不行。分别写出读者优先、写者优先和公平竞争三种情况下的程序。 【解答】 12345678910111213141516171819202122232425262728293031// reader prioriy solutoinsemaphore fmutex = 1; // access to filesemaphore rdcntmutex = 1; //access to readcountint readcount = 0;/*reader*/void reader()&#123; while(1)&#123; P(rdcntmutex); if(readcount == 0)&#123; P(fmutex); &#125; readcount ++; V(rdcntmutex); //do read operation P(rdcntmutex); readcount --; if(readcounnt == 0)&#123; V(fmutex); &#125; V(rdcntmutex); &#125;&#125;/*writer*/void writer()&#123; while(1)&#123; P(fmutex); //do write operation V(fmutex); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//writer priority solutionsemaphore fmutex = 1; // access to filesemaphore rdcntmutex = 1; //access to readcountsemaphore wtcntmutex = 1; //access to writercountsemaphore queue = 1;int readcount = 0;int writercount = 0;/*reader*/void reader()&#123; while(1)&#123; P(queue); P(rdcntmutex); if(readcount == 0)&#123; P(fmutex); &#125; readcount ++; V(rdcntmutex); V(queue); //do read operation P(rdcntmutex); readcount --; if(readcounnt == 0)&#123; V(fmutex); &#125; V(rdcntmutex); &#125;&#125;/*writer*/void writer()&#123; while(1)&#123; P(wtcntmutex); if(writercount == 0)&#123; P(queue); &#125; V(wtcntmutex); P(fmutex); //do write operation V(fmutex); P(wtcntmutex); writercount --; if(writercount == 0)&#123; V(queue); &#125; V(wtcntmutex); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738//fair solutionsemaphore fmutex = 1; // access to filesemaphore rdcntmutex = 1; //access to readcountsemaphore wtcntmutex = 1; //access to writercountsemaphore queue = 1;int readcount = 0;int writercount = 0;/*reader*/void reader()&#123; while(1)&#123; P(queue); P(rdcntmutex); if(readcount == 0)&#123; P(fmutex); &#125; readcount ++; V(rdcntmutex); V(queue); //do read operation P(rdcntmutex); readcount --; if(readcounnt == 0)&#123; V(fmutex); &#125; V(rdcntmutex); &#125;&#125;/*writer*/void writer()&#123; while(1)&#123; P(queue); P(fmutex); //do write operation V(queue); V(fmutex); &#125;&#125; 理发师问题【问题描述】 有一个理发师，一把理发椅和N把供等候理发的顾客坐的椅子。如果没有顾客，则理发师便在理发师椅子上睡觉；当一个顾客到来时，必须唤醒理发师进行理发；如果理发师正在理发时又有顾客来到，则如果有空椅子可坐，他就坐下来等，如果没有空椅子，他就离开。为理发师和顾客各编一段程序（伪代码）描述他们的行为，要求不能带有竞争条件。 【解答】 1234567891011121314151617181920212223242526272829303132#define CHAIRS 5;semaphore customers = 0;semaphore barber = 0;semaphore mutex = 1;int waiting = 0;//barbervoid barber()&#123; while(1)&#123; P(customers); P(mutex); waiting --; V(barber); V(mutex); cut_hair(); &#125;&#125;//customervoid customer()&#123; P(mutex); if(waiting &lt; CHAIRS)&#123; waiting ++; V(customers); V(mutex); P(barber); get_haircut(); &#125; else&#123; V(mutex); &#125;&#125; 吸烟者问题三个吸烟者在一间房间内，还有一个香烟供应者。为了制造并抽掉香烟，每个吸烟者需要三样东西：烟草、纸和火柴。供应者有丰富的货物提供。三个吸烟者中，第一个有自己的烟草，第二个有自己的纸，第三个有自己的火柴。供应者将两样东西放在桌子上，允许一个吸烟者进行对健康不利的吸烟。当吸烟者完成吸烟后唤醒供应者，供应者再放两样东西（随机地）在桌面上，然后唤醒另一个吸烟者。试为吸烟者和供应者编写程序解决问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051semaphore empty = 1;semaphore mutex = 1;semaphore offer1 = 0; //offer paper and matchsemaphore offer2 = 0; //offer tabacco and matchsemaphore offer3 = 0; //offer tabacco and papervoid provider()&#123; while(1)&#123; P(empty); P(mutex); srand(time(0)); switch(rand % 3)&#123; case 0: V(offer1); V(mutex); Wakeup(man1); break; case 1: V(offer2); V(mutex); Wakeup(man2); break; case 2: V(offer3); V(mutex); Wakeup(man3); break; &#125; &#125;&#125;void man1()&#123; P(mutex); //smoke V(mutex); V(empty);&#125;void man2()&#123; P(mutex); //smoke V(mutex); V(empty);&#125;void man3()&#123; P(mutex); //smoke V(mutex); V(empty);&#125; 面包师问题面包师有很多面包和蛋糕，由n 个销售人员销售。每个顾客进店后先取一个号，并且等着叫号。当一个销售人员空闲下来，就叫下一个号。请分别编写销售人员和顾客进程的程序。 123456789101112131415161718semaphore mutex = 1;semaphore sale = n;semaphore customer = 0;void customer() &#123; P(mutex); //叫号 V(mutex); V(customer); P(sale);&#125;void sale()&#123; P(customer); P(mutex); //叫号 V(mutex); V(sale);&#125; 果盘问题桌子上有一只盘子，最多可容纳两个水果，每次只能放入或取出一个水果。爸爸专向盘子放苹果（apple），妈妈专向盘子中放桔子（orange）；儿子专等吃盘子中的桔子，女儿专等吃盘子中的苹果。请用P、V操作来实现爸爸、妈妈、儿子、女儿之间的同步与互斥关系。 12345678910111213141516171819202122232425262728293031323334353637383940semaphore mutex = 1;semaphore apple = 0;semaphore orange = 0;semaphore empty = 2;void mum()&#123; while(1)&#123; P(empty); P(mutex); P(orange); V(mutex); &#125;&#125;void dad()&#123; while(1)&#123; P(empty); P(mutex); P(apple); V(mutex); &#125;&#125;void son()&#123; while(1)&#123; P(mutex); P(orange); V(empty); V(mutex); &#125;&#125;void daughter()&#123; while(1)&#123; P(mutex); P(apple); V(empty); V(mutex); &#125;&#125; 仓库问题（1）一次只能存入一种产品（A或B）；（2）-N &lt; (A产品数量-B产品数量) &lt; M。其中，N和M是正整数。试用“存放A”和“存放B”以及P、V操作描述产品A与产品B的入库过程。 12345678910111213141516171819202122semaphore mutex = 1;semaphore a = M - 1;semaphore b = N - 1;void storeA()&#123; while(1)&#123; P(a); P(mutex); //store A V(mutex); V(b); &#125;&#125;void storeB()&#123; while(1)&#123; P(b); P(mutex); //store B V(mutex); V(a); &#125;&#125; 奇偶数问题三个进程P1、P2、P3 互斥使用一个包含N(N&gt;0)个单元的缓冲区。P1 每次用produce()生成一个正整数并用put()送入缓冲区某一空单元中;P2 每次用getodd()从该缓冲区中取出一个奇数并用countodd()统计奇数个数;P3 每次用geteven()从该缓冲区中取出一个偶数并用counteven()统计偶数个数。请用信号量机制实现这三个进程的同步与互斥活动,并说明所定义信号量的含义。要求用伪代码描述。 1234567891011121314151617181920212223242526272829303132333435363738394041semaphore mutex = 1;semaphore buffer = N;semaphore odd = 0;semaphore even = 0;void P1()&#123; while(1)&#123; P(mutex); P(buffer); produce(); put(); if(odd)&#123; P(odd); &#125; if(even)&#123; P(even); &#125; P(mutex); &#125;&#125;void P2()&#123; while(1)&#123; P(odd); P(mutex); getodd(); countodd(); V(buffer); V(mutex); &#125;&#125;void P3()&#123; while(1)&#123; P(even); P(mutex); geteven(); counteven(); V(buffer); V(mutex); &#125;&#125; 大学问题在天津大学与南开大学之间有一条弯曲的小路，这条路上每次每个方向上只允许一辆 自行车通过。但其中有一个小的安全岛M，同时允许两辆自行车停留，可供两辆自行 车已从两端进入小路的情况下错车使用。如图所示。下面的算法可以使来往的自行车 均可顺利通过。其中使用了4个信号量，T代表天大路口资源，S代表南开路口资源，L 代表从天大到安全岛一段路的资源，K代表从南开到安全岛一段路的资源。程序如 下，请在空白位置处填写适当的PV操作语句，每处空白可能包含若干个PV操作语句。 P(T), P(L) V(L), V(K) V(K), V(T) 南北桥问题有桥如下图所示，车流如箭头所示，桥上不允许两车交汇，但允许同方向多辆车依次 通过（即桥上可以有多个同方向的车）。用P、V操作实现交通管理以防止桥上堵塞。 123456789101112131415161718192021222324252627282930313233343536semaphore mutex = 1;semaphore snmutex = 1;semaphore nsmutex = 1;int sncnt = 0;int nscnt = 0;void SouthtoNorth()&#123; while (1)&#123; P(snmutex); if(sncnt == 0) P(mutex); sncnt ++; V(snmutex); //go through P(snmutex); sncnt --; if(sncnt == 0) V(mutex) V(snmutex); &#125;&#125;void NorthtoSouth()&#123; while (1)&#123; P(nsmutex); if(nscnt == 0) P(mutex); nscnt ++; V(nsmutex); //go through P(nsmutex); nscnt --; if(nscnt == 0) V(mutex) V(nsmutex); &#125;&#125; 小解答题设有两个优先级相同的进程 P1 和 P2，共享 x、y、z 三个变量，执行代码见下表。信号 量 s1 和 s2 的初值均为 0。试问 P1、P2 并发执行后，x、y、z 的值各是多少？给出解题 过程。 注意有三种情况，但是一共只有两个解","categories":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"https://hasuer.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"进程管理","slug":"进程管理","permalink":"https://hasuer.github.io/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"}]},{"title":"132 Pattern","slug":"132Pattern","date":"2020-10-24T11:54:04.000Z","updated":"2020-10-24T11:57:02.319Z","comments":true,"path":"132-pattern/index.html","link":"","permalink":"https://hasuer.github.io/132-pattern/index.html","excerpt":"","text":"132 PatternGiven an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i &lt; j &lt; k and nums[i] &lt; nums[k] &lt; nums[j]. Return true if there is a 132 pattern in nums, otherwise, return false. Follow up: The O(n^2) is trivial, could you come up with the O(n logn) or the O(n) solution? Example 1: 123Input: nums = [1,2,3,4]Output: falseExplanation: There is no 132 pattern in the sequence. Example 2: 123Input: nums = [3,1,4,2]Output: trueExplanation: There is a 132 pattern in the sequence: [1, 4, 2]. Example 3: 123Input: nums = [-1,3,2,0]Output: trueExplanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0]. Constraints: n == nums.length 1 &lt;= n &lt;= 104 -109 &lt;= nums[i] &lt;= 109 Solution QUESTION: To search for a subsequence (s1,s2,s3) such that s1 &lt; s3 &lt; s2. INTUITION: Suppose we want to find a 123 sequence with s1 &lt; s2 &lt; s3, we just need to find s3, followed by s2 and s1. Now if we want to find a 132 sequence with s1 &lt; s3 &lt; s2, we need to switch up the order of searching. we want to first find s2, followed by s3, then s1. DETECTION: More precisely, we keep track of highest value of s3 for each valid (s2 &gt; s3) pair while searching for a valid s1 candidate to the left. Once we encounter any number on the left that is smaller than the largest s3 we have seen so far, we know we found a valid sequence, since s1 &lt; s3 implies s1 &lt; s2. ALGORITHM: We can start from either side but I think starting from the right allow us to finish in a single pass. The idea is to start from end and search for valid (s2,s3) pairs, we just need to remember the largest valid s3 value, using a stack will be effective for this purpose. A number becomes a candidate for s3 if there is any number on the left bigger than it. CORRECTNESS: As we scan from right to left, we can easily keep track of the largest s3 value of all (s2,s3) candidates encountered so far. Hence, each time we compare nums[i] with the largest candidate for s3 within the interval nums[i+1]...nums[n-1] we are effectively asking the question: Is there any 132 sequence with s1 = nums[i]? Therefore, if the function returns false, there must be no 132 sequence. IMPLEMENTATION: Have a stack, each time we store a new number, we first pop out all numbers that are smaller than that number. The numbers that are popped out becomes candidate for s3. We keep track of the maximum of such s3 (which is always the most recently popped number from the stack). Once we encounter any number smaller than s3, we know we found a valid sequence since s1 &lt; s3 implies s1 &lt; s2. RUNTIME: Each item is pushed and popped once at most, the time complexity is therefore O(n). EXAMPLE:i = 6, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 9, S3 candidate = None, Stack = Emptyi = 5, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 7, S3 candidate = None, Stack = [9]i = 4, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 10, S3 candidate = None, Stack = [9,7]i = 3, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 9, S3 candidate = 9, Stack = [10]i = 2, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 8, S3 candidate = 9, Stack = [10,9] We have 8&lt;9, sequence (8,10,9) found! code: 123456789101112131415class Solution &#123;public: bool find132pattern(vector&lt;int&gt;&amp; nums) &#123; int s3 = INT_MIN; stack&lt;int&gt; st; for( int i = nums.size()-1; i &gt;= 0; i -- )&#123; if( nums[i] &lt; s3 ) return true; else while( !st.empty() &amp;&amp; nums[i] &gt; st.top() )&#123; s3 = st.top(); st.pop(); &#125; st.push(nums[i]); &#125; return false; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://hasuer.github.io/categories/LeetCode/"}],"tags":[{"name":"stack","slug":"stack","permalink":"https://hasuer.github.io/tags/stack/"}]},{"title":"外刊句子","slug":"外刊句子","date":"2020-10-24T03:10:34.000Z","updated":"2020-11-21T15:19:17.846Z","comments":true,"path":"外刊句子/index.html","link":"","permalink":"https://hasuer.github.io/%E5%A4%96%E5%88%8A%E5%8F%A5%E5%AD%90/index.html","excerpt":"","text":"外刊句子积累 被动：And such a drop needs to be achieved not by halting the world in its tracks, but by rewiring it. Ever since Industrial Revolution[something happened in the past] ago, mankind has done sth. 占比： contributors; account for; make up big slices of the pie sth. should be heeded 某事要被留心 rare to do 渴望做 retard v. 阻碍，妨碍 relinquish = quit = give up pay off 带来好的结果 all-out 全力以赴的 masterstroke 绝招，妙招 stare down 勇敢的面对 step down 退位 at the tender age of 在不谙世故的…岁上","categories":[],"tags":[{"name":"新英文杂志","slug":"新英文杂志","permalink":"https://hasuer.github.io/tags/%E6%96%B0%E8%8B%B1%E6%96%87%E6%9D%82%E5%BF%97/"}]},{"title":"book_xv6:Chapter_0","slug":"book-xv6-Chapter-0","date":"2020-10-21T09:58:41.000Z","updated":"2020-10-21T10:07:30.781Z","comments":true,"path":"book-xv6-chapter-0/index.html","link":"","permalink":"https://hasuer.github.io/book-xv6-chapter-0/index.html","excerpt":"","text":"【转载自：https://123xzy.github.io/2019/03/08/MIT-6-828-book-xv6-Chapter-0/】 MIT 6.828 Operating System Engineering 这本书要和xv6源码一起阅读 操作系统接口操作系统的任务是在多个程序之间共享计算机，并提供比硬件单独支持更有用的服务集合。操作系统管理和抽象低级硬件，因此像文字处理机就不需要考虑使用哪种类型的磁盘。它还支持多路复用硬件，允许程序间共享计算机（或近似于）并发运行。最后，操作系统提供了程序交互的受控方式，以便程序之间可以共享数据或者协同工作。 OS通过接口向用户程序提供服务，而设计好的接口是很困难的。一方面，我们希望接口简单和紧凑（窄接口比较容易确保对某一特定点的关注。这点很像铺设自来水管道。管路最初阶段可能从需求和效率考虑需要大口径的，但要入户的时候就要转成小口径，译者注），因为这样更容易正确实现。 另一方面，我们倾向于向应用程序提供更多巧妙的功能。解决这种紧张关系的技巧是设计依赖提供更大的通用性的机制的接口。 这本书使用一个简单OS作为具体示例来阐述OS相关概念。这个OS，即xv6，提供的简单接口，来自于Ken Thompson and Dennis Ritchie的Unix操作系统，并且模拟了Unix的内部设计。Unix的接口提供的窄接口，其机制很好的融合在了一起，提供了令人惊讶的通用性。这些接口很成功，以至于像BSD、Linux，Mac OS X、Solaris，甚至一部分Windows，都有类Unix接口。理解xv6是理解其他任何系统的良好开始。 如图0-1所示，xv6采用了传统形式的内核，内核是为运行程序提供服务的特殊程序。每个运行程序（称为进程）的内存中都包含了指令、数据和栈。指令实现了程序的运算，数据则是运算所依赖的变量，栈则组织了程序的调用过程。 当进程需要调用内核服务时，将调用操作系统接口中的过程调用。这种过程称为系统调用。系统调用会陷入内核态，内核执行完服务并返回用户态。因此进程在用户空间和内核空间之间交替变换。 内核使用CPU的硬件保护机制来确保在用户空间的每个进程只能访问自己的内存。内核在硬件特权上运行，因此需要实现这些保护；用户程序在执行时则没有这些特权。当用户程序调用系统调用时，硬件会提升权限级别，并开始执行在内核中预先写好的函数。 内核提供的系统调用集合就是用户程序可见的接口。xv6内核提供了Unix内核传统提供的服务和系统调用的子集。图 0-2列出了xv6的所有系统调用。 本章其余部分概述了xv6的服务：进程、内存、文件描述、管道和文件系统，并通过代码段来说明shell如何使用它们。shell对系统调用的使用将说明系统调用设计的是多么精巧。 shell是一个从用户读取命令并执行他们的普通程序，而且是传统类Unix的主要用户界面。shell只是一个用户程序，而不是内核的一部分，shell没有什么特别之处反倒说明了系统调用接口的力量。这也意味着shell很容易更换，因此现代Unix系统都有各种各样shell去选择，每种shell都有自己的界面和脚本功能。xv6的shell本质上就是Unix Bourne shell的简单实现。其实现源码从第8350行开始。 进程和内存xv6进程由用户空间内存（指令、数据和栈）和内核的每个进程私有状态组成。xv6可以分时（time-share）处理进程，它透明地在等待执行的进程组之间切换，来分配可用的CPU。当进程未执行时，xv6会保存其CPU寄存器，并在下次运行时还原。内核将进程标识符（pid）和每个进程关联。 进程可以使用fork系统调用来创建新的进程。fork创建的子进程（chile process）和调用进程（父进程，parent process）有着一样的内存信息。fork返回父进程和子进程中都返回，在父进程中返回子进程的pid，在子进程中则返回0。例如考虑下面这个程序片段 12345678910111213int pid = fork(); if(pid &gt; 0)&#123; printf(&quot;parent: child=%d\\n&quot;, pid); pid = wait(); printf(&quot;child %d is done\\n&quot;, pid);&#125; else if(pid == 0)&#123; printf(&quot;child: exiting\\n&quot;); exit();&#125; else&#123; printf(&quot;fork error\\n&quot;);&#125; exit系统调用会导致调用进程结束执行并释放如内存和文件这样的资源。wait系统调用返回当前进程的退出子进程的pid。如果调用者没有子进程退出，则等待。在实例中，命令行输出： 12child=1234chileL:exiting 上面两句话会按任意顺序出现，这取决于父进程还是子进程先接收到printf调用。当子进程退出后，父进程的wait返回，因此打印出 1parent:child 1234 is done 注意父进程和子进程在不同的内存和寄存器中运行，改变变量值不会影响另外一个。 exec系统调用用从存储在文件系统的文件加载的新内存镜像来替换调用进程的内存。该文件必须具有特定格式，其指明文件的那部分是指令，那部分是数据，从哪里开始执行等。xv6使用ELF格式，第二章将详细讨论该格式。 当exex成功调用后，不会返回调用程序，而是从ELF头部声明的入口开始执行。exec需要两个参数：可执行文件名和字符串参数数组，例如 123456char *argv[3];argv[0] = &quot;echo&quot;; argv[1] = &quot;hello&quot;; argv[2] = 0; exec(&quot;/bin/echo&quot;, argv); printf(&quot;exec error\\n&quot;); 这个片段将调用程序替换成参数为echo hello的/bin/echo程序实例。大多数程序会忽略第一个参数，这通常是程序名称。 xv6使用上述调用来代替用户运行程序。shell的主体结构很简单，见main（8501行）。主循环使用getcmd读取命令行上的输入。然后调用fork，创建shell进程的副本。父进程调用wait，子进程运行命令。例如，如果用户在提示符下输入echo hello，runcmd将被调用，并以echo hello为参数。runcmd（8406行）执行实际命令。对于echo hello，将调用echo（8426行）。如果exec成功执行，子进程会执行echo的指令，而不是runcmd。在某些点，echo会调用exit，这会导致父进程从wait返回。也许你想知道fork和exec为什么没有合成一个调用，稍后我们将看到，单独调用创建进程和加载程序是一个巧妙的设计。 xv6隐式分配大多数用户空间的内存，fork分配子进程需要的内存，exec分配足够的内存去保存可执行文件。在运行时进程可能需要更多的内存，例如malloc这时候可以调用sbrk(n)将内存扩展n字节。sbrk返回新内存的地址。 xv6不提供用户的概念，也不提供保护一个用户免受一个用户影响的概念，在unix中，所有xv6都以root身份运行。 I/O和文件描述符文件描述符是只是一个小整数值，代表一个进程读取或写入的内核管理对象。进程可以通过打开文件、目录、设备、创建管道、复制存在的描述符来获取文件描述符。简单起见我们通常把文件描述符就当做文件，但其实文件描述符接口是文件、管道和设备的抽象，使它们看起来都是字节流。 xv6内部将文件描述符作为每个预处理表（per—process table）的索引，因此每个进程都有一个从零开始的文件描述符的专有空间。按照惯例，进程从文件描述符0（标准输入）读取，将输出写入到文件描述符1（标准输出），并将错误信息写入文件描述符2（标准错误）。正如我们将看到的，shell利用这个约定（exploits the convention）来实现I/O重定向和管道。shell保证始终打开三个文件描述符（8507），这是控制台的默认文件描述符。 read和write系统调用从描述符命令的打开文件中读取和写入字节。read(fd,buf,n)最多从文件描述符fd读取n字节，将其复制到buf，并返回读取的字节数。每个文件描述符都有一个偏移量，其和引用的文件相关。read从当前文件偏移处读取数据，然后将偏移量向前移动所要读取的n字节数，后续的read将从新的位置继续读取字节。当没有更多的字节能读时，返回0，标志着读到了文件末尾。 write(fd,buf,n)从buf中写入n字节到文件描述符fd，并返回写入的字节数。只有在发生错误时，才会写入少于n字节。像read、write在当前文件偏移处写入数据，并将偏移量向前移动写入的n字节，每次write都会从前一个写入位置写入。 下面的程序片段（构成了cat的本质）从标准输入复制数据到标准输出。如果发生错误，将信息写入标准错误。 123456789101112char buf[512]; int n;for(;;)&#123; n = read(0, buf, sizeof buf); if(n == 0) break; if(n &lt; 0)&#123; fprintf(2, &quot;read error\\n&quot;); exit(); &#125; if(write(1, buf, n) != n)&#123; fprintf(2, &quot;write error\\n&quot;); exit(); &#125;&#125; 在代码段中需要注意的是cat并不知道它是从文件、控制台还是管道读取。同样，cat也不知道它是打印到控制台、文件还是其他地方。文件描述符的使用，文件描述符0是输入，1是输出，这整个约定使得cat能简单实现。 close系统调用释放文件描述符，使其可被cat、open、pipe和dup重用。新分配的文件描述符始终是当前进程的最小未使用编号。 文件描述符和fork的相互交互使得I/O重定向变得易于实现。fork复制父进程的文件描述符表和内存，使得子进程从和父进程有着相同的打开文件。exec替换调用进程的内存，但是保留其文件表。此行为允许shell通过fork，重新打开选定的文件并执行新的程序来实现I/O重定向。下面是shell命令为cat &lt; input.txt简化代码 12345678char *argv[2];argv[0] = &quot;cat&quot;;argv[1] = 0;if(fork() == 0) &#123; close(0); open(&quot;input.txt&quot;, O_RDONLY); exec(&quot;cat&quot;, argv);&#125; 子进程关闭文件描述符0之后，保证open能将其用于新打开的input.txt，此时0就是最小的可用文件描述符。cat使用引用input.txt的文件描述符0（标准输入）执行。 xv6 shell中的I/O重定向就是以上述方式工作（8430）。回想一下，shell已经fork了child shell，并且runcmd将调用exec加载新程序。现在应该清楚为什么fork和exec单独调用是一个好主意。这种分离允许shell在子程序运行所需要的程序之前修复子进程。 尽管fork复制文件描述符表，但每个基础文件偏移量都在父进程和子进程之间分享。看下面这个实例： 1234567if(fork() == 0) &#123; write(1, &quot;hello &quot;, 6); exit();&#125; else &#123; wait(); write(1, &quot;world\\n&quot;, 6);&#125; 在这个片段的末尾，附加到文件描述符1的文件将包含数据hello world。父进程的write（由于wait，只能在子进程结束之后才会运行）会在子进程write中断的地方继续执行。这种行为将有助于从shell命令序列中产生有序输出，如(echo hello;echo world) &gt; output.txt dup复制现有的文件描述符，返回一个指向相同I/O对象的新文件描述符。这两个文件描述符共享偏移量，就像fork复制的文件描述符一样。这是将hello world写入文件的另一种方法： 123fd = dup(1); write(1, &quot;hello &quot;, 6);write(fd, &quot;world\\n&quot;, 6); 如果文件描述符是通过一系列fork和dup从同一原始文件派生的，则他们共享偏移量，否则即使他们使用open打开同一个文件，也不共享偏移量。dup允许shell实现这样的命令：ls existing-file non-existing-file &gt; tmp1 2&gt;&amp;1。2&gt;&amp;1告诉shell提供一个文件描述符2，它是描述符1的副本。现有文件的名字和错误信息都保存在文件tmp1。xv6 shell不支持错误文件描述符的I/O重定向，但你应该知道如何实现。 文件描述符是一个强大的抽象，因为它隐藏了连接的细节：写入文件描述符1的进程可能正写入文件、控制台等设备或者管道。 管道pipe是一个小的内核缓冲区，以一对文件描述符的形式公开给进程，一个用于读取，另一个用于写入。将数据写入管道的一段可使数据从管道的另一端被读取。管道为进程提供了一种通信方式。 下面的示例代码使用连接到管道读取端的标准输入运行程序WC： 1234567891011121314151617int p[2]; char *argv[2];argv[0] = &quot;wc&quot;; argv[1] = 0;pipe(p); if(fork() == 0) &#123; close(0); dup(p[0]); close(p[0]); close(p[1]); exec(&quot;/bin/wc&quot;, argv);&#125; else &#123; write(p[1], &quot;hello world\\n&quot;, 12); close(p[0]); close(p[1]);&#125; 程序调用pipe，它创建一个新管道，并在数组p中记录读取和写入的文件描述符。在fork之后，父进程和子进程都有引用管道的文件描述符。子进程将读取结果传入文件描述符0，关闭p中的文件描述符，以及执行wc。当wc从标准输入读取时，其实是从管道读取。父进程写入管道的写入端，然后关闭两个文件描述符。 如果没有可用数据，管道上的read会等待数据的写入或者关闭写入端的所有文件描述符。在后一种情况下，read返回0，就像已达到数据文件的末尾。阻塞read直到不可能到达新数据的一个原因是在执行wc之前，让子进程关闭管道的写入端非常重要。因为如果wc的一个文件描述符指向了管道的写入端，wc将永远不会看到文件末尾。 xv6 shell实现了诸如grep fork sh.c | wc -l等类似代码（8450）的管道。子进程创建一个管道，将管道的左端和右端相连，然后调用runcmd为管道的左端和右端。然后调用两次wait去等待左端和右端的完成。管道的右端可能是一个命令，该命令本身也是一个管道（如a | b | c），它本省分叉成两个子进程（一个用于b，一个用于c）。因此shell可能会创建一个进程树。树的叶节点是命令，内部节点是等待左右子进程完成的进程。原则上，你可以让内部节点运行管道的左端，但正确的完成会使得实现变得复杂。管道看起来并没有比临时文件强大，例如echo hello world | wc也可以在没有管道的情况下实现echo hello world &gt; /tmp/xyz;wc &lt; /tmp/xzy 管道和临时文件至少有三个关键区别。第一个，管道会自动清理自己，而在文件重定向时，shell必须在完成时小心的溢出/tmp/xzy。其次，管道可以通过任意长度的数据流，而文件重定向需要磁盘上足够的可用空间来存储所有数据。最后，管道允许同步，两个进程可以使用一对管道相互发送消息，每个read都会阻塞调用进程，直到另一个进程通过write写入数据。 文件系统xv6文件系统提供了数据文件，这些数据文件都是没解释的字节数组和目录，其中包含对数据文件和其他目录的命令引用。xv6将目录实现为一种特殊的文件。目录形成一个从称为root的特殊目录开始的树。像/a/b/c这样的路径指向了根目录中b目录中的命名为c的文件或目录。路径如果没有以/开始，就会改用chdir系统调用，来计算相对于调用进程的当前目录的位置。这两种方式都能打开相同的文件（假设涉及的目录都存在）： 1234chdir(&quot;/a&quot;); chdir(&quot;b&quot;); open(&quot;c&quot;, O_RDONLY); open(&quot;/a/b/c&quot;, O_RDONLY); 第一个片段将进程的当前目录更改为/a/b，第二个既不引用也不修改进程的当前目录。 这里有多个系统调用来创建新的文件和目录：mkdir创建一个新的目录，使用O_CREAT标志的open创建一个新的数据文件，mknod创建新的设备文件。下面的示例说明了这三个方面： 1234mkdir(&quot;/dir&quot;); fd = open(&quot;/dir/file&quot;, O_CREATE|O_WRONLY); close(fd);mknod(&quot;/console&quot;, 1, 1); mknod在文件系统中创建一个文件，但是该文件没有内容。相反，该文件的元数据将其标记为设备文件，并记录主要和次要的设备编号（传给mknod的两个参数），它们惟一的标志内核设备。当进程之后打开该文件时，内核将read和write调用转移到内核实现，而不是将它们传到文件系统。 123456789101112fstat`检索有关文件描述符所引用对象的信息。它填充`struct stat`，该结构定义在`stat.h#define T_DIR 1 // Directory#define T_FILE 2 // File #define T_DEV 3 // Devicestruct stat &#123;short type; // Type of file int dev; // File system’s disk device uint ino; // Inode number short nlink; // Number of links to file uint size; // Size of file in bytes&#125;; 文件名和文件本身并不同，同一个基础文件，叫做inode，可以有多个名称，叫做links。link系统调用创建另一个文件系统名称，引用和现有文件相同的inode。下面片段创建了一个文件，其名称既可以为a，也可以为b 12open(&quot;a&quot;, O_CREATE|O_WRONLY);link(&quot;a&quot;, &quot;b&quot;); 从a或者从b读取、写入是一模一样的。每个inode都是有惟一的inode number标识的。执行了上面的代码之后，可以通过fstat的结果来确定a和b指向相同的基础内容，两者都返回相同的inode number（ino），并且nlink将设置为2。 unlink将从文件系统中删除一个名称。只有当文件的链接数为0并没有文件描述符引用该文件时，才会释放文件的inode和磁盘空间，因此unlink(&quot;a&quot;);将使得inode和文件内容只能被b访问。而且下面的方法是常用的方式来创建临时inode，其在进程关闭fd或者退出时，会被清理。 12fd = open(&quot;/tmp/xyz&quot;, O_CREATE|O_RDWR); unlink(&quot;/tmp/xyz&quot;); 用于文件系统操作的xv6 命令被作为用户级程序（如mkdir、ln、rm等）实现。这种设计允许任何人使用新的用户命令扩展shell。事后看来，这个计划似乎很明显，但和unix同时期设计的其他系统经常在shell中构建这样的命令（并将shell构建到内核中）。 一个例外是cd，它内置到shell (8516) 中。cd必须更改shell本身的当前工作目录。如果cd 作为常规命令运行，并且shell 将分叉子进程, 子进程将运行cd，cd将更改子进程的工作目录。父目录（即shell的）工作目录不会更改。 真实世界unix将“标准”文件描述符、管道和方便的shell语法结合起来，用于对其进行操作，这是编写通用可重用程序的一大进步。这个想法引发了整个“软件工具”的文化，它在很大程度上是unix的力量和人气的原因,，shell是第一个所谓的“脚本语言”。在BSD、Linux和Mac OS X等系统中, unix系统调用接口如今仍然存在。 与xv6相比，现代内核提供了更多的系统调用和更多种类的内核服务。在大多数情况下，现代unix派生的操作系统没有遵循早期的unix模型，即将设备公开为特殊文件，如上面讨论的控制台设备文件。unix的作者接着构建了计划9，该计划将“资源是文件”概念应用于现代设施，将网络、图形和其他资源表示为文件或文件树。 文件系统抽象是一个强大的想法，最近以万维网的形式应用于网络资源。即使如此，操作系统接口还有其他模型。multics是unix的前身，它的抽象文件存储使其看起来像内存，产生了截然不同的接口风格。multics设计的复杂性直接影响了unix的设计者，他们试图构建更简单的设计器。 这本书探讨了xv6如何实现类似unix的界面, 但这些想法和概念不仅仅适用于unix。任何操作系统都必须将进程多路复用到底层硬件上，将进程彼此隔离，并提供受控制的进程间通信机制。在研究了xv6之后，您应该能够查看其他更复杂的操作系统，并在这些系统中看到xv6的基本概念。","categories":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"https://hasuer.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"MIT OS","slug":"MIT-OS","permalink":"https://hasuer.github.io/tags/MIT-OS/"}]},{"title":"Blog目录","slug":"Blog目录","date":"2020-10-20T17:13:54.000Z","updated":"2021-06-28T10:37:57.543Z","comments":true,"path":"blog目录/index.html","link":"","permalink":"https://hasuer.github.io/blog%E7%9B%AE%E5%BD%95/index.html","excerpt":"","text":"MIT 6.828 Operating System Engineering 【】","categories":[],"tags":[]},{"title":"MIT 6.828 Operating System Engineering","slug":"MIT 6.828 Operating System Engineering","date":"2020-10-20T17:13:54.000Z","updated":"2020-11-15T15:45:13.640Z","comments":true,"path":"mit-6-828-operating-system-engineering/index.html","link":"","permalink":"https://hasuer.github.io/mit-6-828-operating-system-engineering/index.html","excerpt":"","text":"MIT 6.828 Operating System Engineering【转载自：https://123xzy.github.io/2019/03/08/MIT-6-828-Operating-System-Engineering/】 这个系列的文章会以上面链接中的资源为依据作为学习，在此只是搬运。对于实验和作业会加上自己的理解。每一篇文章前都会加上转载声明，感谢原作者。 MIT 6.828是一门被广泛好评的e操作系统课程。它最重要的特点就是它实践第一的教学原则。在这门课程中会涉及到非常丰富的实验，也会有非常多的动手机会。而且授课者更是亲自构建了一个简化的基于Unix内核的操作系统xv6。所有的实验都是在这个操作系统上完成。虽然它功能很简单，但是它能够帮助我们真正的了解操作系统在做什么 这一系列文章会包括以下几个内容： Lab：MIT 6.828 Lab * Exercise：MIT 6.828 Exercise * Assignment：MIT 6.828 Assignment * book_xv6：别人的中文翻译，MIT 6.828 book_xv6 * 目录book book-rev10：英文原版书籍 MIT 6.828 book_xv6:Chapter 0：操作系统接口 MIT 6.828 book_xv6:Chapter 1：操作系统组成 MIT 6.828 book_xv6:Chapter 2：页表 MIT 6.828 book_xv6:Chapter 3：陷阱、中断和驱动 MIT 6.828 book_xv6:Chapter 4：锁 MIT 6.828 book_xv6:Chapter 5：调度程序 MIT 6.828 book_xv6:Chapter 6：文件系统 MIT 6.828 book_xv6:Appendix A：PC硬件 MIT 6.828 book_xv6:Appendix B：Boot loader Lab MIT 6.828 Lab:Guide MIT 6.828 Lab:Booting a PC MIT 6.828 Lab:Memory Management Assignment MIT 6.828 Assignment:Shell MIT 6.828 Assignment:Boot xv6 MIT 6.828 Assignment:System Calls MIT 6.828 Assignment_ThreadsandLocks MIT 6.828 Assignment_Barriers","categories":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"https://hasuer.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"MIT OS","slug":"MIT-OS","permalink":"https://hasuer.github.io/tags/MIT-OS/"}]},{"title":"MIT 6.828 Assignment_Shell","slug":"MIT 6.828 Assignment_Shell","date":"2020-10-20T15:44:53.000Z","updated":"2020-11-06T14:48:47.751Z","comments":true,"path":"mit-6-828-assignment-shell/index.html","link":"","permalink":"https://hasuer.github.io/mit-6-828-assignment-shell/index.html","excerpt":"","text":"【转载自：】 https://www.cnblogs.com/jxhd1/p/6706701.html https://www.cnblogs.com/fengbohello/p/4262961.html https://123xzy.github.io/2019/03/08/MIT-6-828-Assignment-Shell/ 实验指导书 MIT 6.828 Operating System Engineering 知识了解fork 和 exec在父进程中fork一个子进程，在子进程中调用exec函数启动新的程序。exec函数一共有六个，其中execve为内核级系统调用，其他（execl，execle，execlp，execv，execvp）都是调用execve的库函数。 1#include &lt;unistd.h&gt; fork是分身，execve是变身。 exec系列的系统调用是把当前程序替换成要执行的程序，而fork用来产生一个和当前进程一样的进程（虽然通常执行不同的代码流）。通常运行另一个程序，而同时保留原程序运行的方法是，fork+exec。 看看手册里面的例子就知道怎么用了。 exec系列的系统调用已经是变成别的程序了，已经和本程序无关了 open() 和 close()open 函数用于打开和创建文件。以下是 open 函数的简单描述 12#include &lt;fcntl.h&gt;int open(const char *pathname, int oflag, ... ); 12345678910int execl(const char *pathname, const char *arg, ... /* (char *) NULL */);int execlp(const char *file, const char *arg, ... /* (char *) NULL */);int execle(const char *pathname, const char *arg, ... /*, (char *) NULL, char *const envp[] */);int execv(const char *pathname, char *const argv[]);int execvp(const char *file, char *const argv[]);int execvpe(const char *file, char *const argv[], char *const envp[]); 返回值：成功则返回文件描述符，否则返回 -1 对于open函数来说，第三个参数（…）仅当创建新文件时才使用，用于指定文件的访问权限位（access permission bits）。pathname 是待打开/创建文件的路径名（如 C:/cpp/a.cpp）；oflag 用于指定文件的打开/创建模式，这个参数可由以下常量（定义于 fcntl.h）通过逻辑或构成。O_RDONLY 只读模式O_WRONLY 只写模式O_RDWR 读写模式 打开/创建文件时，至少得使用上述三个常量中的一个。以下常量是选用的： O_APPEND 每次写操作都写入文件的末尾O_CREAT 如果指定文件不存在，则创建这个文件O_EXCL 如果要创建的文件已存在，则返回 -1，并且修改 errno 的值O_TRUNC 如果文件存在，并且以只写/读写方式打开，则清空文件全部内容O_NOCTTY 如果路径名指向终端设备，不要把这个设备用作控制终端。O_NONBLOCK 如果路径名指向 FIFO/块文件/字符文件，则把文件的打开和后继 I/O设置为非阻塞模式（nonblocking mode） 以下三个常量同样是选用的，它们用于同步输入输出O_DSYNC 等待物理 I/O 结束后再 write。在不影响读取新写入的数据的前提下，不等待文件属性更新。O_RSYNC read 等待所有写入同一区域的写操作完成后再进行O_SYNC 等待物理 I/O 结束后再 write，包括更新文件属性的 I/O open 返回的文件描述符一定是最小的未被使用的描述符。 如果 NAME_MAX（文件名最大长度，不包括’\\0’）是 14，而我们想在当前目录下创建文件名长度超过 14 字节的文件，早期的 System V 系统（如 SVR2）会截断超出部分，只保留前 14 个字节；而由 BSD 衍生的（BSD-derived）系统会返回错误信息，并且把 errno 置为 ENAMETOOLONG。POSIX.1 引入常量 _POSIX_NO_TRUNC 用于决定是否截断长文件名/长路径名。如果_POSIX_NO_TRUNC 设定为禁止截断，并且路径名长度超过 PATH_MAX（包括 ‘\\0’），或者组成路径名的任意文件名长度超过 NAME_MAX，则返回错误信息，并且把 errno 置为 ENAMETOOLONG。 The shellMIT 6.828 Operating System Engineering 做作业之前先熟悉OSMIT 6.828 book_xv6:Chapter 0该作业的解释文档下载sh.c 建立t.sh文件 123456ls &gt; ycat &lt; y | sort | uniq | wc &gt; y1cat y1rm y1ls | sort | uniq | wcrm y gcc，你可以编译骨架shell，如下所示：$ gcc sh.c生成一个a.out文件，你可以运行：$ ./a.out &lt;t.sh此执行将打印错误消息，因为您尚未实现多个功能。在本作业的其余部分中，您将实现这些功能 分析先看看主函数的行为 12345678910111213141516171819202122intmain(void)&#123; static char buf[100]; int fd, r; // Read and run input commands. while(getcmd(buf, sizeof(buf)) &gt;= 0)&#123; if(buf[0] == &#x27;c&#x27; &amp;&amp; buf[1] == &#x27;d&#x27; &amp;&amp; buf[2] == &#x27; &#x27;)&#123; // Clumsy but will have to do for now. // Chdir has no effect on the parent if run in the child. buf[strlen(buf)-1] = 0; // chop \\n if(chdir(buf+3) &lt; 0) fprintf(stderr, &quot;cannot cd %s\\n&quot;, buf+3); continue; &#125; if(fork1() == 0) runcmd(parsecmd(buf)); wait(&amp;r); &#125; exit(0);&#125; 循环调用getcmd函数读入命令，如果是cd命令，则先切换文件夹，因为如果在子进程切换将对父进程无效。确认不是cd之后，创建子进程并调用关键函数runcmd()，其中parsecmd(buf)无非就是解析命令，里面就是一些字符串处理，不关心。 下面就我们要完成的代码片段 1234567891011121314151617181920212223242526272829303132333435363738394041// Execute cmd. Never returns.voidruncmd(struct cmd *cmd)&#123; int p[2], r; struct execcmd *ecmd; struct pipecmd *pcmd; struct redircmd *rcmd; if(cmd == 0) exit(0); switch(cmd-&gt;type)&#123; default: fprintf(stderr, &quot;unknown runcmd\\n&quot;); exit(-1); case &#x27; &#x27;: ecmd = (struct execcmd*)cmd; if(ecmd-&gt;argv[0] == 0) exit(0); fprintf(stderr, &quot;exec not implemented\\n&quot;); // Your code here ... break; case &#x27;&gt;&#x27;: case &#x27;&lt;&#x27;: rcmd = (struct redircmd*)cmd; fprintf(stderr, &quot;redir not implemented\\n&quot;); // Your code here ... runcmd(rcmd-&gt;cmd); break; case &#x27;|&#x27;: pcmd = (struct pipecmd*)cmd; fprintf(stderr, &quot;pipe not implemented\\n&quot;); // Your code here ... break; &#125; exit(0);&#125; parsecmd把命令分成了3个类型，分别是可执行命令，重定向命令，以及管道命令。也就是接下来要实现的 简单命令该题的要求就是先调用当前目录下的可执行程序，如果不存在，就去/bin文件夹下寻找，如果没有则报错 需要使用的就是execv函数，它是exec函数族的一个，exec函数族的作用就是根据pathname找到可执行文件，并用它取代调用进程的内容。虽然pid未改变，但是实际运行的内容已经不同。结合之前main函数中的内容，可以看出Shell执行某个命令实际上就是fork出一个子进程，然后把子进程替换为想要执行的程序。这个函数在小册子中也讲解过，可以通过man 3 exec去查看函数解释 除此之外，还需要一个辅助函数access，它的作用是检查能否对某个文件（pathname）执行某个操作（mode）。模式有： R_OK：测试读许可权 W_OK：测试写许可权 X_OK：测试执行许可权 F_OK：测试文件是否存在 12345678910111213141516171819202122232425262728293031323334353637383940case &#x27; &#x27;: ecmd = (struct execcmd*)cmd; if (ecmd-&gt;argv[0] == 0) exit(0); // fprintf(stderr, &quot;exec not implemented\\n&quot;); if (access(ecmd-&gt;argv[0], F_OK) == 0) &#123; execv(ecmd-&gt;argv[0], ecmd-&gt;argv); &#125; else &#123; const char *binPath = &quot;/bin/&quot;; int pathLen = strlen(binPath) + strlen(ecmd-&gt;argv[0]); char *abs_path = (char *)malloc((pathLen+1)*sizeof(char)); strcpy(abs_path, binPath); strcat(abs_path, ecmd-&gt;argv[0]); if (access(abs_path, F_OK) == 0) &#123; execv(abs_path, ecmd-&gt;argv); &#125; else &#123; fprintf(stderr, &quot;%s: Command not found\\n&quot;, ecmd-&gt;argv[0]); &#125; &#125; break;//以下是我自己的答案 1 case &#x27; &#x27;: 2 ecmd = (struct execcmd*)cmd; 3 if (ecmd-&gt;argv[0] == 0) 4 exit(0); 5 // fprintf(stderr, &quot;exec not implemented\\n&quot;); 6 if (execvp(ecmd-&gt;argv[0], ecmd-&gt;argv) == -1) &#123; 7 const char *basePath = &quot;/bin/&quot;; 8 int pathLen = strlen(basePath) + strlen(ecmd-&gt;argv[0]); 9 char *path = (char *)malloc((pathLen+1)*sizeof(char)); 10 strcpy(path, basePath); 11 strcat(path, ecmd-&gt;argv[0]); 12 if (access(path, F_OK) != 0) &#123; 13 fprintf(stderr, &quot;%s: Command not found\\n&quot;, ecmd-&gt;argv[0]); 14 &#125; 15 execv(path, ecmd-&gt;argv); 16 &#125; 17 break; 理解shell实验第一部分网上的答案： 123456789case &#x27; &#x27;: ecmd = (struct execcmd*)cmd; if (ecmd-&gt;argv[0] == 0) exit(0); // fprintf(stderr, &quot;exec not implemented\\n&quot;); if (execvp(ecmd-&gt;argv[0], ecmd-&gt;argv) == -1) &#123; printf(&quot;ls error!&quot;); &#125; break; 当时一直没有搞懂为什么要用execp(ecmd-&gt;argv[0], ecmd-&gt;argv)。当时不理解的地方就在于，man文档说的是: 1int execlp(const char *file, const char *arg, ...); The execv(), execvp(), and execvpe() functions provide an array of pointers to null-terminated strings that represent the argument list available to the new program. The first argument, by convention, should point to the filename associated with the file being executed. The array of pointers must be terminated by a NULL pointer. 为什么`ecmd->argv[0]`的能作为第一个参数，也就是为什么他就是一个指向文件的指针？ 这就不得不提一下我们的exec这个函数族了。 函数定义 : 1int execv(const char *filename, char *const argv[ ], char *const envp[ ]); 返回值: 函数执行成功时没有返回值，执行失败时的返回值为-1. 函数说明 :execve()用来执行参数filename字符串所代表的文件路径，第二个参数是利用数组指针来传递给执行文件，并且需要以空指针(NULL)结束，最后一个参数则为传递给执行文件的新环境变量数组。 1234561. #include&lt;unistd.h&gt; 2. main() 3. &#123; 4. char *argv[ ]=&#123;&quot;ls&quot;, &quot;-al&quot;, &quot;/etc/passwd&quot;, NULL&#125;; 6. execvp(&quot;/bin/ls&quot;, argv); 7. &#125; 这与在bin目录下执行 ls -al /etc/passwd所得到的结果是一样的。 1234567//另一个例子1. #include&lt;unistd.h&gt; 2. main() 3. &#123; 4. char *argv[ ]=&#123;&quot;ls&quot;, &quot;-al&quot;, &quot;/etc/passwd&quot;, NULL&#125;; 6. execvp(&quot;/bin/echo&quot;, argv); 7. &#125; 这与在bin目录下执行 echo -al /etc/passwd所得到的结果是一样的。会在控制台输出-al /etc/passwd。 对于这个问题，老师是这样回答的： argv[]的第一个元素的意义何在一个程序，无论是C语言编写的int main(int argc,char** argv[])，还是shell脚本，都可以从命令行得到运行参数，例如：./myprogram ant bee cat dog那么，argv[1]就是ant，argv[2]就是bee……注意，argv[0]是myprogram，也就是说，有的程序希望在运行的时候知道自己的名字，它就会从argv[0]里找到自己的名字。这就是你设argv[0]的意义。 这样上面的答案就能说通了。先检查文件是否存在，如果不存在就去/bin/下去找这个文件，如果还没有，就说明命令错误了。 此外： I/O重定向12345678910111213The parser already recognizes &quot;&gt;&quot; and &quot;&lt;&quot;, and builds a redircmd for you, so your job is just filling out the missing code in runcmd for those symbols. You might find the man pages for open and close usefulcase &#x27;&gt;&#x27;:case &#x27;&lt;&#x27;: rcmd = (struct redircmd*)cmd; // fprintf(stderr, &quot;redir not implemented\\n&quot;); // Your code here ... close(rcmd-&gt;fd); if (open(rcmd-&gt;file, rcmd-&gt;mode, 0644) &lt; 0) &#123; fprintf(stderr, &quot;Unable to open file: %s\\n&quot;, rcmd-&gt;file); exit(0); &#125; runcmd(rcmd-&gt;cmd); break; 思路就是先关闭程序原先的标准输入/输出，打开指定文件作为新的标准输入/输出。非常容易漏掉权限位，即open的第三个参数。这是权限！ cat是连接0号文件和1号文件，也就是文件标识符是0和1的文件，默认0号文件（标准输入）是键盘，默认1号文件（标准输出）是屏幕。 管道You might find the man pages for pipe, fork, close, and dup useful，也就是说这次涉及的函数主要是pipe、dup、fork、close，通过输入前面创建的t.sh批处理文件，来计算当前目录下文件的大小 1234567891011121314151617181920case &#x27;|&#x27;: pcmd = (struct pipecmd*)cmd; // fprintf(stderr, &quot;pipe not implemented\\n&quot;); // Your code here ... if (pipe(p) &lt; 0) fprintf(stderr,&quot;pipe failed\\n&quot;); if (fork1() == 0) &#123; //子进程 close(1);//子进程关闭自己的标准输出 dup(p[1]); close(p[0]);//关闭子进程自己的读 close(p[1]);//关闭子进程自己的写 runcmd(pcmd-&gt;left); &#125; else &#123; close(0);//父进程关闭自己的标准输入 dup(p[0]); close(p[0]);//关闭父进程自己的读 close(p[1]);//关闭父进程自己的写 runcmd(pcmd-&gt;right); &#125; break; 理解 上面的管道是匿名管道 先创建管道，再创建子进程（fork）。这样父子就都有一个管道，并且都能够进行读和写的操作。 p[0]用来读取，p[1]用来写入 由于批处理文件的命令既有在/bin/下，也有在/usr/bin，因此之前的case需要修改 123456789101112131415161718192021222324252627282930case &#x27; &#x27;: ecmd = (struct execcmd*)cmd; if(ecmd-&gt;argv[0] == 0) exit(0); // fprintf(stderr, &quot;exec not implemented\\n&quot;); if(access(ecmd-&gt;argv[0], F_OK) == 0) &#123; execv(ecmd-&gt;argv[0], ecmd-&gt;argv); &#125; else &#123; // 将路径改为数组实现 const char *binPath[] = &#123;&quot;/bin/&quot;, &quot;/usr/bin/&quot;&#125;; char *abs_path; int bin_count = sizeof(binPath)/sizeof(binPath[0]); int found = 0; for (int i=0; i&lt;bin_count &amp;&amp; found==0; i++) &#123; int pathLen = strlen(binPath[i]) + strlen(ecmd-&gt;argv[0]); abs_path = (char *)malloc((pathLen+1)*sizeof(char)); strcpy(abs_path, binPath[i]); strcat(abs_path, ecmd-&gt;argv[0]); if(access(abs_path, F_OK) == 0) &#123; execv(abs_path, ecmd-&gt;argv); found = 1; &#125; free(abs_path); &#125; if (found == 0) &#123; fprintf(stderr, &quot;%s: Command not found\\n&quot;, ecmd-&gt;argv[0]); &#125; &#125; break;","categories":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"https://hasuer.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"MIT OS","slug":"MIT-OS","permalink":"https://hasuer.github.io/tags/MIT-OS/"}]},{"title":"归并排序","slug":"归并排序","date":"2020-10-17T16:55:24.000Z","updated":"2022-02-23T07:00:14.846Z","comments":true,"path":"归并排序/index.html","link":"","permalink":"https://hasuer.github.io/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/index.html","excerpt":"","text":"归并排序这是一个典型排序问题。用到了递归和分治的思想。 动图1： 动图2： 分为三步： 递归分解 合并排好序的数组 主函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void mergearray(vector&lt;int&gt;&amp; nums, int first, int mid, int last, vector&lt;int&gt;&amp; temp)&#123; int i = first; int j = mid + 1; int k = 0; int m = mid; int n = last; while(i &lt;= m &amp;&amp; j &lt;= n)&#123; if(nums[i] &lt;= nums[j])&#123; temp[k ++] = nums[i ++]; &#125; else&#123; temp[k ++] = nums[j ++]; &#125; &#125; while(i &lt;= m)&#123; temp[k ++] = nums[i ++]; &#125; while(j &lt;= n)&#123; temp[k ++] = nums[j ++]; &#125; for(int i = 0; i &lt; k; i ++)&#123; nums[i + first] = temp[i]; &#125;&#125;void mergesort(vector&lt;int&gt;&amp; nums, int first, int last, vector&lt;int&gt;&amp; temp)&#123; if(first &lt; last)&#123; int mid = (first + last) / 2; mergesort(nums, first, mid, temp); mergesort(nums, mid + 1, last, temp); mergearray(nums, first, mid, last, temp); &#125;&#125;int main()&#123; int n; cout &lt;&lt; &quot;How many elements to sort?\\n&quot;; cin &gt;&gt; n; vector&lt;int&gt; nums(n); cout &lt;&lt; &quot;Enter those numbers:\\n&quot;; for(int i = 0; i &lt; n; i ++)&#123; cin &gt;&gt; nums[i]; &#125; vector&lt;int&gt; temp(n); int first = 0; int last = n - 1; mergesort(nums, first, last, temp); for(int i = 0; i &lt; n; i ++)&#123; cout &lt;&lt; nums[i]; &#125; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://hasuer.github.io/categories/Algorithm/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"https://hasuer.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"}]},{"title":"09 Working with processes","slug":"Unit 9. Working with processes","date":"2020-10-15T08:10:05.000Z","updated":"2020-10-18T10:56:24.904Z","comments":true,"path":"09-working-with-processes/index.html","link":"","permalink":"https://hasuer.github.io/09-working-with-processes/index.html","excerpt":"","text":"What is a process? 进程是一个正在执行的程序。 每一个程序都有自己的运行环境 To see the PID of your current shell process, type: 1echo $$ 其中： echo表示在屏幕上显示东西 $$$$表示查看当前进程的PID Linux 能在同一时间执行多个不同的命令，也可以在同一时间运行多次同一个程序（比如Vi） Starting and stopping a process 所有的进程都是由其他进程发起的 init进程是直接由内核产生，一般来说ID是1 进程的退出 自己执行完毕以后退出 其他的进程发出了信号要结束这个进程 login process environment输入用户名以后，这个用户名会作为login程序的传入参数，在去请求这个参数的对应密码，在去查看和用户输入的是否一致。 Monitoring the processes输入: 1$ ps 来输出进程的状态信息。 有三个可选参数： - a: All processes sttached to a terminal - x: All other processes - u: Provide more columns Viewing processes hierarchy输入: 1$ pstree 来显示进程层次。 Starting processes Foreround processes they are invoked by typing a command at the command line: 1$ find / -name README Background processes they are invoked by putting an ampersand(&amp;) at the end of the command line: 1$ find / -name README &amp; 创建完后台进程以后会有： [1] 2320 - [1]: 这是在后台运行的第一个进程 - 2320: 这个进程的ID Job control in the bash shell- : Suspend the foreground task ​ does not kill a process but suspend it , so you can subsequently restart it. - jobs: Lists background or suspended jobs - fg: Resume suspended task in the foreground - bg: Resume suspended task in the background - Specify a job number for bg, fg, and kill using %job ​ kill job number 3 : kill %3 【EXAMPLE】 Kill signals Using the kill command: 1$ kill -signal PID Using the killall command to kill all named apps: 1$ killall -signal application Signal Keyboard Meaning Default action Description 01 Hangup End process send to a process when its parent die(log off acciddently) 02 Ctrl - C Interrupted End process user presses the interrup key “Ctrl -C” 03 Ctrl - \\ Quit End process and core dump Nope 09 Kill End process - cannot be redifined - handled by kernal die immediately 15 Terminate End process the most used difference between singal 02 and 03: signal 03 by default generate a ‘core dump’(A core dump is a file containing a process’s address space (memory) when the process terminates unexpectedly. ) Running long processes1$ nohup find / -name README &amp; 告诉进程忽略01和03信号的中断。即使你登出了系统也能够让程序继续运行 由于所有的进程都要和他的父进程有所联系，所以使用这个以后，该进程会以init作为他的父进程 The nice command1$ nice [-n &lt;value&gt;] &lt;original command&gt; used to start a process with a user-defined priority Only root can set negative number The renice command1$ renice &lt;new_priority&gt; &lt;PID&gt; used to change the priority of a running process Daemons(后台驻留进程) 这是一个不会停止的进程，从开机开始运行，一直到关机为止 用来控制计算机系统资源，比如打印机队列 Unit Review All processes are started by a parent process (except for init, which is started by the kernel). Every process is identified with a process identifier (PID). A special process is the shell, which can interpret user commands. Processes can terminate by themselves or upon reception of a signal. Signals can be sent by the shell, using a keyboard sequence, or by the kill and killall commands. Processes are started with equal priority, but this can be changed using the nice and renice commands. A daemon is a background process that typically controls a system resource or offers a network service. Checkpoint True or False: Any user can send a signal to a process of another user and cause that process to halt. The answer is false. A normal user will not have the appropriate permission to send signals to another user's processes. The rootuser does have permission to do this. If a process is hanging, the proper order of trying to terminateit with the lowest chance of data corruption is: a.kill -1, , kill, b., kill, kill -9, kill -15, c.kill -9, kill -15, , d., , kill, kill -9 The answer is , , kill, kill -9. kill -9 is always the last resort. What is a daemon? The answer is a daemon is a never-ending process which provides a system service.","categories":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"https://hasuer.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"Linux 基础","slug":"Linux-基础","permalink":"https://hasuer.github.io/tags/Linux-%E5%9F%BA%E7%A1%80/"}]},{"title":"【哈佛公开课】Justice","slug":"【哈佛公开课】公正","date":"2020-10-13T11:41:46.000Z","updated":"2022-02-23T06:55:56.733Z","comments":true,"path":"【哈佛公开课】justice/index.html","link":"","permalink":"https://hasuer.github.io/%E3%80%90%E5%93%88%E4%BD%9B%E5%85%AC%E5%BC%80%E8%AF%BE%E3%80%91justice/index.html","excerpt":"","text":"这是视频课程笔记，视频链接 01 杀人的道德侧面&amp;同类自残案电车难题1 你是电车司机，刹车坏了，转向会杀死一个人，不转向会杀死五个人，你会怎么做？ 【转向：】杀死一个人比杀死五个人好 电车难题2 你是旁观者，看到一个人在桥上，桥上有一个胖子，你可以把他推下去，这样他会死，但是能够救五个人，你会怎么做？ 【与第一个case不同的地方】事实上好像没有什么是不同的。你掌握的主动权，可以选择杀一个还是五个。无论是推人还是转向，你都是选择杀了一个人。 电车难题3 你是一个医生，现在有一个重症患者，五个轻症患者。救重症患者会让他活，但是五个会死，你会怎么做？ 【救五个人】 电车难题4 你是一个医生，5个人要做移植手术，但是没有符合的人选，但是在这是，有一个健康人来体检，你可以杀了他来救五个人，你会怎么做？ 【不会杀】 &gt; 体现出的原则 结果主义道德理论 结果主义认为，行为的道德地位(强制性的、允许的或错误的)总是取决于行为的总体结果。 典例：功利主义 绝对主义道德理论 典例：18世纪 Immanuel kart 让熟悉的变成陌生的 海难问题 4个人在船上，船翻了，在19天没有进食以后，最后三个人杀死了一个最弱的见习船员得救了，这样做对吗？ 【引出的问题】 我们时候又基本的权力？ 一个公平的程序（抓阄决定生死）是否会让结果正义化？ “征得同意”（见习船员同意被杀）在道德判断上起了什么作用？ 02 为生命贴上价格标签&amp;如何衡量快乐 边沁的功利主义 内容：道德的最高原则就是大众福利和集体幸福最大化&amp;在痛苦和快乐之间寻找平衡点（效用最大化） 由来：边沁认为人都是由快乐和痛苦所支配的，所以所有的道德系统要把他们考虑进去。如何都考虑到？就是幸福/效益最大化（追求多数人的最大效益）。 逻辑：对事物附上价值 捷克共和国的吸烟案例：| 成本 | 效益 || :——————: | :————: || 医疗成本的增加 | 香烟的税收 || |过早死去不用付养老金|| |节省房屋成本| 结论是政府的公共财政增加了1.47亿美元，在个人上节省了1200美元。 ​ 在这个案例中有一个严重的问题：没有将人的生命价值考虑进去！ Ford Pinto案例 | 成本 | 效益 || ——————————————————- | —————————————————- || 11美元 * 12.5million的车 = 1.37亿美元 | 每年所有由于车祸要付的钱49.5million | 上述案例将人的生命价值考虑了进去，但是依然被人们所诟病。 讨论 同学A：我们不应该用金钱来衡量人的生命价值，失去亲人失去的不仅仅是收入还有情感纽带 同学B：人的生命可以用金钱来衡量，但是要考虑通货膨胀，所以不能给出具体的数字。 同学C：公司不会盈利如果不考虑成本效益，不会盈利。 同学D：反对功利主义。因为没有考虑少数人的利益。比如上一讲中那个被吃掉的男孩，因为他存活的概率小就不考虑。 同学E：-&gt;D. 在特定的时间节点，如果必要做出选择，就要牺牲少数人的利益。 老师：古罗马，人们会将基督教人扔进斗兽场。少数人（被扔进斗兽场的人）很痛苦，但是围观的人很快乐。假设围观的人很多，快乐远远超过了少数人的痛苦。 对功利主义两种反对的意见 没有考虑少数人的想法与价值 不能够将所有的价值都标上价格，不能考虑到所有的因素，比如价值和道德因素。 不能用统一的金钱量度来衡量 可以尝试的区分高级的和低级的快乐 边沁的功利主义的特点：只考虑到了快乐或痛苦的程度大小和持续长短。 “快乐不分多少，图钉和诗一样美好” 密尔对边沁的功利主义进行了完善 效用是衡量功利主义的唯一标准，但是快乐可以被区别为高级和低级的。 如何区别高级和低级的快乐？ 把低级和高级的快乐都体验一遍，人们会自然喜欢高级的快乐。 密尔的功利主义：人们要经过学习和教育才能够体会到更加高级的快乐，而且当人们一旦经过了教育和学习以后，大多数人会偏爱更加高级的快乐。 03 Free to Champ &amp; Who owns me 自由主义：个人的基本权力是自由。不能简单的将所有人的偏好加起来 三件自由主义认为是不合理的但是国家都会做的： 家长式立法：系安全带，戴头盔 道德立法：同性恋，认为不道德就禁止 收入再分配：税收（这个不是很懂，可能没有理解） 钱的来源是否公正 被财产再分配的人是否自愿 自由主义认为：税收 = 拿走别人的收入 = 强迫劳动 = 奴役 自由主义的根本原则：自己能够支配自己，我属于我自己 所以用健康人去救5个人是不对的，因为我们属于我自己，而不是社会。如果一个个体属于社会，那么用一个健康人的器官去救5个人是没有问题的，但是事实上，我们属于我们自己。 04 The land is mine &amp; Consenting adults Jhon Locke(约翰 洛克) 他是半个自由主义者 同意大多数的的自由主义者，基本权力的不可剥夺性 他还认为这些基本权力包括了自然权利（财产权，自由权） 要知道自然权利，要想象政府出现前世界万物的样子 自然状态是一种自由状态，人生来平等，没有阶级 自然状态也是有法律的—自然法则。它限制了我们，哪怕我们是自由人。 自然法则对我们的唯一约束就是：*我们不能放弃这些权力，也不能从他人身上夺取 即使我是自由的，也不能放弃这些权力，也不能抢夺他人的，（不能违背自然法则） 这种自然状态从何而来？ 第一种解释：人们都从属于上帝 第二种：没有从视频中听到 洛克的私有财产理论：只要我们在这个无主土地上有贡献，土地也属于我们。比如开垦了荒地，地上种的粮食是我的，土地也是我的。 洛克的 consent 起源: 在自然状态下，所有人都是自己的法官，当一个人违反了自然法则，侵犯了他人生命，自由或者财产，你就可以杀死那个人。但是在这种状态下，人们会失去理智，所以人们脱离这种自然状态的唯一方法就是：同意放弃“执行权”，然后建立一个政府和社区，由他们来建立法律，并且每一个进入这个社区的人都实现同意服从大多数人的决定 即使人们进入了政府，但是也不能放弃自然权利。那为什么政府就能让我们交税（财产），服兵役（生命）？ 洛克认为，政府不能是专制的，不能挑选特定的人来胶水和服兵役。但是，如果政府有一个general law, 来（随机）选择，这就不算对于个人权力的侵犯。 05 Hired Guns &amp; For Sale Motherhood 自然状态中的生命权 政府是否有权去征兵 洛克认为，政府有权利强制征兵，他只在乎政府是否是专制的。 他认为，人们进入了政府就已经同意了在享受政府的福利的同时也自愿接受政府的一些约束 通过征兵来讨论同意 有人认为，我们自我拥有，有人则认为这是政府的合法权力 美军攻打伊拉克难征兵，三种方法 增加工资和福利 改用抽签制 军事外包 内战的时候，联邦采用抽签和军事外包。如果被抽中但是不想去，可以花钱找人顶替。 内战的征兵政策和现代的志愿军征兵同样都带有强制的感觉，到底有什么区别呢？ 代孕是否正确？ 按照合同来：交易就是交易 反对按照合同来：缺乏信息（代孕者不知道自己对于孩子的情感的变化）、无人性。 06 Mind your Motiv &amp; The Supreme Principle of Morality 义务论的观点本质上是反功利主义的，即义务论认为至少有时我们有义务以不会带来最好结果的方式行事。 讨论康德 为什么我们有尊重个人尊严的绝对义务，即使是出于好意也不能利用他人。 康德反对功利主义，他认为，每个个体都有一定的尊严,每个人都要尊重。 在康德看来，个体神圣不可侵犯不是来源于， 我们拥有我们自己， 而是 我们都是理性的人。 康德同意功利主义的部分观点：我们都会趋利避害。他反对的是边沁的理论：快乐和痛苦是人类至高无上的主宰。 康德认为是我们的 理性 使得我们变得与众不同，不再只是欲望的集合体。 一般人认为，自由就是指，我们按照自己的意愿行事，或者没有障碍的得到我们想要的。 而康德认为，当我们像动物一样趋乐避苦，满足欲望的的时候，我们不知真正的自由。这时候，我们成为了欲望的 奴隶。我们没有可以的选择满足哪一个欲望，我们满足它只是出于本能。 康德对于自由的定义十分苛刻。act freely = act autonomously = to act according a law I gave to myself. 而不是根据某一种因果关系去做（比如吃的欲望等等） 康德对于这种自由的定义更像是一种自律，（根据自己指定的计划完成）。他自己创造了一个与之对立的单词，也就是他律。指的就是我根据的是欲望做出的选择，而不是自己自主选择的。 所以当我们为了爱好或者快乐去行动的时候，个体成为了实现外来目的的一种手段，这个时候我们就成为了工具。而当我们以自己指定的法则去行动的时候，我们是出于目的本身去行动的，也就是自主行动，我们本身就成为了目的。康德认为，正是这种自由行动的能力赋予了人类特殊的尊严。 这里可以回答之前的一个例子，把基督教徒扔到斗兽场和师子搏斗，从而使看表演的人感到兴奋高兴，以此来得到功利最大化是不对的。因为这是把基督教徒这个个体当作了一种工具和手段，而没有尊重他。 康德对于道德的定义：所以行为的道德价值取决于动机，个体要基于好的动机去完成好的事情。 康德认为正是动机赋予了行为以道德价值。 一个例子 有一个店家，可以少给一个顾客找零而且不被发现，但是他担心被其他人知道以后自己臭名远扬，所以还是给了正确的钱数，这样的行为是否具有道德价值？ 不具有，因为 通过错误的原因做了正确的事 所以说 动机 赋予了道德价值 康德的基本理论包含两个问题 什么才是道德的最高原则 如何自由 07 有关谎言的一课 &amp; A deal is a deal 自律和义务看似对立，康德是怎么认为的？履行义务高尚在哪里？ 康德认为人不是由于遵守法则而显得崇高，而是我遵守的法则是我自己选择的，自愿服从的。从这一点上看，自律和履行义务是高度一致的，相互等价。 到底有多少道德法则，如果高尚源于遵守为自己制定的法则，那么如何保证我的道德心和你的一样？ 康德认为，如果我们出于自己的道德心，自由的选择道德法则，那么一定会得到相同的道德心。因为当我们选择的时候，并不是我在选择，也不是你，而是理性——纯粹的理性在选择。 纯粹的理性是不受外界的条件影响的。所以当我们在选择道德法则的时候，理性会支配意志。由于这些理性都是纯粹的理性，所以大家选择出来的道德法则也是一样的。这叫做绝对命令。 绝对命令是怎么存在的？ 康德说，我们要区别两种解释人类体验的两种观点。 作为体验的客体，我属于感观世界，我的行为受到自然法则（满足自己的感观）的约束。 作为体验的主体，我属于理智世界，在此，我独立于自然法则，我可以按照自己制定的法则来行动。 只有当第二种论点成立的时候，我们才是自由，因为自由就是不受到感观世界的约束。当我受到感观世界的约束的时候，我们会去选择满足自己的感观（欲望），在这种情况下，我们的意志都伴随着对于某种选择的渴望，意志被感性所主导。康德说，当我们说自己是自由的时候，我们就上升到了理性世界，并且意识到了意志的自主性。所以，绝对命令能实现是因为而且也只能是因为，自由让我成为了智思世界的一员。 康德认为，人不仅仅是理性世界的一员，因为，如果我们如果人们只是属于理性的世界，那么我们所有的行为都会和自主意志是一致的，而正是由于我们从属于两个世界，自由世界和需求世界，我们所“做”的和我们“应该做”的。康德得出，道德和经验主意是不一样的，人们对于科学的发现不能解决道德上的问题。 举一个例子：门外凶手的例子。康德认为人们不应该说谎，因为谎言不符合绝对命令。法国哲学家本杰明•康斯坦特写了一篇文章来回应《道德的形而上学基础》，他写道： “这个设想是错的,不可能是对的。如果有一个杀手来到你的门前，寻找你的朋友，而这位朋友正躲在你家里，杀手问你，’你的朋友在你家么？’如果在这样的情况中，还要说真话那真是疯了。” 康德认为即使对上门的凶手撒谎也是不对的。他解释，当你已经开始考虑事件的后果的时候，试图找出绝对命令的例外，你就已经放弃了整个道德框架，成为了一个结果主义者或者是规则功利主义者。大多数人会不赞同这个想法。教授试图从康德的道德理论来为康德边界。 直接的谎言和具有误导性的实话存在道德上的差异吗？ 康德认为两者在道德上是有差异的，尽管这些可能会带来相同的后果。但是康德的道德观不重视结果，而是重视是否坚守了道德法则。康德不会赞同善意的谎言，但是也许会赞同具有误导性的实话。与谎言不同，具有误导性的话语仍然是服从于义务的，由此，即使是具有误导性的事实也是道德的。 是的，我是希望他人被误导。我是希望杀手走出马路或者去商场找我的朋友而不是在衣柜里，我是希望起到这样的效果。我无法控制它的后果，但我可以控制的是，不管结果怎样，我都会站在道德这边并尊重它。 康德认为公正的法律出自于一种特定的社会契约，这种契约的性质很特殊，因为这不是真正意义上的契约。 这种产生公正的契约，是他所说的理性概念，而不是有人们聚集在一起商量出来的。他认为，那些真实存在的人们有着不同的利益，价值观和目标，有他们产生的契约也就未必公正，未必完全遵从正义的原则。 约翰罗尔斯，在他的书《正义论》中阐释了一个作为正义基础的假定协议，他的正义论和康德的理论在两点上高度重合。第一是，罗尔斯批判功利主义，他说，基于公正，每个人的权力都是圣神的，即使是全社会的福利也不能比拟。由正义所保护的权力不能被政治协商和社会利益所左右。第二个是，正义的原则源自于假定的社会契约。并且提出了“无知之幕”来解释他的理论。 无知之幕：假象把人们聚集在一起，来商量出指导我们集体生活的正义原则，由于人们不同的利益，会出现很多不同的声音，由强势的，弱势的，贫穷的富有的。罗尔斯提议，假设我们都处在公平的原始状态，而确保平等的，就是无知之幕。在无知之幕下，大家都不会知道自己的角色，种族阶级地位等等。这个时候达到的原则菜是正义的。 实际约束对人又怎样的约束和强制作用？ 首先实际契约中的内容不全是的正义的。比如美国曾经有法律允许奴隶的存在，这不代表这儿是正义的。 实际约束的强制性体现在两个方面： 自愿的积极同意，默认接收了义务，这包含着独立于其他因素的道德力量。 实际契约是实现互惠互利的工具，只要你为我做了事，我对你就有义务。 实际契约的道德力量借助于两个不同的理念，自律和互惠。但在现实生活中，每个真实契约都可能没在建立之初赋予道德约束力，因为各方谈判的势力可能是不均衡的，自律的理念就会没有实现；因为各方的知识上可能存在差距，互惠的理念就会没有实现。因此，他们对于什么是真正的相等价值就会存在分歧。 现在，想象一种契约，它的各方在权力和知识上是平等的，而非不等的；他们的地位是相同的，而非不同的。这就是罗尔斯的正义观念背后的理论：思考正义的方法就是，站在一个假想契约的角度，站在“不可知面纱”的背后，通过排除，或者使我们暂时忘记，会导致不公平的结果的诸如权力和知识的差距，创造平等的条件。 这就是为什么对康德和罗尔斯来说一个各方平等的假想契约是思考正义原则的唯一途径。","categories":[{"name":"阅读笔记","slug":"阅读笔记","permalink":"https://hasuer.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"人文","slug":"人文","permalink":"https://hasuer.github.io/tags/%E4%BA%BA%E6%96%87/"}]},{"title":"PA1实验报告","slug":"PA1实验报告","date":"2020-10-10T14:48:27.000Z","updated":"2020-10-11T14:41:55.271Z","comments":true,"path":"pa1实验报告/index.html","link":"","permalink":"https://hasuer.github.io/pa1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/index.html","excerpt":"","text":"实验进度 序号 是否已完成 必做任务1 √ 必做任务2 √ 必做任务3 √ 必做任务4 √ 必做任务5 √ 必做任务6 √ 必做任务7 √ 选做任务1 √ 选做任务2 √ 实验前的准备【2020.9.25】 完成了PA0实验指导书的内容，熟悉了 在Linux 环境下进行实验的基本流程 【2020.9.26】 发现实验平台有点卡顿，所以自己尝试着配置了与实验环境一样的虚拟机实验环境来完成实验。 由于使用到GitHub的仓库操作，所以查看的相关资料和网站学习了远程和本地仓库之间的连接。 【2020.9.28】 跟着PA0实验指导书，熟悉了vim的基本使用。 跟着B站视频，学习了tmux和ctags的基本使用方法。 实验开始【2020.9.29】 跟着PA1实验指导书完成了源代码的阅读，配合tmux的快捷键ctrl + ], ctrl + t大致了解了nemu/src/main.c的代码框架。 【2020.9.30】 实现正确的寄存器存储结构 寄存器在物理结构是不是相互独立的，而是互用部分内存。 union和struct的区别 struct会对其中定义的所有变量都分配内存空间，而是用union只会分配一块内存空间，大小是变量中所需空间的最大空间。和寄存器的结构十分符合。 将原来的struct改成union。 由于uint32_t,uint16_t,uint8_t是同一个寄存器的不同部分，所以采用unioin将他们定义。 考虑到要公用同一块空间的8个寄存器要和空间一一对应，所以采用struct将他们定义。 考虑到之后的实验的不确定性，学习了git的分支管理操作（点击这里查看git相关操作）。 【2020.10.2】 重置了工程文件，新建了分支PA1。 单步执行 核心就是将输入的指令字符串做分割。将命令在cmd_table[]中做查找，然后执行相应次数的cpu_exec()。 熟悉sscanf(),strtok()函数的使用。 要求是当没有输入步数是，缺省值是1，所以要先使用strtok()看看是否有步数的输入，做if判断。之后再使用sscanf()从字符串读入格式化的内容。 注意： 要在cmd_table中加入相关的命令。 加入if语句对于输入指令格式的判定。 比正确格式多了，少了，配对不匹配 【2020.10.3】 打印寄存器 这个和单步执行差不多，不在赘述。 要注意的是 键入的是info r所以还是要对它做字符串的拆分，和r配对了执行。 还有一个eip寄存器。 加入if语句对于输入指令格式的判定。 比正确格式多了，少了，配对不匹配 扫描内存 传入的参数格式是[x N EXPR] 注意结合使用if语句和strtok()函数来判断输入的格式是否正确。 使用strtok()和sscanf()函数得到对应的N和EXPR的值，使用swaddr_read()函数一次读取4个字节的内存，将其打印出来。 【2020.10.4】 学习正则表达式 读懂任务指导书求表达式这一部分 【2020.10.5】 表达式求值 使用正则表达式添加词法分析的规则 对输入的表达式进行遍历，根据自己定义的词法分析规则去分析表达式中的tokens，再使用strncpy()函数将tokens存入对应的数组中。 实现check_parentheses(),dominant_operator()函数的实现。 实现单目运算符!,-,*的计算 对于! ：由于!是在规则中指定的，并且没有可能被区别为其他的运算符，所以对于!来说，只要使用dominant_operator()是，只要返回的操作符的索引是表示左边界的形参，说明是单目运算符。 对于-和*：由于，这两个符号还有其他的含义 ：乘以及减。所以需要在eval()中识别出来，改变他们的priority,token_type。接下来思路和!是一样的。 寄存器的计算 要区别32位，16位和8位的寄存器，分别计算。 寄存器在存储进token，str[]中，要注意移除$。 【2020.10.7】 实现free_wp()和new_wp()两个函数。 这两个函数就是简单的链表操作。加上对于传入参数是否非法的判断。 【2020.10.8】 完成了监视点的操作。 思考题思考题1问： opcode_table到底是一个什么类型的数组？ 答：opcode_table是一个函数指针数组，其中包含多条指令和它们对应的某种形式。 思考题2.1问：在cmd_c()函数中，调用cpu_exec()的时候传入了参数-1，你知道这是为什么吗？ 答： 上图中，函数cpu_exec()的参数是uint32_t类型，也就是32位的无符号整型，当参数是-1的时候，由于-1的二进制编码是0xffff，-1会被函数认为是32位中的最大整数，所以会一直循环下取，指导完成所有指令。 思考题2.2问：框架代码中定义wp_pool等变量的时候使用了关键字static, static在此处的含义是什么? 为什么要在此处使用它? 答：static是静态的意思，用在函数上，是指编译过程中进行链接时由static修饰的变量不参与与外部文件的链接。只有在这个文件中的函数才能够调用函数，保证了数据的安全和稳定，有点类似于面向对象的思想。 思考题33.1 查阅i386手册 问：EFLAGS 寄存器中的 CF位是什么意思 ? 答：查阅i386手册P33-P34，2.3.4节有关EFLAGS寄存器的部分。EFLAGS中的CF位是carry flag的意思，在最高位发生进位或者借位时置为1，否则置为0。 问：ModR/M字节是什么 ? 答：P241，17.2.1小节。P40，2.5.3.2小节。ModR/M由mod，reg/opcode，r/m组成。mod字段占字节的两个最高有效位。reg字段占字节的3至5位，它指定一个寄存器的编号或者三位操作码。r/m占字节的后三位，可以与mod结合起来得到32个可能值，8个寄存器和24个内存寻址。这在PA2中有涉及到。 问：mov 指令的 具体格式是怎么样? 答：P45， 3.1小节。 3.2 Shell文件 问：如何查看命令行数？ 答： find . -name &quot;*[.h|.cpp]&quot; | xargs wc -l 可用于计算.c .h文件有多少行。一共128886行。 find . -name &quot;*[.cpp| .h]&quot; | xargs grep &quot;^.&quot;| wc -l用于计算.c .h文件除去空格有多少行。一共114922行。 3.3 Makefile 答： -Wall选项意思是编译后显示所有警告。 -Werror，它要求gcc将所有的警告当成错误进行处理。 实验遇到的问题，思考和解决方法 【**问题1**】 问题：在回答思考题2的时候，不知道为什么传入的参数 -1就是最大值，放入循环中可以执行所有的指令。 答：之前在改完代码以后，没有重新make run导致一直看不到效果。之后通过调试发现当执行cpu_exec(-1)的能够完成所有指令，也就是键入c后的步骤。但是不知道uint32_t是什么类型的数据，查了资料在知道是无符号整数，那答案也就知道了。 【**问题2**】 问题：在实现单步打印的时候，总是和预期不一样 答：对于strtok()的理解不到位，点击这里查看使用方法。经过反复的debug发现使用strtok(str, &quot; &quot;)之后，str就已经和原来不一样了。所以在单步打印中，组合使用strtok(),sscanf()时候要注意。 【**问题3**】 问题：在实现单步打印的时候，当输入的步数时个位数的时候，能够打印输出每一步，当是两位数的时候，就不再打印输出了。 答：事实就是这样，我也不知道为什么。当步数是两位数的时候，参数会传递到cpu_exec()函数中，但是不会打印出每一步。所以我才用了for循环来解决传入参数是两位数时无法打印的问题。 【**问题4**】 问题：在使用正则表达式制定词法分析规则的时候，不知道为什么\\\\+,\\\\b等需要两个\\? 答：以+举例，+在正则表达式中是一个特殊字符，要使用\\将+转义，又由于\\在正则表达式中也有特殊含义，所以第一个\\是用来转义第二个\\的，第二个\\是用来转义+的。 【**问题5**】 问题：在实现指针解引用和区别负号的时候，按照老师给的思路写代码却出现错误。 答：原因在于，在进入函数eval()中时，要对分析出来的tokens进行分析，查看是否符合是-（负号）和*（指针），是的话修改优先级和名称，但是由于指针和符号不是要实现的基本法则，所以在rules[]中定义，所以报错了，加上之后就没有问题了。 实验心得 一定要仔细阅读实验指导书和源代码，会有意想不到的收获。 在这一过程中，你会发现在这个项目中，很多.cpp文件会包含不同的.h文件，这就使得在.h文件中一定要有函数的声明。比如watchpoint.h。 发现自己原来C++的很多知识点也有了不同程度的遗忘，做完了PA1，也巩固了不少。 在PA1中，巩固的知识点有链表的删除插入，结构体和匿名体的区别，寄存器的结构等等。 牢记KISS原则，永远不要一下子追求完美，渐渐的就好。 在刚刚开始编写函数的时候，我总是希望完善，但是事实上这是不太现实的，因为，一开始不可能就想到所有的可能性。所以开始的时候就先假设输入的参数是符合规范的。做到之后在回过头去看看有什么会限制自己想要的答案。 Vim作为编辑器之神果然名不虚传。 刚刚开始使用Vim的时候，十分的不习惯。高效地使用Vim要求熟练的使用各种对应的快捷键，我一开始肯定达不到要求，希望在之后的实验中，加强这种训练，体会Vim的魅力所在。 要熟悉使用英文文献和网页。在必应搜索的时候，可以看看stackoverflow的著名网址，这里的解答或许会让你豁然开朗。","categories":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://hasuer.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"NEMU实验","slug":"NEMU实验","permalink":"https://hasuer.github.io/tags/NEMU%E5%AE%9E%E9%AA%8C/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-10-07T12:59:22.000Z","updated":"2021-09-25T13:57:03.494Z","comments":true,"path":"hello-world/index.html","link":"","permalink":"https://hasuer.github.io/hello-world/index.html","excerpt":"","text":"1. Hexo的搭建2. 主题的选择 ils archer Quick StartWelcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Create a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy 自己总结的12$ hexo clean$ hexo d -g 创建新的Post1$ hexo new &quot;Postname&quot; More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://hasuer.github.io/categories/Algorithm/"},{"name":"技术笔记","slug":"技术笔记","permalink":"https://hasuer.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"},{"name":"阅读笔记","slug":"阅读笔记","permalink":"https://hasuer.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"name":"随笔","slug":"随笔","permalink":"https://hasuer.github.io/categories/%E9%9A%8F%E7%AC%94/"},{"name":"tips","slug":"tips","permalink":"https://hasuer.github.io/categories/tips/"},{"name":"Vscode tips","slug":"Vscode-tips","permalink":"https://hasuer.github.io/categories/Vscode-tips/"},{"name":"Matlab","slug":"Matlab","permalink":"https://hasuer.github.io/categories/Matlab/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://hasuer.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"操作系统实验","slug":"操作系统实验","permalink":"https://hasuer.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/"},{"name":"操作系统原理","slug":"操作系统原理","permalink":"https://hasuer.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://hasuer.github.io/categories/LeetCode/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hasuer.github.io/tags/Interview/"},{"name":"人物传记，企业管理","slug":"人物传记，企业管理","permalink":"https://hasuer.github.io/tags/%E4%BA%BA%E7%89%A9%E4%BC%A0%E8%AE%B0%EF%BC%8C%E4%BC%81%E4%B8%9A%E7%AE%A1%E7%90%86/"},{"name":"心理学","slug":"心理学","permalink":"https://hasuer.github.io/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"},{"name":"成长","slug":"成长","permalink":"https://hasuer.github.io/tags/%E6%88%90%E9%95%BF/"},{"name":"心智","slug":"心智","permalink":"https://hasuer.github.io/tags/%E5%BF%83%E6%99%BA/"},{"name":"人际关系","slug":"人际关系","permalink":"https://hasuer.github.io/tags/%E4%BA%BA%E9%99%85%E5%85%B3%E7%B3%BB/"},{"name":"情感","slug":"情感","permalink":"https://hasuer.github.io/tags/%E6%83%85%E6%84%9F/"},{"name":"投资","slug":"投资","permalink":"https://hasuer.github.io/tags/%E6%8A%95%E8%B5%84/"},{"name":"思维","slug":"思维","permalink":"https://hasuer.github.io/tags/%E6%80%9D%E7%BB%B4/"},{"name":"人生哲学","slug":"人生哲学","permalink":"https://hasuer.github.io/tags/%E4%BA%BA%E7%94%9F%E5%93%B2%E5%AD%A6/"},{"name":"心灵成长","slug":"心灵成长","permalink":"https://hasuer.github.io/tags/%E5%BF%83%E7%81%B5%E6%88%90%E9%95%BF/"},{"name":"哲学","slug":"哲学","permalink":"https://hasuer.github.io/tags/%E5%93%B2%E5%AD%A6/"},{"name":"沟通","slug":"沟通","permalink":"https://hasuer.github.io/tags/%E6%B2%9F%E9%80%9A/"},{"name":"投资理财","slug":"投资理财","permalink":"https://hasuer.github.io/tags/%E6%8A%95%E8%B5%84%E7%90%86%E8%B4%A2/"},{"name":"财商","slug":"财商","permalink":"https://hasuer.github.io/tags/%E8%B4%A2%E5%95%86/"},{"name":"思维模式","slug":"思维模式","permalink":"https://hasuer.github.io/tags/%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%BC%8F/"},{"name":"社会","slug":"社会","permalink":"https://hasuer.github.io/tags/%E7%A4%BE%E4%BC%9A/"},{"name":"人类史","slug":"人类史","permalink":"https://hasuer.github.io/tags/%E4%BA%BA%E7%B1%BB%E5%8F%B2/"},{"name":"历史","slug":"历史","permalink":"https://hasuer.github.io/tags/%E5%8E%86%E5%8F%B2/"},{"name":"NEMU实验","slug":"NEMU实验","permalink":"https://hasuer.github.io/tags/NEMU%E5%AE%9E%E9%AA%8C/"},{"name":"MIT OS","slug":"MIT-OS","permalink":"https://hasuer.github.io/tags/MIT-OS/"},{"name":"进程管理","slug":"进程管理","permalink":"https://hasuer.github.io/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"},{"name":"stack","slug":"stack","permalink":"https://hasuer.github.io/tags/stack/"},{"name":"新英文杂志","slug":"新英文杂志","permalink":"https://hasuer.github.io/tags/%E6%96%B0%E8%8B%B1%E6%96%87%E6%9D%82%E5%BF%97/"},{"name":"排序算法","slug":"排序算法","permalink":"https://hasuer.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"Linux 基础","slug":"Linux-基础","permalink":"https://hasuer.github.io/tags/Linux-%E5%9F%BA%E7%A1%80/"},{"name":"人文","slug":"人文","permalink":"https://hasuer.github.io/tags/%E4%BA%BA%E6%96%87/"}]}