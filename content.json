{"meta":{"title":"Hasuer's Studio.","subtitle":"","description":"","author":"Hasuer","url":"https://hasuer.github.io","root":"/"},"pages":[{"title":"about","date":"2020-09-30T17:10:37.000Z","updated":"2020-09-30T17:11:32.046Z","comments":true,"path":"about/index.html","permalink":"https://hasuer.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"34. Conclusions","slug":"34. Conclusions","date":"2024-06-02T10:13:20.000Z","updated":"2024-05-28T03:32:50.207Z","comments":true,"path":"34-conclusions/index.html","link":"","permalink":"https://hasuer.github.io/34-conclusions/index.html","excerpt":"","text":"Where to Go from HereFeedbackFor feedback, comments, and suggestions, please contact us at hello@designgurus.org Other coursesHere are a few of other courses prepared by Design Gurus: Grokking Dynamic Programming Patterns for Coding Interviews Grokking the Object Oriented Design Interview","categories":[{"name":"Grokking Interview Pattern","slug":"Grokking-Interview-Pattern","permalink":"https://hasuer.github.io/categories/Grokking-Interview-Pattern/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hasuer.github.io/tags/Interview/"}]},{"title":"33. Test Your Knowledge (Hard)","slug":"33. Test Your Knowledge (Hard)","date":"2024-06-02T03:09:09.000Z","updated":"2024-05-28T03:32:34.812Z","comments":true,"path":"33-test-your-knowledge-hard/index.html","link":"","permalink":"https://hasuer.github.io/33-test-your-knowledge-hard/index.html","excerpt":"","text":"Longest Valid ParenthesesProblem StatementYou are given a string containing just the characters ‘(‘ and ‘)’. Your task is to find the length of the longest valid (well-formed) parentheses substring. Example 1: Input: &quot;(())&quot; Expected Output: 4 Justification: The entire string is a valid parentheses substring. Example 2: Input: &quot;)()())&quot; Expected Output: 4 Justification: The longest valid parentheses substring is &quot;()()&quot;. Example 3: Input: &quot;(()&quot; Expected Output: 2 Justification: The longest valid parentheses substring is &quot;()&quot;. Constraints: 0 &lt;= s.length &lt;= 3 * 10^4 s[i] is ‘(‘, or ‘)’. Solution Understanding the Problem: The problem involves finding the longest sequence of valid parentheses. A stack data structure can be used to keep track of the indices of the invalid parentheses. Approach: Initialize a stack and push -1 onto it as a marker for the base. Iterate through the string and for each character: If it is &#39;(&#39;, push its index onto the stack. If it is &#39;)&#39;, pop an element from the stack. If the stack is not empty, calculate the length of the valid parentheses substring by subtracting the current index with the top of the stack. If the stack is empty, push the current index onto the stack to serve as the new base marker. Why This Approach Will Work: The stack keeps track of the indices of invalid parentheses, allowing us to easily calculate the length of valid substrings. By continuously calculating the length and updating the maximum length, we ensure finding the longest valid substring. Algorithm WalkthroughConsider the input &quot;)()())&quot;: Initialize stack with -1: stack = [-1] Iterate through the string: At index 0: &#39;)&#39; Pop from stack: stack = [] Stack is empty, push index 0 onto stack: stack = [0] At index 1: &#39;(&#39; Push index 1 onto stack: stack = [0, 1] At index 2: &#39;)&#39; Pop from stack: stack = [0] Calculate length: 2 - 0 = 2 At index 3: &#39;(&#39; Push index 3 onto stack: stack = [0, 3] At index 4: &#39;)&#39; Pop from stack: stack = [0] Calculate length: 4 - 0 = 4 At index 5: &#39;)&#39; Pop from stack: stack = [] Stack is empty, push index 5 onto stack: stack = [5] The longest valid parentheses substring is of length 4. Code1234567891011121314151617181920class Solution: def longestValidParentheses(self,s: str) -&gt; int: max_length, stack = 0, [-1] # Initialize variables for i, char in enumerate(s): if char == &#x27;(&#x27;: # If opening bracket, add index to stack stack.append(i) else: stack.pop() # Pop for closing bracket if not stack: # If stack is empty, add current index stack.append(i) else: # Calculate the length using the current index and the top of the stack max_length = max(max_length, i - stack[-1]) return max_length# Testing the functionprint(Solution().longestValidParentheses(&quot;(())&quot;)) # Output: 4print(Solution().longestValidParentheses(&quot;)()())&quot;)) # Output: 4print(Solution().longestValidParentheses(&quot;(()&quot;)) # Output: 2 Complexity Analysis Time Complexity: O(n), where n is the length of the input string. The algorithm traverses the string once. Space Complexity: O(n), where n is the length of the input string. In the worst case, the stack will store all characters of the string. Serialize and Deserialize Binary TreeProblem StatementGiven a binary tree, your task is to create two functions. one for serializing the tree into a string format and another for deserializing the string back into the tree. The serialized string should retain all the tree nodes and their connections, allowing for reconstruction without any loss of data. Examples Example 1: Input: [1,2,3,null,null,4,5] Expected Output: [1,2,3,null,null,4,5] Justification : The tree has the structure: 12345 1 / \\2 3 / \\ 4 5 When serialized and then deserialized, it should retain the exact same structure. Example 2: Input: [1,null,2,3] Expected Output: [1,null,2,3] Justification : The tree has the structure: 123451 \\ 2 /3 When serialized and then deserialized, it should retain the exact same structure. Example 3: Input: [5,4,7,3,null,null,null,2] Expected Output: [5,4,7,3,null,null,null,2] Justification : The tree has the structure: 1234567 5 / \\ 4 7 / 3 /2 Constraints: The number of nodes in the tree is in the range [0, 104]. -1000 &lt;= Node.val &lt;= 1000 SolutionTo serialize a binary tree, we will traverse it in a pre-order fashion (root-left-right) and generate a string representation. When we encounter a null value, we’ll represent it with a special character, say “X”. The serialized string will have each value separated by a comma. For deserialization, we will split the string on commas and use a queue to help in the reconstruction. We’ll take the front of the queue and check if it’s “X”. If it is, then it’s a null node, otherwise, we create a new node with the value. The same approach applies recursively for the left and right children. Serialization: Start from the root. If the current node is null, append “X,” to the result string. If not null, append its value and a comma to the result string. Recursively serialize the left subtree. Recursively serialize the right subtree. Deserialization: Split the string by comma to get a list of nodes. Use a queue to facilitate tree reconstruction. For each value in the list: If it’s “X”, return null. Otherwise, create a new node. Recursively deserialize the left and right children. Algorithm Walkthrough:Given the input: [1,2,3,null,null,4,5]. Serialization: Start with root: 1. Add “1,” to the result string. Go left: 2. Add “2,” to the result string. Go left: null. Add “X,” to the result string. Go back and go right: null. Add “X,” to the result string. Go back to 1 and go right: 3. Add “3,” to the result string. Go left: 4. Add “4,” to the result string. Left and right of 4 are null. Add “X,X,” to the result string. Go back to 3 and go right: 5. Add “5,” to the result string. Left and right of 5 are null. Add “X,X,” to the result string. Resulting serialized string: “1,2,X,X,3,4,X,X,5,X,X,”. Deserialization: Split string by comma: [“1”,”2”,”X”,”X”,”3”,”4”,”X”,”X”,”5”,”X”,”X”]. Start with “1”. Create a node with value 1. Move to next value “2”. Create a left child with value 2. Next is “X”. So, the left of 2 is null. Move to the next “X”. Right of 2 is also null. Next is “3”. Create a right child for root with value 3. Next is “4”. Create a left child for 3 with value 4. Two X’s indicate the left and right children of 4 are null. “5” is the right child of 3. Two X’s indicate the children of 5 are null. Code123456789101112131415161718192021222324252627282930313233343536373839404142# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def serialize(self, root: TreeNode) -&gt; str: # Helper function to recursively serialize tree nodes. def helper(node): if not node: return &quot;X,&quot; left_serialized = helper(node.left) right_serialized = helper(node.right) return str(node.val) + &quot;,&quot; + left_serialized + right_serialized return helper(root) def deserialize(self, data: str) -&gt; TreeNode: # Convert string to a list for easy access and management. nodes = iter(data.split(&quot;,&quot;)) # Helper function to recursively deserialize tree nodes. def helper(): val = next(nodes) if val == &quot;X&quot;: return None node = TreeNode(int(val)) node.left = helper() node.right = helper() return node return helper()# Main function to test the codeif __name__ == &quot;__main__&quot;: solution = Solution() testTree = TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5))) serialized = solution.serialize(testTree) deserialized = solution.deserialize(serialized) print(&quot;Serialized:&quot;, serialized) print(&quot;Deserialized (Serialized again for verification):&quot;, solution.serialize(deserialized)) Complexity AnalysisTime Complexity Serialization: We visit every node once and only once, which gives a time complexity of (O(n)), where (n) is the number of nodes in the tree. Deserialization: Similarly, for deserialization, we reconstruct every node once and only once, so the time complexity is also (O(n)). Space Complexity Serialization: In the worst case, we have to append for every node and its two children. Additionally, there might be a considerable number of nulls (X), hence the space complexity would be (O(n)). Deserialization: The primary space consumption lies in the recursion stack, which would be (O(h)), where (h) is the height of the tree. In the worst case, the tree could be skewed, making its height (n), so the space complexity would be (O(n)).","categories":[{"name":"Grokking Interview Pattern","slug":"Grokking-Interview-Pattern","permalink":"https://hasuer.github.io/categories/Grokking-Interview-Pattern/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hasuer.github.io/tags/Interview/"}]},{"title":"32. Test Your Knowledge (Medium)","slug":"32. Test Your Knowledge (Medium)","date":"2024-06-01T02:28:14.000Z","updated":"2024-05-28T03:32:22.232Z","comments":true,"path":"32-test-your-knowledge-medium/index.html","link":"","permalink":"https://hasuer.github.io/32-test-your-knowledge-medium/index.html","excerpt":"","text":"Daily TemperaturesProblem StatementYou are given a list of daily temperatures. Your task is to return an answer array such that answer[i] is the number of days you would have to wait until a warmer temperature for each of the days. If there is no future day for which this is possible, put 0 instead. Examples Input: [45, 50, 40, 60, 55] Expected Output: [1, 2, 1, 0, 0] Justification: The next day after the first day is warmer (50 &gt; 45). Two days after the second day, the temperature is warmer (60 &gt; 50).. The next day after the third day is warmer (60 &gt; 40). There are no warmer days after the fourth and fifth days. Input: [80, 75, 85, 90, 60] Expected Output: [2, 1, 1, 0, 0] Justification: Two days after the first day, the temperature is warmer (85 &gt; 80). The next day after the second day is warmer (85 &gt; 75). The next day after the third day is warmer (90 &gt; 85). There are no warmer days after the fourth and fifth days. Input: [32, 32, 32, 32, 32] Expected Output: [0, 0, 0, 0, 0] Justification: All the temperatures are the same, so there are no warmer days ahead. Constraints: 1 &lt;= temperatures.length &lt;= 105 30 &lt;= temperatures[i] &lt;= 100 Solution Understanding the Problem: The problem is to find the number of days until a warmer day for each day in the list. Approach: Use a stack to keep track of the indices of the days. Iterate through the list of temperatures. While the stack is not empty and the current temperature is greater than the temperature at the index at the top of the stack: Pop an index from the stack and calculate the difference between the current day and the popped index. Store this difference at the popped index in the result array. Push the current day’s index onto the stack. Why This Works: The stack keeps track of the days for which a warmer day has not yet been found. When a warmer day is found, the days are popped from the stack and the difference in days is calculated. Algorithm WalkthroughConsider the input [45, 50, 40, 60, 55]: Initialize an empty stack and a result array filled with zeros: stack = [], res = [0, 0, 0, 0, 0]. Iterate through the list: Day 1 (45): stack = [0]. Day 2 (50): Pop 0 from stack, res[0] = 1 - 0 = 1, stack = [1]. Day 3 (40): stack = [1, 2]. Day 4 (60): Pop 2 from stack, res[2] = 3 - 2 = 1, Pop 1 from stack, res[1] = 3 - 1 = 2, stack = [3]. Day 5 (55): stack = [3, 4]. End of iteration, res = [1, 2, 1, 0, 0]. Code Development12345678910111213141516171819202122232425262728class Solution: def dailyTemperatures(self, temperatures): # Initialize an empty stack and a result list filled with zeros stack = [] res = [0] * len(temperatures) # Iterate through the list of temperatures for i, temp in enumerate(temperatures): # Pop indices from the stack while the current temperature is greater than the temperature at the popped index while stack and temp &gt; temperatures[stack[-1]]: idx = stack.pop() res[idx] = i - idx # Push the current index onto the stack stack.append(i) # Return the final result list return res# Testing the algorithmsolution = Solution()example1 = [45, 50, 40, 60, 55]example2 = [80, 75, 85, 90, 60]example3 = [32, 32, 32, 32, 32]# Output: [1, 2, 1, 0, 0]print(solution.dailyTemperatures(example1))# Output: [2, 1, 1, 0, 0]print(solution.dailyTemperatures(example2))# Output: [0, 0, 0, 0, 0]print(solution.dailyTemperatures(example3)) Complexity Analysis Time Complexity: O(n), where n is the number of temperatures. This is because the algorithm iterates through the list of temperatures once, performing constant-time operations for each temperature. Space Complexity: O(n), as it uses a stack to keep track of indices. Group AnagramsProblem StatementGiven a list of strings, the task is to group the anagrams together. An anagram is a word or phrase formed by rearranging the letters of another, such as “cinema”, formed from “iceman”. Example GenerationExample 1: Input: [&quot;dog&quot;, &quot;god&quot;, &quot;hello&quot;] Output: [[&quot;dog&quot;, &quot;god&quot;], [&quot;hello&quot;]] Justification: “dog” and “god” are anagrams, so they are grouped together. “hello” does not have any anagrams in the list, so it is in its own group. Example 2: Input: [&quot;listen&quot;, &quot;silent&quot;, &quot;enlist&quot;] Output: [[&quot;listen&quot;, &quot;silent&quot;, &quot;enlist&quot;]] Justification: All three words are anagrams of each other, so they are grouped together. Example 3: Input: [&quot;abc&quot;, &quot;cab&quot;, &quot;bca&quot;, &quot;xyz&quot;, &quot;zxy&quot;] Output: [[&quot;abc&quot;, &quot;cab&quot;, &quot;bca&quot;], [&quot;xyz&quot;, &quot;zxy&quot;]] Justification: “abc”, “cab”, and “bca” are anagrams, as are “xyz” and “zxy”. Constraints: 1 &lt;= strs.length &lt;= 10^4 0 &lt;= strs[i].length &lt;= 100 strs[i] consists of lowercase English letters. Solution Sorting Approach: For each word in the input list: Sort the letters of the word. Use the sorted word as a key in a hash map, and add the original word to the list of values for that key. The hash map values will be the groups of anagrams. Why This Will Work: Anagrams will always result in the same sorted word, so they will be grouped together in the hash map. Algorithm Walkthrough Given the input [&quot;abc&quot;, &quot;cab&quot;, &quot;bca&quot;, &quot;xyz&quot;, &quot;zxy&quot;] For “abc”: Sorted word is “abc”. Add “abc” to the hash map with key “abc”. For “cab”: Sorted word is “abc”. Add “cab” to the list in the hash map with key “abc”. Continue this process for all words. The hash map values are the groups of anagrams. Code1234567891011121314151617181920class Solution: def groupAnagrams(self, strs): # Dictionary to hold sorted word as key and list of words as value d = &#123;&#125; for s in strs: sorted_str = &#x27;&#x27;.join(sorted(s)) # If the sorted word is not already a key in the dictionary, add it with a new list as its value if sorted_str not in d: d[sorted_str] = [] # Add the original word to the list of values for the sorted word key d[sorted_str].append(s) # Return the values of the dictionary as a list of lists return list(d.values())# Testing the functionsol = Solution()print(sol.groupAnagrams([&quot;dog&quot;, &quot;god&quot;, &quot;hello&quot;]))print(sol.groupAnagrams([&quot;listen&quot;, &quot;silent&quot;, &quot;enlist&quot;]))print(sol.groupAnagrams([&quot;abc&quot;, &quot;cab&quot;, &quot;bca&quot;, &quot;xyz&quot;, &quot;zxy&quot;])) Complexity Analysis Time Complexity: O(nklog(k)), where n is the number of strings, and k is the maximum length of a string in strs. This is because each of the n strings is sorted in O(k*log(k)) time. Space Complexity: O(n*k), where n is the number of strings, and k is the maximum length of a string in strs. This space is used for the output data structure and the hash map. Decode StringProblem StatementYou have a string that represents encodings of substrings, where each encoding is of the form k[encoded_string], where k is a positive integer, and encoded_string is a string that contains letters only. Your task is to decode this string by repeating the encoded_string k times and return it. It is given that k is always a positive integer. Examples Input: &quot;3[a3[c]]&quot; Expected Output: &quot;acccacccaccc&quot; Justification: The inner 3[c] is decoded as ccc, and then a is appended to the front, forming acc. This is then repeated 3 times to form acccacccaccc. Input: &quot;2[b3[d]]&quot; Expected Output: &quot;bdddbddd&quot; Justification: The inner 3[d] is decoded as ddd, and then b is appended to the front, forming bddd. This is then repeated 2 times to form bddd bddd. Input: &quot;4[z]&quot; Expected Output: &quot;zzzz&quot; Justification: The 4[z] is decoded as z repeated 4 times, forming zzzz. Constraints: 1 &lt;= s.length &lt;= 30 s consists of lowercase English letters, digits, and square brackets ‘[]’. s is guaranteed to be a valid input. All the integers in s are in the range [1, 300]. Solution Understanding the Problem: The problem involves decoding a string that contains patterns where a number is followed by a string in brackets. The number indicates how many times the string in brackets should be repeated. Approach: Use a stack to keep track of the characters in the string. Iterate through the string character by character. When a number is encountered, calculate the complete number. When an opening bracket [ is encountered, push the calculated number to the stack. When a closing bracket ] is encountered, pop elements from the stack until a number is encountered and form the substring to be repeated. Multiply the substring with the number and push the result back to the stack. Handling Nested Brackets: The stack will naturally handle nested brackets as it will continue popping elements until a number is encountered, forming the substring for the innermost bracket first. Algorithm Walkthrough Given Input: &quot;3[a3[c]]&quot; Steps: Initialize an empty stack. Iterate through the string: Encounter 3, push 3 to the stack. Encounter [, do nothing. Encounter a, push a to the stack. Encounter 3, push 3 to the stack. Encounter [, do nothing. Encounter c, push c to the stack. Encounter ], pop c and 3, form ccc and push it back to the stack. Encounter ], pop ccc, a, and 3, form acccacccaccc and push it back to the stack. The final stack contains acccacccaccc as the only element, which is the decoded string. Code12345678910111213141516171819202122232425262728293031class Solution: def decodeString(self, s: str) -&gt; str: stack = [] num = 0 curr_str = &quot;&quot; for c in s: if c.isdigit(): # Calculate the number num = num * 10 + int(c) elif c == &#x27;[&#x27;: # Push the number and current string to the stack stack.append(num) stack.append(curr_str) num = 0 curr_str = &quot;&quot; elif c == &#x27;]&#x27;: # Pop elements to form the substring and push the result back prev_str = stack.pop() repeat = stack.pop() curr_str = prev_str + curr_str * repeat else: # Append the character to the current string curr_str += c return curr_str# Testing the functionsol = Solution()print(sol.decodeString(&quot;3[a3[c]]&quot;)) # Output: acccacccacccprint(sol.decodeString(&quot;2[b3[d]]&quot;)) # Output: bdddbdddprint(sol.decodeString(&quot;4[z]&quot;)) # Output: zzzz Complexity Analysis Time Complexity: O(n), where n is the length of the input string. This is because we are iterating through the string once and processing each character. Space Complexity: O(n), where n is the length of the input string. In the worst case, the stack will store all the characters of the input string. Valid SudokuProblem StatementDetermine if a 9x9 Sudoku board is valid. A valid Sudoku board will hold the following conditions: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. The 9 3x3 sub-boxes of the grid must also contain the digits 1-9 without repetition. Note: The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’. You need to validate only filled cells. Example 1: Input: 123456789[[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]] Expected Output: true Justification: This Sudoku board is valid as it adheres to the rules of no repetition in each row, each column, and each 3x3 sub-box. Example 2: Input: 123456789[[&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]] Expected Output: false Justification: The first and fourth rows both contain the number ‘8’, violating the Sudoku rules. Example 3: Input: 123456789[[&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;3&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;9&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]] Expected Output: false Justification: The fourth column contains the number ‘5’ two times, violating the Sudoku rules. Constraints: board.length == 9 board[i].length == 9 board[i][j] is a digit 1-9 or ‘.’. Solution Initialization: Create three hash sets for rows, columns, and boxes to keep track of the seen numbers. Iteration: Iterate through each cell in the 9x9 board. If the cell is not empty: Formulate keys for the row, column, and box that include the current number and its position. Check the corresponding sets for these keys. If any key already exists in the sets, return false. Otherwise, add the keys to the respective sets. Final Check: If the iteration completes without finding any repetition, return true. This approach works because it checks all the necessary conditions for a valid Sudoku by keeping track of the numbers in each row, column, and box using hash sets. The use of hash sets allows for efficient lookups to ensure no numbers are repeated in any row, column, or box. Algorithm WalkthroughConsider Example 2 from above: Initialize three empty hash sets for rows, columns, and boxes. Start iterating through each cell in the board. For the first cell, which contains ‘8’: Formulate keys: row0(8), col0(8), and box0(8). Since these keys are not in the sets, add them. Continue this for other cells. Upon reaching the first cell of the fourth row, which also contains ‘8’: Formulate keys: row3(8), col0(8), and box1(8). The key col0(8) already exists in the column set, so return false. Code123456789101112131415161718192021222324252627282930313233343536373839class Solution: def isValidSudoku(self, board): # Initialize sets to keep track of the numbers in each row, column, and box. rows = set() columns = set() boxes = set() # Iterate through each cell in the 9x9 board. for i in range(9): for j in range(9): num = board[i][j] if num != &#x27;.&#x27;: # Formulate keys for the row, column, and box. row_key = f&quot;row&#123;i&#125;(&#123;num&#125;)&quot; col_key = f&quot;col&#123;j&#125;(&#123;num&#125;)&quot; box_key = f&quot;box&#123;i // 3 * 3 + j // 3&#125;(&#123;num&#125;)&quot; # Check the corresponding sets for these keys. if (row_key in rows or col_key in columns or box_key in boxes): return False rows.add(row_key) columns.add(col_key) boxes.add(box_key) return True# Testing the codesol = Solution()board1 = [ [&#x27;5&#x27;,&#x27;3&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;7&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;], [&#x27;6&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;1&#x27;,&#x27;9&#x27;,&#x27;5&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;], [&#x27;.&#x27;,&#x27;9&#x27;,&#x27;8&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;6&#x27;,&#x27;.&#x27;], [&#x27;8&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;6&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;3&#x27;], [&#x27;4&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;8&#x27;,&#x27;.&#x27;,&#x27;3&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;1&#x27;], [&#x27;7&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;2&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;6&#x27;], [&#x27;.&#x27;,&#x27;6&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;2&#x27;,&#x27;8&#x27;,&#x27;.&#x27;], [&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;4&#x27;,&#x27;1&#x27;,&#x27;9&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;5&#x27;], [&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;8&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;7&#x27;,&#x27;9&#x27;]]print(sol.isValidSudoku(board1)) # Output: True Complexity Analysis Time Complexity: O(1) or O(81), as we only iterate through the 9x9 board once. Space Complexity: O(1) or O(81), as the maximum size of our sets is 81. Product of Array Except SelfProblem StatementGiven an array of integers, return a new array where each element at index i of the new array is the product of all the numbers in the original array except the one at i. You must solve this problem without using division. Examples Input: [2, 3, 4, 5] Expected Output: [60, 40, 30, 24] Justification: For the first element: 3*4*5 = 60, for the second element: 2*4*5 = 40, for the third element: 2*3*5 = 30, and for the fourth element: 2*3*4 = 24. Input: [1, 1, 1, 1] Expected Output: [1, 1, 1, 1] Justification: Every element is 1, so the product of all other numbers for each index is also 1. Input: [10, 20, 30, 40] Expected Output: [24000, 12000, 8000, 6000] Justification: For the first element: 20*30*40 = 24000, for the second element: 10*30*40 = 12000, for the third element: 10*20*40 = 8000, and for the fourth element: 10*20*30 = 6000. Constraints: 2 &lt;= nums.length &lt;= 105 -30 &lt;= nums[i] &lt;= 30 The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. Solution Initialize Two Arrays: Start by initializing two arrays, left and right. The left array will hold the product of all numbers to the left of index i, and the right array will hold the product of all numbers to the right of index i. Populate the Left Array: The first element of the left array will always be 1 because there are no numbers to the left of the first element. For the remaining elements, each value in the left array is the product of its previous value and the corresponding value in the input array. Populate the Right Array: Similarly, the last element of the right array will always be 1 because there are no numbers to the right of the last element. For the remaining elements, each value in the right array is the product of its next value and the corresponding value in the input array. Calculate the Result: For each index i, the value in the result array will be the product of left[i] and right[i]. Algorithm WalkthroughUsing the input [2, 3, 4, 5]: Initialize left and right arrays with the same length as the input array and fill them with 1. Populate the left array: left[0] = 1 left[1] = left[0] * input[0] = 2 left[2] = left[1] * input[1] = 6 left[3] = left[2] * input[2] = 24 Populate the right array: right[3] = 1 right[2] = right[3] * input[3] = 5 right[1] = right[2] * input[2] = 20 right[0] = right[1] * input[1] = 60 Calculate the result: result[0] = left[0] * right[0] = 60 result[1] = left[1] * right[1] = 40 result[2] = left[2] * right[2] = 30 result[3] = left[3] * right[3] = 24 Code12345678910111213141516171819202122232425class Solution: def productExceptSelf(self, nums): n = len(nums) left, right, result = [1] * n, [1] * n, [1] * n # Populate the left array for i in range(1, n): left[i] = left[i - 1] * nums[i - 1] # Populate the right array for i in range(n - 2, -1, -1): right[i] = right[i + 1] * nums[i + 1] # Calculate the result array for i in range(n): result[i] = left[i] * right[i] return result# Testing the functionsol = Solution()print(sol.productExceptSelf([2, 3, 4, 5]))print(sol.productExceptSelf([1, 1, 1, 1]))print(sol.productExceptSelf([10, 20, 30, 40])) Complexity Analysis: Time Complexity: O(n). We traverse the input array three times, so the time complexity is linear. Space Complexity: O(n). We use three additional arrays (left, right, and result). Maximum Product SubarrayProblem StatementGiven an integer array, find the contiguous subarray (at least one number in it) that has the maximum product. Return this maximum product. Examples Input: [2,3,-2,4] Expected Output: 6 Justification: The subarray [2,3] has the maximum product of 6. Input: [-2,0,-1] Expected Output: 0 Justification: The subarray [0] has the maximum product of 0. Input: [-2,3,2,-4] Expected Output: 48 Justification: The subarray [-2,3,2,-4] has the maximum product of 48. Constraints: 1 &lt;= nums.length &lt;= 2*104 -10 &lt;= nums[i] &lt;= 10 The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. Solution Initialization: Start by initializing two variables, maxCurrent and minCurrent, to the first element of the array. These variables will keep track of the current maximum and minimum product, respectively. Also, initialize a variable maxProduct to the first element of the array. This will store the maximum product found so far. Iterate through the array: For each number in the array (starting from the second number), calculate the new maxCurrent by taking the maximum of the current number, the product of maxCurrent and the current number, and the product of minCurrent and the current number. Similarly, calculate the new minCurrent by taking the minimum of the current number, the product of maxCurrent and the current number, and the product of minCurrent and the current number. Update maxProduct by taking the maximum of maxProduct and maxCurrent. Handle negative numbers: Since a negative number can turn a large negative product into a large positive product, we need to keep track of both the maximum and minimum product at each step. Return the result: After iterating through the entire array, maxProduct will have the maximum product of any subarray. Algorithm WalkthroughUsing the input [2,3,-2,4]: Start with maxCurrent = 2, minCurrent = 2, and maxProduct = 2. For the next number, 3: New maxCurrent = max(3, 2 * 3) = 6 New minCurrent = min(3, 2 * 3) = 3 Update maxProduct = max(2, 6) = 6 For the next number, -2: New maxCurrent = max(-2, 3*(-2)) = -2 New minCurrent = min(-2, 6*(-2)) = -12 maxProduct remains 6 For the last number, 4: New maxCurrent = max(4, -2*4) = 4 New minCurrent = min(4, -12*4) = -48 maxProduct remains 6 The final answer is 6. Code12345678910111213141516171819202122232425262728293031class Solution: def maxProduct(self, nums): # Base case: if the list is empty if not nums: return 0 # Initialize the current maximum, minimum, and the result maxCurrent = minCurrent = maxProduct = nums[0] # Iterate through the list starting from the second element for i in range(1, len(nums)): # If the current number is negative, swap max and min if nums[i] &lt; 0: maxCurrent, minCurrent = minCurrent, maxCurrent # Update maxCurrent for the current number maxCurrent = max(nums[i], maxCurrent * nums[i]) # Update minCurrent for the current number minCurrent = min(nums[i], minCurrent * nums[i]) # Update the result maxProduct = max(maxProduct, maxCurrent) return maxProductsol = Solution()print(sol.maxProduct([2,3,-2,4])) # 6print(sol.maxProduct([-2,0,-1])) # 0print(sol.maxProduct([-2,3,2,-4])) # 48 Complexity Analysis Time Complexity: O(n) - We iterate through the array only once. Space Complexity: O(1) - We use a constant amount of space regardless of the input size. Container With Most WaterProblem StatementGiven an array of non-negative integers, where each integer represents the height of a vertical line positioned at index i. You need to find the two lines that, when combined with the x-axis, form a container that can hold the most water. The goal is to find the maximum amount of water (area) that this container can hold. Note: The water container’s width is the distance between the two lines, and its height is determined by the shorter of the two lines. ExamplesExample 1: Input: [1,3,2,4,5] Expected Output: 9 Justification: The lines at index 1 and 4 form the container with the most water. The width is 3 (4-1), and the height is determined by the shorter line, which is 3. Thus, the area is 3 3 = 9. Example 2: Input: [5,2,4,2,6,3] Expected Output: 20 Justification: The lines at index 0 and 4 form the container with the most water. The width is 5 (4-0), and the height is determined by the shorter line, which is 5. Thus, the area is 5 4 = 20. Example 3: Input: [2,3,4,5,18,17,6] Expected Output: 17 Justification: The lines at index 4 and 5 form the container with the most water. The width is 17 (5-4), and the height is determined by the shorter line, which is 17. Thus, the area is 17 1 = 17. Constraints: n == height.length 2 &lt;= n &lt;= 105 0 &lt;= height[i] &lt;= 104 SolutionThe “Container With Most Water” problem can be efficiently solved using a two-pointer approach. The essence of the solution lies in the observation that the container’s capacity is determined by the length of the two lines and the distance between them. By starting with two pointers at the extreme ends of the array and moving them toward each other, we can explore all possible container sizes. At each step, we calculate the area and update our maximum if the current area is larger. The key insight is to always move the pointer pointing to the shorter line, as this has the potential to increase the container’s height and, thus, its capacity. Initialization: Begin by initializing two pointers, one at the start (left) and one at the end (right) of the array. Also, initialize a variable maxArea to store the maximum area found. Pointer Movement: At each step, calculate the area formed by the lines at the left and right pointers. If this area is greater than maxArea, update maxArea. Then, move the pointer pointing to the shorter line towards the other pointer. This is because by moving the taller line, we might miss out on a larger area, but by moving the shorter line, we have a chance of finding a taller line and, thus a larger area. Termination: Continue moving the pointers until they meet. At this point, we have considered all possible pairs of lines. Return: Once the pointers meet, return the maxArea. Algorithm WalkthroughUsing the input [1,3,2,4,5]: Initialize left to 0 and right to 4. maxArea is 0. Calculate area with left and right: min(1,5) * (4-0) = 4. Update maxArea to 4. Move the left pointer to 1 since height at left is shorter. Calculate area with left and right: min(3,5) * (4-1) = 9. Update maxArea to 9. Move the left pointer to 2. Calculate area with left and right: min(2,5) * (4-2) = 4. maxArea remains 9. Move the left pointer to 3. Calculate area with left and right: min(4,5) * (4-3) = 4. maxArea remains 9. Pointers meet. Return maxArea which is 9. Code12345678910111213141516171819202122class Solution: def maxArea(self, height): left, right = 0, len(height) - 1 # Initialize pointers at the start and end maxArea = 0 # To store the maximum area found while left &lt; right: minHeight = min(height[left], height[right]) # Find the shorter of the two lines maxArea = max(maxArea, minHeight * (right - left)) # Compute the area and update maxArea if needed # Move the pointer pointing to the shorter line if height[left] &lt; height[right]: left += 1 else: right -= 1 return maxAreasol = Solution()print(sol.maxArea([1,3,2,4,5])) # Expected output: 9print(sol.maxArea([5,2,4,2,6,3])) # Expected output: 20print(sol.maxArea([2,3,4,5,18,17,6])) # Expected output: 17 Complexity Analysis: Time Complexity: O(n) - We traverse the array once using two pointers. Space Complexity: O(1) - We use a constant amount of space. Palindromic SubstringsProblem StatementGiven a string, determine the number of palindromic substrings present in it. A palindromic substring is a sequence of characters that reads the same forwards and backward. The substring can be of any length, including 1. Example Input: “racecar” Expected Output: 10 Justification: The palindromic substrings are “r”, “a”, “c”, “e”, “c”, “a”, “r”, “cec”, “aceca”, “racecar”. Input: “noon” Expected Output 6 Justification: The palindromic substrings are “n”, “o”, “o”, “n”, “oo”, “noon”. Input: “apple” Expected Output: 6 Justification: The palindromic substrings are “a”, “p”, “p”, “l”, “e”, “pp”. Constraints: 1 &lt;= s.length &lt;= 1000 s consists of lowercase English letters. SolutionThe core idea behind the algorithm is to consider each character in the string as a potential center of a palindrome and then expand outwards from this center to identify all palindromic substrings. By doing this for every character in the string, we can efficiently count all such substrings. This approach is based on the observation that every palindromic substring has a center (or two centers for even-length palindromes). Initialization: Begin by initializing a counter to zero. This counter will be used to keep track of the number of palindromic substrings. Center Expansion: For each character in the string, treat it as the center of a possible palindrome. There are two scenarios to consider: odd-length palindromes (with a single center) and even-length palindromes (with two centers). For each character, expand outwards and check for both scenarios. Palindrome Check: As you expand outwards from the center, compare the characters. If they are the same, increment the counter. If they are different or if you’ve reached the boundary of the string, stop expanding. Result: Once all characters have been treated as centers and all possible expansions have been checked, the counter will hold the total number of palindromic substrings. Algorithm WalkthroughUsing the input “noon”: Start with the first character “n”: Treat it as the center of an odd-length palindrome. No expansion is possible. Treat it as the left center of an even-length palindrome. The right center would be “o”. Since “n” and “o” are different, no expansion is possible. Move to the second character “o”: Treat it as the center of an odd-length palindrome. No expansion is possible. Treat it as the left center of an even-length palindrome. The right center is also “o”. Increment the counter. Continue this process for each character in the string. The final count is 7. Code123456789101112131415161718192021222324252627class Solution: def countSubstrings(self, s: str) -&gt; int: # Helper function to expand from the center def expandFromCenter(s, left, right): count = 0 # Check for palindrome while staying within string boundaries while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]: count += 1 left -= 1 right += 1 return count count = 0 for i in range(len(s)): # Check for odd length palindromes count += expandFromCenter(s, i, i) # Check for even length palindromes count += expandFromCenter(s, i, i + 1) return count# Test the algorithmsol = Solution()print(sol.countSubstrings(&quot;racecar&quot;)) # 10print(sol.countSubstrings(&quot;noon&quot;)) # 6print(sol.countSubstrings(&quot;apple&quot;)) # 6 Complexity Analysis: Time Complexity: O(n^2). For each character in the string, we might expand outwards up to n times. Space Complexity: O(1). We are not using any additional data structures that scale with the input size. Remove Nth Node From End of ListProblem StatementGiven a linked list, remove the last nth node from the end of the list and return the head of the modified list. Example 1: Input: list = 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5, n = 2 Expected Output: 1 -&gt; 2 -&gt; 3 -&gt; 5 Justification: The 2nd node from the end is “4”, so after removing it, the list becomes [1,2,3,5]. Example 2: Input: list = 10 -&gt; 20 -&gt; 30 -&gt; 40, n = 4 Expected Output: 20 -&gt; 30 -&gt; 40 Justification: The 4th node from the end is “10”, so after removing it, the list becomes [20,30,40]. Example 3: Input: list = 7 -&gt; 14 -&gt; 21 -&gt; 28 -&gt; 35, n = 3 Expected Output: 7 -&gt; 14 -&gt; 28 -&gt; 35 Justification: The 3rd node from the end is “21”, so after removing it, the list becomes [7,14,28,35]. Constraints: The number of nodes in the list is sz. 1 &lt;= sz &lt;= 30 0 &lt;= Node.val &lt;= 100 1 &lt;= n &lt;= sz Solution Two-Pass Approach: Begin by calculating the length of the linked list. This can be done by traversing the list from the head to the end. Once the length is determined, calculate which node to remove by subtracting n from the length. Traverse the list again and remove the node at the calculated position. One-Pass Approach using Two Pointers: Use two pointers, first and second, and place them at the start of the list. Move the first pointer n nodes ahead in the list. Now, move both first and second pointers one step at a time until the first pointer reaches the end of the list. The second pointer will now be n nodes from the end. Remove the node next to the second pointer. Advantage of One-Pass Approach: The one-pass approach is more efficient as it traverses the list only once, whereas the two-pass approach requires two traversals. Edge Cases: If n is equal to the length of the list, remove the head of the list. Algorithm WalkthroughUsing the input list = [1,2,3,4,5], n = 2: Initialize two pointers, first and second, at the head of the list. Move the first pointer 2 nodes ahead. Now, first points to “3” and second points to “1”. Move both first and second pointers one step at a time. When first reaches “5”, second will be at “3”. The next node to second is “4”, which is the node to be removed. Remove “4” by updating the next pointer of “3” to point to “5”. The modified list is [1,2,3,5]. Code123456789101112131415161718192021222324252627282930313233# class Node:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def removeNth(head, n): # Create a dummy node to simplify edge cases dummy = Node(0) dummy.next = head first = dummy second = dummy # Move first pointer n nodes ahead for _ in range(n + 1): first = first.next # Move first to the end, maintaining the gap while first: first = first.next second = second.next # Remove the nth node from the end second.next = second.next.next return dummy.nexthead = Node(1, Node(2, Node(3, Node(4, Node(5)))))result = Solution.removeNth(head, 2)print(&quot;Nodes after removing the Nth node from the end:&quot;, end=&quot; &quot;)while result: print(result.val, end=&quot; &quot;) result = result.next Complexity Analysis Time Complexity: O(L) - We traverse the list with two pointers. Here, L is the number of nodes in the list. Space Complexity: O(1) - We only used constant extra space. Find Minimum in Rotated Sorted ArrayProblem StatementYou have an array of length n, which was initially sorted in ascending order. This array was then rotated x times. It is given that 1 &lt;= x &lt;= n. For example, if you rotate [1, 2, 3, 4] array 3 times, resultant array is [2, 3, 4, 1]. Your task is to find the minimum element from this array. Note that the array contains unique elements. You must write an algorithm that runs in O(log n) time. Example 1: Input: [8, 1, 3, 4, 5] Expected Output: 1 Justification: The smallest number in the array is 1. Example 2: Input: [4, 5, 7, 8, 0, 2, 3] Expected Output: 0 Justification: The smallest number in the array is 0. Example 3: Input: [7, 9, 12, 3, 4, 5] Expected Output: 3 Justification: In this rotated array, the smallest number present is 3. Constraints: n == nums.length 1 &lt;= n &lt;= 5000 -5000 &lt;= nums[i] &lt;= 5000 All the integers of nums are unique. nums is sorted and rotated between 1 and n times. SolutionTo determine the minimum element in a rotated sorted array, we’ll leverage the binary search method. In a standard sorted array, the elements increase (or remain the same) from left to right. But in our rotated sorted array, at some point, there will be a sudden drop, which indicates the start of the original sorted sequence and, hence, the minimum element. This drop will be our guide during the search. With binary search, we’ll repeatedly halve our search range until we pinpoint the location of this sudden drop or the smallest element. Initialization: Start with two pointers, left and right, set at the beginning and the end of the array, respectively. Binary Search Process: Calculate the middle index, mid. If the element at mid is greater than the element at right, this indicates that the minimum element is somewhere to the right of mid. Hence, update left to mid + 1. Otherwise, the minimum element is to the left, so update right to mid. Termination: The loop will eventually lead left to point to the minimum element. This happens when left equals right. Edge Case Handling: If the array isn’t rotated at all, the smallest element will be the first. Our binary search process accounts for this scenario. Algorithm WalkthroughConsider the array [4, 5, 7, 8, 0, 2, 3]: Start with left = 0 and right = 6. Calculate mid = (0 + 6) / 2 = 3. The array element at index 3 is 8. Since 8 &gt; 3 (element at right), update left to mid + 1 = 4. Now, left = 4 and right = 6. Calculate mid = (4 + 6) / 2 = 5. Element at index 5 is 2. Since 2 &lt; 3, update right to mid = 5. Now, left = 4 and right = 5. Calculate mid = (4 + 5) / 2 = 4. Element at index 4 is 0. Since 0 &lt; 2, update right to mid = 4. left is now equal to right, both pointing at index 4, where the minimum element 0 is present. Code12345678910111213141516171819202122class Solution: def findMin(self, nums) -&gt; int: left, right = 0, len(nums) - 1 # Continue until the search range is exhausted while left &lt; right: mid = (left + right) // 2 # Finding the middle index # If mid element is greater than the rightmost element, the minimum is on the right if nums[mid] &gt; nums[right]: left = mid + 1 else: right = mid # Otherwise, the minimum is on the left or at mid return nums[left] # Return the smallest element# Testsol = Solution()print(sol.findMin([8, 1, 3, 4, 5])) # Expected output: 1print(sol.findMin([4, 5, 7, 8, 0, 2, 3])) # Expected output: 0print(sol.findMin([7, 9, 12, 3, 4, 5])) # Expected output: 3 Complexity AnalysisTime Complexity: O(log n) because we are using a binary search approach, which reduces the problem size by half in each step. Space Complexity: O(1) as we are using a constant amount of space regardless of the input size. Pacific Atlantic Water FlowProblem Statement:Given a matrix m x n that represents the height of each unit cell in a Island, determine which cells can have water flow to both the Pacific and Atlantic oceans. The Pacific ocean touches the left and top edges of the continent, while the Atlantic ocean touches the right and bottom edges. From each cell, water can only flow to adjacent cells (top, bottom, left, or right) if the adjacent cell’s height is less than or equal to the current cell’s height. We need to return a list of grid coordinates where water can flow to both the Pacific and Atlantic oceans. Example 1: Input: [[1,2,3],[4,5,6],[7,8,9]] Expected Output: [[0,2],[1,2],[2,0],[2,1],[2,2]] Justification: The cells that can flow to both the Pacific and Atlantic oceans are [0,2]: To Pacific Ocean: Directly from [0,2] since it’s on the top border. To Atlantic Ocean: [0,2] -&gt; [1,2] -&gt; [2,2]. [1,2]: To Pacific Ocean: [1,2] -&gt; [0,2]. To Atlantic Ocean: [1,2] -&gt; [2,2]. [2,0]: To Pacific Ocean: Directly from [2,0] since it’s on the left border. To Atlantic Ocean: [2,0] -&gt; [2,1]. [2,1]: To Pacific Ocean: [2,1] -&gt; [2,0]. To Atlantic Ocean: [2,1] -&gt; [2,2]. [2,2]: To Pacific Ocean: [2,2] -&gt; [1,2] -&gt; [0,2]. To Atlantic Ocean: Directly from [2,2] since it’s on the bottom-right corner. Example 2: Input: [[10,10,10],[10,1,10],[10,10,10]] Expected Output: [[0,0],[0,1],[0,2],[1,0],[1,2],[2,0],[2,1],[2,2]] Justification: The water can flow to both oceans from all cells except from the central cell [1,1]. Example 3: Input: [[5,4,3],[4,3,2],[3,2,1]] Expected Output: [[0,0],[0,1],[0,2],[1,0],[2,0]] Justification: All the leftmost cells can have water flowing to both oceans. Similarly, top cells also satisfy the criteria. Constraints: m == matrix.length n == matrix[r].length 1 &lt;= m, n &lt;= 200 0 &lt;= matrix[r][c] &lt;= 105 SolutionOverview: The problem is essentially asking for matrix cells from which water can flow to both the Pacific and Atlantic oceans. The matrix is viewed as an elevation map. By starting from the borders of the matrix, which are directly connected to the oceans, we can perform a Depth First Search (DFS) inwards to determine which cells can flow water to each ocean. We can then compare the results for both oceans to identify cells that can flow to both. Detailed Explanation: Initialization: Begin by creating two matrices, pacific and atlantic, of the same size as the input matrix. These matrices will be used to mark the cells that can flow water to the respective oceans. The edges of the matrix adjacent to the top and left borders are considered part of the Pacific, while those adjacent to the bottom and right borders are considered part of the Atlantic. DFS Traversal: Perform a Depth First Search (DFS) starting from each cell on the borders. For the Pacific ocean, initiate DFS from the top and left borders. For the Atlantic ocean, initiate DFS from the bottom and right borders. While traversing using DFS, move from a cell to its neighboring cells only if the neighboring cell’s height is greater than or equal to the current cell. This ensures that water can flow in that direction (from high or equal elevation to higher elevations). Mark cells as visited for each ocean as you traverse to prevent reprocessing. Result Compilation: After completing the DFS traversal for both oceans, iterate over the matrix to identify cells that were visited in both the pacific and atlantic matrices. These are the cells from which water can flow to both oceans. Collect these cells and return them as the result. Algorithm Walkthrough Initialization: We have our input matrix: [[1,2,3],[4,5,6],[7,8,9]] Create two matrices pacific and atlantic with dimensions matching the input matrix, filled with False values. These will keep track of cells water can reach from each ocean. Define the matrix boundaries: top and left for Pacific, and bottom and right for Atlantic. Starting from Borders: For the Pacific ocean: Start DFS from the top border: [0,0], [0,1], and [0,2]. For [0,0] and [0,1], water cannot flow left or upwards as there’s no cell in that direction. Only downwards or to the right is possible. But since the elevation increases in both these directions, water cannot flow. For [0,2] (value 3), water can flow downwards to [1,2] (value 6) as 3 &lt; 6. Start DFS from the left border: [0,0], [1,0], and [2,0]. Only [2,0] (value 7) can flow to [2,1] (value 8) as 7 &lt; 8. For the Atlantic ocean: Start DFS from the bottom border: [2,0], [2,1], and [2,2]. For [2,0] and [2,1], water cannot flow downwards as there’s no cell in that direction. Only upwards or to the left/right is possible. However, only [2,1] can flow to [2,2] as 8 &lt; 9. For [2,2] (value 9), water can flow upwards to [1,2] (value 6) as 9 &gt; 6. Start DFS from the right border: [0,2] [1,2], and [2,2]. For [0,2], water can flow downwards as already discussed. For [1,2], water can flow upwards to [0,2] and downwards to [2,2]. Identifying Common Cells: Iterate through the matrix and find cells where both pacific and atlantic matrices are True. For our example, the cells are: [0,2], [1,2], [2,0], [2,1], and [2,2]. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution: # Define the directions for North, East, South, and West DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)] def pacificAtlantic(self, matrix): # Check if the matrix is empty or has no rows/columns if not matrix or not matrix[0]: return [] m, n = len(matrix), len(matrix[0]) # Initialize two matrices to track the visited status for Pacific and Atlantic oceans pacific = [[False for _ in range(n)] for _ in range(m)] atlantic = [[False for _ in range(n)] for _ in range(m)] # Start the DFS traversal for each cell on the borders for both oceans for i in range(m): self.dfs(matrix, i, 0, pacific, float(&#x27;-inf&#x27;)) self.dfs(matrix, i, n - 1, atlantic, float(&#x27;-inf&#x27;)) for j in range(n): self.dfs(matrix, 0, j, pacific, float(&#x27;-inf&#x27;)) self.dfs(matrix, m - 1, j, atlantic, float(&#x27;-inf&#x27;)) # Gather the result, which are the cells that both oceans can reach res = [] for i in range(m): for j in range(n): if pacific[i][j] and atlantic[i][j]: res.append([i, j]) return res def dfs(self, matrix, r, c, visited, height): # Check boundaries, if the cell was visited before, or if the cell has a value less than the current height m, n = len(matrix), len(matrix[0]) if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or visited[r][c] or matrix[r][c] &lt; height: return # Mark the cell as visited visited[r][c] = True # Explore the neighboring cells for dir in self.DIRECTIONS: self.dfs(matrix, r + dir[0], c + dir[1], visited, matrix[r][c])sol = Solution()print(sol.pacificAtlantic([[1,2,3],[4,5,6],[7,8,9]])) # Expected output: [[0,2],[1,2],[2,0],[2,1],[2,2]]print(sol.pacificAtlantic([[10,10,10],[10,1,10],[10,10,10]])) # Expected output: [[0,1],[1,0],[1,2],[2,1]]print(sol.pacificAtlantic([[5,4,3],[4,3,2],[3,2,1]])) # Expected output: [[0,2],[1,2],[2,0],[2,1],[2,2]] Complexity AnalysisTime Complexity: O(m x n) where m is the number of rows and n is the number of columns in the matrix. This is because each cell is visited once for both oceans. Space Complexity: O(m x n) due to the two additional matrices (for Pacific and Atlantic) to keep track of visited cells. Validate Binary Search TreeProblem StatementDetermine if a given binary tree is a binary search tree (BST). In a BST, for each node: All nodes to its left have values less than the node’s value. All nodes to its right have values greater than the node’s value. Example GenerationExample 1: Input: [5,3,7] Expected Output: true Justification: The left child of the root (3) is less than the root, and the right child of the root (7) is greater than the root. Hence, it’s a BST. Example 2: Input: [5,7,3] Expected Output: false Justification: The left child of the root (7) is greater than the root, making it invalid. Example 3: Input: [10,5,15,null,null,12,20] Expected Output: true Justification: Each subtree of the binary tree is a valid binary search tree. So, a whole binary tree is a valid binary search tree. Constraints: The number of nodes in the tree is in the range [1, 104]. -2^31 &lt;= Node.val &lt;= 2^31- 1 SolutionIn essence, to validate if a given binary tree is a binary search tree (BST), we employ a recursive approach that checks the validity of each node by comparing its value with a permissible range. This range is determined by the node’s ancestors, ensuring every node meets the BST property. Initially, the root node can take any value between negative infinity and positive infinity. As we traverse down the tree, we update this range based on the current node’s value. Detailed Breakdown: Recursion: For each node in the binary tree, we validate its value against a permissible range. If the value does not lie within this range, the tree is not a BST. The range for any node is influenced by its ancestors, ensuring that every node, even those deep in the tree, satisfies the BST condition. Base Case: If the node we are inspecting is null (i.e., we’ve reached a leaf node), we return true since a null subtree is always a BST by definition. Recursive Step: Compare the node’s value against its permissible range. If it’s not within the range, return false. If it is within range, we recursively check the left and right children, but with updated permissible ranges. Implementation: Initially, the root node’s range is set to (-Infinity, +Infinity). For every left child, the upper limit of its permissible range is updated to the current node’s value. Similarly, for every right child, the lower limit is updated to the current node’s value. Algorithm WalkthroughFor the tree [10,5,15,null,null,12,20]: Start with the root, range = (-Infinity, +Infinity) Node 10 is within the range. Move to the left child, range = (-Infinity, 10) Node 5 is within the range. Move to the right child of root, range = (10, +Infinity) Node 15 is within the range. Move to the left child of 15, range = (10, 15) Node 12 is within the range. Move to the right child of 15, range = (15, +Infinity) Node 20 is within the range. return true, as the next left node is null. Code1234567891011121314151617181920212223242526272829303132# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def isValidBST(self, root: TreeNode) -&gt; bool: # Helper function to recursively check node value against a range def helper(node, low=float(&#x27;-inf&#x27;), high=float(&#x27;inf&#x27;)): if not node: return True if not low &lt; node.val &lt; high: return False # Recursively check left (with updated high) and right (with updated low) return helper(node.left, low, node.val) and helper(node.right, node.val, high) return helper(root)# Test the solution with the examplesif __name__ == &quot;__main__&quot;: sol = Solution() example1 = TreeNode(5, TreeNode(3), TreeNode(7)) print(sol.isValidBST(example1)) # true example2 = TreeNode(5, TreeNode(7), TreeNode(3)) print(sol.isValidBST(example2)) # false example3 = TreeNode(10, TreeNode(5), TreeNode(15, TreeNode(12), TreeNode(20))) print(sol.isValidBST(example3)) # false Complexity Analysis Time Complexity: O(n) - We traverse each node once. Space Complexity: O(h) - The space is determined by the height of the tree due to recursive calls. In the worst case (skewed tree), it’s O(n), while in the best case (balanced tree), it’s O(log n). Construct Binary Tree from Preorder and Inorder TraversalProblem StatementGiven the preorder and inorder traversal sequences of a binary tree, your task is to reconstruct this binary tree. Assume that the tree does not contain duplicate values. Example GenerationExample 1: Input: Preorder: [1,2,4,5,3,6,7] Inorder: [4,2,5,1,6,3,7] Expected Output: Tree Representation: [1,2,3,4,5,6,7] Justification: The first value in preorder (1) is the root. In the inorder list, everything left of value 1 is the left subtree and everything on the right is the right subtree. Following this pattern recursively helps in reconstructing the binary tree. Example 2: Input: Preorder: [8,5,9,7,1,12,2,4,11,3] Inorder: [9,5,1,7,2,12,8,4,3,11] Expected Output: Tree Representation: [8,5,4,9,7,11,1,12,2,null,3] Justification: Start with 8 (from preorder) as the root. Splitting at 8 in inorder, we find the left and right subtrees. Following this pattern recursively, we can construct the tree. Example 3: Input: Preorder: [3,5,6,2,7,4,1,9,8] Inorder: [6,5,7,2,4,3,9,1,8] Expected Output: Tree Representation: [3,5,1,6,2,9,8,null,null,7,4] Justification: Following the same approach, using 3 as root from preorder, we split the inorder sequence into left and right subtrees and continue recursively. Constraints: 1 &lt;= preorder.length &lt;= 3000 inorder.length == preorder.length -3000 &lt;= preorder[i], inorder[i] &lt;= 3000 preorder and inorder consist of unique values. Each value of inorder also appears in preorder. preorder is guaranteed to be the preorder traversal of the tree. inorder is guaranteed to be the inorder traversal of the tree. SolutionReconstructing a binary tree from its preorder and inorder traversals involves recognizing the structure imposed by these traversal methods. The first element of the preorder traversal always gives us the root of the tree. Once we identify the root, its position in the inorder traversal divides the tree into its left and right subtrees. By harnessing this division recursively for both the left and the right subtrees, we can reconstruct the entire binary tree. Detailed Steps: Start with Preorder’s Root: The first element in the preorder list is always the root of the tree. Find the Root in Inorder: Once we have the root from preorder, we find its position in the inorder sequence. This position divides the tree into its left and right subtrees. Recursion: Based on the root’s position in inorder, we can split both the preorder and inorder lists into two halves each - one for the left subtree and the other for the right subtree. We then recursively construct the left and right subtrees. Base Case: If the inorder sequence becomes empty, it indicates there’s no tree to construct, so we return null. This approach capitalizes on the properties of the preorder and inorder traversals to recursively reconstruct the tree. Algorithm WalkthroughGiven Preorder: [1,2,4,5,3,6,7] and Inorder: [4,2,5,1,6,3,7] Take the first value from preorder (1) as the root. Find the position of 1 in inorder (position 4). Everything before position 4 in inorder is the left subtree, and everything after is the right subtree. Using the size of the left subtree (3 nodes), we take the next 3 values from preorder [2,4,5] for the left subtree and recursively repeat the process. Similarly, for the right subtree, we use the remaining values from preorder [3,6,7] and follow the same recursive approach. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# class TreeNode:# def __init__(self, val=0):# self.val = val# self.left = self.right = Noneclass Solution: def __init__(self): self.preIndex = 0 self.inorderIndexMap = &#123;&#125; def buildTree(self, preorder, inorder): # Create a dictionary to store the indices of values in the inorder list self.inorderIndexMap = &#123;val: idx for idx, val in enumerate(inorder)&#125; # Call the helper function to construct the binary tree return self._constructTree(preorder, 0, len(inorder) - 1) def _constructTree(self, preorder, inStart, inEnd): # Base case: If the start index is greater than the end index, return None if inStart &gt; inEnd: return None # Get the value at the current preorder index as the root value rootVal = preorder[self.preIndex] self.preIndex += 1 root = TreeNode(rootVal) # If the start index is equal to the end index, return the root node if inStart == inEnd: return root # Find the index of the root value in the inorder list inIndex = self.inorderIndexMap[rootVal] # Recursively construct the left and right subtrees root.left = self._constructTree(preorder, inStart, inIndex - 1) root.right = self._constructTree(preorder, inIndex + 1, inEnd) return rootdef printTree(root): if not root: return queue = [root] while queue: levelSize = len(queue) isLastLevel = True for _ in range(levelSize): curr = queue.pop(0) if curr: print(curr.val, end=&#x27; &#x27;) queue.append(curr.left) queue.append(curr.right) if curr.left or curr.right: isLastLevel = False else: print(&#x27;null&#x27;, end=&#x27; &#x27;) if isLastLevel: break# Example usage:sol = Solution()root = sol.buildTree([3, 9, 20, 15, 7], [9, 3, 15, 20, 7])printTree(root) # Expected output: 3 9 20 null null 15 7 Complexity Analysis Time Complexity: O(n). We are visiting each node once, and the look-up for the inorder index is constant time (due to HashMap or equivalent). Space Complexity: O(n). The space is majorly used for the hashmap and the recursive stack. Clone GraphProblem StatementGiven a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors. Example 1: Input: 1231--2| |4--3 Expected Output: 1231--2| |4--3 Explanation: The graph has four nodes with the following connections: Node 1 is connected to nodes 2 and 4. Node 2 is connected to nodes 1 and 3. Node 3 is connected to nodes 2 and 4. Node 4 is connected to nodes 1 and 3. Example 2: Input: 12345 1--2 / \\5 3 | 4 Expected Output: 12345 1--2 / \\5 3 | 4 Explanation: The graph consists of five nodes with these connections: Node 1 is connected to nodes 2 and 5. Node 2 is connected to nodes 1 and 3. Node 3 is connected to nodes 2 and 4. Node 4 is connected to node 3. Node 5 is connected to node 1. Example 3: Input: 12345 1--2 / \\4 3 \\ / 5--6 Expected Output: 12345 1--2 / \\4 3 \\ / 5--6 Explanation: The graph has six nodes with the following connections: Node 1 is connected to nodes 2 and 4. Node 2 is connected to nodes 1 and 3. Node 3 is connected to nodes 2 and 6. Node 4 is connected to nodes 1 and 5. Node 5 is connected to nodes 4 and 6. Node 6 is connected to nodes 3 and 5. Constraints: The number of nodes in the graph is in the range [0, 100]. 1 &lt;= Node.val &lt;= 100 Node.val is unique for each node. There are no repeated edges and no self-loops in the graph. The Graph is connected and all nodes can be visited starting from the given node. SolutionTo deep clone a given graph, the primary approach is to traverse the graph using Depth-First Search (DFS) and simultaneously create clones of the visited nodes. A hashmap (or dictionary) is utilized to track and associate original nodes with their respective clones, ensuring no duplications. Initialization: Create an empty hashmap to match the original nodes to their clones. DFS Traversal and Cloning: Traverse the graph with DFS. When encountering a node not in the hashmap, create its clone and map them in the hashmap. Recursively apply DFS for each of the node’s neighbors. After cloning a node and all its neighbors, associate the cloned node with the clones of its neighbors. Termination: Once DFS covers all nodes, return the cloned version of the starting node. Algorithm Walkthrough (using Example 1):For the input graph: 1231--2| |4--3 Start with an empty hashmap visited. Begin DFS with node 1. Node 1 isn’t in visited. Clone it to get 1&#39; and map (1, 1&#39;) in the hashmap. For each neighbor of node 1, apply DFS. First with 2. Node 2 isn’t in visited. Clone to get 2&#39; and map (2, 2&#39;). Node 2‘s neighbors are 1 and 3. Node 1 is visited, so link 2&#39;to 1&#39;. Move to 3. Node 3 isn’t in visited. Clone to get 3&#39; and map (3, 3&#39;). Node 3 has neighbors 2 and 4. Node 2 is visited, so link 3&#39; to 2&#39;. Move to 4. Node 4 isn’t in visited. Clone to get 4&#39; and map (4, 4&#39;). Node 4 has neighbors 1 and 3, both visited. Link 4&#39; to 1&#39; and 3&#39;. With DFS complete, return the clone of the starting node, 1&#39;. Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from collections import deque# class GraphNode:# def __init__(self, val = 0, neighbors = None):# self.val = val# self.neighbors = neighbors if neighbors is not None else []class Solution: def __init__(self): # Dictionary to keep track of nodes that are already visited self.visited = &#123;&#125; def cloneGraph(self, node: &#x27;GraphNode&#x27;) -&gt; &#x27;GraphNode&#x27;: if not node: return node # If the node is already visited, return its clone if node in self.visited: return self.visited[node] # Otherwise, create a new node with the same value clone_node = GraphNode(node.val, []) self.visited[node] = clone_node # Process all the neighbors for the current node for neighbor in node.neighbors: clone_node.neighbors.append(self.cloneGraph(neighbor)) return clone_node def printGraph(self, node): # Use BFS to print the graph printed = set() queue = deque([node]) while queue: curr = queue.popleft() if curr not in printed: print(curr.val, &#x27;--&gt;&#x27;, [n.val for n in curr.neighbors]) for n in curr.neighbors: queue.append(n) printed.add(curr) def main(self): sol = Solution() # Example 1: Create and clone a simple two-node graph node1 = GraphNode(1) node2 = GraphNode(2) node1.neighbors = [node2] node2.neighbors = [node1] sol.printGraph(sol.cloneGraph(node1)) # Expecting: 1--&gt;2, 2--&gt;1if __name__ == &quot;__main__&quot;: Solution().main() Complexity Analysis Time Complexity: O(N+M) where N is the number of nodes and M is the number of edges. Each node and edge is visited once. Space Complexity: O(N) as we are creating a clone for each node. Additionally, the recursion stack might use O(H) where H is the depth of the graph (in the worst case this would be O(N)). House Robber IIProblem StatementYou are given an array representing the amount of money each house has. This array models a circle of houses, meaning that the first and last houses are adjacent. You are tasked with figuring out the maximum amount of money you can rob without alerting the neighbors. The rule is: if you rob one house, you cannot rob its adjacent houses. ExamplesExample 1: Input: [4, 2, 3, 1] Expected Output: 7 Justification: Rob the 1st and 3rd house, which gives 4 + 3 = 7. Example 2: Input: [5, 1, 2, 5] Expected Output: 7 Justification: Rob the 1st and 3rd house, which gives 5 + 2 = 7. Example 3: Input: [1, 2, 3, 4, 5] Expected Output: 8 Justification: Rob the 3rd and 5th house, which gives 3 + 5 = 8. Constraints: 1 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 1000 SolutionThe core idea of our algorithm is to split the circular house problem into two simpler linear problems and then solve each linear problem using a dynamic programming approach. Since the first and last houses in the circle are adjacent, we can’t rob them both. Thus, we consider two scenarios: robbing houses excluding the first one and robbing houses excluding the last one. For each scenario, we use a helper function that returns the maximum amount we can rob. This helper function utilizes dynamic programming to keep track of the cumulative robbery amounts, ensuring that no two consecutive houses are robbed. Finally, our solution is the maximum of the two scenarios. Edge Cases Handling: Begin by checking for edge cases: If the input array is null or has a length of 0, return 0 since there are no houses to rob. If there’s only one house, return its value. If there are two houses, return the maximum value of the two houses. Two Scenarios Handling: Due to the circular structure, handle two scenarios: Exclude the first house and compute for the rest. Exclude the last house and compute for the others. Use a helper function to compute the maximum for each scenario. Simple Robber Helper Function: This function calculates the maximum robbing amount for a linear set of houses using dynamic programming: Maintain two variables, prevMax and currMax, to keep track of the max amount robbed up to the previous and current house, respectively. Iterate through each house in the given range (based on the scenario). At each house, decide whether to rob it (in which case you can’t rob the previous house) or skip it. For each house, update currMax based on whether robbing the current house results in a larger amount than skipping it. Return the Maximum: The main function concludes by returning the maximum value from the two scenarios. Algorithm WalkthroughUsing the input [4, 2, 3, 1]: Check for edge cases. Since the array has more than two houses, move to the next step. Calculate the maximum amount that can be robbed for the two scenarios: a. For the scenario excluding the last house (consider houses from index 0 to 2): Start with prevMax = 0 and currMax = 0. For the first house (value 4), currMax becomes 4. For the second house (value 2), currMax remains 4 (because 4 &gt; 2 + 0). For the third house (value 3), currMax becomes 7 (because 4 + 3 &gt; 4). So, for this scenario, the maximum is 7. b. For the scenario excluding the first house (consider houses from index 1 to 3): Start with prevMax = 0 and currMax = 0. For the second house (value 2), currMax becomes 2. For the third house (value 3), currMax becomes 3 (because 3 &gt; 2). For the fourth house (value 1), currMax remains 3 (because 3 &gt; 1 + 2). So, for this scenario, the maximum is 3. The main function then returns the maximum of the two scenarios, which is 7 in this case. Code123456789101112131415161718192021222324class Solution: def rob(self, nums): if not nums: return 0 if len(nums) == 1: return nums[0] if len(nums) == 2: return max(nums[0], nums[1]) # Compare the result excluding the first or the last house. return max(self._rob(nums, 0, len(nums) - 2), self._rob(nums, 1, len(nums) - 1)) # The simple rob function that doesn&#x27;t consider the circle scenario. def _rob(self, nums, start, end): prevMax, currMax = 0, 0 for i in range(start, end + 1): temp = currMax currMax = max(prevMax + nums[i], currMax) prevMax = temp return currMax# Test the solutionsolution = Solution()print(solution.rob([4, 2, 3, 1])) # Expected 7print(solution.rob([5, 1, 2, 5])) # Expected 7print(solution.rob([1, 2, 3, 4, 5])) # Expected 8 Complexity AnalysisTime Complexity: We are solving the house robber problem twice (once excluding the first house and once excluding the last house). Each run of the house robber problem has a time complexity of (O(n)), where (n) is the number of houses. Thus, our overall time complexity is (O(n)). Space Complexity: We use a constant amount of space to store our previous and current max values. Hence, the space complexity is (O(1)). Decode WaysProblem StatementYou have given a string that consists only of digits. This string can be decoded into a set of alphabets where ‘1’ can be represented as ‘A’, ‘2’ as ‘B’, … , ‘26’ as ‘Z’. The task is to determine how many ways the given digit string can be decoded into alphabets. Examples Input: “121” Expected Output: 3 Justification: The string “121” can be decoded as “ABA”, “AU”, and “LA”. Input: “27” Expected Output: 1 Justification: The string “27” can only be decoded as “BG”. Input: “110” Expected Output: 1 Justification: The string “110” can only be decoded as “JA”. Constraints: 1 &lt;= s.length &lt;= 100 s contains only digits and may contain leading zero(s). SolutionOur approach to solving this problem involves using dynamic programming to iteratively build the solution. Given a string of digits, we want to determine how many ways it can be decoded into alphabets. The key insight is that the number of ways to decode a string of length i is dependent on the number of ways to decode the previous two substrings of length i-1 and i-2. We’ll use two variables, prev and current, to store these values and update them as we loop through the string. Initialization: Begin by checking if the string is valid for decoding (e.g., it should not start with a ‘0’). If the string is invalid, return 0. Next, initialize two variables, prev and current, both set to 1. prev will store the number of ways to decode the string of length i-2, and current will store the number of ways to decode the string of length i-1. Iterate Through the String: Loop through the string from the second character to the end. For each character, compute the number of ways it can be decoded when combined with the previous character. Update Variables: For each character, evaluate the following conditions: If the current character and the previous character form a valid number between 10 and 26, they can be decoded together. If the current character is not ‘0’, it can be decoded individually. Use these conditions to update the prev and current variables accordingly. Return the Result: Once the iteration completes, the current variable will hold the total number of ways the entire string can be decoded. Return this value. This dynamic programming approach is efficient because it computes the solution by using previously calculated results, and it avoids redundant calculations. By tracking and updating the number of ways to decode the current and previous substrings, the algorithm effectively builds the solution for the entire string. Algorithm WalkthroughConsider the input “121”: Initialize prev = 1 and current = 1. For the second character ‘2’: “12” can be decoded as “AB” or “L”. Update prev and current by swapping their values and setting current += prev. Now, prev = 1 and current = 2. For the third character ‘1’: “21” can be decoded as “BA” or “U”. Again, update prev and current. Now, prev = 2 and current = 3. The final answer is 3, which is the value of current. Code123456789101112131415161718192021222324252627282930class Solution: def numDecodings(self, s: str) -&gt; int: # Return 0 for empty strings or strings starting with &#x27;0&#x27; if not s or s[0] == &#x27;0&#x27;: return 0 # Initialize two variables to store results of sub-problems prev, current = 1, 1 for i in range(1, len(s)): temp = 0 # If current character is not &#x27;0&#x27;, it can be decoded on its own if s[i] != &#x27;0&#x27;: temp = current # Check if two characters can be decoded together if 10 &lt;= int(s[i-1:i+1]) &lt;= 26: temp += prev prev, current = current, temp return currentif __name__ == &quot;__main__&quot;: sol = Solution() print(sol.numDecodings(&quot;121&quot;)) # Expected 3 print(sol.numDecodings(&quot;27&quot;)) # Expected 1 print(sol.numDecodings(&quot;110&quot;)) # Expected 1 Complexity Analysis Time Complexity: O(N), where N is the length of the string. We loop through the string once. Space Complexity: O(1), as we only use a constant amount of space regardless of the input size. Unique PathsProblem StatementGiven a 2-dimensional grid of size m x n (where m is the number of rows and n is the number of columns), you need to find out the number of unique paths from the top-left corner to the bottom-right corner. The constraints are that you can only move either right or down at any point in time. Examples Example 1: Input: 3, 3 Expected Output: 6 Justification: The six possible paths are: 1. Right, Right, Down, Down 2. Right, Down, Right, Down 3. Right, Down, Down, Right 4. Down, Right, Right, Down 5. Down, Right, Down, Right 6. Down, Down, Right, Right Example 2: Input: 3, 2 Expected Output: 3 Justification: The three possible paths are: Right, right, down Right, down, right Down, right, right Example 3: Input: 2, 3 Expected Output: 3 Justification: The three possible paths are: Down, right, right Right, down, right Right, right, down SolutionThe unique paths problem can be approached using a dynamic programming solution. Essentially, the idea is to think of the grid as a graph where each cell is a node. Given we can only move right or down, the number of ways to reach a cell is the sum of the number of ways to reach the cell above it and the cell to its left. By breaking down the problem in this way, we can iteratively compute the number of paths to reach any cell, starting from the top-left and working our way to the bottom-right of the grid. Initialization: Create a 2-dimensional array dp of size m x n initialized to zero. This array will store the number of unique paths to reach each cell. Boundary Cases: All cells in the first row can only be reached by moving right from the top-left corner. So, the number of unique paths for all cells in the first row will be 1. Similarly, all cells in the first column can only be reached by moving downwards from the top-left corner. So, the number of unique paths for all cells in the first column will be 1. Filling the Table: For each remaining cell, the number of unique paths to that cell is the sum of the number of paths from the cell above it and the cell to the left of it. This is because we can only move right or down. Result: The bottom-right cell will contain the total number of unique paths from the top-left corner to the bottom-right corner. Algorithm WalkthroughUsing the input from Example 1 (2, 2): Initialize a 2x2 matrix dp with all zeros. 120 00 0 Fill the first row and first column with 1s. 121 11 0 For cell dp[1][1], add values from cell above (dp[0][1]) and cell to the left (dp[1][0]). 121 11 2 The bottom-right cell (dp[1][1]) contains the number of unique paths: 2. Constraints: 1 &lt;= m, n &lt;= 100 Code12345678910111213141516171819class Solution: def uniquePaths(self, m: int, n: int) -&gt; int: # Initialize the dp array with 1s dp = [[1] * n for _ in range(m)] # Calculate the number of ways to reach each cell for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] # Return number of ways to reach the bottom-right cell return dp[-1][-1]if __name__ == &quot;__main__&quot;: sol = Solution() print(sol.uniquePaths(2, 2)) # 2 print(sol.uniquePaths(3, 2)) # 3 print(sol.uniquePaths(2, 3)) # 3 Complexity Analysis Time Complexity: O(m * n) - We are processing each cell once. Space Complexity: O(m * n) - Due to the 2D dp array. Word BreakProblem StatementGiven a non-empty string and a dictionary containing a list of non-empty words, determine if the string can be segmented into a space-separated sequence of one or more dictionary words. Each word in the dictionary can be reused multiple times. ExamplesExample 1: Input: String: “ilovecoding” Dictionary: [“i”, “love”, “coding”] Expected Output: True Justification: The string can be segmented as “i love coding”. Example 2: Input: String: “helloworld” Dictionary: [“hello”, “world”, “hell”, “low”] Expected Output: True Justification: The string can be segmented as “hello world”. Example 3: Input: String: “enjoylife” Dictionary: [“enj”, “life”, “joy”] Expected Output: False Justification: Despite having the words “enj” and “life” in the dictionary, we can’t segment the string into the space-separated dictionary words. Constraints: 1 &lt;= s.length &lt;= 300 1 &lt;= wordDict.length &lt;= 1000 1 &lt;= wordDict[i].length &lt;= 20 s and wordDict[i] consist of only lowercase English letters. All the strings of wordDict are unique. SolutionOur algorithm’s primary objective is to determine whether the given string can be broken down into a sequence of words present in the dictionary. To achieve this, we use a dynamic programming approach, maintaining an array to keep track of the possibility of forming valid sequences up to every index of the string. The primary idea is to iterate through the string and, at each step, check all possible word endings at the current position. If a valid word is found, and the starting position of that word was marked as achievable, we mark the current position as achievable too. Initialization: Begin by initializing a boolean array dp of size n+1, where n is the length of the string. This array will record whether the string can be segmented up to a certain index. We set the first element, dp[0], to true since an empty string can always be segmented. Dynamic Programming: Iterate over the length of the string. For each index i, verify every substring ending at i and see if it exists in the dictionary. If a valid word is found and the starting position (denoted as dp[j]) of the substring is true, set dp[i+1] to true. Proceed in this manner until you reach the end of the string. Result: Once the iteration is complete, the value of dp[n] will indicate if the entire string can be segmented into dictionary words or not. Optimization: For faster lookups, convert the word dictionary into a set. This ensures constant time complexity when searching for words in the dictionary. Algorithm WalkthroughGiven the string “helloworld” and dictionary [“hello”, “world”, “hell”, “low”]: Initialize dp to [true, false, false, ..., false] (length = 11 since “helloworld” has 10 characters). For i = 0, substring = “h”. It’s not in the dictionary, so move to next. For i = 1, substring = “he”, “h”. Neither is in the dictionary. For i = 4, substring = “hello”, which is in the dictionary and dp[0] is true. So, set dp[5] to true. Continuing this, when we get to i = 9, substring = “world” is in the dictionary, and dp[5] is true, so we set dp[10] to true. Finally, dp[10] is true, so “helloworld” can be segmented. Code1234567891011121314151617181920212223242526class Solution: def wordBreak(self, s, wordDict): # Convert wordDict into a set for O(1) lookup wordSet = set(wordDict) # Initialize dp list with false values and set the first value to true dp = [False] * (len(s) + 1) dp[0] = True # Iterate over the string for i in range(1, len(s) + 1): # For each position, check all possible words that end at this position for j in range(i): if dp[j] and s[j:i] in wordSet: dp[i] = True break # Return if the entire string can be segmented or not return dp[len(s)]# Test the codesol = Solution()print(sol.wordBreak(&quot;ilovecoding&quot;, [&quot;i&quot;, &quot;love&quot;, &quot;coding&quot;])) # trueprint(sol.wordBreak(&quot;helloworld&quot;, [&quot;hello&quot;, &quot;world&quot;, &quot;hell&quot;, &quot;low&quot;])) # trueprint(sol.wordBreak(&quot;enjoylife&quot;, [&quot;enj&quot;, &quot;life&quot;, &quot;joy&quot;])) # false Complexity Analysis Time Complexity: O(n^2) due to the two nested loops where we check all possible substrings. Space Complexity: O(n) for the DP array and the word set. Lowest Common Ancestor of a Binary Search TreeProblem StatementGiven a binary search tree (BST) and two of its nodes, find the node that is the lowest common ancestor (LCA) of the two given nodes. The LCA of two nodes is the node that lies in between the two nodes in terms of value and is the furthest from the root. In other words, it’s the deepest node where the two nodes diverge in the tree. Remember, in a BST, nodes have unique values. Examples Input: BST: [6,2,8,0,4,7,9,null,null,3,5] Node 1: 2 Node 2: 8 Expected Output: 6 Justification: The nodes 2 and 8 are on the left and right children of node 6. Hence, node 6 is their LCA. Input: BST: [6,2,8,0,4,7,9,null,null,3,5] Node 1: 0 Node 2: 3 Expected Output: 2 Justification: The nodes 0 and 3 are on the left and right children of node 2, which is the closest ancestor to these nodes. Input: BST: [6,2,8,0,4,7,9,null,null,3,5] Node 1: 4 Node 2: 5 Expected Output: 4 Justification: Node 5 is the right child of node 4. Hence, the LCA is node 4 itself. Constraints: The number of nodes in the tree is in the range [2, 105]. -10^9 &lt;=Node.val &lt;= 10^9 All Node.val are unique. p != q p and q will exist in the BST. SolutionThe binary search tree property helps us find the solution without exploring the entire tree. Each node, starting from the root, provides a range based on its value that can determine where the two nodes are located. Starting at the Root: Begin at the root of the BST. Determining Direction: If the values of both nodes are greater than the current root node’s value, then the LCA must be in the right subtree. If the values are both less, then the LCA is in the left subtree. Divergence Point: If one node’s value is less than the root’s value and the other node’s value is greater (or if one of them matches the root’s value), then the current root is the LCA, since the path to reach both nodes diverges from here. Iterative Search: Repeat the process iteratively on the selected subtree (either left or right) until you find the LCA. Algorithm WalkthroughUsing the first example input: BST: [6,2,8,0,4,7,9,null,null,3,5] Node 1: 2 Node 2: 8 Steps: Start at root which is 6. Both 2 and 8 are on different sides of 6 (2 on the left and 8 on the right). Therefore, 6 is the lowest common ancestor. Code123456789101112131415161718192021222324252627# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def lowestCommonAncestor(self, root, p, q): # Iterate until the LCA is found while root: if p &lt; root.val and q &lt; root.val: root = root.left # Both nodes are on the left elif p &gt; root.val and q &gt; root.val: root = root.right # Both nodes are on the right else: return root.val # One node is on the left and the other is on the right, so we found the LCA return None # Just in case, though we should always find an LCA in a valid inputif __name__ == &quot;__main__&quot;: # Creating the example tree root = TreeNode(6, TreeNode(2, TreeNode(0), TreeNode(4, TreeNode(3), TreeNode(5))), TreeNode(8, TreeNode(7), TreeNode(9))) solution = Solution() # Testing the solution on the provided examples print(solution.lowestCommonAncestor(root, 2, 8)) # expected: 6 print(solution.lowestCommonAncestor(root, 0, 3)) # expected: 2 print(solution.lowestCommonAncestor(root, 4, 5)) # expected: 4 Complexity AnalysisThe algorithm traverses the BST in a single path, either going left or right, but never both. Therefore: Time Complexity: O(h), where h is the height of the BST. pace Complexity: O(1) since we only used a constant amount of space. Longest Consecutive SequenceProblem StatementGiven an unsorted array of integers, find the length of the longest consecutive sequence of numbers in it. A consecutive sequence means the numbers in the sequence are contiguous without any gaps. For instance, 1, 2, 3, 4 is a consecutive sequence, but 1, 3, 4, 5 is not. Examples Input: [10, 11, 14, 12, 13] Output: 5 Justification: The entire array forms a consecutive sequence from 10 to 14. Input: [3, 6, 4, 100, 101, 102] Output: 3 Justification: There are two consecutive sequences, [3, 4] and [100,101,102]. The latter has a maximum length of 3. Input: [4, 3, 6, 2, 5, 8, 4, 7, 0, 1] Output: 9 Justification: The longest consecutive sequences here are [0, 1, 2,, 3, 4, 5, 6, 7, 8]. Input: [7, 8, 10, 11, 15] Output: 2 Justification: The longest consecutive sequences here are [7,8] and [10,11], both of length 2. Constraints: 0 &lt;= nums.length &lt;= 105 -10^9 &lt;= nums[i] &lt;= 10^9 SolutionTo solve this problem, the key observation is that if n is part of a consecutive sequence, then n+1 and n-1 must also be in that sequence. HashSet: Begin by inserting all elements of the array into a HashSet. The reason for using a HashSet is to ensure O(1) time complexity during look-up operations. Initial Scan: Iterate through each element of the array. For every number, check if it’s the starting point of a possible sequence. This can be determined by checking if n-1 exists in the HashSet. If not, then it means n is the start of a sequence. Building Sequences: For each starting number identified in step 2, keep checking if n+1, n+2… exist in the HashSet. For each present number, increase the length of the sequence and move to the next number. Result: Store the length of each sequence found in step 3. The answer will be the longest of all sequences identified. Algorithm WalkthroughGiven the input: [3, 6, 4, 100, 101, 102] Initialize an empty HashSet and populate it with all numbers from the input. Start with the first number, 3. Since 2 (which is 3-1) is not in the HashSet, we recognize 3 as the starting of a sequence. Check for 4. It’s there. Move to 5. It’s not there. So, the sequence is [3,4] with a length of 2. Next, take 6. 5 is not there, so 6 might be the start of a new sequence. However, 7 isn’t in the HashSet. So, the sequence is just [6]. For 100, 99 isn’t there, so 100 is a starting point. Check for 101. It’s there. Check for 102. It’s there. Check for 103. It’s not there. The sequence is [100,101,102] with a length of 3. The algorithm returns 3, which is the length of the longest sequence. Code12345678910111213141516171819202122232425262728class Solution: def longestConsecutive(self, nums): # Using a set to store numbers for constant time lookup num_set = set(nums) longest_sequence = 0 for num in num_set: # Checking if current number is the start of a sequence if num - 1 not in num_set: current_num = num current_streak = 1 # Extend the streak for as long as possible while current_num + 1 in num_set: current_num += 1 current_streak += 1 # Keep track of the longest streak longest_sequence = max(longest_sequence, current_streak) return longest_sequenceif __name__ == &quot;__main__&quot;: sol = Solution() print(sol.longestConsecutive([10, 11, 14, 12, 13])) # 5 print(sol.longestConsecutive([3, 6, 4, 100, 101, 102])) # 3 print(sol.longestConsecutive([7, 8, 10, 11, 15])) # 2 Complexity Analysis Time Complexity: O(n). Although it seems that the while loop runs for each number, it only runs for the numbers that are the starting points of sequences. So, in total, each number is processed only once. Space Complexity: O(n). The space used by our set. Meeting Rooms IIProblem StatementGiven a list of time intervals during which meetings are scheduled, determine the minimum number of meeting rooms that are required to ensure that none of the meetings overlap in time. Examples Example 1: Input: [[10, 15], [20, 25], [30, 35]] Expected Output: 1 Justification: There are no overlapping intervals in the given list. So, only 1 meeting room is enough for all the meetings. Example 2: Input: [[10, 20], [15, 25], [24, 30]] Expected Output: 2 Justification: The first and second intervals overlap, and the second and third intervals overlap as well. So, we need 2 rooms. Example 3: Input: [[10, 20], [20, 30]] Expected Output: 1 Justification: The end time of the first meeting is the same as the start time of the second meeting. So, one meeting can be scheduled right after the other in the same room. Constraints: 1 &lt;= intervals.length &lt;= 104 0 &lt;= starti &lt; endi &lt;= 106 SolutionTo determine the minimum number of rooms required to host the meetings without any time overlap, our approach first involves sorting all meeting intervals based on their start times. This sorting allows us to sequentially evaluate meetings in the order they start. We then utilize a priority queue (min-heap) to keep track of end times of the meetings currently taking place. This queue helps in efficiently determining the earliest ending meeting. By sequentially examining each meeting and comparing its start time to the earliest ending time from the heap, we can decide if a new room is needed or if an existing room can be reused. Sorting: Begin by sorting all intervals based on their start times. This enables us to sequentially check for overlapping intervals. Priority Queue: A priority queue (min-heap) is used to monitor end times of meetings that are currently in session. If the start time of the next meeting is less than the smallest end time (i.e., the top of the priority queue), it indicates we require another room. Reusing Rooms: Once we have checked a meeting and it doesn’t overlap with the smallest end time, this means that the meeting room used by the meeting with the smallest end time can be reassigned. Therefore, we remove the earliest ending meeting from the priority queue. Counting Rooms: At any given time, the size of the priority queue reflects the number of rooms in use. This can be used to deduce the minimum number of rooms needed up to that point. Algorithm WalkthroughGiven an input [[10, 20], [15, 30], [25, 40]]: First, sort the intervals: [[10, 20], [15, 30], [25, 40]] (in this case, the intervals are already sorted). Initialize a priority queue. Add the end time of the first meeting to the queue. For the next interval [15, 30], the start time 15 is less than the top of the queue (i.e., 20). Hence, we need another room. Add 30 to the priority queue. For the next interval [25, 40], the start time 25 is greater than the top of the queue (i.e., 20). So, we can use the room which will be free at time 20. Remove 20 from the queue and add 40. The size of the priority queue at the end is 2, indicating 2 rooms are required. Code12345678910111213141516171819202122232425262728293031323334import heapqclass Solution: def minMeetingRooms(self, intervals: [[int]]) -&gt; int: if not intervals: return 0 # Initialize a heap free_rooms = [] # Sort the meetings in increasing order of their start time. intervals.sort(key=lambda x: x[0]) # Add the first meeting. We have to give a new room to the first meeting. heapq.heappush(free_rooms, intervals[0][1]) # For all the remaining meeting rooms for i in intervals[1:]: # If the room due to free up the earliest is free, assign that room to this meeting. if free_rooms[0] &lt;= i[0]: heapq.heappop(free_rooms) # If a new room is to be assigned, then also we add to the heap. heapq.heappush(free_rooms, i[1]) # The size of the heap tells us the minimum rooms required for all the meetings. return len(free_rooms)# Testsol = Solution()print(sol.minMeetingRooms([[10, 15], [20, 25], [30, 35]])) # 1print(sol.minMeetingRooms([[10, 20], [15, 25], [24, 30]])) # 2print(sol.minMeetingRooms([[10, 20], [20, 30]])) # 1 Complexity Analysis Time Complexity: The time complexity of our algorithm is (O(N \\log N)), where (N) is the number of intervals. This is because we’re sorting the intervals once and then using priority queues to process them. Space Complexity: The space complexity is (O(N)) as we’re storing all intervals in the worst case. Encode and Decode StringsProblem StatementGiven a list of strings, your task is to develop two functions: one that encodes the list of strings into a single string, and another that decodes the resulting single string back into the original list of strings. It is crucial that the decoded list is identical to the original one. It is given that you can use any encoding technique to encode list of string into the single string. Examples Example 1: Input: [“apple”, “banana”] Expected Output: [“apple”, “banana”] Justification: When we encode the input strings [“apple”, “banana”], we get a single encoded string. Decoding this encoded string should give us the original list [“apple”, “banana”]. Example 2: Input: [“sun”, “moon”, “stars”] Expected Output: [“sun”, “moon”, “stars”] Justification: After encoding the input list, decoding it should bring back the original list. Example 3: Input: [“Hello123”, “&amp;*^%”] Expected Output: [“Hello123”, “&amp;*^%”] Justification: Regardless of the content of the string (special characters, numbers, etc.), decoding the encoded list should reproduce the original list. Constraints: 1 &lt;= strs.length &lt;= 200 0 &lt;= strs[i].length &lt;= 200 strs[i] contains any possible characters out of 256 valid ASCII characters. SolutionOur approach will utilize a delimiter that doesn’t appear in the input strings. For the sake of simplicity, we can choose a character like #. If # is possible in the input, we can use multiple characters like ## to reduce the chance it appears in the input. Encoding: For each string in the list, we append it to the encoded string. After appending the string, we add the delimiter ##. Continue this for all the strings in the list. Decoding: We split the encoded string using our delimiter ##. This will give us a list of strings which is our original list. Handling Edge Cases: If ## can be part of the input strings, then our approach will fail. To handle such cases, we can prefix each string with its length followed by a special character, like |, before the actual string. This way, during decoding, we can use the length to identify the end of one string and the beginning of the next. Algorithm WalkthroughLet’s walk through the algorithm using the input [“apple”, “banana##cherry”]: During encoding: “apple” becomes “5|apple##” “banana##cherry” becomes “15|banana##cherry##” The final encoded string is “5|apple##15|banana##cherry##” During decoding: Read the first character, which is 5. It tells us the next 5 characters form the first string “apple”. The next character # is part of our delimiter, so we skip two characters. Next, read the number 15, which tells us the next 15 characters form the string “banana##cherry”. Finally, we reach the end of our encoded string. Code12345678910111213141516171819202122232425262728293031class Solution: def encode(self, strs): &quot;&quot;&quot;Encodes a list of strings to a single string.&quot;&quot;&quot; encoded = &quot;&quot; for s in strs: # For each string, append its length, a delimiter &#x27;|&#x27;, the string itself, and then &quot;##&quot; encoded += str(len(s)) + &quot;|&quot; + s + &quot;##&quot; return encoded def decode(self, s): &quot;&quot;&quot;Decodes a single string to a list of strings.&quot;&quot;&quot; res = [] i = 0 while i &lt; len(s): # Find the delimiter to extract string&#x27;s length delim = s.find(&#x27;|&#x27;, i) size = int(s[i:delim]) # Using the extracted size, retrieve the actual string and add to the result list res.append(s[delim + 1: delim + 1 + size]) # Move index to start of next encoded string segment i = delim + size + 3 return res# Test the encode and decode functionssol = Solution()example = [&quot;apple&quot;, &quot;banana##cherry&quot;]print(sol.decode(sol.encode(example))) # Expected Output: [&#x27;apple&#x27;, &#x27;banana##cherry&#x27;] Complexity Analysis Time Complexity: For encoding, it is (O(n)), where (n) is the combined length of all the strings in the list because we iterate over each character once. For decoding, it’s also (O(n)) for the same reason. Space Complexity: (O(n)) as we store the encoded version of the string, and its length is proportional to the combined length of all the strings in the list. Number of Connected Components in an Undirected GraphProblem StatementGiven an undirected graph represented by ‘n’ nodes labeled from 0 to n-1 and a list of undirected edges (each edge is a pair of nodes), determine the number of connected components in the graph. A connected component is a group of nodes that are directly or indirectly linked to each other through the edges. Examples Example 1 Input: n = 5, edges = [[0,1], [2,3], [3,4]] Expected Output: 2 Justification: Two components are: 0-1, and 2-3-4. Example 2 Input: n = 4, edges = [[0,1], [1,2], [2,3]] Expected Output: 1 Justification: All the nodes are connected in a single chain: 0-1-2-3. Example 3 Input: n = 3, edges = [[0,1]] Expected Output: 2 Justification: Two connected components exist: 0-1 and an isolated node 2. Constraints: 1 &lt;= n &lt;= 2000 1 &lt;= edges.length &lt;= 5000 edges[i].length == 2 0 &lt;= ai &lt;= bi &lt; n ai != bi There are no repeated edges. SolutionWe will use the Union-Find (also known as Disjoint Set Union, DSU) data structure to solve this problem. This approach is efficient in identifying and merging different sets: Initialization: Create an array parent of size n where parent[i] = i. This array will keep track of the parent of each node. Initially, each node is its own parent. Count the number of separate components. Initially, the count is n since every node is a separate component. Union Operation: For each edge (u, v), find the parent of u and the parent of v. If the parents are different, then u and v belong to different components. So, we merge them by assigning one’s parent to the other and reduce the component count by 1. Find Operation: This operation determines the parent of a node. If a node’s parent is itself, return the node. Otherwise, recursively find the parent of its parent. To optimize the search in future look-ups, we can apply path compression by updating the parent of the current node to its root during the recursion. Result: After processing all edges, the component count will represent the number of connected components. Algorithm WalkthroughUsing the input n = 5 and edges = [[0,1], [2,3], [3,4]]: Initialize parent = [0, 1, 2, 3, 4] and count = 5. Process edge [0,1]: Parent of 0 is 0. Parent of 1 is 1. They have different parents. Merge them by setting parent of 1 to 0 and reduce count to 4. Process edge [2,3]: Parent of 2 is 2. Parent of 3 is 3. Merge them by setting parent of 3 to 2. Reduce count to 3. Process edge [3,4]: Parent of 3 is 2 (from previous merge). Parent of 4 is 4. Merge them by setting parent of 4 to 2. Reduce count to 2. Final count is 2. Code12345678910111213141516171819202122232425class Solution: def __init__(self): self.parents = [] def find(self, x): if self.parents[x] != x: self.parents[x] = self.find(self.parents[x]) # Path compression return self.parents[x] def countComponents(self, n, edges): self.parents = [i for i in range(n)] # Initially, each node is its own parent for edge in edges: root1 = self.find(edge[0]) root2 = self.find(edge[1]) if root1 != root2: self.parents[root1] = root2 # Union operation n -= 1 # Decrease the component count return n# Test the codesol = Solution()print(sol.countComponents(4, [[0,1],[2,3]])) #Expected 2print(sol.countComponents(5, [[0,1],[1,2],[2,0]])) #Expected 3print(sol.countComponents(3, [])) #Expected 3 Complexity Analysis Time Complexity: The union operation is almost O(1) with path compression. So, for E edges, the time complexity is approximately O(E). Space Complexity: O(N) due to the parent array. Graph Valid TreeProblem StatementGiven a number n, which indicates the number of nodes numbered from 0 to n-1, and a list of undirected edges for the graph, determine if the graph is a valid tree. A graph qualifies as a valid tree if it meets the following criteria: It has no cycles. It is fully connected. Examples Example 1: Input: n = 5, edges = [[0,1],[0,2],[0,3],[1,4]] Expected Output: true Justification: There are no cycles in the graph, and all nodes are connected, forming a valid tree. Example 2: Input: n = 4, edges = [[0,1],[1,2],[2,3],[3,0]]]] Expected Output: false Justification: There is a cycle in the graph (0-1-2-3-0), thus it’s not a valid tree. Example 3: Input: n = 5, edges = [[0,1],[1,2],[2,3]] Expected Output: false Justification: TNode 4 is not connected to any other node, making the graph not fully connected. Constraints: 1 &lt;= n &lt;= 2000 0 &lt;= edges.length &lt;= 5000 edges[i].length == 2 0 &lt;= ai &lt;= bi &lt; n ai != bi There are no self-loops or repeated edges. SolutionTo determine if a given undirected graph forms a valid tree, we must ensure two key conditions are met: The graph should not have any cycles. The graph should be fully connected (i.e., all nodes are reachable from any other node). To verify these conditions, we can adopt the following approach: Initialization: Construct an adjacency list for the graph. Initialize a set (or an array) to keep track of visited nodes. DFS for Cycle Check: Use Depth First Search (DFS) to explore the graph. During this traversal, if we ever try to revisit a node we’ve previously visited (excluding the parent node), it indicates the presence of a cycle. Connectivity Check: After ensuring there are no cycles, we need to ensure that the graph is fully connected. This can be done by verifying that the number of unique nodes visited during our DFS equals the total number of nodes. Return Result: If both checks pass, then it’s a valid tree and we return true. Otherwise, return false. Algorithm WalkthroughUsing the input from Example 1: 12n = 5edges = [[0,1],[0,2],[0,3],[1,4]] Start with the adjacency list: 123450 -&gt; [1, 2, 3]1 -&gt; [0, 4]2 -&gt; [0]3 -&gt; [0]4 -&gt; [1] Start DFS from node 0. Mark node 0 as visited. Move to node 1 (from node 0). Mark node 1 as visited. From node 1, visit node 4. Mark node 4 as visited. Backtrack to node 1, and backtrack again to node 0. From node 0, visit node 2. Mark node 2 as visited. From node 0, visit node 3. Mark node 3 as visited. At the end of DFS, we’ve visited all nodes and found no cycles. Since we visited all nodes, the graph is fully connected. Hence, the graph is a valid tree. Code1234567891011121314151617181920212223242526272829303132333435from collections import defaultdictclass Solution: def __init__(self): self.graph = defaultdict(list) self.visited = set() def validTree(self, n, edges): # Building the adjacency list for the graph for edge in edges: self.graph[edge[0]].append(edge[1]) self.graph[edge[1]].append(edge[0]) # Checking for cycle if self.hasCycle(-1, 0): return False # Checking for connectivity return len(self.visited) == n def hasCycle(self, parent, node): self.visited.add(node) for neighbor in self.graph[node]: if neighbor == parent: continue if neighbor in self.visited or self.hasCycle(node, neighbor): return True return False# Test the algorithm with example inputssol = Solution()print(sol.validTree(5, [[0,1],[0,2],[0,3],[1,4]])) # trueprint(sol.validTree(4, [[0,1],[1,2],[2,3],[3,0]])) # falseprint(sol.validTree(5, [[0,1],[1,2],[2,3]])) # false Complexity Analysis Time Complexity: The algorithm visits each node and edge once, so its time complexity is ( O(n + e) ), where ( n ) is the number of nodes and ( e ) is the number of edges. Space Complexity: We are using a graph and visited set, so the space complexity is ( O(n + e) ). Implement Trie (Prefix Tree)Problem StatementDesign and implement a Trie (also known as a Prefix Tree). A trie is a tree-like data structure that stores a dynamic set of strings, and is particularly useful for searching for words with a given prefix. Implement the Solution class: Solution() Initializes the object. void insert(word) Inserts word into the trie, making it available for future searches. bool search(word) Checks if the word exists in the trie. bool startsWith(word) Checks if any word in the trie starts with the given prefix. Examples Example 1: Input: Trie operations: [&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;startsWith&quot;] Arguments: [[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;]] Expected Output: [-1, -1, 1, 1] Justification: After inserting “apple”, “apple” exists in the Trie. There is also a word that starts with “app”, which is “apple”. Example 2: Input: Trie operations: [&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;search&quot;] Arguments: [[], [&quot;banana&quot;], [&quot;apple&quot;], [&quot;ban&quot;], [&quot;banana&quot;]] Expected Output: [-1, -1, 0, 1, 1] Justification: After inserting “banana”, “apple” does not exist in the Trie but a word that starts with “ban”, which is “banana”, does exist. Example 3: Input: Trie operations: [&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;] Arguments: [[], [&quot;grape&quot;], [&quot;grape&quot;], [&quot;grap&quot;], [&quot;gr&quot;]] Expected Output: [-1, -1, 1, 1, 1] Justification: After inserting “grape”, “grape” exists in the Trie. There are words that start with “grap” and “gr”, which is “grape”. Constraints: 1 &lt;= word.length, prefix.length &lt;= 2000 word and prefix consist only of lowercase English letters. At most 3 * 104 calls in total will be made to insert, search, and startsWith. SolutionThe trie is represented as a tree, where each node contains an array of pointers (or references) to its children and a boolean flag indicating if the current node marks the end of a word. When inserting or searching for a word, we start at the root node and navigate through the tree character by character until we either finish the operation or determine the word doesn’t exist in the trie. Now, let’s break down the operations: Insert: We begin at the root node. For every character in the word, check if there’s a child node for it. If the child node doesn’t exist, we create it. Navigate to the child node and repeat the process for the next character. Once the end of the word is reached, mark the current node as an endpoint of a word. Search: Starting at the root, traverse the trie character by character. For every character in the word, check if there’s a child node for it. If at any point there isn’t a child node for the character, the word doesn’t exist in the trie. If we can traverse the entire word and the last node is marked as an endpoint, the word exists in the trie. StartsWith: The operation is similar to the search, but we don’t need the last node to be an endpoint. If we can traverse the prefix without any missing nodes, there exists a word in the trie that starts with the given prefix. Algorithm WalkthroughUsing Example 1: [&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;startsWith&quot;] [[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;]] Create an empty Trie. Insert “apple”. Start from the root. For ‘a’, move to the child node or create one if it doesn’t exist. Move to ‘p’, then the next ‘p’, followed by ‘l’ and finally ‘e’. Mark ‘e’ as the end of a word. Search for “apple”. Start from the root and traverse nodes ‘a’ -&gt; ‘p’ -&gt; ‘p’ -&gt; ‘l’ -&gt; ‘e’. Since ‘e’ is marked as the end of a word, return true. Check if a word starts with “app”. Traverse nodes for ‘a’ -&gt; ‘p’ -&gt; ‘p’. All nodes exist, so return true. Code12345678910111213141516171819202122232425262728293031323334353637383940414243# class TrieNode:# def __init__(self):# self.children = &#123;&#125; # Dictionary to store child nodes.# self.isEnd = False # Flag to represent end of a word.class Solution: def __init__(self): self.root = TrieNode() # Inserts a word into the trie. def insert(self, word: str) -&gt; None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.isEnd = True # Returns if the word is in the trie. def search(self, word: str) -&gt; bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.isEnd # Returns if there is any word in the trie that starts with the given prefix. def startsWith(self, prefix: str) -&gt; bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return Trueif __name__ == &quot;__main__&quot;: trie = Solution() trie.insert(&quot;apple&quot;) print(trie.search(&quot;apple&quot;)) # True print(trie.search(&quot;app&quot;)) # False print(trie.startsWith(&quot;app&quot;))# True Complexity Analysis Time Complexity: Insert: (O(m)), where (m) is the key length. Search and StartsWith: (O(m)) in the worst case scenario. Space Complexity: (O(n \\times m)), where (n) is the number of inserted keys and (m) is the average key length. Design Add and Search Words Data StructureProblem StatementDesign a data structure that supports the addition of new words and the ability to check if a string matches any previously added word. Implement the Solution class: Solution() Initializes the object. void addWord(word) Inserts word into the data structure, making it available for future searches. bool search(word) Checks if there is any word in the data structure that matches word. The method returns true if such a match exists, otherwise returns false. Note: In the search query word, the character &#39;.&#39; can represent any single letter, effectively serving as a wildcard character. ExamplesExample 1: Input: 12[&quot;Solution&quot;, &quot;addWord&quot;, &quot;addWord&quot;, &quot;search&quot;, &quot;search&quot;][[], [&quot;apple&quot;], [&quot;banana&quot;], [&quot;apple&quot;], [&quot;.....&quot;]] Expected Output: 1[-1, -1, -1, 1, 1] Justification: After adding the words “apple” and “banana”, searching for “apple” will return true since “apple” is in the data structure. Searching for “…..” will also return true as both “apple” and “banana” match the pattern. Example 2: Input: 12[&quot;Solution&quot;, &quot;addWord&quot;, &quot;addWord&quot;, &quot;search&quot;, &quot;search&quot;][[], [&quot;cat&quot;], [&quot;dog&quot;], [&quot;c.t&quot;], [&quot;d..g&quot;]] Expected Output: 1[-1, -1, -1, 1, 0] Justification: “c.t” matches “cat” and “d..g” doesn’t matches “dog”. Example 3: Input: 12[&quot;Solution&quot;, &quot;addWord&quot;, &quot;search&quot;, &quot;search&quot;][[], [&quot;hello&quot;], [&quot;h.llo&quot;], [&quot;h...o&quot;]] Expected Output: 1[-1, -1, 1, 0] Justification: “h.llo” and “h…o” both match “hello”. Constraints: 1 &lt;= word.length &lt;= 25 word in addWord consists of lowercase English letters. word in search consist of ‘.’ or lowercase English letters. There will be at most 2 dots in word for search queries. At most 104 calls will be made to addWord and search. SolutionThe crux of the problem lies in efficiently inserting words and then searching for them, even if the query includes wildcards. To solve this, we utilize the trie (prefix tree) data structure. A trie is a tree-like structure that’s useful for storing a dynamic set of strings, especially when the dataset involves large numbers of queries on prefixes of strings. Each node of the trie can represent a character of a word, and the path from the root node to any node represents the word stored up to that point. The key operation for the wildcard is a recursive search, which allows us to explore multiple paths in the trie when we encounter the wildcard character. 1. Trie Data Structure: Every node of the trie contains multiple child nodes (one for each character of the alphabet). We start with a root node that represents an empty string. Each level of the trie represents the next character of a word. 2. Adding a Word: To insert a word into our trie, we begin at the root and traverse down the trie based on the characters in the word. If a particular character doesn’t have a corresponding child node in the current node, we create a new child node for that character. Once we’ve processed every character of the word, we mark the final node as the end of a valid word. 3. Searching: Searching for a word is similar to inserting, but with an additional consideration for the wildcard character (‘.’). If we encounter a ‘.’, we must consider all child nodes of the current node and recursively continue our search from each of them. If any of the paths result in a match, we return true. If we reach the end of a word without encountering any mismatches or premature ends, we’ve found a valid word in our trie. This trie-based approach ensures efficient operations for both inserting and searching for words. In cases without wildcards, the search operation can be performed in linear time relative to the word’s length. However, with wildcards, the time complexity might increase, but the trie structure still ensures that we do this efficiently. Algorithm WalkthroughGiven the word “apple” to insert and then search for “…..”: Start at the root node. For inserting “apple”: At ‘a’, move down or create a node if it doesn’t exist. At ‘p’, move down or create. Do the same for the next ‘p’, ‘l’, and ‘e’. Mark the last node (for ‘e’) as the end of a word. For searching “…..”: At the first ‘.’, check all child nodes and continue. Repeat for each ‘.’. If any path leads to a node that represents the end of a word, return true. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# class TrieNode:# def __init__(self):# # Initialize children as a dictionary to represent all possible next characters.# self.children = &#123;&#125; # # Flag to check if the current node marks the end of any word.# self.isEnd = False class Solution: def __init__(self): # Initialize the root node. self.root = TrieNode() def addWord(self, word: str): node = self.root for ch in word: # If current character isn&#x27;t already a child of the node, add it. if ch not in node.children: node.children[ch] = TrieNode() # Move on to the next character/node. node = node.children[ch] # After processing all characters of the word, mark the current node as end of a word. node.isEnd = True def search(self, word: str) -&gt; bool: return self.searchInNode(word, self.root) def searchInNode(self, word: str, node: TrieNode) -&gt; bool: for i, ch in enumerate(word): # Check for wildcard character. if ch == &#x27;.&#x27;: # Recursively search for all possible characters in place of the wildcard. return any(self.searchInNode(word[i+1:], node.children[child]) for child in node.children if child) # If character doesn&#x27;t exist in children, word can&#x27;t exist in the trie. if ch not in node.children: return False # Move to the next character/node. node = node.children[ch] # After processing all characters of the word, return if it&#x27;s a valid word. return node.isEnd# Test the algorithmobj = Solution()obj.addWord(&quot;apple&quot;)obj.addWord(&quot;banana&quot;)print(obj.search(&quot;apple&quot;)) # Trueprint(obj.search(&quot;.....&quot;)) # True Complexity Analysis Time Complexity: Insertion (addWord): O(n), where n is the length of the word. This is because each insertion operation runs in linear time with respect to the length of the word. Search: O(n * m) in the worst case, where n is the length of the word and m is the total number of nodes in the Trie. This happens when the search word contains dots (‘.’). However, for words without dots, the search is O(n). Space Complexity: O(m n), where m is the total number of Trie nodes and n is the average number of characters in the words. Each Trie node has up to 26 children (for each letter of the alphabet). In the worst case, when no nodes are shared, the space complexity is O(m n).","categories":[{"name":"Grokking Interview Pattern","slug":"Grokking-Interview-Pattern","permalink":"https://hasuer.github.io/categories/Grokking-Interview-Pattern/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hasuer.github.io/tags/Interview/"}]},{"title":"30. Revision","slug":"30. Revision","date":"2024-05-30T13:53:23.000Z","updated":"2024-05-28T03:31:55.568Z","comments":true,"path":"30-revision/index.html","link":"","permalink":"https://hasuer.github.io/30-revision/index.html","excerpt":"","text":"A Cheat SheetHere is a brief description of all the coding patterns discussed in this course: 1. Pattern: Two PointersDescription: This method uses two pointers to traverse an array or a list from different ends or directions. Usage: It’s particularly useful for ordered data structures, where we can make intelligent decisions based on the position of the pointers. Problems: ‘Pair with Target Sum’, ‘Remove Duplicates’, ‘Squaring a Sorted Array’. 2. Pattern: Island (Matrix Traversal)Description: It involves traversing a matrix to find ‘islands’ or contiguous groups of elements. Usage: It’s generally used in grid-based problems, especially when we need to group connected elements together. Problems: ‘Number of Islands’, ‘Max Area of Island’, ‘Flood Fill’. 3. Pattern: Fast &amp; Slow PointersDescription: In this method, two pointers move at different speeds in a data structure. Usage: It is commonly used to detect cycles in a structure, find middle elements, or to solve other specific problems related to linked lists. Problems: ‘LinkedList Cycle’, ‘Middle of the LinkedList’, ‘Palindrome LinkedList’. 4. Pattern: Sliding WindowDescription: This pattern involves creating a ‘window’ into the data structure and then moving that window around to gather specific information. Usage: Mostly used in array or list-based problems where you need to find a contiguous subset that fulfills certain conditions. Problems: ‘Maximum Sum Subarray of Size K’, ‘Smallest Subarray with a given sum’, ‘Longest Substring with K Distinct Characters’. 5. Pattern: Merge IntervalsDescription: This pattern involves merging overlapping intervals. Usage: Often used in problems involving time intervals, ranges, or sequences. Problems: ‘Merge Intervals’, ‘Insert Interval’, ‘Intervals Intersection’. 6. Pattern: Cyclic SortDescription: This pattern involves sorting an array containing numbers in a given range. Usage: It’s useful in situations where the data involves a finite range of natural numbers. Problems: ‘Cyclic Sort’, ‘Find the Missing Number’, ‘Find all Duplicates’. 7. Pattern: In-place Reversal of a Linked ListDescription: This pattern involves reversing elements of a linked list in-place. Usage: It’s generally used when reversing a sequence without using extra space. Problems: ‘Reverse a LinkedList’, ‘Reverse a Sub-list’, ‘Reverse Every K-element Sub-list’. 8. Pattern: Tree Breadth First SearchDescription: This pattern involves level-by-level traversal of a tree. Usage: It’s used when we need to traverse a tree or graph in a level-by-level (breadth-first) manner. Problems: ‘Level Order Traversal’, ‘Reverse Level Order Traversal’, ‘Zigzag Traversal’. 9. Pattern: Tree Depth First SearchDescription: This pattern involves traversing a tree or graph depth-wise before visiting siblings or neighbors. Usage: It’s used when you need to search deeper into a tree/graph first before going across. Problems: ‘Binary Tree Path Sum’, ‘All Paths for a Sum’, ‘Count Paths for a Sum’. 10. Pattern: Two HeapsDescription: This pattern involves using two heaps to divide a set of numbers into two parts. Usage: It’s useful when you need to find median numbers in a sequence, or other similar problems. Problems: ‘Find the Median of a Number Stream’, ‘Sliding Window Median’, ‘Maximize Capital’. 11. Pattern: SubsetsDescription: This pattern involves generating all subsets of a set. Usage: It’s helpful for solving problems that require exploring all subsets of a given set. Problems: ‘Subsets’, ‘Subsets With Duplicates’, ‘Permutations’. 12. Pattern: Modified Binary SearchDescription: This is a tweaked version of the binary search algorithm. Usage: It’s used when a simple binary search isn’t sufficient, like finding a number in a bitonic array. Problems: ‘Order-agnostic Binary Search’, ‘Ceiling of a Number’, ‘Next Letter’. 13. Pattern: Top ‘K’ ElementsDescription: This pattern is used to find the top ‘k’ elements among a certain category. Usage: It’s commonly used in problems involving sorting, searching, and in heap data structures. Problems: ‘Top K Frequent Numbers’, ‘Kth Largest Number in a Stream’, ‘Top K Frequent Elements’. 14. Pattern: Bitwise XORDescription: This pattern involves the use of Bitwise XOR to solve various array-based problems. Usage: It’s used when we need to manipulate and compare bits directly. Problems: ‘Single Number’, ‘Two Single Numbers’, ‘Complement of Base 10 Number’. 15. Pattern: BacktrackingDescription: This pattern involves exploring all possible solutions and then backtracking to correct the course whenever you’re on the wrong path. Usage: It’s typically used for solving complex combinatorial problems, puzzles, and games. Problems: ‘Sudoku Solver’, ‘N-Queens’, ‘Generate Parentheses’. 16. Pattern: 0/1 Knapsack (Dynamic Programming)Description: This pattern deals with problems where items have different values and weights, and we need to determine the maximum value we can carry. Usage: It’s typically used in optimization problems, especially those involving physical constraints. Problems: ‘0/1 Knapsack’, ‘Equal Subset Sum Partition’, ‘Subset Sum’. 17. Pattern: Topological Sort (Graph)Description: This pattern involves sorting nodes in a directed graph in a specific order where the preceding node comes before the following node. Usage: It’s used for scheduling problems and in scenarios where order needs to be imposed on how you process nodes. Problems: ‘Task Scheduling Order’, ‘All Tasks Scheduling Orders’, ‘Alien Dictionary’. 18. Pattern: K-way MergeDescription: This pattern involves merging ‘k’ sorted lists. Usage: It’s typically used in problems involving lists, where merging is required. Problems: ‘Merge K Sorted Lists’, ‘Kth Smallest Number in M Sorted Lists’, ‘Smallest Number Range’. 19. Pattern: Monotonic StackDescription: This pattern involves using a stack to maintain a monotonic (either entirely non-increasing or non-decreasing) order of elements. Usage: It’s often used for solving problems where you need to find the next greater or smaller elements. Problems: ‘Next Greater Element’, ‘Next Smaller Element’, ‘Largest Rectangle in Histogram’. 20. Pattern: Multi-threadedDescription: This pattern involves designing algorithms that can execute multiple threads in parallel. Usage: It’s used in situations where a task can be divided into independent sub-tasks that can execute concurrently. Problems: ‘Invert Binary Tree’, ‘Binary Search Tree Iterator’, ‘Same Tree’. 21. Pattern: Union FindDescription: Union Find, also known as Disjoint Set Union (DSU), is a data structure that keeps track of a partition of a set into disjoint subsets. Usage: This pattern is particularly useful for problems where we need to find whether 2 elements belong to the same group or need to solve connectivity-related problems in a graph or tree. Problems: ‘Graph Redundant Connection’, ‘Number of Provinces’, ‘Is Graph Bipartite’.","categories":[{"name":"Grokking Interview Pattern","slug":"Grokking-Interview-Pattern","permalink":"https://hasuer.github.io/categories/Grokking-Interview-Pattern/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hasuer.github.io/tags/Interview/"}]},{"title":"29. Miscellaneous","slug":"29. Miscellaneous","date":"2024-05-29T06:36:16.000Z","updated":"2024-05-28T03:31:43.553Z","comments":true,"path":"29-miscellaneous/index.html","link":"","permalink":"https://hasuer.github.io/29-miscellaneous/index.html","excerpt":"","text":"Design Gurus Educative.io Kth Smallest NumberProblem StatementGiven an unsorted array of numbers, find Kth smallest number in it. Please note that it is the Kth smallest number in the sorted order, not the Kth distinct element. Example 1: 123Input: [1, 5, 12, 2, 11, 5], K = 3Output: 5Explanation: The 3rd smallest number is &#x27;5&#x27;, as the first two smaller numbers are [1, 2]. Example 2: 1234Input: [1, 5, 12, 2, 11, 5], K = 4Output: 5Explanation: The 4th smallest number is &#x27;5&#x27;, as the first three smaller numbers are[1, 2, 5]. Example 3: 123Input: [5, 12, 11, -1, 12], K = 3Output: 11Explanation: The 3rd smallest number is &#x27;11&#x27;, as the first two small numbers are [5, -1]. SolutionThis is a well-known problem and there are multiple solutions available to solve this. A few other similar problems are: Find the Kth largest number in an unsorted array. Find the median of an unsorted array. Find the ‘K’ smallest or largest numbers in an unsorted array. Let’s discuss different algorithms to solve this problem and understand their time and space complexity. Similar solutions can be devised for the above-mentioned three problems. Brute-forceThe simplest brute-force algorithm will be to find the Kth smallest number in a step by step fashion. This means that, first, we will find the smallest element, then 2nd smallest, then 3rd smallest and so on, until we have found the Kth smallest element. Here is what the algorithm will look like: 1234567891011121314151617181920212223242526272829303132333435363738394041424344import mathclass Solution: def findKthSmallestNumber(self, nums, k): # to handle duplicates, we will keep track of previous smallest number and its index previousSmallestNum, previousSmallestIndex = -math.inf, -1 currentSmallestNum, currentSmallestIndex = math.inf, -1 for i in range(k): for j in range(len(nums)): if nums[j] &gt; previousSmallestNum and nums[j] &lt; currentSmallestNum: # found the next smallest number currentSmallestNum = nums[j] currentSmallestIndex = j elif nums[j] == previousSmallestNum and j &gt; previousSmallestIndex: # found a number which is equal to the previous smallest number; since numbers # can repeat, we will consider &#x27;nums[j]&#x27; only if it has a different index than # previous smallest currentSmallestNum = nums[j] currentSmallestIndex = j break # break here as we have found our definitive next smallest number # current smallest number becomes previous smallest number for the next iteration previousSmallestNum = currentSmallestNum previousSmallestIndex = currentSmallestIndex currentSmallestNum = math.inf return previousSmallestNumdef main(): sol = Solution() print(&quot;Kth smallest number is: &quot; + str(sol.findKthSmallestNumber([1, 5, 12, 2, 11, 5], 3))) # as there&#x27;re two 5s in input array, our 3rd and 4th smallest numbers should be a &#x27;5&#x27; print(&quot;Kth smallest number is: &quot; + str(sol.findKthSmallestNumber([1, 5, 12, 2, 11, 5], 4))) print(&quot;Kth smallest number is: &quot; + str(sol.findKthSmallestNumber([5, 12, 11, -1, 12], 3)))main() Time &amp; Space ComplexityThe time complexity of the above algorithm will be O(N\\K)*. The algorithm runs in constant space O(1). Brute-force using SortingWe can use an in-place sort like a HeapSort to sort the input array to get the Kth smallest number. Following is the code for this solution: 1234567891011121314151617181920class Solution: def findKthSmallestNumber(self, nums, k): return sorted(nums)[k-1]def main(): sol = Solution() print(&quot;Kth smallest number is: &quot; + str(sol.findKthSmallestNumber([1, 5, 12, 2, 11, 5], 3))) # as there&#x27;re two 5s in input array, our 3rd and 4th smallest numbers should be a &#x27;5&#x27; print(&quot;Kth smallest number is: &quot; + str(sol.findKthSmallestNumber([1, 5, 12, 2, 11, 5], 4))) print(&quot;Kth smallest number is: &quot; + str(sol.findKthSmallestNumber([5, 12, 11, -1, 12], 3)))main() Time &amp; Space ComplexitySorting will take O(NlogN) and if we are not using an in-place sorting algorithm, we will need O(N) space. Using Max-HeapAs discussed in Kth Smallest Number, we can iterate the array and use a Max Heap to keep track of ‘K’ smallest number. In the end, the root of the heap will have the Kth smallest number. Here is what this algorithm will look like: 123456789101112131415161718192021222324252627282930313233343536from heapq import *class Solution: def findKthSmallestNumber(self, nums, k): maxHeap = [] # put first k numbers in the max heap for i in range(k): heappush(maxHeap, -nums[i]) # go through the remaining numbers of the array, if the number from the array is # smaller than the top(biggest) number of the heap, remove the top number from heap # and add the number from array for i in range(k, len(nums)): if -nums[i] &gt; maxHeap[0]: heappop(maxHeap) heappush(maxHeap, -nums[i]) # the root of the heap has the Kth smallest number return -maxHeap[0]def main(): sol = Solution() print(&quot;Kth smallest number is: &quot; + str(sol.findKthSmallestNumber([1, 5, 12, 2, 11, 5], 3))) # as there&#x27;re two 5s in input array, our 3rd and 4th smallest numbers should be a &#x27;5&#x27; print(&quot;Kth smallest number is: &quot; + str(sol.findKthSmallestNumber([1, 5, 12, 2, 11, 5], 4))) print(&quot;Kth smallest number is: &quot; + str(sol.findKthSmallestNumber([5, 12, 11, -1, 12], 3)))main() Time &amp; Space ComplexityThe time complexity of the above algorithm is O(KlogK + (N-K)logK) which is asymptotically equal to O(N\\logK)*. The space complexity will be O(K) because we need to store ‘K’ smallest numbers in the heap. Using Min-HeapAlso discussed in Kth Smallest Number, we can use a Min Heap to find the Kth smallest number. We can insert all the numbers in the min-heap and then extract the top ‘K’ numbers from the heap to find the Kth smallest number. Time &amp; Space ComplexityInserting all numbers in the heap will take O(N\\logN)* and extracting ‘K’ numbers will take O(K\\logN)*. Overall, the time complexity of this algorithm will be O(NlogN+KlogN) and the space complexity will be O(N). Using Partition Scheme of QuicksortQuicksort picks a number called pivot and partition the input array around it. After partitioning, all numbers smaller than the pivot are to the left of the pivot, and all numbers greater than or equal to the pivot are to the right of the pivot. This ensures that the pivot has reached its correct sorted position. We can use this partitioning scheme to find the Kth smallest number. We will recursively partition the input array and if, after partitioning, our pivot is at the K-1 index we have found our required number; if not, we will choose one the following option: If pivot’s position is larger than K-1, we will recursively partition the array on numbers lower than the pivot. If pivot’s position is smaller than K-1, we will recursively partition the array on numbers greater than the pivot. Here is what our algorithm will look like: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution: def findKthSmallestNumber(self, nums, k): return self.find_Kth_smallest_number_rec(nums, k, 0, len(nums) - 1) def find_Kth_smallest_number_rec(self, nums, k, start, end): p = self.partition(nums, start, end) if p == k - 1: return nums[p] if p &gt; k - 1: # search lower part return self.find_Kth_smallest_number_rec(nums, k, start, p - 1) # search higher part return self.find_Kth_smallest_number_rec(nums, k, p + 1, end) def partition(self, nums, low, high): if low == high: return low pivot = nums[high] for i in range(low, high): # all elements less than &#x27;pivot&#x27; will be before the index &#x27;low&#x27; if nums[i] &lt; pivot: nums[low], nums[i] = nums[i], nums[low] low += 1 # put the pivot in its correct place nums[low], nums[high] = nums[high], nums[low] return lowdef main(): sol = Solution() print(&quot;Kth smallest number is: &quot; + str(sol.findKthSmallestNumber([1, 5, 12, 2, 11, 5], 3))) # as there&#x27;re two 5s in input array, our 3rd and 4th smallest numbers should be a &#x27;5&#x27; print(&quot;Kth smallest number is: &quot; + str(sol.findKthSmallestNumber([1, 5, 12, 2, 11, 5], 4))) print(&quot;Kth smallest number is: &quot; + str(sol.findKthSmallestNumber([5, 12, 11, -1, 12], 3)))main() Time &amp; Space ComplexityThe above algorithm is known as QuickSelect and has a Worst case time complexity of O(N^2). The best and average case is O(N), which is better than the best and average case of QuickSort. Overall, QuickSelect uses the same approach as QuickSort i.e., partitioning the data into two parts based on a pivot. However, contrary to QuickSort, instead of recursing into both sides QuickSelect only recurses into one side – the side with the element it is searching for. This reduces the average and best case time complexity from O(N\\logN)* to O(N). The worst-case occurs when, at every step, the partition procedure splits the N-length array into arrays of size ‘11’ and ‘N−1’. This can only happen when the input array is sorted or if all of its elements are the same. This “unlucky” selection of pivot elements requires O(N) recursive calls, leading to an O(N^2) worst-case. Worst-case space complexity will be O(N) used for the recursion stack. See details under Quicksort. Using Randomized Partitioning Scheme of QuicksortAs mentioned above, the worst case for Quicksort occurs when the partition procedure splits the N-length array into arrays of size ‘11’ and ‘N−1’. To mitigate this, instead of always picking a fixed index for pivot (e.g., in the above algorithm we always pick nums[high] as the pivot), we can randomly select an element as pivot. After randomly choosing the pivot element, we expect the split of the input array to be reasonably well balanced on average. Here is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import randomclass Solution: def findKthSmallestNumber(self, nums, k): return self.find_Kth_smallest_number_rec(nums, k, 0, len(nums) - 1) def find_Kth_smallest_number_rec(self, nums, k, start, end): p = self.partition(nums, start, end) if p == k - 1: return nums[p] if p &gt; k - 1: # search lower part return self.find_Kth_smallest_number_rec(nums, k, start, p - 1) # search higher part return self.find_Kth_smallest_number_rec(nums, k, p + 1, end) def partition(self, nums, low, high): if low == high: return low pivotIndex = random.randint(low, high) nums[pivotIndex], nums[high] = nums[high], nums[pivotIndex] pivot = nums[high] for i in range(low, high): # all elements less than &#x27;pivot&#x27; will be before the index &#x27;low&#x27; if nums[i] &lt; pivot: nums[low], nums[i] = nums[i], nums[low] low += 1 # put the pivot in its correct place nums[low], nums[high] = nums[high], nums[low] return lowdef main(): sol = Solution() print(&quot;Kth smallest number is: &quot; + str(sol.findKthSmallestNumber([1, 5, 12, 2, 11, 5], 3))) # as there are two 5s in input array, our 3rd and 4th smallest numbers should be a &#x27;5&#x27; print(&quot;Kth smallest number is: &quot; + str(sol.findKthSmallestNumber([1, 5, 12, 2, 11, 5], 4))) print(&quot;Kth smallest number is: &quot; + str(sol.findKthSmallestNumber([5, 12, 11, -1, 12], 3)))main() Time &amp; Space ComplexityThe above algorithm has the same worst and average case time complexities as mentioned for the previous algorithm. But choosing the pivot randomly has the effect of rendering the worst-case very unlikely, particularly for large arrays. Therefore, the expected time complexity of the above algorithm will be O(N), but the absolute worst case is still O(N^2). Practically, this algorithm is a lot faster than the non-randomized version. Using the Median of MediansWe can use the Median of Medians algorithm to choose a good pivot for the partitioning algorithm of the Quicksort. This algorithm finds an approximate median of an array in linear time O(N). When this approximate median is used as the pivot, the worst-case complexity of the partitioning procedure reduces to linear O(N), which is also the asymptotically optimal worst-case complexity of any sorting/selection algorithm. This algorithm was originally developed by Blum, Floyd, Pratt, Rivest, and Tarjan and was describe in their 1973 paper. This is how the partitioning algorithm works: If we have 5 or less than 5 elements in the input array, we simply take its first element as the pivot. If not then we divide the input array into subarrays of five elements (for simplicity we can ignore any subarray having less than five elements). Sort each subarray to determine its median. Sorting a small and fixed numbered array takes constant time. At the end of this step, we have an array containing medians of all the subarray. Recursively call the partitioning algorithm on the array containing medians until we get our pivot. Every time the partition procedure needs to find a pivot, it will follow the above three steps. Here is what this algorithm will look like: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class Solution: def findKthSmallestNumber(self, nums, k): return self.find_Kth_smallest_number_rec(nums, k, 0, len(nums) - 1) def find_Kth_smallest_number_rec(self, nums, k, start, end): p = self.partition(nums, start, end) if p == k - 1: return nums[p] if p &gt; k - 1: # search lower part return self.find_Kth_smallest_number_rec(nums, k, start, p - 1) # search higher part return self.find_Kth_smallest_number_rec(nums, k, p + 1, end) def partition(self, nums, low, high): if low == high: return low median = self.median_of_medians(nums, low, high) # find median in the array and swap it with &#x27;nums[high]&#x27; which will become our pivot for i in range(low, high): if nums[i] == median: nums[i], nums[high] = nums[high], nums[i] break pivot = nums[high] for i in range(low, high): # all elements less than &#x27;pivot&#x27; will be before the index &#x27;low&#x27; if nums[i] &lt; pivot: nums[low], nums[i] = nums[i], nums[low] low += 1 # put the pivot in its correct place nums[low], nums[high] = nums[high], nums[low] return low def median_of_medians(self, nums, low, high): n = high - low + 1 # if we have less than 5 elements, ignore the partitioning algorithm if n &lt; 5: return nums[low] # partition the given array into chunks of 5 elements partitions = [nums[j:j+5] for j in range(low, high+1, 5)] # for simplicity, lets ignore any partition with less than 5 elements fullPartitions = [ partition for partition in partitions if len(partition) == 5] # sort all partitions sortedPartitions = [sorted(partition) for partition in fullPartitions] # find median of all partations; the median of each partition is at index &#x27;2&#x27; medians = [partition[2] for partition in sortedPartitions] return self.partition(medians, 0, len(medians)-1)def main(): sol = Solution() print(&quot;Kth smallest number is: &quot; + str(sol.findKthSmallestNumber([1, 5, 12, 2, 11, 5], 3))) # as there are two 5s in input array, our 3rd and 4th smallest numbers should be a &#x27;5&#x27; print(&quot;Kth smallest number is: &quot; + str(sol.findKthSmallestNumber([1, 5, 12, 2, 11, 5], 4))) print(&quot;Kth smallest number is: &quot; + str(sol.findKthSmallestNumber([5, 12, 11, -1, 12], 3)))main() Time &amp; Space ComplexityThe above algorithm has a guaranteed O(N) worst-case time. Please see the proof of its running time here and under “Selection-based pivoting”. The worst-case space complexity is O(N). ConclusionTheoretically, the Median of Medians algorithm gives the best time complexity of O(N) but practically both the Median of Medians and the Randomized Partitioning algorithms nearly perform equally. In the context of Quicksort, given an O(N) selection algorithm using the Median of Medians, one can use it to find the ideal pivot (the median) at every step of quicksort and thus produce a sorting algorithm with O(NlogN) running time in the worst-case. Though practical implementations of this variant are considerably slower on average, they are of theoretical interest because they show that an optimal selection algorithm can yield an optimal sorting algorithm.","categories":[{"name":"Grokking Interview Pattern","slug":"Grokking-Interview-Pattern","permalink":"https://hasuer.github.io/categories/Grokking-Interview-Pattern/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hasuer.github.io/tags/Interview/"}]},{"title":"28. Pattern Multi-thread","slug":"28. Pattern Multi-thread","date":"2024-05-28T06:34:14.000Z","updated":"2024-05-28T03:31:31.404Z","comments":true,"path":"28-pattern-multi-thread/index.html","link":"","permalink":"https://hasuer.github.io/28-pattern-multi-thread/index.html","excerpt":"","text":"416. Partition Equal Subset Sum Design Gurus Educative.io ATTENTION: 这些题目还没有看 Introduction to Multi-threaded PatternIn many algorithms, concurrency and thread safety are very important. With technical interviews in mind, we can easily apply these concepts to most coding problems and stand out from the crowd. Thread safety can be easily added to any algorithm that uses multiple threads. Algorithms can be made multi-threaded to perform multiple concurrent tasks or to perform pre-fetching or post-processing functions to speed things up. Let’s see this pattern in action. Same TreeProblem StatementGiven the roots of two binary trees ‘p’ and ‘q’, write a function to check if they are the same or not. Two binary trees are considered the same if they met following two conditions: Both tree are structurally identical. Each corresponding node on both the trees have the same value. Example 1: Given the following two binary trees: Output: true Explanation: Both trees are structurally identical and have same values. Example 2: Given the following two binary trees: Output: false Explanation: Trees are structurally different. Example 3: Given the following two binary trees: Output: false Explanation: Corresponding nodes have different value ( 4 &amp; 9 ). Constraints: The number of nodes in both trees is in the range [0, 100]. -10^4 &lt;= Node.val &lt;= 10^4 SolutionA simple solution would be to recursively check each corresponding node of the two trees. If one of the trees do not have a corresponding node or their values differ, we can conclude that the trees are not the same. CodeHere is what our algorithm will look like: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# class TreeNode:# def __init__(self, val):# self.val = val# self.left = None# self.right = Noneclass Solution: def isSameTree(self, p, q): # p and q are both None if not p and not q: return True # one of p and q is None if not p or not q: return False # one of p and q has a different value if p.val != q.val: return False # check left and right subtree recursively return self.isSameTree(p.right, q.right) and self.isSameTree(p.left, q.left)if __name__ == &quot;__main__&quot;: p = TreeNode(10) p.left = TreeNode(4) p.left.left = TreeNode(1) p.right = TreeNode(15) p.right.left = TreeNode(14) q = TreeNode(10) q.left = TreeNode(4) q.left.left = TreeNode(1) q.right = TreeNode(15) q.right.left = TreeNode(14) sol = Solution() print(sol.isSameTree(p, q)) q.right.right = TreeNode(20) print(sol.isSameTree(p, q)) p.right.right = TreeNode(20) print(sol.isSameTree(p, q)) p.left.val = 9 print(sol.isSameTree(p, q)) Time Complexity The solution will take O(min(M, N)) time, where ‘M’ and ‘N’ are the number of nodes in the given trees respectively. We are taking minimum of ‘M’ and ‘N’, since as soon as we see a difference in value or structure, we do not check the remaining trees. Space Complexity We will need O(N) space for the recursion stack in the worst case (when the binary tree is a list). Overall, we will need to store nodes equal to the height of the tree, hence, O(H) space complexity, where H is the height of the given tree. Making the Algorithm Multi-threadedTo further improve the algorithm, we can make isSameTree() multi-threaded to check the left and right subtrees in separate threads. We can find how many processors the machine has on which our algorithm is running. We will, then, start multiple threads so that each core can run one thread. We will use a Volatile Boolean variable isSame so that multiple threads can update its value concurrently. Here is the code that takes care of this scenario: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import osimport threading# class TreeNode:# def __init__(self, val):# self.val = val# self.left = None# self.right = Noneclass Solution: def __init__(self): self.isSame = True def isSameTree(self, p, q): self.isSame = True num_threads = os.cpu_count() return self.isSameTree_multi_threaded(p, q, num_threads) def isSameTree_multi_threaded(self, p, q, num_threads): # p and q are both None if not p and not q: return True # one of p and q is None if not p or not q: return False # one of p and q has a different value if p.val != q.val: return False # if we can start more threads, we will spawn a new thread to check the # right subtree, otherwise we will do everything in the current thread if num_threads &gt; 0: # spawn a separate thread for checking the right sub-tree def check_right_subtree(): nonlocal p, q, num_threads self.isSame &amp;= self.isSameTree_multi_threaded(p.right, q.right, num_threads // 2) t1 = threading.Thread(target=check_right_subtree) t1.start() # check the left sub-tree in the current thread self.isSame &amp;= self.isSameTree_multi_threaded(p.left, q.left, num_threads // 2) t1.join() # wait for the thread checking the right sub-tree else: # do everything in the current thread self.isSame &amp;= self.isSameTree_multi_threaded(p.right, q.right, 0) and self.isSameTree_multi_threaded(p.left, q.left, 0) return self.isSameif __name__ == &quot;__main__&quot;: p = TreeNode(10) p.left = TreeNode(4) p.left.left = TreeNode(1) p.right = TreeNode(15) p.right.left = TreeNode(14) q = TreeNode(10) q.left = TreeNode(4) q.left.left = TreeNode(1) q.right = TreeNode(15) q.right.left = TreeNode(14) sol = Solution() print(sol.isSameTree(p, q)) q.right.right = TreeNode(20) print(sol.isSameTree(p, q)) p.right.right = TreeNode(20) print(sol.isSameTree(p, q)) p.left.val = 9 print(sol.isSameTree(p, q)) Time and Space ComplexitiesEverything has the same complexity as the previous solution. Invert Binary TreeProblem StatementGiven the root of a binary tree, invert it. Example: Given the following two binary trees: Constraints: The number of nodes in both trees is in the range [0, 100]. -100 &lt;= Node.val &lt;= 100 SolutionThis problem is quite similar to Same Tree. We can follow the same approach. After swapping left and right child of a node, we will recursively invert its left and right subtrees. CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233343536373839404142# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def invertTree(self, root): # Base case: if the root is None, just return None if root is None: return None # Swap the left and right children of the current node root.left, root.right = root.right, root.left # Recursively invert the left and right subtrees self.invertTree(root.left) self.invertTree(root.right) return rootif __name__ == &quot;__main__&quot;: # Construct the binary search tree root = TreeNode(10) root.left = TreeNode(4) root.left.left = TreeNode(1) root.right = TreeNode(15) root.right.left = TreeNode(14) root.right.right = TreeNode(19) root.right.right.right = TreeNode(20) # Invert the binary search tree sol = Solution() sol.invertTree(root) # Print out the results to check if the tree was inverted correctly print(root.right.val == 4) # Expect: True print(root.left.val == 15) # Expect: True print(root.left.right.val == 14) # Expect: True print(root.left.left.val == 19) # Expect: True print(root.left.left.left.val == 20) # Expect: True Time ComplexitySince we traverse each node once, the solution will take O(N) time where ‘N’ is the total number of nodes in the tree. Space ComplexityWe will need O(N) space for the recursion stack in the worst case (when the binary tree is a list). Overall, we will need to store nodes equal to the height of the tree, hence, O(H) space complexity, where H is the height of the given tree. Making the Algorithm Multi-threadedTo further improve the algorithm, we can make invertTree() multi-threaded to invert left and right subtrees in separate threads. We can find how many cores the machine has on which our algorithm is running. We will, then, start multiple threads so that each core can run one thread. Here is the code that takes care of this scenario: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import threadingimport multiprocessing# Definition for a binary search tree node# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def invertTree(self, root): num_threads = multiprocessing.cpu_count() # Number of available processors return self.invert_tree_multithreaded(root, num_threads) def invert_tree_multithreaded(self, root, num_threads): if root is None: return None # Invert the current node root.left, root.right = root.right, root.left if num_threads &gt; 0: # Spawn a separate thread to invert the left subtree t1 = threading.Thread(target=self.invert_tree_multithreaded, args=(root.left, num_threads // 2)) t1.start() # Invert the right subtree in the same thread self.invert_tree_multithreaded(root.right, num_threads // 2) t1.join() # Wait for the thread inverting the left subtree else: self.invert_tree_multithreaded(root.left, 0) self.invert_tree_multithreaded(root.right, 0) return rootif __name__ == &#x27;__main__&#x27;: root = TreeNode(10) root.left = TreeNode(4) root.left.left = TreeNode(1) root.right = TreeNode(15) root.right.left = TreeNode(14) root.right.right = TreeNode(19) root.right.right.right = TreeNode(20) sol = Solution() sol.invertTree(root) print(root.right.val == 4) # Expected: True print(root.left.val == 15) # Expected: True print(root.left.right.val == 14) # Expected: True print(root.left.left.val == 19) # Expected: True print(root.left.left.left.val == 20) # Expected: True Time and Space ComplexitiesEverything has the same complexity as the previous solution. Binary Search Tree IteratorProblem StatementImplement an iterator for the in-order traversal of a binary search tree (BST). That is, given a BST, we need to implement two functions: bool hasNext(): Returns true if at least one element is left in the in-order traversal of the BST. int next(): Return the next element in the in-order traversal of the BST. Example: Given the following BST: Here is the in-order traversal of this tree: [1, 4, 10, 14, 15, 19, 20] Here is the expected output from the algorithm based on different calls: hasNext() -&gt; true next() -&gt; 1 next() -&gt; 4 hasNext() -&gt; true next() -&gt; 10 next() -&gt; 14 next() -&gt; 15 next() -&gt; 19 next() -&gt; 20 hasNext() -&gt; false Constraints: The number of nodes in the tree is in the range [1, 10^5]. 0 &lt;= Node.val &lt;= 106 At most 105 calls will be made to hasNext, and next. SolutionA brute force solution could be to store the in-order traversal of the BST in an array and used that array to process the two functions next() and hasNext(). We can maintain a pointer in the array, which points to the next element to be returned to the caller. This algorithm will take O(N) space for storing all elements in the array, and O(N) time to traverse the tree. Both the operations will take O(1) time complexity, as we have pre-processed all the data to store the in-order traversal of the BST in the array. Transforming a Recursive Algorithm to an Iterative oneWe know that we can perform the in-order traversal of a BST recursively. But for the iterator, we can’t use recursion as we can’t stop recursion in the middle to return the required element; this way, we will lose the recursive state of the traversal. Also, we didn’t want to perform the in-order traversal every time next() or hasNext() is called; this will make these function O(N) operations. We know that we can transform a recursive solution to make it iterative using a stack. This was exactly what we need! This way, we can control the recursion by saving the state of the in-order traversal of the BST in the stack, and later we can resume the tree traversal when next() is called again. CodeHere is what our algorithm will look like: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# definition for a binary search tree node# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def __init__(self, root: TreeNode): self.stack = list() self.traverse_left(root) # returns whether we have a next smallest number def hasNext(self): return self.stack # returns the next smallest number def next(self): tmpNode = self.stack.pop() self.traverse_left(tmpNode.right) return tmpNode.val # traverse the left sub-tree to push all nodes on the stack def traverse_left(self, node): while node is not None: self.stack.append(node) node = node.leftdef main(): root = TreeNode(10) root.left = TreeNode(4) root.left.left = TreeNode(1) root.right = TreeNode(15) root.right.left = TreeNode(14) root.right.right = TreeNode(19) root.right.right.right = TreeNode(20) sol = Solution(root) print(&quot;hasNext() -&gt; &quot; + str(bool(sol.hasNext()))) print(&quot;next() -&gt; &quot; + str(sol.next())) print(&quot;next() -&gt; &quot; + str(sol.next())) print(&quot;hasNext() -&gt; &quot; + str(bool(sol.hasNext()))) print(&quot;next() -&gt; &quot; + str(sol.next())) print(&quot;next() -&gt; &quot; + str(sol.next())) print(&quot;next() -&gt; &quot; + str(sol.next())) print(&quot;next() -&gt; &quot; + str(sol.next())) print(&quot;next() -&gt; &quot; + str(sol.next())) print(&quot;hasNext() -&gt; &quot; + str(bool(sol.hasNext())))main() Time Complexity The hasNext() will take O(1) time. Since next() calls the traverseLeft() function which traverses the left subtree and in the worst case the left subtree could contain all elements (practically it would be a list), hence, next() can take O(N) time in the worst case. One thing to note there though, traverseLeft() processes each element only once. This means, amortized cost of traverseLeft() will be O(1) for ‘n’ calls of next(), therefore, next() has O(1) amortized cost. Space ComplexityWe will need O(N) space for the stack in the worst case (when the BST is a list). Overall, we will need to store nodes equal to the height of the tree, hence,O(H) space complexity, where H is the height of the given tree. Making the Algorithm Thread SafeOur algorithm does not have thread-safety. The algorithm would fail if multiple threads access the same BSTIterator object. We could get a synchronization issue in the next() function for the following two lines: 12TreeNode tmpNode = stack.pop();traverseLeft(tmpNode.right); If two threads access the function concurrently, the stack could end up in a bad state. Here is what can happen. Suppose one thread executes the first line to pop an element from the stack. Before it executes the next line (to traverse the left subtree), another thread which is also processing these lines, can also pop another element from the stack, thus, making the stack invalid. This means we need to synchronize this function so that only one thread is allowed to process next() at any time. Here is the new synchronized version of the algorithm. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import multiprocessing# definition for a binary search tree node# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def __init__(self, root: TreeNode): self.stack = list() self.lock = multiprocessing.Lock() self.traverse_left(root) # returns whether we have a next smallest number def hasNext(self): return self.stack # returns the next smallest number def next(self): self.lock.acquire() tmpNode = self.stack.pop() self.traverse_left(tmpNode.right) self.lock.release() return tmpNode.val # traverse the left sub-tree to push all nodes on the stack def traverse_left(self, node): while node is not None: self.stack.append(node) node = node.leftif __name__ == &#x27;__main__&#x27;: root = TreeNode(10) root.left = TreeNode(4) root.left.left = TreeNode(1) root.right = TreeNode(15) root.right.left = TreeNode(14) root.right.right = TreeNode(19) root.right.right.right = TreeNode(20) sol = Solution(root) print(&quot;hasNext() -&gt; &quot; + str(bool(sol.hasNext()))) print(&quot;next() -&gt; &quot; + str(sol.next())) print(&quot;next() -&gt; &quot; + str(sol.next())) print(&quot;hasNext() -&gt; &quot; + str(bool(sol.hasNext()))) print(&quot;next() -&gt; &quot; + str(sol.next())) print(&quot;next() -&gt; &quot; + str(sol.next())) print(&quot;next() -&gt; &quot; + str(sol.next())) print(&quot;next() -&gt; &quot; + str(sol.next())) print(&quot;next() -&gt; &quot; + str(sol.next())) print(&quot;hasNext() -&gt; &quot; + str(bool(sol.hasNext()))) Making the Algorithm Multi-threadedTo further improve the algorithm, we can make next() multi-threaded so that can return the element to the caller immediately and spawn a separate thread to perform the post-processing required to traverse the left subtree. In the next() function, we do have the required node available right away, but we could not return to the caller before we traverse the left subtree of the right child of the current node: 1traverseLeft(tmpNode.right); we can spawn a new thread to process this traversal and return the element to the caller. This way, the caller is unblocked as it has the data quickly, and all the post-processing is done in a separate thread. This made the algorithm a bit complex though. Now, whenever we are starting a new execution of next() or hasNext(), we need to ensure any previous thread doing the post-processing has finished. This means that we have to add a check before processing next() or hasNext() to wait and call join() on the previous thread if it has not already finished. Here is the code that takes care of this scenario: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import multiprocessing# definition for a binary search tree node# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def __init__(self, root: TreeNode): self.stack = multiprocessing.Manager().list() self.lock = multiprocessing.Lock() self.t1 = None self.traverse_left(self.stack, root) # returns whether we have a next smallest number def hasNext(self): self.check_thread() return self.stack # returns the next smallest number def next(self): self.lock.acquire() self.check_thread() tmpNode = self.stack.pop() self.t1 = multiprocessing.Process(target=self.traverse_left, args=(self.stack, tmpNode.right)) self.t1.start() self.lock.release() return tmpNode.val # traverse the left sub-tree to push all nodes on the stack def traverse_left(self, stack, node): while node is not None: stack.append(node) node = node.left # if the previous thread is active, wait before it finishes def check_thread(self): if self.t1 is not None and self.t1.is_alive(): self.t1.join() # wait for the thread traversing the left subtree if __name__ == &#x27;__main__&#x27;: root = TreeNode(10) root.left = TreeNode(4) root.left.left = TreeNode(1) root.right = TreeNode(15) root.right.left = TreeNode(14) root.right.right = TreeNode(19) root.right.right.right = TreeNode(20) sol = Solution(root) print(&quot;hasNext() -&gt; &quot; + str(bool(sol.hasNext()))) print(&quot;next() -&gt; &quot; + str(sol.next())) print(&quot;next() -&gt; &quot; + str(sol.next())) print(&quot;hasNext() -&gt; &quot; + str(bool(sol.hasNext()))) print(&quot;next() -&gt; &quot; + str(sol.next())) print(&quot;next() -&gt; &quot; + str(sol.next())) print(&quot;next() -&gt; &quot; + str(sol.next())) print(&quot;next() -&gt; &quot; + str(sol.next())) print(&quot;next() -&gt; &quot; + str(sol.next())) print(&quot;hasNext() -&gt; &quot; + str(bool(sol.hasNext()))) Time and Space ComplexitiesEverything has the same complexity as the previous solution.","categories":[{"name":"Grokking Interview Pattern","slug":"Grokking-Interview-Pattern","permalink":"https://hasuer.github.io/categories/Grokking-Interview-Pattern/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hasuer.github.io/tags/Interview/"}]},{"title":"27. Pattern Prefix Sum","slug":"27. Pattern Prefix Sum","date":"2024-05-27T06:29:54.000Z","updated":"2024-05-28T03:31:20.750Z","comments":true,"path":"27-pattern-prefix-sum/index.html","link":"","permalink":"https://hasuer.github.io/27-pattern-prefix-sum/index.html","excerpt":"","text":"416. Partition Equal Subset Sum Design Gurus Educative.io ATTENTION: 这些题目还没有看 Introduction Prefix Sum PatternWhat is Prefix Sum?A prefix sum is the cumulative sum of elements in an array up to a certain index. It is a powerful tool for efficiently solving range sum queries and various subarray problems. By precomputing the prefix sums of an array, we can quickly calculate the sum of any subarray in constant time. This technique is widely used in algorithmic problems to improve performance and reduce time complexity, making it essential for handling large datasets and multiple queries efficiently. For example, if we have an array ([1, 2, 3, 4]), the prefix sums would be calculated as follows: Prefix sum at index 0: (1) Prefix sum at index 1: (1 + 2 = 3) Prefix sum at index 2: (1 + 2 + 3 = 6) Prefix sum at index 3: (1 + 2 + 3 + 4 = 10) So, the prefix sum array for ([1, 2, 3, 4]) is ([1, 3, 6, 10]). Algorithm to Calculate Prefix Sum Initialize an array prefix of the same length as the input array. Set prefix[0] to arr[0]. For each subsequent element, set prefix[i] to prefix[i-1] + arr[i]. Return the prefix array. Code 12345678910111213141516171819202122class Solution: def compute_prefix_sum(self, arr): # Initialize the prefix array with zeros prefix = [0] * len(arr) # Set the first element of the prefix array to the first element of the input array prefix[0] = arr[0] # Compute the prefix sum for each subsequent element for i in range(1, len(arr)): prefix[i] = prefix[i - 1] + arr[i] # Return the computed prefix sum array return prefixif __name__ == &quot;__main__&quot;: sol = Solution() arr = [1, 2, 3, 4] prefix_sum = sol.compute_prefix_sum(arr) print(prefix_sum) # Output: [1, 3, 6, 10] Complexity AnalysisTime Complexity Computation: The for-loop runs (n-1) times, where (n) is the length of the input array, resulting in O(n) time. Therefore, the overall time complexity is O(n). Space Complexity Prefix Array: The prefix array requires O(n) space, where (n) is the length of the input array. Input Array: The input array itself requires O(n) space. Thus, the overall space complexity is O(n). Why Use Prefix Sums?Prefix sums are used to improve the efficiency of range sum queries. Without a prefix sum, calculating the sum of elements between two indices (i) and (j) in an array requires iterating through the elements from (i) to (j), which takes O(n) time. By precomputing the prefix sums, we can answer these queries in O(1) time. Example: Range Sum QueryGiven an array nums and a range query (i, j), find the sum of elements between indices i and j. Example Input: arr = [1, 2, 3, 4], i = 1, j = 3 Output: 9 Justification: The sum of 2, 3 and 4 is 9. Step-by-Step Algorithm Compute the Prefix Sum Array: Initialize a prefix array prefix of the same length as the input array. Set prefix[0] to the first element of the input array. Iterate through the input array starting from index 1: Set prefix[i] to prefix[i-1] + arr[i]. The prefix sum array is now ready to be used for range sum queries. Answer the Range Sum Query: For a given range ([i, j]): If (i = 0), the sum is prefix[j]. Otherwise, the sum is prefix[j] - prefix[i-1]. Code12345678910111213141516171819202122232425262728class Solution: def compute_prefix_sum(self, arr): # Step 1: Initialize the prefix array with zeros prefix = [0] * len(arr) # Step 2: Set the first element of the prefix array to the first element of the input array prefix[0] = arr[0] # Step 3: Compute the prefix sum for each subsequent element for i in range(1, len(arr)): prefix[i] = prefix[i - 1] + arr[i] # Step 4: Return the computed prefix sum array return prefix def range_sum_query(self, prefix, i, j): # Step 5: Calculate the sum of elements between indices i and j using the prefix array if i == 0: return prefix[j] return prefix[j] - prefix[i - 1]if __name__ == &quot;__main__&quot;: sol = Solution() arr = [1, 2, 3, 4] prefix_sum = sol.compute_prefix_sum(arr) range_sum = sol.range_sum_query(prefix_sum, 1, 3) print(&quot;Sum of elements from index 1 to 3:&quot;, range_sum) # Output: 9 Complexity AnalysisTime Complexity: Computation: The for-loop runs (n-1) times, resulting in O(n) time. Range Sum Query: Answering a range sum query takes O(1) time. Therefore, the overall time complexity is O(n) for preprocessing and O(1) for each query. Space Complexity: Prefix Array: The prefix array requires O(n) space. Input Array: The input array itself requires O(n) space. Thus, the overall space complexity is O(n). Applications of Prefix Sums Range Sum Queries: As explained above, prefix sums can quickly answer the sum of elements between any two indices in an array. Subarray Problems: Prefix sums are used to find subarrays with a given sum, maximum sum subarray, and other subarray-related problems. 2D Prefix Sums: Extending the concept to two-dimensional arrays helps in efficiently calculating the sum of elements in sub-matrices. Frequency Counting: Prefix sums can be used to maintain cumulative frequencies, helping in statistical calculations and data analysis. Balancing Loads: In distributed systems, prefix sums can help in balancing workloads evenly across multiple servers. By understanding and utilizing prefix sums, you can solve many algorithmic problems more efficiently, making your solutions both faster and more elegant. Find the Middle Index in ArrayProblem StatementGiven an integer array nums, return the leftmost middleIndex (i.e., the smallest amongst all the possible ones). A middleIndex is an index where the sum of the numbers to the left of this index is equal to the sum of the numbers to the right of this index. You can consider the left sum 0 for middleIndex == 0, and right sum 0 for middleIndex == nums.length - 1. If no middleIndex exists in nums, return -1. ExamplesExample 1: Input: nums = [1, 7, 3, 6, 5, 6] Expected Output: 3 Justification: The sum of the numbers to the left of index 3 (1 + 7 + 3 = 11) is equal to the sum of the numbers to the right of index 3 (5 + 6 = 11). Example 2: Input: nums = [2, 1, -1] Expected Output: 0 Justification: The sum of the numbers to the left of index 0 is considered to be 0. The sum of the numbers to the right of index 0 (1 + -1 = 0) is also 0. Example 3: Input: nums = [2, 3, 5, 5, 3, 2] Expected Output: -1 Justification: There is no middleIndex exists in the array. Constraints: 1 &lt;= nums.length &lt;= 100 -1000 &lt;= nums[i] &lt;= 1000 SolutionTo solve this problem, we need to find an index where the sum of the elements on the left equals the sum of the elements on the right. We can achieve this by calculating the total sum of the array first. Then, as we iterate through the array, we keep a running sum of the elements to the left of the current index. By subtracting this running sum and the current element from the total sum, we get the sum of the elements to the right of the current index. If the left sum equals the right sum at any index, we return that index. This approach ensures that we only need to traverse the array once, making it efficient in terms of time complexity. This method is effective because it minimizes the number of passes over the array, reducing the overall time complexity to O(n). Additionally, it only requires a few extra variables for storing sums, keeping the space complexity to O(1). This combination of efficiency and simplicity makes it a robust solution for finding the middle index. Step-by-step Algorithm Calculate the total sum of the array. Initialize a variable leftSum to 0. Iterate through the array using a loop: For each element at index i, calculate the right sum as totalSum - leftSum - nums[i]. If leftSum equals the right sum, return i. Update leftSum by adding the current element nums[i]. If no index is found, return -1. Algorithm WalkthroughLet’s walk through the algorithm using the example nums = [1, 7, 3, 6, 5, 6]. Step 1: Calculate totalSum = 1 + 7 + 3 + 6 + 5 + 6 = 28. Step 2: Initialize leftSum = 0. Step 3 : Start loop through the array. Index 0: rightSum = 28 - 0 - 1 = 27. leftSum = 0 + 1 = 1. Index 1: rightSum = 28 - 1 - 7 = 20. leftSum = 1 + 7 = 8. Index 2: rightSum = 28 - 8 - 3 = 17. leftSum = 8 + 3 = 11. Index 3: rightSum = 28 - 11 - 6 = 11. leftSum equals rightSum at index 3. Return 3. Code12345678910111213141516171819202122232425class Solution: def findMiddleIndex(self, nums) -&gt; int: # Calculate the total sum of all elements in the array totalSum = sum(nums) # Initialize the sum of elements to the left leftSum = 0 # Iterate through each element in the array for i, num in enumerate(nums): # Calculate the sum of elements to the right rightSum = totalSum - leftSum - num # Check if the sum of elements to the left equals the sum of elements to the right if leftSum == rightSum: return i # Update the sum of elements to the left leftSum += num return -1solution = Solution()example1 = [1, 7, 3, 6, 5, 6]example2 = [2, 1, -1]example3 = [2, 3, 5, 5, 3, 2]print(solution.findMiddleIndex(example1)) # Output: 3print(solution.findMiddleIndex(example2)) # Output: 0print(solution.findMiddleIndex(example3)) # Output: -1 Complexity AnalysisTime Complexity: O(N) We traverse the array twice, once to calculate the total sum and once to find the middle index. Space Complexity: O(1) We use a constant amount of extra space for variables (totalSum, leftSum). Left and Right Sum Differences (easy)Problem StatementGiven an input array of integers nums, find an integer array, let’s call it differenceArray, of the same length as an input integer array. Each element of differenceArray, i.e., differenceArray[i], should be calculated as follows: take the sum of all elements to the left of index i in array nums (denoted as leftSum[i]), and subtract it from the sum of all elements to the right of index i in array nums (denoted as rightSum[i]), taking the absolute value of the result. Formally: differenceArray[i] = | leftSum[i] - rightSum[i] | If there are no elements to the left/right of i, the corresponding sum should be taken as 0. ExamplesExample 1: Input: [2, 5, 1, 6] Expected Output: [12, 5, 1, 8] Explanation: For i=0: |(0) - (5+1+6)| = |0 - 12| = 12 For i=1: |(2) - (1+6)| = |2 - 7| = 5 For i=2: |(2+5) - (6)| = |7 - 6| = 1 For i=3: |(2+5+1) - (0)| = |8 - 0| = 8 Example 2: Input: [3, 3, 3] Expected Output: [6, 0, 6] Explanation: For i=0: |(0) - (3+3)| = 6 For i=1: |(3) - (3)| = 0 For i=2: |(3+3) - (0)| = 6 Example 3: Input: [1, 2, 3, 4, 5] Expected Output: [14, 11, 6, 1, 10] Explanation: Calculations for each index i will follow the above-mentioned logic. Constraints: 1 &lt;= nums.length &lt;= 1000 1 &lt;= nums[i] &lt;= 105 SolutionThe algorithm takes a numerical approach to find the absolute differences between the sum of numbers to the left and to the right of each index in the input array, nums. It efficiently calculates two new arrays: leftSum and rightSum that respectively store the cumulative sums of elements to the left and right of every index i (inclusive). Afterward, it calculates the absolute difference between corresponding values in leftSum and rightSum to form the resulting array, differenceArray. This algorithm ensures minimized repeated calculations, as each sum is calculated in a linear pass and reused while determining the absolute differences. Initialize Arrays: A new array, leftSum, is initialized with the same length as nums to keep track of the cumulative sum to the left of each index. Similarly, rightSum is initialized to keep track of the cumulative sum to the right of each index. differenceArray is initialized to store the final results. Populate the leftSum Array: Traverse nums from left to right. For each index i, leftSum[i] is determined by adding nums[i] to leftSum[i-1]. If i is 0, leftSum[i] is simply nums[i] since there are no elements to the left. Populate the rightSum Array: Traverse nums from right to left. For each index i, rightSum[i] is determined by adding nums[i] to rightSum[i+1]. If i is the last index, rightSum[i] is nums[i] since there are no elements to the right. Calculate the differenceArray: Traverse from index 0 to length-1 of nums. For each i, differenceArray[i] is calculated as the absolute difference between leftSum[i] and rightSum[i]. Return the Result: differenceArray is returned as it contains the final result. Algorithm WalkthroughConsider the example where nums = [2, 5, 1, 6] for a detailed walkthrough. Step 1: Initialize Arrays: leftSum = [0, 0, 0, 0] rightSum = [0, 0, 0, 0] differenceArray = [0, 0, 0, 0] Step 2: Populate the leftSum Array: i=0: leftSum[0] = nums[0] = 2 i=1: leftSum[1] = nums[1] + leftSum[0] = 5 + 2 = 7 i=2: leftSum[2] = nums[2] + leftSum[1] = 1 + 7 = 8 i=3: leftSum[3] = nums[3] + leftSum[2] = 6 + 8 = 14 Step 3: Populate the rightSum Array: i=3: rightSum[3] = nums[3] = 6 i=2: rightSum[2] = nums[2] + rightSum[3] = 1 + 6 = 7 i=1: rightSum[1] = nums[1] + rightSum[2] = 5 + 7 = 12 i=0: rightSum[0] = nums[0] + rightSum[1] = 2 + 12 = 14 Step 4: Calculate the differenceArray: differenceArray[i] = |leftSum[i] - rightSum[i]| for each i differenceArray[0] = |2 - 14| = 12 differenceArray[1] = |7 - 12| = 5 differenceArray[2] = |8 - 7| = 1 differenceArray[3] = |14 - 6| = 8 Step 5: Return the Result: The final array differenceArray = [12, 5, 1, 8] is returned as the output. CodeHere is the code for this algorithm: 123456789101112131415161718192021222324252627282930313233343536class Solution: def findDifferenceArray(self, nums): n = len(nums) leftSum = [0] * n rightSum = [0] * n differenceArray = [0] * n # Calculate leftSum array leftSum[0] = nums[0] for i in range(1, n): leftSum[i] = leftSum[i-1] + nums[i] # Calculate rightSum array rightSum[n-1] = nums[n-1] for i in range(n-2, -1, -1): rightSum[i] = rightSum[i+1] + nums[i] # Calculate differenceArray for i in range(n): differenceArray[i] = abs(leftSum[i] - rightSum[i]) return differenceArrayif __name__ == &quot;__main__&quot;: solution = Solution() example1 = [2, 5, 1, 6] example2 = [3, 1, 4, 2, 2] example3 = [1, 2, 3, 4, 5] # Output should be: [12, 5, 1, 8] print(solution.findDifferenceArray(example1)) # Output should be: [9, 5, 0, 6, 10] print(solution.findDifferenceArray(example2)) # Output should be: [14, 11, 6, 1, 10] print(solution.findDifferenceArray(example3)) Time Complexity Calculating Prefix and Suffix Sums: Prefix Sum Calculation: The loop that calculates the prefix sum runs n times, where n is the number of elements in the input array. Therefore, it has a time complexity of (O(n)). Suffix Sum Calculation: Similarly, the loop for calculating the suffix sum also runs n times, resulting in a time complexity of (O(n)). Calculating Answer Array: The loop that calculates the absolute difference between prefix and suffix sums at each index also runs n times, contributing (O(n)) to the time complexity. Combining all these, the overall time complexity of the algorithm is (O(n) + O(n) + O(n) = O(3n)), which simplifies to (O(n)) because we typically ignore constant factors in Big O notation. Space Complexity Prefix and Suffix Sum Arrays: The algorithm utilizes two additional arrays: prefixSum and suffixSum, each of size n. This contributes (2n) to the space complexity, i.e., (O(2n)). Answer Array: Additionally, an answer array of size n is used to store the final results. This adds an additional (O(n)) to the space complexity. Combining these, the overall space complexity is (O(2n) + O(n) = O(3n)), which simplifies to (O(n)) when considering Big O notation. Maximum Size Subarray Sum Equals kProblem StatementGiven an array of integers nums and an integer k, find the length of the longest subarray that sums to k. If no such subarray exists, return 0. ExamplesExample 1: Input: nums = [1, 2, 3, -2, 5], k = 5 Output: 2 Explanation: The longest subarray with a sum of 5 is [2, 3], which has a length of 2. Example 2: Input: nums = [-2, -1, 2, 1], k = 1 Output: 2 Explanation: The longest subarray with a sum of 1 is [-1, 2], which has a length of 2. Example 3: Input: nums = [3, 4, 7, 2, -3, 1, 4, 2], k = 7 Output: 4 Explanation: The longest subarray with a sum of 7 is [7, 2, -3, 1], which has a length of 4. Constraints: 1 &lt;= nums.length &lt;= 2 * 10^5 -10^4 &lt;= nums[i] &lt;= 10^4 -10^9 &lt;= k &lt;= 10^9 SolutionTo solve this problem, we can use a hash map (or dictionary) to keep track of the cumulative sum at each index. The key idea is to use the cumulative sum to quickly determine the length of subarrays that sum up to k. By storing the earliest occurrence of each cumulative sum, we can efficiently check if there is a subarray ending at the current index with the required sum. This approach leverages the relationship between the cumulative sums to find the longest subarray with a sum of k in linear time. This approach is efficient because it avoids the need for nested loops, which would result in a quadratic time complexity. Instead, by using a hash map to store the cumulative sums, we can achieve a linear time complexity, making the solution scalable for large input sizes. Step-by-Step Algorithm Initialization: Create an empty hash map (cumMap) to store cumulative sums and their earliest indices. Initialize cumSum to 0 to keep track of the cumulative sum as we iterate through the array. Initialize maxLen to 0 to keep track of the maximum length of the subarray with a sum of k. Iterate through the array: Loop through each element in the nums array using a for loop: Update the cumulative sum: For each element num at index i, update the cumulative sum: cumSum += num. Check if the cumulative sum equals k: If cumSum == k, update maxLen to i + 1 since the entire array from the start to the current index sums to k. Check for a subarray with a sum of k: Calculate cumSum - k. If (cumSum - k) exists in cumMap, it means there is a subarray that sums to k: Update maxLen to the maximum of its current value and the length of this subarray: i - cumMap[cumSum - k]. Store the cumulative sum and its index: If cumSum is not already in cumMap, add it with its index i: cumMap[cumSum] = i. Return the maximum length: After the loop ends, return maxLen. Algorithm WalkthroughUsing the input nums = [1, 2, 3, -2, 5], k = 5: Initialization: cumMap = &#123;&#125; cumSum = 0 maxLen = 0 Iteration: Index 0, num = 1: Update the cumulative sum: cumSum = 1 Check if the cumulative sum equals k: cumSum != k Check for a subarray with a sum of k: cumSum - k = -4 does not exist in cumMap Store the cumulative sum and its index: Add 1 to cumMap: cumMap = &#123;1: 0&#125; Index 1, num = 2: Update the cumulative sum: cumSum = 3 Check if the cumulative sum equals k: cumSum != k Check for a subarray with a sum of k: cumSum - k = -2 does not exist in cumMap Store the cumulative sum and its index: Add 3 to cumMap: cumMap = &#123;1: 0, 3: 1&#125; Index 2, num = 3: Update the cumulative sum: cumSum = 6 Check if the cumulative sum equals k: cumSum != k Check for a subarray with a sum of k: cumSum - k = 1 exists in cumMap at index 0 Update maxLen: maxLen = max(0, 2 - 0) = 2 Store the cumulative sum and its index: Add 6 to cumMap: cumMap = &#123;1: 0, 3: 1, 6: 2&#125; Index 3, num = -2: Update the cumulative sum: cumSum = 4 Check if the cumulative sum equals k: cumSum != k Check for a subarray with a sum of k: cumSum - k = -1 does not exist in cumMap Store the cumulative sum and its index: Add 4 to cumMap: cumMap = &#123;1: 0, 3: 1, 6: 2, 4: 3&#125; Index 4, num = 5: Update the cumulative sum: cumSum = 9 Check if the cumulative sum equals k: cumSum != k Check for a subarray with a sum of k: cumSum - k = 4 exists in cumMap at index 3 Update maxLen: maxLen = max(2, 4 - 3) = 2 Store the cumulative sum and its index: Add 9 to cumMap: cumMap = &#123;1: 0, 3: 1, 6: 2, 4: 3, 9: 4&#125; Result: The maximum length of a subarray summing to 5 is 2. Code1234567891011121314151617181920212223242526272829303132333435363738394041class Solution: def maxSubArrayLen(self, nums, k): # Create a dictionary to store cumulative sums and their earliest indices cum_map = &#123;&#125; cum_sum = 0 # Initialize cumulative sum max_len = 0 # Initialize max length of subarray with sum k # Iterate through the array for i in range(len(nums)): cum_sum += nums[i] # Update cumulative sum # Check if cumulative sum equals k if cum_sum == k: max_len = i + 1 # Update max length # Check if there is a subarray with sum k if (cum_sum - k) in cum_map: max_len = max(max_len, i - cum_map[cum_sum - k]) # Update max length # Store the cumulative sum and its index if cum_sum not in cum_map: cum_map[cum_sum] = i return max_len # Return the maximum lengthif __name__ == &quot;__main__&quot;: sol = Solution() # Test cases nums1 = [1, 2, 3, -2, 5] k1 = 5 print(sol.maxSubArrayLen(nums1, k1)) # Output: 2 nums2 = [-2, -1, 2, 1] k2 = 1 print(sol.maxSubArrayLen(nums2, k2)) # Output: 2 nums3 = [3, 4, 7, 2, -3, 1, 4, 2] k3 = 7 print(sol.maxSubArrayLen(nums3, k3)) # Output: 4 Complexity Analysis Time Complexity: The algorithm runs in O(n) time, where n is the number of elements in the array. This is because we traverse the array once and perform constant-time operations for each element. Space Complexity: The space complexity is O(n) because, in the worst case, we may store each cumulative sum in the hash map. Binary Subarrays With SumProblem StatementGiven a binary called nums and an integer called goal, return the number of subarrays that have a sum equal to goal. A subarray is a part of the array that is continuous, meaning all its elements are next to each other. ExamplesExample 1 Input: nums = [1, 1, 0, 1, 1], goal = 2 Expected Output: 5 Justification: The subarrays with a sum of 3 are: [1, 1] (from index 0 to 1), [1, 1, 0] (from index 0 to 2), [1, 0, 1] (from index 1 to 3), [0, 1, 1] (from index 2 to 5), and [1, 1] (from index 4 to 5). Example 2 Input: nums = [1, 1, 1, 1, 0, 0], goal = 3 Expected Output: 4 Justification: The subarrays with a sum of 3 are: [1, 1, 1] (from index 0 to 2), [1, 1, 1] (from index 1 to 3), [1, 1, 1, 0] (from index 1 to 4), and [1, 1, 1, 0, 0] (from index 1 to 5). Example 3 Input: nums = [0, 0, 0, 0, 1, 0, 1], goal = 1 Expected Output: 12 Justification: The subarrays with a sum of 1 are: [0, 0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 1], [0, 1], [1], [0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0], [0, 0, 1, 0], [0, 1, 0], [1, 0], [0, 1], and[1]`. SolutionTo solve this problem, we can use a technique called the prefix sum combined with a hashmap (or dictionary). The prefix sum helps in calculating the sum of elements in any subarray efficiently. We will keep a running total (prefix sum) as we iterate through the array. For each prefix sum, we will check if there is a previous prefix sum that, when subtracted from the current prefix sum, equals the goal. This way, we can count the subarrays that meet the requirement. This approach works because it allows us to find the subarray sums in constant time by leveraging previously computed sums stored in the hashmap. This is efficient and avoids the need for a nested loop, reducing the time complexity from O(N^2) to O(N). Step-by-step Algorithm Initialize a variable count to 0. This will hold the number of subarrays that sum up to the goal. Initialize a variable prefix_sum to 0. This will keep track of the sum of elements from the start up to the current position. Initialize a hashmap (dictionary) prefix_sums with one entry &#123;0: 1&#125;. This accounts for subarrays that start from the beginning. Iterate through each element in the array nums. Add the current element to prefix_sum. Check if prefix_sum - goal exists in the prefix_sums. If it does, add the value of prefix_sums[prefix_sum - goal] to count. Increment the value of prefix_sum in prefix_sums by 1. If prefix_sum is not in the hashmap, set it to 1. After the loop, count will hold the number of subarrays with a sum equal to goal. Algorithm WalkthroughUsing the input nums = [1, 1, 0, 1, 1] and goal = 2: Initialize count = 0, prefix_sum = 0, prefix_sums = &#123;0: 1&#125; Iterate through nums: Step 1: Current element 1 prefix_sum = 1 prefix_sum - goal = -1 (not in prefix_sums) Update prefix_sums: &#123;0: 1, 1: 1&#125; Step 2: Current element 1 prefix_sum = 2 prefix_sum - goal = 0 (exists in prefix_sums, add prefix_sums[0] to count) count = 1 Update prefix_sums: &#123;0: 1, 1: 1, 2: 1&#125; Step 3: Current element 0 prefix_sum = 2 prefix_sum - goal = 0 (exists in prefix_sums, add prefix_sums[0] to count) count = 2 Update prefix_sums: &#123;0: 1, 1: 1, 2: 2&#125; Step 4: Current element 1 prefix_sum = 3 prefix_sum - goal = 1 (exists in prefix_sums, add prefix_sums[1] to count) count = 3 Update prefix_sums: &#123;0: 1, 1: 1, 2: 2, 3: 1&#125; Step 5: Current element 1 prefix_sum = 4 prefix_sum - goal = 2 (exists in prefix_sums, add prefix_sums[2] to count) count = 5 Update prefix_sums: &#123;0: 1, 1: 1, 2: 2, 3: 1, 4: 1&#125; Final count is 5. Code123456789101112131415161718192021222324252627282930313233class Solution: def numSubarraysWithSum(self, nums, goal): count = 0 # Initialize count of subarrays prefix_sum = 0 # Initialize prefix sum prefix_sums = &#123;0: 1&#125; # Initialize hashmap for prefix sums with initial prefix sum of 0 for num in nums: prefix_sum += num # Update prefix sum # If (prefix_sum - goal) exists in hashmap, it means we found a subarray with sum equals to goal if prefix_sum - goal in prefix_sums: count += prefix_sums[prefix_sum - goal] # Update count of subarrays # Update the hashmap with current prefix sum if prefix_sum in prefix_sums: prefix_sums[prefix_sum] += 1 else: prefix_sums[prefix_sum] = 1 return count # Return the count of subarraysif __name__ == &quot;__main__&quot;: sol = Solution() nums1 = [1, 1, 0, 1, 1] goal1 = 2 print(sol.numSubarraysWithSum(nums1, goal1)) # Expected output: 5 nums2 = [1, 1, 1, 1, 0, 0] goal2 = 3 print(sol.numSubarraysWithSum(nums2, goal2)) # Expected output: 4 nums3 = [0, 0, 0, 0, 1, 0, 1] goal3 = 1 print(sol.numSubarraysWithSum(nums3, goal3)) # Expected output: 12 Complexity AnalysisTime ComplexityThe time complexity of this algorithm is O(N), where n is the number of elements in the input array nums. This is because we iterate through the array once, and each operation inside the loop (like updating the prefix sum and hashmap) is done in constant time. Space ComplexityThe space complexity of this algorithm is O(N), where n is the number of elements in the input array nums. This is because, in the worst case, we might store every prefix sum in the hashmap. If all prefix sums are unique, the hashmap will have n entries. Subarray Sums Divisible by KProblem StatementGiven an array of integers nums and an integer k, return the count of non-empty subarrays that have a sum that is divisible by k. A subarray is a continuous part of an array. ExamplesExample 1 Input: nums = [3, 1, 2, -2, 5, -1], k = 3 Expected Output: 7 Justification: The subarrays that sum to a multiple of 3 are [3], [1, 2], [3, 1, 2], [3, 1, 2, -2, 5], [1, 2, -2, 5], [-2, 5], and [2, -2]. Example 2 Input: nums = [4, 5, 0, -2, -3, 1], k = 5 Expected Output: 7 Justification: The subarrays that sum to a multiple of 5 are [5], [4, 5, 0, -2, -3, 1], [5, 0], [0], [5, 0, -2, -3], [0, -2, -3], and [-2, -3]. Example 3 Input: nums = [-1, 2, 9], k = 2 Expected Output: 2 Justification: The subarrays that sum to a multiple of 2 are [2] and [-1, 2, 9]. Constraints: 1 &lt;= nums.length &lt;= 3 * 10^4 -10^4 &lt;= nums[i] &lt;= 10^4 2 &lt;= k &lt;= 10^4 SolutionTo solve this problem, we will use a hash map (dictionary) to keep track of the cumulative sums and their remainders when divided by k. This helps in finding the number of subarrays whose sum is divisible by k. The idea is to iterate through the array while maintaining a running sum. For each element, calculate the cumulative sum and its remainder when divided by k. If this remainder has been seen before, it indicates that there is a subarray which sum is divisible by k. By using the hash map to store and count these remainders, we efficiently count the subarrays without needing nested loops, making the approach more efficient. This approach works because it leverages the properties of modular arithmetic to efficiently determine subarrays that meet the criteria. Using a hash map to store the counts of remainders enables us to quickly check for existing subarrays that, when combined with the current element, form a subarray whose sum is divisible by k. Step-by-step Algorithm Initialize a hash map remainder_count to store the frequency of remainders. Start with &#123;0: 1&#125; to handle cases where the subarray itself is divisible by k. Initialize cumulative_sum to 0 and count to 0. Iterate through each element in nums: Add the current element to cumulative_sum. Compute the remainder of cumulative_sum divided by k. If the remainder is negative, adjust it by adding k. If the remainder is already in remainder_count, increment count by the value associated with the remainder in the hash map. Increment the count of this remainder in the hash map. Return count. Algorithm WalkthroughUsing the input = nums = [3, 1, 2, -2, 5, -1] and k = 3. Initialization: remainder_count = &#123;0: 1&#125; cumulative_sum = 0 count = 0 Iteration 1 (num = 3): cumulative_sum = 3 remainder = 3 % 3 = 0 count += remainder_count[0] = 1 -&gt; count = 1 Update remainder_count: &#123;0: 2&#125; Iteration 2 (num = 1): cumulative_sum = 4 remainder = 4 % 3 = 1 count += remainder_count.get(1, 0) = 0 -&gt; count = 1 Update remainder_count: &#123;0: 2, 1: 1&#125; Iteration 3 (num = 2): cumulative_sum = 6 remainder = 6 % 3 = 0 count += remainder_count[0] = 2 -&gt; count = 3 Update remainder_count: &#123;0: 3, 1: 1&#125; Iteration 4 (num = -2): cumulative_sum = 4 remainder = 4 % 3 = 1 count += remainder_count[1] = 1 -&gt; count = 4 Update remainder_count: &#123;0: 3, 1: 2&#125; Iteration 5 (num = 5): cumulative_sum = 9 remainder = 9 % 3 = 0 count += remainder_count[0] = 3 -&gt; count = 7 Update remainder_count: &#123;0: 4, 1: 2&#125; Iteration 6 (num = -1): cumulative_sum = 8 remainder = 8 % 3 = 2 count += remainder_count.get(2, 0) = 0 -&gt; count = 7 Update remainder_count: &#123;0: 4, 1: 2, 2: 1&#125; The total count of subarrays whose sum is divisible by k is 7. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution: def subarraysDivByK(self, nums, k): # Create a dictionary to store the frequency of remainders remainder_count = &#123;0: 1&#125; # Initialize cumulative sum and count of subarrays cumulative_sum = 0 count = 0 # Loop through each number in the array for num in nums: # Add the current number to the cumulative sum cumulative_sum += num # Calculate the remainder of cumulative sum divided by k remainder = cumulative_sum % k # If remainder is negative, adjust it by adding k if remainder &lt; 0: remainder += k # If this remainder has been seen before, add its frequency to the count count += remainder_count.get(remainder, 0) # Update the frequency of this remainder in the dictionary remainder_count[remainder] = remainder_count.get(remainder, 0) + 1 # Return the total count of subarrays return countif __name__ == &quot;__main__&quot;: solution = Solution() # Example 1 nums1 = [3, 1, 2, -2, 5, -1] k1 = 3 print(solution.subarraysDivByK(nums1, k1)) # 7 # Example 2 nums2 = [4, 5, 0, -2, -3, 1] k2 = 5 print(solution.subarraysDivByK(nums2, k2)) # 7 # Example 3 nums3 = [-1, 2, 9] k3 = 2 print(solution.subarraysDivByK(nums3, k3)) # 2 Complexity AnalysisTime ComplexityThe time complexity of the algorithm is O(N), where (n) is the number of elements in the input array nums. This is because we traverse the array exactly once, performing constant-time operations for each element. Space ComplexityThe space complexity of the algorithm is O(K), where (k) is the value of the divisor. This is due to the hash map (or dictionary) that stores at most (k) different remainders. In the worst case, the hash map will store all possible remainders from (0) to (k-1). Sum of Absolute Differences in a Sorted ArrayProblem StatementGiven an integer array nums sorted in increasing order, return an array result of the same length, where result[i] should be the sum of the absolute differences between nums[i] and every other element in nums. ExamplesExample 1 Input: [1, 3, 6] Output: [7, 5, 8] Explanation: For result[0]: |1-3| + |1-6| = 2 + 5 = 7 For result[1]: |3-1| + |3-6| = 2 + 3 = 5 For result[2]: |6-1| + |6-3| = 5 + 3 = 8 Example 2 Input: [2, 4, 7] Output: [7, 5, 8] Explanation: For result[0]: |2-4| + |2-7| = 2 + 5 = 7 For result[1]: |4-2| + |4-7| = 2 + 3 = 5 For result[2]: |7-2| + |7-4| = 5 + 3 = 8 Example 3 Input: [1, 2, 4, 5] Output: [8, 6, 6, 6] Explanation: For result[0]: |1-2| + |1-4| + |1-5| = 1 + 3 + 4 = 8 For result[1]: |2-1| + |2-4| + |2-5| = 1 + 2 + 3 = 6 For result[2]: |4-1| + |4-2| + |4-5| = 3 + 2 + 1 = 6 For result[3]: |5-1| + |5-2| + |5-4| = 4 + 3 + 1 = 8 Constraints: 2 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= nums[i + 1] &lt;= 104 SolutionTo solve this problem, we need to calculate the sum of absolute differences for each element in the array. We can simplify this by using prefix sums to avoid repeatedly calculating the same differences. By leveraging prefix sums, we can compute the total difference more efficiently. For each element, we will split the array into two parts: the left part and the right part. The left part includes all elements before the current one, and the right part includes all elements after the current one. Using the prefix sums, we can quickly get the sum of elements on the left and right, then use these sums to calculate the absolute differences. This method avoids the need for nested loops and reduces the time complexity. Step-by-step Algorithm Initialize Arrays: Create an array result of the same length as nums initialized to zero. Create an array prefixSum of length n + 1 (where n is the length of nums) initialized to zero. Calculate Prefix Sums: Iterate through the nums array. For each index i, compute prefixSum[i + 1] = prefixSum[i] + nums[i]. This gives us the sum of all elements from the start up to index i. Compute Result Array: Iterate through the nums array. For each index i: Calculate the sum of the left part using prefixSum[i]. Calculate the sum of the right part using prefixSum[n] - prefixSum[i + 1]. Compute result[i] using the formula: result[i] = (i * nums[i] - leftSum) + (rightSum - (n - i - 1) * nums[i]) The left part is i * nums[i] - leftSum. The right part is rightSum - (n - i - 1) * nums[i]. Return Result: Return the result array. Algorithm WalkthroughLet’s consider the input: nums = &#123;1, 2, 4, 5&#125; Initialize Arrays: nums = [1, 2, 4, 5] result = [0, 0, 0, 0] prefixSum = [0, 0, 0, 0, 0] Calculate Prefix Sums: For i = 0, prefixSum[1] = prefixSum[0] + nums[0] = 0 + 1 = 1 prefixSum = [0, 1, 0, 0, 0] For i = 1, prefixSum[2] = prefixSum[1] + nums[1] = 1 + 2 = 3 prefixSum = [0, 1, 3, 0, 0] For i = 2, prefixSum[3] = prefixSum[2] + nums[2] = 3 + 4 = 7 prefixSum = [0, 1, 3, 7, 0] For i = 3, prefixSum[4] = prefixSum[3] + nums[3] = 7 + 5 = 12 prefixSum = [0, 1, 3, 7, 12] Compute Result Array: For i = 0: leftSum = prefixSum[0] = 0 rightSum = prefixSum[4] - prefixSum[1] = 12 - 1 = 11 ```result[0] = (0 1 - 0) + (11 - 3 1) = 0 + 8 = 8 1234567891011 - `result = [8, 0, 0, 0]`- For `i = 1`: - `leftSum = prefixSum[1] = 1` - `rightSum = prefixSum[4] - prefixSum[2] = 12 - 3 = 9` - ``` result[1] = (1 * 2 - 1) + (9 - 2 * 2) = 1 + 5 = 6 result = [8, 6, 0, 0] For i = 2: leftSum = prefixSum[2] = 3 rightSum = prefixSum[4] - prefixSum[3] = 12 - 7 = 5 ```result[2] = (2 4 - 3) + (5 - 1 4) = 5 + 1 = 6 1234567891011 - `result = [8, 6, 6, 0]`- For `i = 3`: - `leftSum = prefixSum[3] = 7` - `rightSum = prefixSum[4] - prefixSum[4] = 12 - 12 = 0` - ``` result[3] = (3 * 5 - 7) + (0 - 0 * 5) = 8 + 0 = 8 result = [8, 6, 6, 8] Return Result: The final result array is [8, 6, 6, 8]. Code12345678910111213141516171819202122232425262728class Solution: def getSumAbsoluteDifferences(self, nums): n = len(nums) result = [0] * n prefix_sum = [0] * (n + 1) # Calculate prefix sums for i in range(n): prefix_sum[i + 1] = prefix_sum[i] + nums[i] # Calculate result array for i in range(n): left_sum = prefix_sum[i] right_sum = prefix_sum[n] - prefix_sum[i + 1] result[i] = i * nums[i] - left_sum + right_sum - (n - i - 1) * nums[i] return resultif __name__ == &quot;__main__&quot;: sol = Solution() example1 = [1, 3, 6] example2 = [2, 4, 7] example3 = [1, 2, 4, 5] print(sol.getSumAbsoluteDifferences(example1)) # [7, 5, 8] print(sol.getSumAbsoluteDifferences(example2)) # [7, 5, 8] print(sol.getSumAbsoluteDifferences(example3)) # [8, 6, 6, 8] Complexity AnalysisTime Complexity Prefix Sum Calculation: We iterate through the array once to calculate the prefix sums, which takes O(n) time. Result Calculation: We iterate through the array once more to compute the result for each element, which also takes O(n) time. Thus, the overall time complexity is O(n), where n is the length of the input array. Space Complexity We use an extra array of size n+1 for the prefix sums. We also use an extra array of size n for the result. Thus, the overall space complexity is O(n). Subarray Sum Equals KProblem StatementGiven an array nums containing n integers and integer k, return the total number of subarrays having sum equal to k. A subarray is defined as a contiguous non-empty sequence of the array elements. ExamplesExample 1: Input: nums = [1, 2, 3], k = 3 Expected Output: 2 Justification: There are two subarrays that sum to 3: [1, 2] and [3]. Example 2: Input: nums = [10, 2, -2, -20, 10], k = -10 Expected Output: 3 Justification: Three subarrays sum up to -10: [10, 2, -2, -20], [2, -2, -20, 10], and [-20, 10]. Example 3: Input: nums = [5, 1, 2, -3, 4, -2], k = 3 Expected Output: 2 Justification: There are two subarrays that sum to 3: [2, -3, 4], and [1, 2]. SolutionTo solve this problem, we’ll employ a technique that involves using a hashmap to efficiently track the cumulative sum of elements as we iterate through the array. The core idea is that if the cumulative sum up to two indices, say i and j, differs by the target value k, then the sum of the elements lying between i and j is k. The algorithm will iterate through the array, calculating the cumulative sum at each step. We then check if (cumulative sum - k) is present in the hashmap. If it is, it means there exists a previous cumulative sum such that the difference between the current sum and that sum equals k, indicating a valid subarray. We add the count of these occurrences to our total. Additionally, we keep updating the hashmap with the count of each cumulative sum encountered. This approach is effective as it allows us to find the required subarrays in a single pass through the array, making it efficient in terms of time complexity. Step-by-step Algorithm Initialize a variable count to 0 and a hashmap cumulativeSumFrequency with a key-value pair (0:1) to handle edge cases. Iterate through the array nums while keeping track of the cumulativeSum. For each element num in nums: Add num to cumulativeSum. Check if (cumulativeSum - k) is in cumulativeSumFrequency. If it is, add its frequency to count. Update cumulativeSumFrequency by incrementing the count of cumulativeSum. Return the value of count. Algorithm WalkthroughLet’s walk through the algorithm with Example 2: nums = [10, 2, -2, -20, 10], k = -10. Start with cumulativeSum = 0, count = 0, cumulativeSumFrequency = &#123;0: 1&#125;. For num = 10: cumulativeSum = 10. (cumulativeSum - k) = 20 is not in cumulativeSumFrequency. Update cumulativeSumFrequency to &#123;0: 1, 10: 1&#125;. For num = 2: cumulativeSum = 12. (cumulativeSum - k) = 22 is not in cumulativeSumFrequency. Update cumulativeSumFrequency to &#123;0: 1, 10: 1, 12: 1&#125;. For num = -2: cumulativeSum = 10. (cumulativeSum - k) = 20 is not in cumulativeSumFrequency. Update cumulativeSumFrequency to &#123;0: 1, 10: 2, 12: 1&#125;. For num = -20: cumulativeSum = -10. (cumulativeSum - k) = 0 is in cumulativeSumFrequency. Add 1 to count. Update cumulativeSumFrequency to &#123;0: 1, 10: 2, 12: 1, -10: 1&#125;. For num = 10: cumulativeSum = 0. (cumulativeSum - k) = 10 is in cumulativeSumFrequency with frequency 2. Add 2 to count. Update cumulativeSumFrequency to &#123;0: 2, 10: 2, 12: 1, -10: 1&#125;. Final count is 3. Code12345678910111213141516171819class Solution: def subarraySum(self, nums, k): count, cumulative_sum, cumulative_sum_frequency = 0, 0, &#123;0: 1&#125; for num in nums: cumulative_sum += num # Update cumulative sum # Check if there&#x27;s a subarray sum that equals k count += cumulative_sum_frequency.get(cumulative_sum - k, 0) # Update the frequency map for the current cumulative sum cumulative_sum_frequency[cumulative_sum] = cumulative_sum_frequency.get(cumulative_sum, 0) + 1 return count # Return the total count of subarrays# Testing with the provided examplessolution = Solution()print(solution.subarraySum([1, 2, 3], 3)) # Example 1print(solution.subarraySum([10, 2, -2, -20, 10], -10)) # Example 2print(solution.subarraySum([5, 1, 2, -3, 4, -2], 3)) # Example 3 Complexity Analysis Time Complexity: O(n), where n is the length of the input array. This is due to a single loop through the array and constant-time hashmap operations. Space Complexity: O(n), where n is the length of the input array. The primary space usage is the hashmap storing the cumulative sum frequencies, which in the worst case can grow to the size of the array.","categories":[{"name":"Grokking Interview Pattern","slug":"Grokking-Interview-Pattern","permalink":"https://hasuer.github.io/categories/Grokking-Interview-Pattern/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hasuer.github.io/tags/Interview/"}]},{"title":"25. Pattern Union Find","slug":"25. Pattern Union Find","date":"2024-05-25T06:26:45.000Z","updated":"2024-05-28T03:31:01.820Z","comments":true,"path":"25-pattern-union-find/index.html","link":"","permalink":"https://hasuer.github.io/25-pattern-union-find/index.html","excerpt":"","text":"Introduction to Union Find PatternUnion Find, also known as Disjoint Set Union (DSU), is a data structure that keeps track of a partition of a set into disjoint subsets (meaning no set overlaps with another). It provides two primary operations: find, which determines which subset a particular element is in, and union, which merges two subsets into a single subset. This pattern is particularly useful for problems where we need to find whether 2 elements belong to the same group or need to solve connectivity-related problems in a graph or tree. Core Operations of Union-Find (Disjoint Set Union - DSU): Find: Determine which set a particular element belongs to. This can be used for determining if two elements are in the same set. Union: Merge two sets together. This operation is used when there is a relationship between two elements, indicating they should be in the same set. Union-Find: A Story of ConnectionsImagine a social network where everyone is initially a single user with no friends. The moment two users become friends, they form a group. If a user befriends someone from another group, the two groups merge into a larger friend circle. Union-Find helps track these friendships and circles. How DSU Work? Initial State: Everyone is in their own separate group. Think of each person as their own little island. Making Connections (Union): When two people shake hands, they now belong to the same group. If they were already in groups, their entire groups merge. Checking Connections (Find): Want to know if two people are connected? Union-Find can check if they’re in the same group. How DSU is Implemented? Parents Array: Each element has a parent. In the beginning, each element is their own parent. Find Operation: Follows the chain of parents until it reaches the root parent, which represents the group. Union Operation: Connects two groups by setting the parent of one group’s root to the other group’s root. Operations on Disjoint Set Data Structures1. Creating Disjoint Sets: Each element points to a parent. Initially, each element is its own parent, forming n disjoint sets. A “root” element is one that points to itself, identifying the set’s representative. 12# Initialize &#x27;n&#x27; elements where each element is its own parent.parent = [i for i in range(n)] # &#x27;n&#x27; is the number of elements 2. Find Operation:The Find operation determines which set a particular element belongs to. This can be used to determine if two elements are in the same set. In the below code: parent is an array where parent[i] is the parent of i. If parent[i] == i, then i is the root of the set and hence the representative. The find function follows the chain of parents for i until it reaches the root. 12345678def find(i): # If the element is its own parent, it&#x27;s the representative of its set. if parent[i] == i: return i # Otherwise, recursively find the representative of the set. else: return find(parent[i]) Above function recursively traverses the parent array until it finds a node that is the parent of itself. 3. Union Operation:The Union operation merges two disjoint sets. It takes two elements as input, finds the representatives of their sets using the Find operation, and finally merges the two sets. 123456789101112def union(i, j): # Find the representatives of the two sets. irep = find(i) jrep = find(j) # If they are already in the same set, return. if irep == jrep: return # Make the representative of the first set point to the representative of the second set. parent[irep] = jrep Above function merges two sets by making the representative of one set the parent of the other. Now, we need to optimize the find() and union() methods. OptimizationsHere are various methods for optimally perform operations on disjoint set. 1. Path Compression:This optimization is applied during the Find operation. The idea behind path compression is to flatten the structure of the tree, making each member of the set point directly to the set’s representative. This ensures that subsequent Find operations are faster and more efficient. When an element’s representative is found using the Find operation, the element’s parent is updated to directly reference the representative, thereby compressing the path. 123456789101112131415def find(i): # If i is the parent of itself if Parent[i] == i: # Then i is the representative of its set return i else: # Recursively find the representative of the set that i belongs to result = find(Parent[i]) # Path Compression: Directly connect i to the representative of its set Parent[i] = result # Return the representative return result This modified Find operation ensures that every node directly points to the representative of the set, and it makes it easy to find the representative of any two elements. 2. Union by Rank:This optimization focuses on keeping the tree balanced during the Union operation. When two sets are merged, the tree with a smaller rank (or depth) is attached to the root of the tree with a larger rank. This ensures that the tree remains relatively flat, optimizing future operations. If both trees have the same rank, the rank of one of them is incremented by one, and the other tree is attached to it. 12345678910111213141516171819def unionbyrank(i, j): # Find the representatives of the two sets. irep = find(i) jrep = find(j) # If they are already in the same set, return. if irep == jrep: return # Attach the tree with a smaller rank under the tree with a larger rank. if rank[irep] &lt; rank[jrep]: parent[irep] = jrep elif rank[irep] &gt; rank[jrep]: parent[jrep] = irep # If both trees have the same rank, increase the rank of one tree by 1. else: parent[irep] = jrep rank[jrep] += 1 This function uses the rank array to decide which tree gets attached under which tree. 3. Union by Size:Similar in spirit to Union by Rank, this optimization considers the size (or number of nodes) of the trees when merging them. The primary goal is to ensure that the smaller tree (in terms of nodes) is always attached to the larger tree. This approach helps in maintaining a balanced tree structure, ensuring that operations on the data structure remain efficient. 12345678910111213141516def unionbysize(i, j): # Find the representatives of the two sets. irep = find(i) jrep = find(j) # If they are already in the same set, return. if irep == jrep: return # Attach the smaller tree under the larger tree. if size[irep] &lt; size[jrep]: parent[irep] = jrep size[jrep] += size[irep] else: parent[jrep] = irep size[irep] += size[jrep] This function uses the size array to ensure that the tree with fewer nodes is added under the tree with more nodes. ExampleHere’s a complete implementation of the disjoint set with path compression and union by rank: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# Python3 program to implement Disjoint Set Data Structure.class Solution: def __init__(self, n): # Constructor: Initialize sets of n items. # rank: Store the depth of trees (used for union by rank). self.rank = [1] * n # parent: Store the parent of each item. Initially, every item is its own parent. self.parent = [i for i in range(n)] def find(self, x): # If x is not its own parent, then it&#x27;s not the representative of its set. if self.parent[x] != x: # Path Compression: Connect x directly to its set&#x27;s representative. self.parent[x] = self.find(self.parent[x]) # Return the representative of the set. return self.parent[x] def Union(self, x, y): # Find the representatives (or the root nodes) for x and y. xset = self.find(x) yset = self.find(y) # If x and y are already in the same set, return. if xset == yset: return # Union by Rank: # Attach the tree with a smaller rank under the root of the tree with a larger rank. if self.rank[xset] &lt; self.rank[yset]: self.parent[xset] = yset elif self.rank[xset] &gt; self.rank[yset]: self.parent[yset] = xset # If ranks are the same, choose one tree and increment its rank. else: self.parent[yset] = xset self.rank[xset] += 1# Driver codeif __name__ == &quot;__main__&quot;: # Create a disjoint set data structure with 5 elements. obj = Solution(5) # Merge sets that contain 0 and 2. obj.Union(0, 2) # Merge sets that contain 4 and 2. obj.Union(4, 2) # Merge sets that contain 3 and 1. obj.Union(3, 1) # Check if 4 and 0 are in the same set. if obj.find(4) == obj.find(0): print(&#x27;Yes&#x27;) else: print(&#x27;No&#x27;) # Check if 1 and 0 are in the same set. if obj.find(1) == obj.find(0): print(&#x27;Yes&#x27;) else: print(&#x27;No&#x27;) Pros and Cons of DSU Pros: Efficiency: Provides near constant time operations for union and find operations, making it highly efficient. Simplicity: Once set up, it’s straightforward to use for solving problems related to disjoint sets. Cons: Space Overhead: Requires additional space to store the parent and rank of each element. Initial Setup: Requires initial setup to create and initialize the data structure. Why Choose Union-Find Over BFS/DFS?You can solve similar problems using the Breadth-First Search (BFS) and Depth-First Search (DFS) algorithms, but the Union Find algorithm provides the optimal solution over them. For problems related to connectivity checks and component identification, Union-Find is often more efficient than BFS/DFS. Time Complexity: BFS/DFS: For BFS and DFS, the time complexity is O(V + E) where V is the number of vertices and E is the number of edges. This can be quite slow for large graphs. Union-Find: With path compression and union by rank, the amortized time complexity for union and find operations can be approximated as O(a(n)), where a(n) is the inverse Ackermann function. This function grows very slowly, making Union-Find operations almost constant time in practice. Let’s jump onto our first problem and apply the Union Find pattern. Redundant Connection684. Redundant Connection Design Gurus Problem StatementGiven an undirected graph containing 1 to n nodes. The graph is represented by a 2D array of edges, where edges[i] = [ai, bi], represents an edge between ai, and bi. Identify one edge that, if removed, will turn the graph into a tree. A tree is a graph that is connected and has no cycles. Assume that the graph is always reducible to a tree by removing just one edge. If there are multiple answers, return the edge that occurs last in the input. Examples Example 1: Input: [[1,2], [1,3], [3,4], [1,4], [1,5]] Expected Output: [1,4] Justification: The edge [1,4] is redundant because removing it will eliminate the cycle 1-3-4-1 while keeping the graph connected. Example 2: Input: [[1,2], [2,3], [3,1], [3,4]] Expected Output: [3,1] Justification: The edge [3,1] creates a cycle 1-2-3-1. Removing it leaves a tree with no cycles. Example 3: Input: [[1,2], [2,3], [3,4], [4,2], [5,6]] Expected Output: [4,2] Justification: The edge [4,2] adds a cycle 2-3-4-2 in one part of the graph. Removing this edge breaks the cycle, and the remaining graph is a tree. Constraints: n == edges.length 3 &lt;= n &lt;= 1000 edges[i].length == 2 1 &lt;= ai &lt; bi &lt;= edges.length ai != bi There are no repeated edges. The given graph is connected. SolutionThe solution to this problem employs the Union-Find algorithm, which is effective for cycle detection in graphs. Initially, each node is considered as a separate set. As we iterate through the edges of the graph, we use the Union-Find approach to determine if the nodes connected by the current edge are already part of the same set. If they are, it indicates the presence of a cycle, and this edge is the redundant one. Otherwise, unite these two sets, meaning connect the nodes without forming a cycle. This approach focuses on progressively merging nodes into larger sets while keeping an eye out for the edge that connects nodes already in the same set. Here’s how we’ll apply it: Initialize an array to represent each node’s parent. Initially, each node is its own parent, indicating that they are each in their own separate sets. Iterate through the list of edges. For each edge, apply the “Find” operation to both nodes. If the nodes have different parents, they belong to different sets, and we can union them by pointing the parent of one to the other. If the “Find” operation reveals that the two nodes already share a parent, then they’re in the same set, meaning the edge under consideration creates a cycle. This edge is the redundant connection we’re looking for. The process ends once we find the redundant connection or after processing all edges. This approach works as it precisely detects cycles in the way trees should not have them. It’s efficient because the “Union” and “Find” operations can be optimized to almost constant time complexity with path compression and union by rank. Algorithm Walkthrough:Consider the input [[1,2], [1,3], [3,4], [1,4], [1,5]]. Initialize the parent array where parent[i] = i. Consider the edge [1,2]: Find the parents of 1 and 2. Since they’re different, union them by making one the parent of the other. Next, consider the edge [1,3]: Their parents are different, so union them. Now, consider the edge [3,4]: Again, different parents, so union them. Consider the edge [1,4]: Find operations for both nodes return the same parent, indicating a cycle. We identify [1,4] as the redundant edge. Code1234567891011121314151617181920212223242526272829303132class Solution: def findRedundantConnection(self, edges): parent = [i for i in range(len(edges) + 1)] def find(node): if parent[node] != node: parent[node] = find(parent[node]) # Path compression return parent[node] def union(node1, node2): parent[find(node1)] = find(node2) # Union for edge in edges: node1, node2 = edge if find(node1) == find(node2): return edge # Redundant connection found union(node1, node2) return []if __name__ == &#x27;__main__&#x27;: solution = Solution() # Test the algorithm with the three example inputs example1 = [[1,2], [1,3], [3,4], [1,4], [1,5]] example2 = [[1,2], [2,3], [3,1], [3,4]] example3 = [[1,2], [2,3], [3,4], [4,2], [5,6]] print(&quot;Example 1:&quot;, solution.findRedundantConnection(example1)) print(&quot;Example 2:&quot;, solution.findRedundantConnection(example2)) print(&quot;Example 3:&quot;, solution.findRedundantConnection(example3)) Complexity Analysis: Time Complexity: The time complexity is O(N log N), where N is the number of nodes, due to the Union-Find operations with path compression over all edges.). Space Complexity: The space complexity is (O(N)), since we maintain a parent array of size (N) where (N) is the number of vertices. Number of Provinces547. Number of Provinces Design Gurus 和Pattern Island中的Number of Islands 类似。这道题的matrix表示的是邻接矩阵，可以使用并查集。 同时这道题在Pattern Graph中也出现了，也可以使用DFS。 Number of Islands表示的是陆地和海洋，适合使用DFS. Problem StatementThere are n cities. Some of them are connected in a network. If City A is directly connected to City B, and City B is directly connected to City C, city A is directly connected to City C. If a group of cities are connected directly or indirectly, they form a province. You are given a square matrix of size n x n, where each cell’s value indicates whether a direct connection between cities exists (1 for connected and 0 for not connected). Determine the total number of provinces. Examples Example 1: Input: [[1,1,0],[1,1,1],[0,1,1]] Expected Output: 1 Justification: Here, all cities are connected either directly or indirectly, forming one province. Example 2: Input: [[1,0,0],[0,1,0],[0,0,1]] Expected Output: 3 Justification: In this scenario, no cities are connected to each other, so each city forms its own province. Example 3: Input: [[1,0,0,1],[0,1,1,0],[0,1,1,0],[1,0,0,1]] Expected Output: 2 Justification: Cities 1 and 4 form a province, and cities 2 and 3 form another province, resulting in a total of 2 provinces. Constraints: 1 &lt;= n &lt;= 200 n == isConnected.length n == isConnected[i].length isConnected[i][j] is 1 or 0. isConnected[i][i] == 1 isConnected[i][j] == isConnected[j][i] SolutionTo solve this problem, we’ll employ the Union-Find algorithm, a powerful tool for managing disjoint sets. The essence of the approach is to group cities into sets, where each set represents a connected province. Initially, every city is considered its own province. As we go through the matrix, we use Union operations to join cities that are directly connected, effectively merging their sets. The Find operation identifies the representative of each set (or province) and helps in determining if two cities are already in the same province. By iteratively applying Union operations to all connected city pairs, we merge their respective sets. In the end, the number of distinct sets (or provinces) is determined by counting the unique representatives of each set, providing the solution to our problem. This approach ensures efficient handling of connections and an accurate count of disconnected provinces. Here’s a detailed explanation: Initialization: We initialize an array parent to keep track of the root of each node. Each node is initially its own parent. Union Operation: If two nodes belong to different sets (different parents), we connect them by making the root of one the parent of the other, effectively merging the sets. Find Operation with Path Compression: When we wish to determine which set a node belongs to, we find its root. If during this search we traverse nodes, we directly connect them to the root to flatten the structure, which speeds up future ‘find’ operations. Counting Provinces: We start with the assumption that each node is its own province. As we connect nodes, we decrement the count of provinces. This approach is efficient due to path compression, which flattens the tree structure used internally, leading to very fast subsequent find operations. Algorithm WalkthroughGiven an input isConnected = [[1,1,0],[1,1,0],[0,0,1]], let’s walk through the algorithm: Initialize parent to [0, 1, 2]. Compare node 0 with node 1, they are connected. Union them, parent becomes [0, 0, 2]. Provinces decrement to 2. Compare node 0 with node 2, no connection. Skip. Compare node 1 with node 2, no connection. Skip. The final count of provinces is 2. Code1234567891011121314151617181920212223242526272829303132333435363738394041class Solution: def __init__(self): self.parent = [] # Initialize an empty list to store parent nodes. def find(self, i): if self.parent[i] != i: self.parent[i] = self.find(self.parent[i]) # Apply path compression to optimize the find operation. return self.parent[i] def union(self, i, j): self.parent[self.find(i)] = self.find(j) # Union two nodes by updating their parent pointers. def findProvinces(self, isConnected): n = len(isConnected) self.parent = list(range(n)) # Initialize parent array to represent individual provinces. provinces = n # Initialize the count of provinces to the total number of nodes. for i in range(n): for j in range(i + 1, n): if isConnected[i][j] == 1 and self.find(i) != self.find(j): self.union(i, j) # Connect nodes if they are connected and belong to different provinces. provinces -= 1 # Decrement the count of provinces when merging. return provinces # Return the count of provinces remaining.# Example Test Casesif __name__ == &#x27;__main__&#x27;: solution = Solution() # Example 1 example1 = [[1,1,0],[1,1,0],[0,0,1]] print(solution.findProvinces(example1)) # Expected Output: 2 # Example 2 example2 = [[1,0,0],[0,1,0],[0,0,1]] print(solution.findProvinces(example2)) # Expected Output: 3 # Example 3 example3 = [[1,0,0,1],[0,1,1,0],[0,1,1,0],[1,0,0,1]] print(solution.findProvinces(example3)) # Expected Output: 2 Complexity AnalysisTime Complexity: The time complexity is O(n^3) in the worst case, where n is the number of nodes. This is because the union and find operations can take O(n) time without optimizations and we perform up to O(n^2) comparisons. However, with path compression and union by rank, the amortized time complexity of each union-find operation can be reduced to nearly O(1), making the algorithm run in nearly O(n^2) time. Space complexity: The space complexity is O(n) for storing the parent array. Is Graph Bipartite?785. Is Graph Bipartite? Design Gurus Problem StatementGiven a 2D array graph[][], representing the undirected graph, where graph[u] is an array of nodes that are connected with node u. Determine whether a given undirected graph is a bipartite graph. The graph is a bipartite graph, if we can split the set of nodes into two distinct subsets such that no two nodes within the same subset are adjacent (i.e., no edge exists between any two nodes within a single subset). Examples Example 1: Input: [[1,3], [0,2], [1,3], [0,2]] Expected Output: true Justification: The nodes can be divided into two groups: {0, 2} and {1, 3}. No two nodes within each group are adjacent, thus the graph is bipartite. Example 2: Input: [[1], [0], [3], [2]] Expected Output: true Justification: The graph is a simple chain of 4 nodes. It’s clearly bipartite as we can have {0, 2} and {1, 3} as the two subsets. Example 3: Input: [[1,2,3],[0,2],[0,1,3],[0,2]] Expected Output: false Justification: We found that edges (1, 2), (1, 3), and (2, 3) connect nodes within the same set, which violates the condition for a bipartite graph where each edge must connect nodes in different subsets. Thus, there’s no way to divide this graph into two subsets that satisfy the bipartite condition. Constraints: graph.length == n 1 &lt;= n &lt;= 100 0 &lt;= graph[u].length &lt; n 0 &lt;= graph[u][i] &lt;= n - 1 graph[u] does not contain u. All the values of graph[u] are unique. If graph[u] contains v, then graph[v] contains u. SolutionTo check if a graph can be bipartitioned, we employ the Union Find strategy. Initially, each node is treated as a distinct set, signifying that every node is in its own group. As we progress, each edge in the graph is examined. The pivotal aspect here is to determine whether the nodes connected by an edge are in different sets. If they are in the same set, it indicates a violation of the bipartition condition. For edges connecting nodes in separate sets, we perform a union operation, merging these sets. This step is crucial as it helps in grouping the nodes in a manner that allows for a potential bipartition. Throughout this process, path compression flattens the structure of the sets, speeding up subsequent operations. The graph can be considered bipartite if, after evaluating all edges, no adjacent nodes are found in the same set. However, if any adjacent nodes are in the same set, the graph fails the bipartition test. This method effectively uses the concept of disjoint sets to determine if a given graph can be split into two groups without any overlapping edges. Step-by-step algorithm要看能不能分为两个部分，并且每一个部分中的任何两个节点都有相连，那就是说如果我们遍历和一个节点i相邻的所有节点的时候，这些和节点i相邻的节点应该划分为同一个簇，因为他们都不能和节点i在以一个group里，所以只能在i的对立。在遍历的过程中如果发现一个edge连接的两个点已经在一个group了，那就应该return false. Code1234567891011121314151617181920212223242526272829303132333435class Solution: def isBipartite(self, graph): # Initialize parent list, initially each node is its own parent parent = [i for i in range(len(graph))] # Define a function to find the parent of a node using path compression def find(node): if parent[node] != node: parent[node] = find(parent[node]) # Path compression return parent[node] # Define a function to perform union of two nodes by updating their parents def union(node1, node2): parent[find(node1)] = find(node2) # Iterate through each node in the graph for u in range(len(graph)): if graph[u]: parentU = find(u) # Find the parent of the current node firstNeighbor = graph[u][0] # Get the first neighbor of the current node # Iterate through neighbors of the current node for v in graph[u]: if find(v) == parentU: # Check for a conflict in the same partition return False # If conflict is detected, the graph is not bipartite union(firstNeighbor, v) # Union the first neighbor with the current neighbor return True# Example usagesol = Solution()print(sol.isBipartite([[1, 3], [0, 2], [1, 3], [0, 2]])) # Trueprint(sol.isBipartite([[1], [0], [3], [2]])) # Trueprint(sol.isBipartite([[1, 2, 3], [0, 2], [0, 1, 3], [0, 2]])) # False Complexity AnalysisTime complexity: Each union and find operation can be considered almost O(1) due to path compression. The main loop processes each edge once, and there are E edges in the graph. Hence, the time complexity is O(E), where E is the number of edges in the graph. Space complexity: We use an array to represent the union-find structure. This array has a size equal to the number of vertices V. Hence, the space complexity is O(V), where V is the number of vertices in the graph. # Path With Minimum EffortProblem StatementGiven a 2D array heights[][] of size n x m, where heights[n][m] represents the height of the cell (n, m). Find a path from the top-left corner to the bottom-right corner that minimizes the effort required to travel between consecutive points, where effort is defined as the maximum absolute difference in height between two points in a path. In a single step, you can either move up, down, left or right. Determine the minimum effort required for any path from the first point to the last.(找一条路径中最大的effort,并且这个effort需要是所有路径中最大effort中最小的) Example GenerationExample 1: Input: [[1,2,3],[3,8,4],[5,3,5]] Expected Output: 1 Justification: The path with the minimum effort is along the edges of the grid (right, right, down, down) which requires an effort of 1 between each pair of points. Example 2: Input: [[1,2,2],[3,3,3],[5,3,1]] Expected Output: 2 Justification: The path that minimizes the maximum effort goes through (1,2,2,3,1), which has a maximum effort of 2 (from 3 to 1). Example 3: Input: [[1,1,1],[1,1,1],[1,1,1]] Expected Output: 0 Justification: The path that minimizes the maximum effort goes through (1,1,1,1,1), which has a maximum effort of 0. Constraints: rows == heights.length columns == heights[i].length 1 &lt;= rows, columns &lt;= 100 1 &lt;= heights[i][j] &lt;= 106 SolutionTo solve this problem, we’ll employ the Union Find algorithm. The core idea here is to sort all the edges (the differences in elevation between adjacent cells) in ascending order. Then, starting from the smallest edge, we’ll progressively unite adjacent cells in the grid. The process of uniting cells involves linking together cells that can be reached with the current maximum effort level. This step is crucial because it helps to build a path incrementally while ensuring that we keep the effort as low as possible. We continue this process of uniting cells until the top-left cell and the bottom-right cell are connected. At this point, the current maximum effort level represents the minimum effort needed to traverse from the start to the end. This method efficiently finds the path with the least resistance while considering all possible paths and their associated efforts. The algorithm involves the following steps: Step 1: Initialization Create a UnionFind instance for a 3x3 grid, resulting in 9 elements (0 to 8). Initialize an empty list to store edges. Step 2: Building Edges Iterate over each cell in the grid. For each cell, calculate the absolute difference in elevation with its right and bottom neighbors (if they exist). Step 3: Sorting Edges Sort the edges by their elevation difference in ascending order. Step 4: Perform Union-Find Operations For each edge in the sorted list, perform the following: Extract the two cells (cell1 and cell2) and their elevation difference from the edge. Perform the union operation on cell1 and cell2. Step 5: Union Operation In the union function, find the roots of both cell1 and cell2 using the find method. If the roots are different, join the two sets. If one set has a higher rank (depth), make it the parent of the other. If both sets have equal rank, make one the parent of the other and increase the rank of the parent. Step 6: Find Operation In the find method, for a given cell, find the root of the set to which it belongs. Implement path compression: Set each cell along the way to point directly to the root. This optimizes future find operations. Step 7: Check for Connection After each union operation, check if the start cell (0,0) and the end cell (2,2) are connected. This is done by checking if the roots of cell 0 and cell 8 (in the UnionFind structure) are the same. If they are connected, stop the process. Step 8: Result The elevation difference of the last processed edge that connected the start and end cells is the minimum effort required. Algorithm WalkthroughStep 1: Initialization Initialize a UnionFind instance for a 3x3 grid, resulting in 9 elements. Create an empty list to store the edges. Step 2: Building Edges Iterate through each cell in the grid and calculate the absolute differences with its right and bottom neighbors (if they exist). For the input [[1,2,3],[3,8,4],[5,3,5]], create edges with their differences: Between (0,0) and (0,1): |1-2| = 1 Between (0,1) and (0,2): |2-3| = 1 Between (0,0) and (1,0): |1-3| = 2 Between (1,0) and (2,0): |3-5| = 2 Between (1,0) and (1,1): |3-8| = 5 Between (1,1) and (1,2): |8-4| = 4 Between (0,1) and (1,1): |2-8| = 6 Between (1,1) and (2,1): |8-3| = 5 Between (0,2) and (1,2): |3-4| = 1 Between (1,2) and (2,2): |4-5| = 1 Between (2,0) and (2,1): |5-3| = 2 Between (2,1) and (2,2): |3-5| = 2 Step 3: Union-Find Operations First, we sort the edges by their differences: Edges with Difference = 1: (0,0) and (0,1): Difference = 1 (0,1) and (0,2): Difference = 1 (0,2) and (1,2): Difference = 1 (1,2) and (2,2): Difference = 1 Edges with Difference = 2: (0,0) and (1,0): Difference = 2 (1,0) and (2,0): Difference = 2 (2,0) and (2,1): Difference = 2 (2,1) and (2,2): Difference = 2 Edges with Higher Differences (not initially relevant for the desired path). Now, let’s perform the Union-Find operations: Processing Edges with Difference = 1 Union (0,0) and (0,1): Connects cells 0 and 1. Parents: [0, 0, 2, 3, 4, 5, 6, 7, 8]. Union (0,1) and (0,2): Connects cells 1 and 2 (and hence 0 with 2). Parents: [0, 0, 0, 3, 4, 5, 6, 7, 8]. Union (0,2) and (1,2): Connects cells 2 and 5. Parents: [0, 0, 0, 3, 4, 0, 6, 7, 8]. Union (1,2) and (2,2): Connects cells 5 and 8. Parents: [0, 0, 0, 3, 4, 0, 6, 7, 0]. At this step, cells 0 and 8 are connected. The last edge difference is 1. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class UnionFind: def __init__(self, size): self.parent = [i for i in range(size)] # Initialize parent array self.rank = [0] * size # Initialize rank array def find(self, x): if self.parent[x] != x: # Path compression: If x is not its own parent, find its root parent. self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): rootX = self.find(x) # Find root parent of x rootY = self.find(y) # Find root parent of y if rootX != rootY: # Union the sets if they have different root parents if self.rank[rootX] &gt; self.rank[rootY]: # Union by rank: Attach the shorter tree to the taller one self.parent[rootY] = rootX elif self.rank[rootX] &lt; self.rank[rootY]: self.parent[rootX] = rootY else: # If ranks are equal, choose any root to be the new parent and increase rank self.parent[rootY] = rootX self.rank[rootX] += 1class Solution: def minimumEffortPath(self, heights): row, col = len(heights), len(heights[0]) uf = UnionFind(row * col) # Initialize Union-Find data structure edges = [] for i in range(row): for j in range(col): if i &gt; 0: # Add edge to the cell above (if it exists) edges.append((i * col + j, (i - 1) * col + j, abs(heights[i][j] - heights[i - 1][j]))) if j &gt; 0: # Add edge to the cell on the left (if it exists) edges.append((i * col + j, i * col + (j - 1), abs(heights[i][j] - heights[i][j - 1]))) edges.sort(key=lambda x: x[2]) # Sort edges by the difference in heights for x, y, diff in edges: # Iterate through sorted edges uf.union(x, y) # Union the cells connected by the edge if uf.find(0) == uf.find( row * col - 1): # If the source and destination cells are connected, return the effort return diff return 0# Examplessol = Solution()print(&quot;Example 1:&quot;, sol.minimumEffortPath([[1, 2, 3], [3, 8, 4], [5, 3, 5]])) # Expected Output: 1print(&quot;Example 2:&quot;, sol.minimumEffortPath([[1, 2, 2], [3, 3, 3], [5, 3, 1]])) # Expected Output: 2print(&quot;Example 3:&quot;, sol.minimumEffortPath([[1, 1, 1], [1, 1, 1], [1, 1, 1]])) # Expected Output: 0 Complexity AnalysisTime Complexity: The time complexity of this algorithm is primarily dictated by the sorting of the edges. If there are n cells, we can have at most 2n edges (since each cell can have at most 2 outgoing edges to its right and bottom neighbors). Sorting 2n edges takes O(2n log(2n)), which simplifies to O(n log n). The union-find operations (find and union) take O(n) time each. Hence, the overall time complexity is O(n log n). Space Complexity: The space complexity is O(n) for storing the parents and ranks in the union-find data structure and the edge list.","categories":[{"name":"Grokking Interview Pattern","slug":"Grokking-Interview-Pattern","permalink":"https://hasuer.github.io/categories/Grokking-Interview-Pattern/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hasuer.github.io/tags/Interview/"}]},{"title":"24. Pattern Topological Sort (Graph)","slug":"24. Pattern Topological Sort (Graph)","date":"2024-05-24T06:25:49.000Z","updated":"2024-05-28T03:30:51.175Z","comments":true,"path":"24-pattern-topological-sort-graph/index.html","link":"","permalink":"https://hasuer.github.io/24-pattern-topological-sort-graph/index.html","excerpt":"","text":"416. Partition Equal Subset Sum Design Gurus Educative.io IntroductionTopological Sort is used to find a linear ordering of elements that have dependencies on each other. For example, if event ‘B’ is dependent on event ‘A’, ‘A’ comes before ‘B’ in topological ordering. This pattern defines an easy way to understand the technique for performing topological sorting of a set of elements and then solves a few problems using it. Let’s see this pattern in action. *Topological Sort (medium)Design Gurus Educative.io Problem StatementTopological Sort of a directed graph (a graph with unidirectional edges) is a linear ordering of its vertices such that for every directed edge (U, V) from vertex U to vertex V, U comes before V in the ordering. Given a directed graph, find the topological ordering of its vertices. Example 1: 1234Input: Vertices=4, Edges=[3, 2], [3, 0], [2, 0], [2, 1]Output: Following are the two valid topological sorts for the given graph:1) 3, 2, 0, 12) 3, 2, 1, 0 Example 2: 1234567Input: Vertices=5, Edges=[4, 2], [4, 3], [2, 0], [2, 1], [3, 1]Output: Following are all valid topological sorts for the given graph:1) 4, 2, 3, 0, 12) 4, 3, 2, 0, 13) 4, 3, 2, 1, 04) 4, 2, 3, 1, 05) 4, 2, 0, 3, 1 Example 3: 12345678910Input: Vertices=7, Edges=[6, 4], [6, 2], [5, 3], [5, 4], [3, 0], [3, 1], [3, 2], [4, 1]Output: Following are all valid topological sorts for the given graph:1) 5, 6, 3, 4, 0, 1, 22) 6, 5, 3, 4, 0, 1, 23) 5, 6, 4, 3, 0, 2, 14) 6, 5, 4, 3, 0, 1, 25) 5, 6, 3, 4, 0, 2, 16) 5, 6, 3, 4, 1, 2, 0 There are other valid topological ordering of the graph too. SolutionThe basic idea behind the topological sort is to provide a partial ordering among the vertices of the graph such that if there is an edge from U to V then U≤V i.e., U comes before V in the ordering. Here are a few fundamental concepts related to topological sort: Source: Any node that has no incoming edge and has only outgoing edges is called a source. Sink: Any node that has only incoming edges and no outgoing edge is called a sink. So, we can say that a topological ordering starts with one of the sources and ends at one of the sinks. A topological ordering is possible only when the graph has no directed cycles, i.e. if the graph is a Directed Acyclic Graph (DAG). If the graph has a cycle, some vertices will have cyclic dependencies which makes it impossible to find a linear ordering among vertices. To find the topological sort of a graph we can traverse the graph in a Breadth First Search (BFS) way. We will start with all the sources, and in a stepwise fashion, save all sources to a sorted list. We will then remove all sources and their edges from the graph. After the removal of the edges, we will have new sources, so we will repeat the above process until all vertices are visited. Here is the visual representation of this algorithm for Example-3: This is how we can implement this algorithm: a. Initialization We will store the graph in Adjacency Lists, which means each parent vertex will have a list containing all of its children. We will do this using a HashMap where the ‘key’ will be the parent vertex number and the value will be a List containing children vertices. To find the sources, we will keep a HashMap to count the in-degrees i.e., count of incoming edges of each vertex. Any vertex with ‘0’ in-degree will be a source. b. Build the graph and find in-degrees of all vertices We will build the graph from the input and populate the in-degrees HashMap. c. Find all sources All vertices with ‘0’ in-degrees will be our sources and we will store them in a Queue. d. Sort For each source, do the following things: Add it to the sorted list. Get all of its children from the graph. Decrement the in-degree of each child by 1. If a child’s in-degree becomes ‘0’, add it to the sources Queue. Repeat step 1, until the source Queue is empty. CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from collections import dequeclass Solution: def sort(self, vertices, edges): sortedOrder = [] if vertices &lt;= 0: return sortedOrder # a. Initialize the graph inDegree = &#123;i: 0 for i in range(vertices)&#125; # count of incoming edges graph = &#123;i: [] for i in range(vertices)&#125; # adjacency list graph # b. Build the graph for edge in edges: parent, child = edge[0], edge[1] graph[parent].append(child) # put the child into it&#x27;s parent&#x27;s list inDegree[child] += 1 # increment child&#x27;s inDegree # c. Find all sources i.e., all vertices with 0 in-degrees sources = deque() for key in inDegree: if inDegree[key] == 0: sources.append(key) # d. For each source, add it to the sortedOrder and subtract &#x27;1&#x27; from all of its # children&#x27;s in-degrees if a child&#x27;s in-degree becomes zero, add it to sources queue while sources: vertex = sources.popleft() sortedOrder.append(vertex) for child in graph[vertex]: # get the node&#x27;s children to decrement their in-degrees inDegree[child] -= 1 if inDegree[child] == 0: sources.append(child) # topological sort is not possible as the graph has a cycle if len(sortedOrder) != vertices: return [] return sortedOrderdef main(): sol = Solution() print(&quot;Topological sort: &quot; + str(sol.sort(4, [[3, 2], [3, 0], [2, 0], [2, 1]]))) print(&quot;Topological sort: &quot; + str(sol.sort(5, [[4, 2], [4, 3], [2, 0], [2, 1], [3, 1]]))) print(&quot;Topological sort: &quot; + str(sol.sort(7, [[6, 4], [6, 2], [5, 3], [5, 4], \\ [3, 0], [3, 1], [3, 2], [4, 1]])))main() Time ComplexityIn step ‘d’, each vertex will become a source only once and each edge will be accessed and removed once. Therefore, the time complexity of the above algorithm will be O(V+E), where ‘V’ is the total number of vertices and ‘E’ is the total number of edges in the graph. Space ComplexityThe space complexity will be O(V+E), since we are storing all of the edges for each vertex in an adjacency list. Similar ProblemsProblem 1: Find if a given Directed Graph has a cycle in it or not. Solution: If we can’t determine the topological ordering of all the vertices of a directed graph, the graph has a cycle in it. This was also referred to in the above code: 12if (sortedOrder.size() != vertices) // topological sort is not possible as the graph has a cycle return new ArrayList&lt;&gt;(); Tasks Scheduling (medium)Top Interview 150 | 207. Course Schedule Design Gurus Educative.io Problem StatementThere are ‘N’ tasks, labeled from ‘0’ to ‘N-1’. Each task can have some prerequisite tasks which need to be completed before it can be scheduled. Given the number of tasks and a list of prerequisite pairs, find out if it is possible to schedule all the tasks. Example 1: 1234Input: Tasks=3, Prerequisites=[0, 1], [1, 2]Output: trueExplanation: To execute task &#x27;1&#x27;, task &#x27;0&#x27; needs to finish first. Similarly, task &#x27;1&#x27; needs to finish before &#x27;2&#x27; can be scheduled. A possible sceduling of tasks is: [0, 1, 2] Example 2: 123Input: Tasks=3, Prerequisites=[0, 1], [1, 2], [2, 0]Output: falseExplanation: The tasks have cyclic dependency, therefore they cannot be sceduled. Example 3: 123Input: Tasks=6, Prerequisites=[2, 5], [0, 5], [0, 4], [1, 4], [3, 2], [1, 3]Output: trueExplanation: A possible sceduling of tasks is: [0 1 4 3 2 5] SolutionThis problem is asking us to find out if it is possible to find a topological ordering of the given tasks. The tasks are equivalent to the vertices and the prerequisites are the edges. We can use a similar algorithm as described in Topological Sort to find the topological ordering of the tasks. If the ordering does not include all the tasks, we will conclude that some tasks have cyclic dependencies. CodeHere is what our algorithm will look like (only the highlighted lines have changed): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# 和上一题一摸一样from collections import dequeclass Solution: def isSchedulingPossible(self, tasks, prerequisites): sortedOrder = [] if tasks &lt;= 0: return False # a. Initialize the graph inDegree = &#123;i: 0 for i in range(tasks)&#125; # count of incoming edges graph = &#123;i: [] for i in range(tasks)&#125; # adjacency list graph # b. Build the graph for prerequisite in prerequisites: parent, child = prerequisite[0], prerequisite[1] graph[parent].append(child) # put the child into it&#x27;s parent&#x27;s list inDegree[child] += 1 # increment child&#x27;s inDegree # c. Find all sources i.e., all vertices with 0 in-degrees sources = deque() for key in inDegree: if inDegree[key] == 0: sources.append(key) # d. For each source, add it to the sortedOrder and subtract one from all of its # children&#x27;s in-degrees if a child&#x27;s in-degree becomes zero, add it to sources queue while sources: vertex = sources.popleft() sortedOrder.append(vertex) for child in graph[vertex]: # get the node&#x27;s children to decrement their in-degrees inDegree[child] -= 1 if inDegree[child] == 0: sources.append(child) # if sortedOrder doesn&#x27;t contain all tasks, there is a cyclic dependency between # tasks, therefore, we will not be able to schedule all tasks return len(sortedOrder) == tasksdef main(): sol = Solution() print(&quot;Is scheduling possible: &quot; + str(sol.isSchedulingPossible(3, [[0, 1], [1, 2]]))) print(&quot;Is scheduling possible: &quot; + str(sol.isSchedulingPossible(3, [[0, 1], [1, 2], [2, 0]]))) print(&quot;Is scheduling possible: &quot; + str(sol.isSchedulingPossible(6, [[2, 5], [0, 5], [0, 4], [1, 4], [3, 2], [1, 3]])))main() Time complexityIn step ‘d’, each task can become a source only once and each edge (prerequisite) will be accessed and removed once. Therefore, the time complexity of the above algorithm will be O(V+E), where ‘V’ is the total number of tasks and ‘E’ is the total number of prerequisites. Space complexityThe space complexity will be O(V+E), since we are storing all of the prerequisites for each task in an adjacency list. Similar ProblemsCourse Schedule: There are ‘N’ courses, labeled from ‘0’ to ‘N-1’. Each course can have some prerequisite courses which need to be completed before it can be taken. Given the number of courses and a list of prerequisite pairs, find if it is possible for a student to take all the courses. Solution: This problem is exactly similar to our parent problem. In this problem, we have courses instead of tasks. Tasks Scheduling Order (medium)Top Interview 150 | 210. Course Schedule II Design Gurus Educative.io Problem StatementThere are ‘N’ tasks, labeled from ‘0’ to ‘N-1’. Each task can have some prerequisite tasks which need to be completed before it can be scheduled. Given the number of tasks and a list of prerequisite pairs, write a method to find the ordering of tasks we should pick to finish all tasks. Example 1: 1234Input: Tasks=3, Prerequisites=[0, 1], [1, 2]Output: [0, 1, 2]Explanation: To execute task &#x27;1&#x27;, task &#x27;0&#x27; needs to finish first. Similarly, task &#x27;1&#x27; needs to finish before &#x27;2&#x27; can be scheduled. A possible scheduling of tasks is: [0, 1, 2] Example 2: 123Input: Tasks=3, Prerequisites=[0, 1], [1, 2], [2, 0]Output: []Explanation: The tasks have cyclic dependency, therefore they cannot be scheduled. Example 3: 123Input: Tasks=6, Prerequisites=[2, 5], [0, 5], [0, 4], [1, 4], [3, 2], [1, 3]Output: [0 1 4 3 2 5] Explanation: A possible scheduling of tasks is: [0 1 4 3 2 5] SolutionThis problem is similar to Tasks Scheduling, the only difference being that we need to find the best ordering of tasks so that it is possible to schedule them all. CodeHere is what our algorithm will look like (only the highlighted lines have changed): 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from collections import dequeclass Solution: def findOrder(self, tasks, prerequisites): sortedOrder = [] if tasks &lt;= 0: return sortedOrder # a. Initialize the graph inDegree = &#123;i: 0 for i in range(tasks)&#125; # count of incoming edges graph = &#123;i: [] for i in range(tasks)&#125; # adjacency list graph # b. Build the graph for prerequisite in prerequisites: parent, child = prerequisite[0], prerequisite[1] graph[parent].append(child) # put the child into it&#x27;s parent&#x27;s list inDegree[child] += 1 # increment child&#x27;s inDegree # c. Find all sources i.e., all vertices with 0 in-degrees sources = deque() for key in inDegree: if inDegree[key] == 0: sources.append(key) # d. For each source, add it to the sortedOrder and subtract one from all of its # children&#x27;s in-degrees if a child&#x27;s in-degree becomes zero, add it to sources queue while sources: vertex = sources.popleft() sortedOrder.append(vertex) for child in graph[vertex]: # get the node&#x27;s children to decrement their in-degrees inDegree[child] -= 1 if inDegree[child] == 0: sources.append(child) # if sortedOrder doesn&#x27;t contain all tasks, there is a cyclic dependency between # tasks, therefore, we will not be able to schedule all tasks if len(sortedOrder) != tasks: return [] return sortedOrderdef main(): sol = Solution() print(&quot;Is scheduling possible: &quot; + str(sol.findOrder(3, [[0, 1], [1, 2]]))) print(&quot;Is scheduling possible: &quot; + str(sol.findOrder(3, [[0, 1], [1, 2], [2, 0]]))) print(&quot;Is scheduling possible: &quot; + str(sol.findOrder(6, [[2, 5], [0, 5], [0, 4], [1, 4], [3, 2], [1, 3]])))main() Time complexityIn step ‘d’, each task can become a source only once and each edge (prerequisite) will be accessed and removed once. Therefore, the time complexity of the above algorithm will be O(V+E), where ‘V’ is the total number of tasks and ‘E’ is the total number of prerequisites. Space complexityThe space complexity will be O(V+E), since we are storing all of the prerequisites for each task in an adjacency list. Similar ProblemsCourse Schedule: There are ‘N’ courses, labeled from ‘0’ to ‘N-1’. Each course has some prerequisite courses which need to be completed before it can be taken. Given the number of courses and a list of prerequisite pairs, write a method to find the best ordering of the courses that a student can take in order to finish all courses. Solution: This problem is exactly similar to our parent problem. In this problem, we have courses instead of tasks. *All Tasks Scheduling Orders (hard)Design Gurus Educative.io Problem StatementThere are ‘N’ tasks, labeled from ‘0’ to ‘N-1’. Each task can have some prerequisite tasks which need to be completed before it can be scheduled. Given the number of tasks and a list of prerequisite pairs, write a method to print all possible ordering of tasks meeting all prerequisites. Example 1: 123Input: Tasks=3, Prerequisites=[0, 1], [1, 2]Output: [0, 1, 2]Explanation: There is only possible ordering of the tasks. Example 2: 12345Input: Tasks=4, Prerequisites=[3, 2], [3, 0], [2, 0], [2, 1]Output: 1) [3, 2, 0, 1]2) [3, 2, 1, 0]Explanation: There are two possible orderings of the tasks meeting all prerequisites. Example 3: 123456789101112131415Input: Tasks=6, Prerequisites=[2, 5], [0, 5], [0, 4], [1, 4], [3, 2], [1, 3]Output: 1) [0, 1, 4, 3, 2, 5]2) [0, 1, 3, 4, 2, 5]3) [0, 1, 3, 2, 4, 5]4) [0, 1, 3, 2, 5, 4]5) [1, 0, 3, 4, 2, 5]6) [1, 0, 3, 2, 4, 5]7) [1, 0, 3, 2, 5, 4]8) [1, 0, 4, 3, 2, 5]9) [1, 3, 0, 2, 4, 5]10) [1, 3, 0, 2, 5, 4]11) [1, 3, 0, 4, 2, 5]12) [1, 3, 2, 0, 5, 4]13) [1, 3, 2, 0, 4, 5] SolutionThis problem is similar to Tasks Scheduling Order the only difference is that we need to find all the topological orderings of the tasks. At any stage, if we have more than one source available and since we can choose any source, therefore, in this case, we will have multiple orderings of the tasks. We can use a recursive approach with Backtracking to consider all sources at any step. CodeHere is what our algorithm will look like: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283from collections import dequeclass Solution: def __init__(self): self.orders = [] def printOrders(self, tasks, prerequisites): sortedOrder = [] if tasks &lt;= 0: return self.orders # a. Initialize the graph inDegree = &#123;i: 0 for i in range(tasks)&#125; # count of incoming edges graph = &#123;i: [] for i in range(tasks)&#125; # adjacency list graph # b. Build the graph for prerequisite in prerequisites: parent, child = prerequisite[0], prerequisite[1] graph[parent].append(child) # put the child into it&#x27;s parent&#x27;s list inDegree[child] += 1 # increment child&#x27;s inDegree # c. Find all sources i.e., all vertices with 0 in-degrees sources = deque() for key in inDegree: if inDegree[key] == 0: sources.append(key) self.print_all_topological_sorts(graph, inDegree, sources, sortedOrder) return self.orders def print_all_topological_sorts(self, graph, inDegree, sources, sortedOrder): if sources: for vertex in sources: sortedOrder.append(vertex) sourcesForNextCall = deque(sources) # make a copy of sources # only remove the current source, all other sources should remain in the queue for # the next call sourcesForNextCall.remove(vertex) # get the node&#x27;s children to decrement their in-degrees for child in graph[vertex]: inDegree[child] -= 1 if inDegree[child] == 0: sourcesForNextCall.append(child) # recursive call to print other orderings from the remaining (and new) sources self.print_all_topological_sorts( graph, inDegree, sourcesForNextCall, sortedOrder) # backtrack, remove the vertex from the sorted order and put all of its children # back to consider the next source instead of the current vertex sortedOrder.remove(vertex) for child in graph[vertex]: inDegree[child] += 1 # if sortedOrder doesn&#x27;t contain all tasks, either we&#x27;ve a cyclic dependency between # tasks, or we have not processed all the tasks in this recursive call if len(sortedOrder) == len(inDegree): self.orders.append(sortedOrder.copy())def main(): sol = Solution() print(&quot;Task Orders: &quot;) result1 = sol.printOrders(3, [[0, 1], [1, 2]]) for order in result1: print(order) print(&quot;Task Orders: &quot;) result2 = sol.printOrders(4, [[3, 2], [3, 0], [2, 0], [2, 1]]) for order in result2: print(order) print(&quot;Task Orders: &quot;) result3 = sol.printOrders(6, [[2, 5], [0, 5], [0, 4], [1, 4], [3, 2], [1, 3]]) for order in result3: print(order)if __name__ == &quot;__main__&quot;: main() Time and Space ComplexityIf we don’t have any prerequisites, all combinations of the tasks can represent a topological ordering. As we know, that there can be N!N! combinations for ‘N’ numbers, therefore the time and space complexity of our algorithm will be O(V! E)* where ‘V’ is the total number of tasks and ‘E’ is the total prerequisites. We need the ‘E’ part because in each recursive call, at max, we remove (and add back) all the edges. *Alien Dictionary (hard)没咋看懂题目：应该是对于给定的单词列表，相邻的单词对比，找出第一个不同的字符，这个字符的顺序将定义一条有向边。Leetcode 269 会员 Design Gurus Educative.io Problem StatementThere is a dictionary containing words from an alien language for which we don’t know the ordering of the letters. Write a method to find the correct order of the letters in the alien language. It is given that the input is a valid dictionary and there exists an ordering among its letters. Example 1: 123456789Input: Words: [&quot;ba&quot;, &quot;bc&quot;, &quot;ac&quot;, &quot;cab&quot;]Output: bacExplanation: Given that the words are sorted lexicographically by the rules of the alien language, sofrom the given words we can conclude the following ordering among its characters: 1. From &quot;ba&quot; and &quot;bc&quot;, we can conclude that &#x27;a&#x27; comes before &#x27;c&#x27;.2. From &quot;bc&quot; and &quot;ac&quot;, we can conclude that &#x27;b&#x27; comes before &#x27;a&#x27; From the above two points, we can conclude that the correct character order is: &quot;bac&quot; Example 2: 12345678Input: Words: [&quot;cab&quot;, &quot;aaa&quot;, &quot;aab&quot;]Output: cabExplanation: From the given words we can conclude the following ordering among its characters: 1. From &quot;cab&quot; and &quot;aaa&quot;, we can conclude that &#x27;c&#x27; comes before &#x27;a&#x27;.2. From &quot;aaa&quot; and &quot;aab&quot;, we can conclude that &#x27;a&#x27; comes before &#x27;b&#x27; From the above two points, we can conclude that the correct character order is: &quot;cab&quot; Example 3: 1234567891011Input: Words: [&quot;ywx&quot;, &quot;wz&quot;, &quot;xww&quot;, &quot;xz&quot;, &quot;zyy&quot;, &quot;zwz&quot;]Output: ywxzExplanation: From the given words we can conclude the following ordering among its characters: 1. From &quot;ywx&quot; and &quot;wz&quot;, we can conclude that &#x27;y&#x27; comes before &#x27;w&#x27;.2. From &quot;wz&quot; and &quot;xww&quot;, we can conclude that &#x27;w&#x27; comes before &#x27;x&#x27;.3. From &quot;xww&quot; and &quot;xz&quot;, we can conclude that &#x27;w&#x27; comes before &#x27;z&#x27;4. From &quot;xz&quot; and &quot;zyy&quot;, we can conclude that &#x27;x&#x27; comes before &#x27;z&#x27;5. From &quot;zyy&quot; and &quot;zwz&quot;, we can conclude that &#x27;y&#x27; comes before &#x27;w&#x27; From the above five points, we can conclude that the correct character order is: &quot;ywxz&quot; Constraints: 1 &lt;= words.length &lt;= 100 1 &lt;= words[i].length &lt;= 100 words[i] consists of only lowercase English letters. SolutionSince the given words are sorted lexicographically by the rules of the alien language, we can always compare two adjacent words to determine the ordering of the characters. Take Example-1 above: [“ba”, “bc”, “ac”, “cab”] Take the first two words “ba” and “bc”. Starting from the beginning of the words, find the first character that is different in both words: it would be ‘a’ from “ba” and ‘c’ from “bc”. Because of the sorted order of words (i.e. the dictionary!), we can conclude that ‘a’ comes before ‘c’ in the alien language. Similarly, from “bc” and “ac”, we can conclude that ‘b’ comes before ‘a’. These two points tell us that we are actually asked to find the topological ordering of the characters, and that the ordering rules should be inferred from adjacent words from the alien dictionary. This makes the current problem similar to Tasks Scheduling Order, the only difference being that we need to build the graph of the characters by comparing adjacent words first, and then perform the topological sort for the graph to determine the order of the characters. CodeHere is what our algorithm will look like (only the highlighted lines have changed): 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# 但是有一点不太懂就是为什么。只要选取相邻的两个就可以建立邻接表from collections import dequeclass Solution: def findOrder(self, words): if len(words) == 0: return &quot;&quot; # a. Initialize the graph inDegree = &#123;&#125; # count of incoming edges graph = &#123;&#125; # adjacency list graph for word in words: for character in word: inDegree[character] = 0 graph[character] = [] # b. Build the graph for i in range(0, len(words)-1): # find ordering of characters from adjacent words w1, w2 = words[i], words[i + 1] for j in range(0, min(len(w1), len(w2))): parent, child = w1[j], w2[j] if parent != child: # if the two characters are different # put the child into it&#x27;s parent&#x27;s list graph[parent].append(child) inDegree[child] += 1 # increment child&#x27;s inDegree break # only the first different character between the two words will help us # find the order # c. Find all sources i.e., all vertices with 0 in-degrees sources = deque() for key in inDegree: if inDegree[key] == 0: sources.append(key) # d. For each source, add it to the sortedOrder and subtract one from all of its # children&#x27;s in-degrees if a child&#x27;s in-degree becomes zero, add it to sources queue sortedOrder = [] while sources: vertex = sources.popleft() sortedOrder.append(vertex) for child in graph[vertex]: # get the node&#x27;s children to decrement their in-degrees inDegree[child] -= 1 if inDegree[child] == 0: sources.append(child) # if sortedOrder doesn&#x27;t contain all characters, there is a cyclic dependency between # characters, therefore, we&#x27;ll not be able to find the correct ordering of characters if len(sortedOrder) != len(inDegree): return &quot;&quot; return &#x27;&#x27;.join(sortedOrder)def main(): sol = Solution() print(&quot;Character order: &quot; + sol.findOrder([&quot;ba&quot;, &quot;bc&quot;, &quot;ac&quot;, &quot;cab&quot;])) print(&quot;Character order: &quot; + sol.findOrder([&quot;cab&quot;, &quot;aaa&quot;, &quot;aab&quot;])) print(&quot;Character order: &quot; + sol.findOrder([&quot;ywx&quot;, &quot;wz&quot;, &quot;xww&quot;, &quot;xz&quot;, &quot;zyy&quot;, &quot;zwz&quot;]))main() Time complexityIn step ‘d’, each task can become a source only once and each edge (a rule) will be accessed and removed once. Therefore, the time complexity of the above algorithm will be O(V+E), where ‘V’ is the total number of different characters and ‘E’ is the total number of the rules in the alien language. Since, at most, each pair of words can give us one rule, therefore, we can conclude that the upper bound for the rules is O(N) where ‘N’ is the number of words in the input. So, we can say that the time complexity of our algorithm is O(V+N). Space complexityThe space complexity will be O(V+N), since we are storing all of the rules for each character in an adjacency list. *Problem Challenge 1Leetcode 444 会员 Design Gurus Educative.io Reconstructing a Sequence (hard)Given a sequence originalSeq and an array of sequences, write a method to find if originalSeq can be uniquely reconstructed from the array of sequences. Unique reconstruction means that we need to find if originalSeq is the only sequence such that all sequences in the array are subsequences of it. Example 1: 12345Input: originalSeq: [1, 2, 3, 4], seqs: [[1, 2], [2, 3], [3, 4]]Output: trueExplanation: The sequences [1, 2], [2, 3], and [3, 4] can uniquely reconstruct [1, 2, 3, 4], in other words, all the given sequences uniquely define the order of numbers in the &#x27;originalSeq&#x27;. Example 2: 123456Input: originalSeq: [1, 2, 3, 4], seqs: [[1, 2], [2, 3], [2, 4]]Output: falseExplanation: The sequences [1, 2], [2, 3], and [2, 4] cannot uniquely reconstruct [1, 2, 3, 4]. There are two possible sequences we can construct from the given sequences:1) [1, 2, 3, 4]2) [1, 2, 4, 3] Example 3: 1234Input: originalSeq: [3, 1, 4, 2, 5], seqs: [[3, 1, 5], [1, 4, 2, 5]]Output: trueExplanation: The sequences [3, 1, 5] and [1, 4, 2, 5] can uniquely reconstruct [3, 1, 4, 2, 5]. Constraints: n == originalSeq.length 1 &lt;= n &lt;= 10^4 originalSeq is a permutation of all the integers in the range [1, n]. 1 &lt;= seqs.length &lt;= 10^4 1 &lt;= seqs[i].length &lt;= 10^4 `1 &lt;= sum(seqs[i].length) &lt;= 10^5 1 &lt;= seqs[i][j] &lt;= n All the arrays of sequences are unique. seqs[i] is a subsequence of nums. Try it yourselfTry solving this question here: 12# 我的想法：什么时候sources中的元素超过了1一个，那就是有有问题的，输出false# 漏了一种情况，就是可以构建出唯一的序列，但是和给的origin_seq不一样 SolutionSince each sequence in the given array defines the ordering of some numbers, we need to combine all these ordering rules to find two things: Is it possible to construct the originalSeq from all these rules? Are these ordering rules not sufficient enough to define the unique ordering of all the numbers in the originalSeq? In other words, can these rules result in more than one sequence? Take Example-1: 1originalSeq: [1, 2, 3, 4], seqs:[[1, 2], [2, 3], [3, 4]] The first sequence tells us that ‘1’ comes before ‘2’; the second sequence tells us that ‘2’ comes before ‘3’; the third sequence tells us that ‘3’ comes before ‘4’. Combining all these sequences will result in a unique sequence: [1, 2, 3, 4]. The above explanation tells us that we are actually asked to find the topological ordering of all the numbers and also to verify that there is only one topological ordering of the numbers possible from the given array of the sequences. This makes the current problem similar to Tasks Scheduling Order with two differences: We need to build the graph of the numbers by comparing each pair of numbers in the given array of sequences. We must perform the topological sort for the graph to determine two things: Can the topological ordering construct the originalSeq? That there is only one topological ordering of the numbers possible. This can be confirmed if we do not have more than one source at any time while finding the topological ordering of numbers. CodeHere is what our algorithm will look like (only the highlighted lines have changed): 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# 我的想法是：什么时候sources中的元素超过了1一个，那就是有有问题的，输出false# 漏了一种情况，就是可以构建出唯一的序列，但是和给的origin_seq不一样# 以下是官方solutionfrom collections import dequeclass Solution: def canConstruct(self, originalSeq, sequences): sortedOrder = [] if len(originalSeq) &lt;= 0: return False # a. Initialize the graph inDegree = &#123;&#125; # count of incoming edges graph = &#123;&#125; # adjacency list graph for sequence in sequences: for num in sequence: inDegree[num] = 0 graph[num] = [] # b. Build the graph for sequence in sequences: for i in range(1, len(sequence)): parent, child = sequence[i - 1], sequence[i] graph[parent].append(child) inDegree[child] += 1 # if we don&#x27;t have ordering rules for all the numbers we&#x27;ll not able to uniquely # construct the sequence if len(inDegree) != len(originalSeq): return False # c. Find all sources i.e., all vertices with 0 in-degrees sources = deque() for key in inDegree: if inDegree[key] == 0: sources.append(key) # d. For each source, add it to the sortedOrder and subtract one from all of its # children&#x27;s in-degrees if a child&#x27;s in-degree becomes zero, add it to sources queue while sources: if len(sources) &gt; 1: return False # more than one sources mean, there is more than one way to # reconstruct the sequence if originalSeq[len(sortedOrder)] != sources[0]: return False # the next source(or number) is different from the original sequence vertex = sources.popleft() sortedOrder.append(vertex) for child in graph[vertex]: # get the node&#x27;s children to decrement their in-degrees inDegree[child] -= 1 if inDegree[child] == 0: sources.append(child) # if sortedOrder&#x27;s size is not equal to original sequence&#x27;s size, there is no unique # way to construct return len(sortedOrder) == len(originalSeq)def main(): sol = Solution() print(&quot;Can construct: &quot; + str(sol.canConstruct([1, 2, 3, 4], [[1, 2], [2, 3], [3, 4]]))) print(&quot;Can construct: &quot; + str(sol.canConstruct([1, 2, 3, 4], [[1, 2], [2, 3], [2, 4]]))) print(&quot;Can construct: &quot; + str(sol.canConstruct([3, 1, 4, 2, 5], [[3, 1, 5], [1, 4, 2, 5]])))main() Time complexityIn step ‘d’, each number can become a source only once and each edge (a rule) will be accessed and removed once. Therefore, the time complexity of the above algorithm will be O(V+E), where ‘V’ is the count of distinct numbers and ‘E’ is the total number of the rules. Since, at most, each pair of numbers can give us one rule, we can conclude that the upper bound for the rules is O(N) where ‘N’ is the count of numbers in all sequences. So, we can say that the time complexity of our algorithm is O(V+N). Space complexityThe space complexity will be O(V+N), since we are storing all of the rules for each number in an adjacency list. *Problem Challenge 2310. Minimum Height Trees Design Gurus Educative.io Minimum Height Trees (hard)We are given an undirected graph that has characteristics of a k-ary tree. In such a graph, we can choose any node as the root to make a k-ary tree. The root (or the tree) with the minimum height will be called Minimum Height Tree (MHT). There can be multiple MHTs for a graph. In this problem, we need to find all those roots which give us MHTs. Write a method to find all MHTs of the given graph and return a list of their roots. Example 1: 1234Input: vertices: 5, Edges: [[0, 1], [1, 2], [1, 3], [2, 4]]Output:[1, 2]Explanation: Choosing &#x27;1&#x27; or &#x27;2&#x27; as roots give us MHTs. In the below diagram, we can see that the height of the trees with roots &#x27;1&#x27; or &#x27;2&#x27; is three which is minimum. Example 2: 1234Input: vertices: 4, Edges: [[0, 1], [0, 2], [2, 3]]Output:[0, 2]Explanation: Choosing &#x27;0&#x27; or &#x27;2&#x27; as roots give us MHTs. In the below diagram, we can see that the height of the trees with roots &#x27;0&#x27; or &#x27;2&#x27; is three which is minimum. Example 3: 12Input: vertices: 4, Edges: [[0, 1], [1, 2], [1, 3]]Output:[1] Constraints: 1 &lt;= vertices &lt;= 2 * 10^4 edges.length == n - 1 0 &lt;= ai, bi &lt; n ai != bi All the pairs (ai, bi) are distinct. The given input is guaranteed to be a tree and there will be no repeated edges. SolutionThe key intuition behind solving this problem is based on the definition of a tree’s height: the height of a tree is the number of edges on the longest path between the root and any leaf. So, an MHT is a tree that minimizes this longest path. Imagine we have a longest path P in the tree. The path P has two ends; let’s call them end A and end B. Now, let’s consider what the root of an MHT can be: If we select a root that is not on the path P, the height of the tree would at least be the length of P, because there would be a path from the root to either A or B that is longer than P (as it includes P plus some additional edges). Therefore, the root of the MHT must be on P. If the root is on P, but not in the middle of P, then the height of the tree will be larger than if we selected the root in the middle of P, because the longest path will be from the root to either end of P. Therefore, the root of the MHT must be in the middle of P. So, the problem of finding the MHT root(s) reduces to finding the middle node(s) of the longest path in the tree. We can find the middle node(s) of the longest path by using an algorithm called ‘leaf pruining’. Let’s look into this. From the above discussion, we can deduce that the leaves can’t give us MHT, hence, we can remove them from the graph and remove their edges too. Once we remove the leaves, we will have new leaves. Since these new leaves can’t give us MHT, we will repeat the process and remove them from the graph too. We will prune the leaves until we are left with one or two nodes which will be our answer and the roots for MHTs. The algorithm works because when you trim leaves, you’re essentially trimming the ends of all the longest paths in the tree. If there’s one longest path, you’re trimming it from both ends, and if there are multiple longest paths, you’re trimming them all. Eventually, you’re left with one or two nodes, which must be the middle of the longest path(s), and those are the roots of the MHTs. We can implement the above process using the topological sort. Any node with only one edge (i.e., a leaf) can be our source and, in a stepwise fashion, we can remove all sources from the graph to find new sources. We will repeat this process until we are left with one or two nodes in the graph, which will be our answer. This Java algorithm is used to find the root nodes of the Minimum Height Trees (MHTs) in a graph. An MHT is a tree rooted at a specific node that minimizes the tree’s height. In a graph with ‘n’ nodes, there can be one or two MHTs. Here’s a breakdown of the algorithm: It starts by checking if the number of nodes is less than or equal to 0, returning an empty list if true, as there would be no trees in the graph. If the graph contains only one node, it returns that single node as an MHT. Next, it initializes two HashMaps, inDegree to store the count of incoming edges for every vertex and graph as an adjacency list representation of the graph. It populates these HashMaps with initial values. The algorithm then constructs the graph. As it’s an undirected graph, each edge connects two nodes bi-directionally, meaning it adds a link for both nodes and increments the in-degrees of the two nodes. The algorithm finds all leaf nodes (nodes with only one in-degree) and adds them to a queue. Next, it iteratively removes the leaf nodes level by level, subtracting one from the in-degree of each leaf node’s children. If a child node becomes a leaf node as a result, it is added to the queue of leaf nodes. This process repeats until the graph has been reduced to one or two nodes, which represent the roots of the MHTs. Finally, the algorithm adds the remaining nodes in the leaves queue to minHeightTrees and returns this list. These nodes are the roots of the MHTs in the graph. CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from collections import dequeclass Solution: def findTrees(self, nodes, edges): if nodes &lt;= 0: return [] # with only one node, since its in-degrees will be 0, therefore, we need to handle it # separately if nodes == 1: return [0] # a. Initialize the graph inDegree = &#123;i: 0 for i in range(nodes)&#125; # count of incoming edges graph = &#123;i: [] for i in range(nodes)&#125; # adjacency list graph # b. Build the graph for edge in edges: n1, n2 = edge[0], edge[1] # since this is an undirected graph, therefore, add a link for both the nodes graph[n1].append(n2) graph[n2].append(n1) # increment the in-degrees of both the nodes inDegree[n1] += 1 inDegree[n2] += 1 # c. Find all leaves i.e., all nodes with 1 in-degrees leaves = deque() for key in inDegree: if inDegree[key] == 1: leaves.append(key) # d. Remove leaves level by level and subtract each leave&#x27;s children&#x27;s in-degrees. # Repeat this until we are left with 1 or 2 nodes, which will be our answer. # Any node that has already been a leaf cannot be the root of a minimum height tree, # because its adjacent non-leaf node will always be a better candidate. totalNodes = nodes while totalNodes &gt; 2: leavesSize = len(leaves) totalNodes -= leavesSize for i in range(0, leavesSize): vertex = leaves.popleft() # get the node&#x27;s children to decrement their in-degrees for child in graph[vertex]: inDegree[child] -= 1 if inDegree[child] == 1: leaves.append(child) return list(leaves)def main(): sol = Solution() print(&quot;Roots of MHTs: &quot; + str(sol.findTrees(5, [[0, 1], [1, 2], [1, 3], [2, 4]]))) print(&quot;Roots of MHTs: &quot; + str(sol.findTrees(4, [[0, 1], [0, 2], [2, 3]]))) print(&quot;Roots of MHTs: &quot; + str(sol.findTrees(4, [[1, 2], [1, 3]])))main() Time complexityIn step ‘d’, each node can become a source only once and each edge will be accessed and removed once. Therefore, the time complexity of the above algorithm will be O(V+E), where ‘V’ is the total nodes and ‘E’ is the total number of the edges. Space complexityThe space complexity will be O(V+E), since we are storing all of the edges for each node in an adjacency list.","categories":[{"name":"Grokking Interview Pattern","slug":"Grokking-Interview-Pattern","permalink":"https://hasuer.github.io/categories/Grokking-Interview-Pattern/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hasuer.github.io/tags/Interview/"}]},{"title":"23. Pattern Trie","slug":"23. Pattern Trie","date":"2024-05-23T06:24:12.000Z","updated":"2024-05-28T03:30:41.147Z","comments":true,"path":"23-pattern-trie/index.html","link":"","permalink":"https://hasuer.github.io/23-pattern-trie/index.html","excerpt":"","text":"Introduction to TrieIntroduction to TrieA Trie, short for retrieval, is a specialized tree-based data structure primarily used for efficient storing, searching, and retrieval of strings over a given alphabet. It excels in scenarios where a large collection of strings needs to be managed and pattern-matching operations need to be performed with optimal efficiency. Defining a TrieA Trie, often referred to as a prefix tree, is constructed to represent a set of strings where each node in the tree corresponds to a single character of a string. The path from the root node to a particular node represents the characters of a specific string. This structural characteristic allows Tries to effectively share common prefixes among strings, leading to efficient storage and retrieval. In the context of a Trie, the given strings are typically formed from a fixed alphabet. Each edge leading from a parent node to its child node corresponds to a character from the alphabet. By following the path of characters from the root to a specific node, we can reconstruct the string associated with that path. Let’s look at the below Trie diagram. In the above Trie, car and cat shares the common prefix, and apple and ant shares the common prefix. Need for Trie Data Structure?Tries are commonly employed in applications such as spell checking, autocomplete suggestions, and searching within dictionaries or databases. They excel at these tasks because they minimize the search complexity in proportion to the length of the target string, making them significantly more efficient than other data structures like binary search trees. Advantages of Using Tries Fast Pattern Matching: Tries provide rapid pattern matching queries, taking time proportional to the length of the pattern (or the string being searched). Common Prefix Sharing: Strings with common prefixes share nodes in the Trie, leading to efficient memory utilization and reduced redundancy. Efficient Insertion and Deletion: Tries are amenable to dynamic operations like insertion and deletion, while maintaining efficient search times. Alphabet Flexibility: Tries can handle various alphabets, making them versatile for a range of applications. Word Frequency Counting: Tries can be extended to store additional information at nodes, such as the frequency of words or strings. In comparison to using a binary search tree, where a well-balanced tree would require time proportional to the product of the maximum string length and the logarithm of the number of keys, Tries offer the advantage of a search time linearly dependent on the length of the string being searched. This results in an optimization of search operations, especially when dealing with large datasets. In summary, a Trie is a powerful data structure that optimizes string-related operations by efficiently storing and retrieving strings with shared prefixes. Its unique structure and fast search capabilities make it an invaluable tool in various text-based applications. Properties of the Trie Data StructureTrie is a tree-like data structure. So, it’s important to know the properties of Trie. Single Root Node: Every trie has one root node, serving as the starting point for all strings stored within. Node as a String: In a trie, each node symbolizes a string, with the path from the root to that node representing the string in its entirety. Edges as Characters: The edges connecting nodes in a trie represent individual characters. This means that traversing an edge essentially adds a character to the string. Node Structure: Nodes in a trie typically contain either hashmaps or arrays of pointers. Each position in this array or hashmap corresponds to a character. Additionally, nodes have a flag to signify if a string concludes at that particular node. Character Limitation: While tries can accommodate a vast range of characters, for the purpose of this discussion, we’re focusing on lowercase English alphabets (a-z). This means each node will have 26 pointers, with the 0th pointer representing ‘a’ and the 25th one representing ‘z’. Path Equals Word: In a trie, any path you trace from the root node to another node symbolizes a word or a string. This makes it easy to identify and retrieve strings. These properties underline the essence of the trie data structure, emphasizing its efficiency and utility in managing strings, especially when dealing with large datasets. Implementation of TriesLet’s start by understanding the basic implementation of a Trie. Each node in a Trie can have multiple children, each representing a character. To illustrate this, consider the following simple Trie structure: Here’s a step-by-step guide to implement a Trie: The Trie starts from the root node. The path from the root to the node “c” represents the character “c.” The path from “c” to “a” represents the string “ca,” and from “a” to “r” represents the string “car.” The path from “c” to “a” represents the string “ca,” and from “a” to “t” represents the string “cat.” Representation of Trie NodeThe Trie node has an array or list of children nodes, typically of size 26 to represent the English lowercase alphabets (a-z). Additionally, there’s a boolean flag isEndOfWord to indicate whether the current node marks the end of a word in the Trie. 12345class TrieNode: def __init__(self): self.children = [None]*26 self.isEndOfWord = False Now, let’s look at the basic operations such as insertion, searching, and deletion on the Trie data structure. Insertion in Trie Data StructureInsertion in a Trie involves adding a string to the Trie, character by character, starting from the root. If the character already exists in the Trie, we move to the next node; otherwise, we create a new node for the character. Algorithm Start from the root node. For each character in the string: Check if the character exists in the current node’s children. If it exists, move to the corresponding child node. If it doesn’t exist, create a new node for the character and link it to the current node. Move to the newly created node. After processing all characters in the string, mark the current node as the end of the word. ExampleConsider that we need to insert the ‘can’, ‘cat’, ‘cant’, and ‘apple’ into the trie. We insert them in the following order: Initial Trie: 1Root Insert ‘can’: 1234567Root | c | a | n Explanation: Starting from the root, we add nodes for each character in “can”. Insert ‘cat’: 1234567Root | c | a | \\ n t Explanation: “cat” shares the first two characters with “can”, so we just add a new branch for the ‘t’ after ‘a’. Insert ‘cant’: 123456789Root | c | a | \\ n t | t Explanation: “cant” extends from the path of “can”, so we add a new node for ‘t’ after the existing ‘n’. Insert ‘apple’: 1234567891011Root | \\ c a | | a p | \\ | t n p | | t l | e Explanation: Starting from the root, we add nodes for each character in “apple” branching from the ‘a’ node. Code123456789101112131415161718192021class TrieNode: def __init__(self): self.children = [None] * 26 # Assuming only lowercase English letters self.isEndOfWord = Falseclass Trie: def __init__(self): self.root = TrieNode() def charToIndex(self, ch): # Convert character to index (0-25) return ord(ch) - ord(&#x27;a&#x27;) def insert(self, word): node = self.root for char in word: index = self.charToIndex(char) if not node.children[index]: node.children[index] = TrieNode() node = node.children[index] node.isEndOfWord = True Complexity AnalysisTime Complexity: O(n) - Where n is the length of the word. This is when the word doesn’t share any prefix with the words already in the Trie or is longer than any word in the Trie. Space Complexity: Best Case: O(1) - When the word is entirely a prefix of an existing word or shares a complete prefix with words in the Trie. Worst Case: O(n) - When the word doesn’t share any characters with the words in the Trie. Searching in Trie Data StructureSearching into Trie is similar to the insertion into the Trie. Let’s look at the below algorithm to search in the Trie data structure. Algorithm Start from the root node. For each character in the word: a. Calculate its index (e.g., ‘a’ is 0, ‘b’ is 1, …). b. Check if the corresponding child node exists. c. If it exists, move to the child node and continue. d. If it doesn’t exist, return false (word not found). After processing all characters, check the isEndOfWord flag of the current node. If it’s true, the word exists in the Trie; otherwise, it doesn’t. Code12345678910111213141516171819class TrieNode: def __init__(self): self.children = [None] * 26 # Children nodes self.isEndOfWord = False # Flag to represent the end of a wordclass Trie: def __init__(self): self.root = TrieNode() # Function to search a word in the Trie def search(self, word): node = self.root for char in word: index = ord(char) - ord(&#x27;a&#x27;) if not node.children[index]: return False # Word not found node = node.children[index] return node.isEndOfWord # Return true if word exists, false otherwise Complexity AnalysisTime Complexity: O(n) - Where n is the length of the word. This happens when you have to traverse the Trie to the deepest level. Space Complexity: O(1) - Searching doesn’t require any additional space as it’s just about traversing the Trie. Deletion in Trie Data StructureWhen we delete a key in a Trie, there are three cases to consider: Key is a leaf node: If the key is a leaf node, we can simply remove it from the Trie. Key is a prefix of another key: If the key is a prefix of another key in the Trie, then we cannot remove it entirely. Instead, we just unmark the isEndOfWord flag. Key has children: If the key has children, we need to recursively delete the child nodes. If a child node becomes a leaf node after the deletion of the key, we can remove the child node as well. Algorithm Initialization: Start from the root of the Trie. Begin with the first character of the word you want to delete. Base Case: If you’ve reached the end of the word: Check if the current node has the isEndOfWord flag set to true. If not, the word doesn’t exist in the Trie, so return false. If the flag is true, unset it. This means the word is no longer recognized as a word in the Trie. Check if the current node has any children. If it doesn’t, it means this node doesn’t contribute to any other word in the Trie, so it can be safely deleted. Return true to indicate to its parent that it can be removed. Recursive Case: For the current character in the word: Calculate its index (e.g., ‘a’ is 0, ‘b’ is 1, …). Check if the corresponding child node exists. If it doesn’t, the word is not present in the Trie, so return false. If the child node exists, make a recursive call to the delete function with the child node and the next character in the word. Post-Recursive Handling: After the recursive call, check the return value: If it’s true, it means the child node can be deleted. Remove the reference to the child node. Check the current node. If it doesn’t have any other children and its isEndOfWord flag is not set, it means this node doesn’t contribute to any word in the Trie. Return true to indicate to its parent that it can be removed. If the node has other children or its isEndOfWord flag is set, return false. Completion: Once all characters in the word have been processed, the word will either be deleted from the Trie (if it existed) or the Trie will remain unchanged (if the word didn’t exist). Code123456789101112131415161718192021222324252627282930313233class TrieNode: def __init__(self): self.children = [None] * 26 # Children nodes self.isEndOfWord = False # Flag to represent the end of a wordclass Trie: def __init__(self): self.root = TrieNode() # Recursive function to delete a key from the Trie def _delete(self, current, word, index): if index == len(word): if current.isEndOfWord: current.isEndOfWord = False return not any(current.children) return False ch = word[index] node = current.children[ord(ch) - ord(&#x27;a&#x27;)] if not node: return False shouldDeleteChild = self._delete(node, word, index + 1) if shouldDeleteChild: current.children[ord(ch) - ord(&#x27;a&#x27;)] = None return not any(current.children) return False # Function to delete a word from the Trie def deleteWord(self, word): self._delete(self.root, word, 0) Complexity AnalysisTime Complexity: O(n) - Where n is the length of the word. This is when you have to traverse the Trie to the deepest level and potentially backtrack to delete nodes. Space Complexity: O(1) - Deletion, like searching, doesn’t require any additional space. Implement Trie (Prefix Tree)Top Interview 150 | 208. Implement Trie (Prefix Tree) Design Gurus Problem StatementDesign and implement a Trie (also known as a Prefix Tree). A trie is a tree-like data structure that stores a dynamic set of strings, and is particularly useful for searching for words with a given prefix. Implement the Solution class: Solution() Initializes the object. void insert(word) Inserts word into the trie, making it available for future searches. bool search(word) Checks if the word exists in the trie. bool startsWith(word) Checks if any word in the trie starts with the given prefix. Examples Example 1: Input: Trie operations: [&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;startsWith&quot;] Arguments: [[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;]] Expected Output: [-1, -1, 1, 1] Justification: After inserting “apple”, “apple” exists in the Trie. There is also a word that starts with “app”, which is “apple”. Example 2: Input: Trie operations: [&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;search&quot;] Arguments: [[], [&quot;banana&quot;], [&quot;apple&quot;], [&quot;ban&quot;], [&quot;banana&quot;]] Expected Output: [-1, -1, 0, 1, 1] Justification: After inserting “banana”, “apple” does not exist in the Trie but a word that starts with “ban”, which is “banana”, does exist. Example 3: Input: Trie operations: [&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;] Arguments: [[], [&quot;grape&quot;], [&quot;grape&quot;], [&quot;grap&quot;], [&quot;gr&quot;]] Expected Output: [-1, -1, 1, 1, 1] Justification: After inserting “grape”, “grape” exists in the Trie. There are words that start with “grap” and “gr”, which is “grape”. Constraints: 1 &lt;= word.length, prefix.length &lt;= 2000 word and prefix consist only of lowercase English letters. At most 3 * 104 calls in total will be made to insert, search, and startsWith. SolutionThe trie is represented as a tree, where each node contains an array of pointers (or references) to its children and a boolean flag indicating if the current node marks the end of a word. When inserting or searching for a word, we start at the root node and navigate through the tree character by character until we either finish the operation or determine the word doesn’t exist in the trie. Now, let’s break down the operations: Insert: We begin at the root node. For every character in the word, check if there’s a child node for it. If the child node doesn’t exist, we create it. Navigate to the child node and repeat the process for the next character. Once the end of the word is reached, mark the current node as an endpoint of a word. Search: Starting at the root, traverse the trie character by character. For every character in the word, check if there’s a child node for it. If at any point there isn’t a child node for the character, the word doesn’t exist in the trie. If we can traverse the entire word and the last node is marked as an endpoint, the word exists in the trie. StartsWith: The operation is similar to the search, but we don’t need the last node to be an endpoint. If we can traverse the prefix without any missing nodes, there exists a word in the trie that starts with the given prefix. Algorithm WalkthroughUsing Example 1: [&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;startsWith&quot;] [[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;]] Create an empty Trie. Insert “apple”. Start from the root. For ‘a’, move to the child node or create one if it doesn’t exist. Move to ‘p’, then the next ‘p’, followed by ‘l’ and finally ‘e’. Mark ‘e’ as the end of a word. Search for “apple”. Start from the root and traverse nodes ‘a’ -&gt; ‘p’ -&gt; ‘p’ -&gt; ‘l’ -&gt; ‘e’. Since ‘e’ is marked as the end of a word, return true. Check if a word starts with “app”. Traverse nodes for ‘a’ -&gt; ‘p’ -&gt; ‘p’. All nodes exist, so return true. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344# class TrieNode:# def __init__(self):# self.children = &#123;&#125; # Dictionary to store child nodes.# self.isEnd = False # Flag to represent end of a word.class Solution: def __init__(self): self.root = TrieNode() # Inserts a word into the trie. def insert(self, word: str) -&gt; None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.isEnd = True # Returns if the word is in the trie. def search(self, word: str) -&gt; bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.isEnd # Returns if there is any word in the trie that starts with the given prefix. def startsWith(self, prefix: str) -&gt; bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return Trueif __name__ == &quot;__main__&quot;: trie = Solution() trie.insert(&quot;apple&quot;) print(trie.search(&quot;apple&quot;)) # True print(trie.search(&quot;app&quot;)) # False print(trie.startsWith(&quot;app&quot;)) # True Complexity Analysis Time Complexity: Insert: (O(m)), where (m) is the key length. Search and StartsWith: (O(m)) in the worst case scenario. Space Complexity: (O(n \\times m)), where (n) is the number of inserted keys and (m) is the average key length. Index Pairs of a StringLeetcode 会员 Design Gurus Problem StatementGiven a string text and a list of strings words, identify all [i, j] index pairs such that the substring text[i...j] is in words. These index pairs should be returned in ascending order, first by the start index, then by the end index. Find every occurrence of each word within the text, ensuring that overlapping occurrences are also identified. Examples Input: text = &quot;bluebirdskyscraper&quot;, words = [&quot;blue&quot;, &quot;bird&quot;, &quot;sky&quot;] Expected Output: [[0, 3], [4, 7], [8, 10]] Justification: The word “blue” is found from index 0 to 3, “bird” from 4 to 7, and “sky” from 8 to 10 in the string. Input: text = &quot;programmingisfun&quot;, words = [&quot;pro&quot;, &quot;is&quot;, &quot;fun&quot;, &quot;gram&quot;] Expected Output: [[0, 2], [3, 6], [11, 12], [13, 15]] Justification: “pro” is found from 0 to 2, “gram” from 3 to 6, “is” from 11 to 12, and “fun” from 13 to 15. Input: text = &quot;interstellar&quot;, words = [&quot;stellar&quot;, &quot;star&quot;, &quot;inter&quot;] Expected Output: [[0, 4], [5, 11]] Justification: “inter” is found from 0 to 4, and “stellar” from 5 to 11. “star” is not found. Constraints: 1 &lt;= text.length &lt;= 100 1 &lt;= words.length &lt;= 20 1 &lt;= words[i].length &lt;= 50 text and words[i] consist of lowercase English letters. All the strings of words are unique. SolutionTo solve this problem, we will use a trie data structure, which is particularly efficient for managing a set of strings and performing quick searches for patterns within a text. A trie, also known as a prefix tree, allows us to efficiently store and retrieve strings with a common prefix, making it ideal for our purpose of identifying substrings within a given text. The approach involves two main phases: building the trie with the given list of words and then using it to find the index pairs in the text. The trie’s structure enables us to search for each word in the text in an optimized manner, significantly reducing the number of comparisons needed compared to brute force methods. Step-by-Step Algorithm Initialize the Trie: Create a trie and insert all the words from the given list into it. This is done in the first part of the code. Search and Record Index Pairs: Iterate over each character in the text. This character will act as the starting point for potential matches. For each starting character, initiate a pointer p at the root of the trie. Then, iterate over the text starting from the current starting point until the end of the text. In each iteration: Check if the current character exists as a child of the current trie node pointed by p. If it does not exist, break out of the inner loop as no further matching is possible from this starting point. If it exists, move the pointer p to this child node. Check if the current node p is a leaf node (indicated by p.isEnd being true). If it is, it means a complete word from the list has been found. Record the start and end indices of this word. The start index is the position of the starting character, and the end index is the current position in the text. Continue this process for each character in the text to ensure all occurrences, including overlapping ones, are found. Algorithm WalkthroughUsing the input text = &quot;programmingisfun&quot;, words = [&quot;pro&quot;, &quot;is&quot;, &quot;fun&quot;, &quot;gram&quot;]: Initialize the Trie with Words: “pro”, “is”, “fun”, and “gram” are inserted into the trie. Search and Record Index Pairs: Start at index 0 (&#39;p&#39; in &quot;programmingisfun&quot;): Pointer p is at the root. Finds ‘p’, moves to ‘r’, then ‘o’. p.isEnd is true at ‘o’, so record [0, 2]. At index 1 (&#39;r&#39;), no match is found. similarly, At index 2 (&#39;o&#39;), no match is found. At index 3 ( &#39;g&#39; ): Finds ‘g’, ‘r’, ‘a’, ‘m’. p.isEnd is true at ‘m’, so record [3, 6]. At index 11 ( &#39;i&#39; ): Finds ‘i’, ‘s’. p.isEnd is true at ‘s’, so record [11, 12]. At index 13 ( &#39;s&#39; ): Finds ‘f’, ‘u’, ‘n’. p.isEnd is true at ‘n’, so record [13, 15]. Compile Results: The results [[0, 2], [3, 6], [11, 12], [13, 15]] are compiled into the 2D array ans and returned. By following these steps, the algorithm efficiently locates all occurrences of the words in the text, including overlapping ones, using the trie structure for optimized searching. Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class TrieNode: def __init__(self): self.children = &#123;&#125; # Using a dictionary to hold child nodes for each letter self.isEnd = False # Flag to mark the end of a wordclass Trie: def __init__(self): self.root = TrieNode() # Inserts a word into the trie def insert(self, word): cur = self.root for c in word: if c not in cur.children: cur.children[c] = TrieNode() # Create a new node if not present cur = cur.children[c] cur.isEnd = True # Mark the end of a wordclass Solution: def indexPairs(self, text, words): trie = Trie() # Populate the trie with the list of words for word in words: trie.insert(word) result = [] for i in range(len(text)): p = trie.root for j in range(i, len(text)): currentChar = text[j] if currentChar not in p.children: break # Break if the character is not in the trie p = p.children[currentChar] if p.isEnd: result.append([i, j]) # Add index pair if word found as a list return result # Return a list of lists containing index pairs# Example usage:solution = Solution()text1 = &quot;bluebirdskyscraper&quot;words1 = [&quot;blue&quot;, &quot;bird&quot;, &quot;sky&quot;]print(solution.indexPairs(text1, words1))text2 = &quot;programmingisfun&quot;words2 = [&quot;pro&quot;, &quot;is&quot;, &quot;fun&quot;, &quot;gram&quot;]print(solution.indexPairs(text2, words2))text3 = &quot;interstellar&quot;words3 = [&quot;stellar&quot;, &quot;star&quot;, &quot;inter&quot;]print(solution.indexPairs(text3, words3)) Time and Space Complexity AnalysisTime Complexity: Building the Trie: O(N \\ L)*, where N is the number of words and L is the average length of these words. Finding Index Pairs: O(T^2), where T is the length of the text string. Overall: O(N \\ L + T^2)* Space Complexity: Trie Storage: O(N L)*, for storing N words each of average length L. Design Add and Search Words Data StructureTop Interview 150 | 211. Design Add and Search Words Data Structure Design Gurus Problem StatementDesign a data structure that supports the addition of new words and the ability to check if a string matches any previously added word. Implement the Solution class: Solution() Initializes the object. void addWord(word) Inserts word into the data structure, making it available for future searches. bool search(word) Checks if there is any word in the data structure that matches word. The method returns true if such a match exists, otherwise returns false. Note: In the search query word, the character &#39;.&#39; can represent any single letter, effectively serving as a wildcard character. ExamplesExample 1: Input: 12[&quot;Solution&quot;, &quot;addWord&quot;, &quot;addWord&quot;, &quot;search&quot;, &quot;search&quot;][[], [&quot;apple&quot;], [&quot;banana&quot;], [&quot;apple&quot;], [&quot;.....&quot;]] Expected Output: 1[-1, -1, -1, 1, 1] Justification: After adding the words “apple” and “banana”, searching for “apple” will return true since “apple” is in the data structure. Searching for “…..” will also return true as both “apple” and “banana” match the pattern. Example 2: Input: 12[&quot;Solution&quot;, &quot;addWord&quot;, &quot;addWord&quot;, &quot;search&quot;, &quot;search&quot;][[], [&quot;cat&quot;], [&quot;dog&quot;], [&quot;c.t&quot;], [&quot;d..g&quot;]] Expected Output: 1[-1, -1, -1, 1, 0] Justification: “c.t” matches “cat” and “d..g” doesn’t matches “dog”. Example 3: Input: 12[&quot;Solution&quot;, &quot;addWord&quot;, &quot;search&quot;, &quot;search&quot;][[], [&quot;hello&quot;], [&quot;h.llo&quot;], [&quot;h...o&quot;]] Expected Output: 1[-1, -1, 1, 0] Justification: “h.llo” and “h…o” both match “hello”. Constraints: 1 &lt;= word.length &lt;= 25 word in addWord consists of lowercase English letters. word in search consist of ‘.’ or lowercase English letters. There will be at most 2 dots in word for search queries. At most 104 calls will be made to addWord and search. SolutionThe crux of the problem lies in efficiently inserting words and then searching for them, even if the query includes wildcards. To solve this, we utilize the trie (prefix tree) data structure. A trie is a tree-like structure that’s useful for storing a dynamic set of strings, especially when the dataset involves large numbers of queries on prefixes of strings. Each node of the trie can represent a character of a word, and the path from the root node to any node represents the word stored up to that point. The key operation for the wildcard is a recursive search, which allows us to explore multiple paths in the trie when we encounter the wildcard character. 1. Trie Data Structure: Every node of the trie contains multiple child nodes (one for each character of the alphabet). We start with a root node that represents an empty string. Each level of the trie represents the next character of a word. 2. Adding a Word: To insert a word into our trie, we begin at the root and traverse down the trie based on the characters in the word. If a particular character doesn’t have a corresponding child node in the current node, we create a new child node for that character. Once we’ve processed every character of the word, we mark the final node as the end of a valid word. 3. Searching: Searching for a word is similar to inserting, but with an additional consideration for the wildcard character (‘.’). If we encounter a ‘.’, we must consider all child nodes of the current node and recursively continue our search from each of them. If any of the paths result in a match, we return true. If we reach the end of a word without encountering any mismatches or premature ends, we’ve found a valid word in our trie. This trie-based approach ensures efficient operations for both inserting and searching for words. In cases without wildcards, the search operation can be performed in linear time relative to the word’s length. However, with wildcards, the time complexity might increase, but the trie structure still ensures that we do this efficiently. Algorithm WalkthroughGiven the word “apple” to insert and then search for “…..”: Start at the root node. For inserting “apple”: At ‘a’, move down or create a node if it doesn’t exist. At ‘p’, move down or create. Do the same for the next ‘p’, ‘l’, and ‘e’. Mark the last node (for ‘e’) as the end of a word. For searching “…..”: At the first ‘.’, check all child nodes and continue. Repeat for each ‘.’. If any path leads to a node that represents the end of a word, return true. Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# class TrieNode:# def __init__(self):# # Initialize children as a dictionary to represent all possible next characters.# self.children = &#123;&#125; # # Flag to check if the current node marks the end of any word.# self.isEnd = False class Solution: def __init__(self): # Initialize the root node. self.root = TrieNode() def addWord(self, word: str): node = self.root for ch in word: # If current character isn&#x27;t already a child of the node, add it. if ch not in node.children: node.children[ch] = TrieNode() # Move on to the next character/node. node = node.children[ch] # After processing all characters of the word, mark the current node as end of a word. node.isEnd = True def search(self, word: str) -&gt; bool: return self.searchInNode(word, self.root) def searchInNode(self, word: str, node: TrieNode) -&gt; bool: for i, ch in enumerate(word): # Check for wildcard character. if ch == &#x27;.&#x27;: # Recursively search for all possible characters in place of the wildcard. return any(self.searchInNode(word[i + 1:], node.children[child]) for child in node.children if child) # If character doesn&#x27;t exist in children, word can&#x27;t exist in the trie. if ch not in node.children: return False # Move to the next character/node. node = node.children[ch] # After processing all characters of the word, return if it&#x27;s a valid word. return node.isEnd# Test the algorithmobj = Solution()obj.addWord(&quot;apple&quot;)obj.addWord(&quot;banana&quot;)print(obj.search(&quot;apple&quot;)) # Trueprint(obj.search(&quot;.....&quot;)) # True Complexity Analysis Time Complexity: Insertion (addWord): O(n), where n is the length of the word. This is because each insertion operation runs in linear time with respect to the length of the word. Search: O(n * m) in the worst case, where n is the length of the word and m is the total number of nodes in the Trie. This happens when the search word contains dots (‘.’). However, for words without dots, the search is O(n). Space Complexity: O(m n), where m is the total number of Trie nodes and n is the average number of characters in the words. Each Trie node has up to 26 children (for each letter of the alphabet). In the worst case, when no nodes are shared, the space complexity is O(m n). # Extra Characters in a String2707. Extra Characters in a String Design Gurus 没咋看懂 Problem StatementGiven a string s and an array of words words. Break string s into multiple non-overlapping substrings such that each substring should be part of the words. There are some characters left which are not part of any substring. Return the minimum number of remaining characters in s, which are not part of any substring after string break-up. Examples Example 1: Input: s = &quot;amazingracecar&quot;, dictionary = [&quot;race&quot;, &quot;car&quot;] Expected Output: 7 Justification: The string s can be rearranged to form “racecar”, leaving ‘a’, ‘m’, ‘a’, ‘z’, ‘i’, ‘n’, ‘g’ as extra. Example 2: Input: s = &quot;bookkeeperreading&quot;, dictionary = [&quot;keep&quot;, &quot;read&quot;] Expected Output: 9 Justification: The words “keep” and “read” can be formed from s, but ‘b’, ‘o’, ‘o’, ‘k’, ‘e’, ‘r’, ‘i’, ‘n’, ‘g’ are extra. Example 3: Input: s = &quot;thedogbarksatnight&quot;, dictionary = [&quot;dog&quot;, &quot;bark&quot;, &quot;night&quot;] Expected Output: 6 Justification: The words “dog”, “bark”, and “night” can be formed, leaving ‘t’, ‘h’, ‘e’, ‘s’, ‘a’, ‘t’ as extra characters. Constraints: 1 &lt;= str.length &lt;= 50 1 &lt;= dictionary.length &lt;= 50 1 &lt;= dictionary[i].length &lt;= 50 dictionary[i] and s consists of only lowercase English letters dictionary contains distinct words SolutionThe solution approach utilizes a dynamic programming strategy combined with a trie data structure. The dynamic programming aspect allows for efficiently keeping track of the minimum extra characters required at each position in the string s. This is achieved by building a bottom-up solution, where we start from the end of the string and work our way towards the beginning, calculating the minimum extra characters required for each substring. The trie data structure is used to efficiently find and match the words from the dictionary within the string s. The combination of these two methods ensures that the solution is both time-efficient and space-efficient, as it avoids redundant computations and efficiently manages the storage of the dictionary words. Step-by-Step Algorithm Initialize Trie: Construct a trie using the words from the dictionary. Each node in the trie represents a character, and a complete path from the root to a leaf node represents a word. Dynamic Programming Array: Initialize a dynamic programming (DP) array, dp, of length n + 1, where n is the length of the string s. This array will store the minimum number of extra characters required for the substring starting from each index. DP Calculation: Iterate backwards through the string s: Set dp[start] to dp[start + 1] + 1 initially. This represents the case where the current character is considered an extra character. For each start position, iterate through the string to check if a word in the trie can be formed starting from this position. If the current substring matches a word in the trie (node.isEnd is true), update dp[start] to be the minimum of its current value and dp[end + 1], where end is the end of the matched word. This step ensures that we consider removing the matched word and count the rest as extra characters. Return Result: The value of dp[0] gives the minimum number of extra characters in the entire string s. Algorithm WalkthroughLet’s consider the input s = &quot;bookkeeperreading&quot;, dictionary = [&quot;keep&quot;, &quot;read&quot;] Trie Construction: Build the trie with “keep” and “read”. DP Initialization: Initialize dp array of length 18 (since “bookkeeperreading” has 17 characters). DP Calculation: Start from index 16 (last character ‘g’): For each index, try to form a word from the trie. For example, at index 12, the word “read” can be formed. Update dp[12] to be the minimum of dp[12] and dp[16] (which is the end of “read” + 1). Iterate Backwards: Continue this process for each character in s. If a character does not form a word in the trie, dp[start] remains dp[start + 1] + 1. Final Result: dp[0] will have the minimum extra characters after processing the entire string. This approach systematically checks each substring of s against the trie, and the dynamic programming array efficiently keeps track of the minimum extra characters required. The use of a trie ensures that each substring check is done in an optimized manner, avoiding unnecessary recomputations. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class TrieNode: def __init__(self): self.children = &#123;&#125; # Represents each character of the alphabet. self.isEnd = False # To determine if the current TrieNode marks the end of a word.class Solution: def minExtraChar(self, s, dictionary): root = self.buildTrie(dictionary) # Building the trie from the dictionary. n = len(s) dp = [0] * (n + 1) # DP array to store minimum extra characters. # 从后往前是因为这样适合Trie的结构来进行search for start in range(n - 1, -1, -1): dp[start] = dp[start + 1] + 1 # Default case: considering current character as extra. node = root for end in range(start, n): if s[end] not in node.children: break # No further word can be formed. node = node.children[s[end]] if node.isEnd: dp[start] = min(dp[start], dp[end + 1]) return dp[0] # Minimum extra characters for the entire string. def buildTrie(self, dictionary): root = TrieNode() for word in dictionary: node = root for char in word: if &#x27;a&#x27; &lt;= char &lt;= &#x27;z&#x27;: # Ensure the character is a lowercase letter if char not in node.children: node.children[char] = TrieNode() # Creating new node if not exists. node = node.children[char] else: raise ValueError(f&quot;Invalid character &#123;char&#125; in dictionary word &#123;word&#125;&quot;) node.isEnd = True # Mark the end of a word. return rootdef main(): solution = Solution() print(solution.minExtraChar(&quot;amazingracecar&quot;, [&quot;race&quot;, &quot;car&quot;])) # Output: 7 print(solution.minExtraChar(&quot;bookkeeperreading&quot;, [&quot;keep&quot;, &quot;read&quot;])) # Output: 9 print(solution.minExtraChar(&quot;thedogbarksatnight&quot;, [&quot;dog&quot;, &quot;bark&quot;, &quot;night&quot;])) # Output: 6if __name__ == &quot;__main__&quot;: main() Time and Space Complexity AnalysisTime Complexity Trie Construction: (O(W * L)), where (W) is the number of words in the dictionary and (L) is the average length of these words. Dynamic Programming Calculation: (O(n^2)), where (n) is the length of the input string s. Total Time Complexity: (O(W * L + n^2)). Space Complexity Trie Storage: (O(W * L)), for storing the words in the trie. Dynamic Programming Array: (O(n)), for the array used in dynamic programming. Total Space Complexity: (O(W * L + n)). Search Suggestions System1268. Search Suggestions System Design Gurus 不如暴力解法，看leetcode上之前用java写的 Problem StatementGiven a list of distinct strings products and a string searchWord. Determine a set of product suggestions after each character of the search word is typed. Every time a character is typed, return a list containing up to three product names from the products list that have the same prefix as the typed string. If there are more than 3 matching products, return 3 lexicographically smallest products. These product names should be returned in lexicographical (alphabetical) order. Examples Example 1: Input: Products: [“apple”, “apricot”, “application”], searchWord: “app” Expected Output: [[“apple”, “apricot”, “application”], [“apple”, “apricot”, “application”], [“apple”, “application”]] Justification: For the perfix ‘a’, “apple”, “apricot”, and “application” match. For the prefix ‘ap’, “apple”, “apricot”, and “application” match. For the prefix ‘app’, “apple”, and “application” match Example 2: Input: Products: [“king”, “kingdom”, “kit”], searchWord: “ki” Expected Output: [[“king”, “kingdom”, “kit”], [“king”, “kingdom”, “kit”]] Justification: All products starting with “k” are “king”, “kingdom”, and “kit”. The list remains the same for the ‘ki’ prefix. Example 3: Input: Products: [“fantasy”, “fast”, “festival”], searchWord: “farm” Expected Output: [[“fantasy”, “fast”, “festival”], [“fantasy”, “fast”], [], []] Justification: Initially, “fantasy”, “fast”, and “festival” match ‘f’. Moving to ‘fa’, only “fantasy” and “fast” match. No product matches with “far”, and “farm”. Constraints: 1 &lt;= products.length &lt;= 1000 1 &lt;= products[i].length &lt;= 3000 1 &lt;= sum(products[i].length) &lt;= 2 * 10^4 All the strings of products are unique. products[i] consists of lowercase English letters. 1 &lt;= searchWord.length &lt;= 1000 searchWord consists of lowercase English letters. SolutionTo solve this problem, We will use the trie data structure to store the list of products. The trie is built by inserting each product, where each node represents a character. This structure allows us to efficiently find products that share a common prefix. After building the trie, we process the search word by checking each of its prefixes. For each prefix, we perform a depth-first search (DFS) starting from the node matching the end of the prefix. The DFS is designed to find up to three lexicographically up to 3 smallest words that start with the given prefix. This approach of using a trie combined with DFS for each prefix ensures that we can quickly and effectively generate the required list of product suggestions. Step-by-Step Algorithm Build the Trie: Create a root node representing the starting point of the trie. For each product: Start from the root and for each character in the product, navigate to the corresponding child node. Create a new node if it doesn’t exist. Mark the node corresponding to the last character of the product as a word end. Process Each Prefix of the Search Word: Initialize an empty list to store the final suggestions for each prefix. For each character in the search word, form a prefix. Start from the root of the trie and navigate to the node corresponding to the last character of the current prefix. If the node for the current prefix doesn’t exist, add an empty list to the suggestions and move to the next prefix. DFS for Each Prefix: Upon reaching the node corresponding to the current prefix, perform a DFS. Initialize an empty buffer to store up to three products. Explore all possible paths from the current node. If a path leads to a node marked as a word end, add the corresponding product to the buffer. Stop the DFS when you have collected three products or explored all paths. Compile Suggestions: Add the buffer containing up to three products to the list of suggestions for the current prefix. Continue the process for the next prefix. Algorithm Walkthrough for Example 3 Input: Products = [“fantasy”, “fast”, “festival”], Search Word = “farm” Walkthrough: Building the Trie: Insert “fantasy”, “fast”, “festival” into the trie, creating nodes for each character. Mark the end of each word in the trie. Processing Prefixes: Prefix “f”: Node exists. Proceed to DFS. Prefix “fa”: Node exists. Proceed to DFS. Prefix “far”: Node does not exist. Add an empty list to suggestions and skip DFS. Prefix “farm”: Node does not exist. Add an empty list to suggestions and skip DFS. DFS for “f” and “fa”: For “f”: DFS finds “fantasy”, “fast”, “festival”. Add these to suggestions. For “fa”: DFS finds “fantasy”, “fast”. Add these to suggestions. Final Output: Suggestions: [[“fantasy”, “fast”, “festival”], [“fantasy”, “fast”], [], []]. This walkthrough illustrates how the trie efficiently organizes the products, and the DFS ensures that only the top three lexicographical matches for each prefix are selected. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980# class TrieNode:# # Initialize a TrieNode with a dictionary to hold children nodes and a flag to mark word&#x27;s end# def __init__(self):# self.children = &#123;&#125;# self.isEnd = Falseclass Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for ch in word: # Create a new child node if the character is not already a child of the current node if ch not in node.children: node.children[ch] = TrieNode() node = node.children[ch] # Mark the end of a word node.isEnd = True def dfs(self, node, prefix, list): # Stop if we already have 3 suggestions if len(list) == 3: return # Add the word to the list if we&#x27;re at the end of a word if node.isEnd: list.append(prefix) # Recursively search for all possible words for ch in &#x27;abcdefghijklmnopqrstuvwxyz&#x27;: if ch in node.children: self.dfs(node.children[ch], prefix + ch, list) def search(self, prefix): node = self.root # Traverse the trie to the end of the prefix for ch in prefix: if ch not in node.children: return [] # Return an empty list if the prefix is not present node = node.children[ch] list = [] self.dfs(node, prefix, list) # Start DFS from the end of the current prefix return listclass Solution: def suggestedProducts(self, products, searchWord): trie = Trie() # Insert each product into the trie for product in products: trie.insert(product) result = [] prefix = &#x27;&#x27; # For each character in the search word, find the top 3 suggestions for ch in searchWord: prefix += ch result.append(trie.search(prefix)) return resultif __name__ == &quot;__main__&quot;: solution = Solution() # Test Example 1 products1 = [&quot;apple&quot;, &quot;apricot&quot;, &quot;application&quot;] searchWord1 = &quot;app&quot; print(&quot;Example 1:&quot;, solution.suggestedProducts(products1, searchWord1)) # Test Example 2 products2 = [&quot;king&quot;, &quot;kingdom&quot;, &quot;kit&quot;] searchWord2 = &quot;ki&quot; print(&quot;Example 2:&quot;, solution.suggestedProducts(products2, searchWord2)) # Test Example 3 products3 = [&quot;fantasy&quot;, &quot;fast&quot;, &quot;festival&quot;] searchWord3 = &quot;farm&quot; print(&quot;Example 3:&quot;, solution.suggestedProducts(products3, searchWord3)) Time and Space Complexity AnalysisTime Complexity Building the Trie: (O(N x L)), where (N) is the number of products and (L) is the average length of the products. Searching for Each Prefix: (O(M x K)), where (M) is the length of the search word and (K) is the time taken for the DFS, which is limited to 3 (constant time). Overall, it’s approximately (O(M)). Overall Time Complexity: O(N * L + M), combining the time to build the Trie and perform searches. Space Complexity Trie Storage: (O(N x L)), as each product of average length (L) is stored in the trie. Search Results: (O(M)), as we store up to 3 suggestions for each character in the search word. Overall, the space complexity is dominated by the trie storage, which is (O(N x L)).","categories":[{"name":"Grokking Interview Pattern","slug":"Grokking-Interview-Pattern","permalink":"https://hasuer.github.io/categories/Grokking-Interview-Pattern/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hasuer.github.io/tags/Interview/"}]},{"title":"22. Pattern Backtracking","slug":"22. Pattern Backtracking","date":"2024-05-22T06:18:42.000Z","updated":"2024-05-28T03:30:31.239Z","comments":true,"path":"22-pattern-backtracking/index.html","link":"","permalink":"https://hasuer.github.io/22-pattern-backtracking/index.html","excerpt":"","text":"Introduction to Backtracking PatternBacktrackingBacktracking is an algorithmic technique that uses brute-force approach to solve a problem. Brute-force approach states that for any problem, we should try out all possible solutions and pick up those solutions that satisfy the problem constraints. In backtracking, we build a solution incrementally and follow the approach that if the current solution can’t lead to a valid solution, abandon it and backtrack (or go back) to try another solution. Because of this, recursion becomes a suitable technique for solving backtracking problems. Dynamic Programming (DP) uses a similar approach where we try out all possible solutions (using Memoization) to pick up the most optimized solution. DP is used to solve optimization problems; backtracking, on the other hand, is mostly used when multiple valid solutions are possible for a problem. An ExampleLet’s understand backtracking with an example. Imagine we want to plant, in a straight line, three fruit trees Apple, Orange, and Mango. What are the possible ways these trees can be planted? The only restriction we have is that Apple and Orange trees can’t be placed next to each other. Following a brute-force approach, we can find all possible combinations in which the three trees can be placed and pick those that fulfill the given constraint. Let’s try finding all the possible arrangements. The first tree can be of any kind, Apple, Orange, or Mango. If our first tree is Apple, the second tree can be Orange or Mango. If we place Orange as our second tree, then our constraint is not fulfilled (which was not to place Apple and Orange together). Hence it is not a valid arrangement; therefore, we go back (i.e., backtrack) and place Mango as our second tree. Now, we can place Orange in the third place; this arrangement fulfills the problem constraint. The following diagram shows all possible arrangements: From the above diagram, we can clearly see that the two valid arrangements are: [Apple, Mango, Orange] and [Orange, Mango, Apple]. This approach of evaluating all possible solutions, going back whenever we see that a certain constraint can’t be met, and trying out other possible solutions is called backtracking. Let’s solve some more problems to develop a deeper understanding of backtracking. Combination SumTop Interview 150 | 39. Combination Sum Design Gurus Problem StatementGiven an array of distinct positive integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order. The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different. Example 1: 123Input: candidates = [2, 3, 6, 7], target = 7 Output: [[2, 2, 3], [7]] Explanation: The elements in these two combinations sum up to 7. Example 2: 123Input: candidates = [2, 4, 6, 8], target = 10 Output: [[2,2,2,2,2], [2,2,2,4], [2,2,6], [2,4,4], [2,8], [4,6]] Explanation: The elements in these six combinations sum up to 10. Constraints: 1 &lt;= candidates.length &lt;= 30 2 &lt;= candidates[i] &lt;= 40 All elements of candidates are distinct. 1 &lt;= target &lt;= 40 SolutionThis problem is quite similar to the example discussed in the previous lesson (placing apple, orange, and mango trees). We can follow the brute-force approach to incrementally build the solution. If, at any time, we find out that the current solution can’t lead to a valid combination, we will abandon it and backtrack to try the remaining solutions. Let’s try this approach on the following input: Candidates: [3, 4, 5], Target: 9 Here are the number of steps in our algorithm: We will start with an empty set. This also means that the sum of the elements in the set is zero. We can try adding all three numbers separately in the set. This will give us three sets: [3], [4], [5]. Let’s take set [3], since the sum of its elements is less than the Target (=9), we will try adding more numbers to it. We can add all three numbers again to generate new sets. We can add ‘3’ again, as each number can be added multiple times. After adding all numbers separately to the set [3], we will get the following sets: [3, 3], [3, 4], [3, 5]. We can see, each set has a sum less than the target. We can now, repeat the same process as described in step-4. For [3, 3]: Adding ‘3’ will give us a valid solution [3, 3, 3] having a sum equal to the target. Adding ‘4’ and ‘5’ will give us a sum which is greater than the target. Therefore, we can stop the search here for this set, as adding any additional number will not produce a correct solution. For [3, 4]: We will add ‘4’ or ‘5’ to it, which will give us a sum greater than the target. We will stop our search here for this set. For [3, 5]: We can only add ‘5’ to it, which does not produce a valid solution. Similar approach can be applied to other sets. In the end, we can see that the valid solutions are: [3, 3, 3] and [4, 5]. CodeThe basic idea is to start with an empty combination and iterate through the candidates array, adding each candidate to the current combination and recursively calling the function with the updated combination and the remaining target. If the target becomes 0, we add the current combination to the result list. If the target becomes negative, we backtrack and remove the last added candidate from the combination. The function combinationSum takes in two parameters, an array of distinct integers candidates and a target integer target, and returns a list of all unique combinations of candidates where the chosen numbers sum to target. The function starts by defining the function backtrack(candidates, start, target, comb, res). This function takes five parameters, candidates, start, target, comb, and res: candidates is the array containing candidate elements. start is the starting index of the candidates array. target is the remaining target. comb is the current combination. res is the final result list. The backtrack function uses recursion to find the combinations. The base case for the recursion is if the target is 0. When the target is 0, that means we have found a valid combination and we append a copy of the current combination to the result list. It then iterates through the candidates array starting from the given index. If the current candidate is greater than the remaining target, it skips the current candidate and move on to the next. If the current candidate is less than the remaining target, it adds the current candidate to the current combination, recursively calls the function with the updated combination and remaining target, and then backtracks by removing the last added candidate from the combination. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class Solution(object): def combinationSum(self, candidates, target): res = [] # To store the final result self.backtrack(candidates, 0, target, [], res) return res def backtrack(self, candidates, start, target, comb, res): # If target is 0, we have found a valid combination if target == 0: # Append a copy of the current combination to the result list res.append(list(comb)) return # Iterate through the candidates array starting from the given index for i in range(start, len(candidates)): # If the current candidate is greater than the remaining target, move on to the next if target &lt; candidates[i]: continue # Add the current candidate to the current combination comb.append(candidates[i]) # Recursively call the function with the updated combination and remaining target self.backtrack(candidates, i, target - candidates[i], comb, res) # Backtrack by removing the last added candidate from the combination comb.pop()def main(): # Test case 1 candidates = [2, 3, 6, 7] target = 7 s = Solution() print(s.combinationSum(candidates, target)) # expected output: [[2, 2, 3], [7]] # Test case 2 candidates = [2, 3, 5] target = 8 s = Solution() print( s.combinationSum(candidates, target) ) # expected output: [[2, 2, 2, 2], [2, 3, 3], [3, 5]] # Test case 3 candidates = [] target = 8 s = Solution() print(s.combinationSum(candidates, target)) # expected output: [] # Test case 4 candidates = [5, 10, 15] target = 20 s = Solution() print( s.combinationSum(candidates, target) ) # expected output: [[5,5,5,5], [5,5,10], [5,15], [10,10]] # Test case 5 candidates = [2, 4, 6, 8] target = 10 s = Solution() print( s.combinationSum(candidates, target) ) # expected output: [[2,2,2,2,2], [2,2,2,4], [2,2,6], [2,4,4], [2,8], [4,6]] # Test case 6 candidates = [2, 3, 5] target = 0 s = Solution() print(s.combinationSum(candidates, target)) # expected output: [[]]main() Time ComplexityThis algorithm has a time complexity of O(N^(T/M + 1)), where is N the total number of elements in the candidates array, T is the target value, and M is the smallest value among the candidates. This is because the execution of the backtracking is similar to a DFS traversal of an n-ary tree. So, the time complexity would be the same as the number of nodes in the n-ary tree. This can be seen in the above diagram. Each node can call the backtrack function a maximum of N times, i.e., the total number of candidates. The maximal depth of the n-ary tree would be T/M, where we keep on adding the smallest element to the combination. As we know, the maximal number of nodes in N-ary tree of T/M height would be N^(T/M + 1), hence the time complexity is O(N^(T/M + 1)). Space ComplexityIgnoring the space needed for the output array, the space complexity will be O(T/M) because at any time, we can pile up to T/M recursive calls of the backtrack function; this will happen when we keep on adding the smallest element to the combination. As a result, the space overhead of the recursion is O(T/M). Word SearchTop Interview 150 | 79. Word Search Design Gurus 类似 这道题 Problem StatementGiven an m x n grid of characters board and a string word, return true if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. Example 1:Input: word=”ABCCED”, board: 123&#123; &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;E&#x27; &#125;,&#123; &#x27;S&#x27;, &#x27;F&#x27;, &#x27;C&#x27;, &#x27;S&#x27; &#125;,&#123; &#x27;A&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;E&#x27; &#125; Output: true Explanation: The word exists in the board:-&gt; { ‘A’, ‘B’, ‘C’, ‘E’ },-&gt; { ‘S’, ‘F’, ‘C’, ‘S’ },-&gt; { ‘A’, ‘D’, ‘E’, ‘E’ } Example 2:Input: word=”SEE”, board: 123&#123; &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;E&#x27; &#125;,&#123; &#x27;S&#x27;, &#x27;F&#x27;, &#x27;C&#x27;, &#x27;S&#x27; &#125;,&#123; &#x27;A&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;E&#x27; &#125; Output: true Explanation: The word exists in the board:-&gt; { ‘A’, ‘B’, ‘C’, ‘E’ },-&gt; { ‘S’, ‘F’, ‘C’, ‘S’ },-&gt; { ‘A’, ‘D’, ‘E’, ‘E’ } Constraints: m == board.length n = board[i].length 1 &lt;= m, n &lt;= 6 1 &lt;= word.length &lt;= 15 board and word consists of only lowercase and uppercase English letters. SolutionThe basic approach to solving the word search problem using backtracking is to start at the first character of the word and check all 8 adjacent cells in the grid to see if any of them match the next character of the word. If a match is found, mark the cell as visited and recursively check the next character of the word in the adjacent cells of the newly visited cell. If the entire word is found, return true. If no match is found, backtrack to the previous cell and try a different path. Repeat this process until the entire grid has been searched or the word is found. CodeThis function takes a 2D list board and a string word as input, and returns True if the word can be found in board and False otherwise. It uses a helper function dfs which takes 4 additional parameters: i and j are the current coordinates of the cell that is being visited, k is the index of the current character of the word being matched, and board and word are the inputs passed to the main function. The dfs function uses a helper variable tmp to store the current value of the cell before it is marked as visited. This is done so that we can backtrack later. It then uses recursion to check if the next character of the word exists in the 4 adjacent cells, and it will mark the cell as visited and move to next index of the word by incrementing k by 1. If the next character is found, the function returns true, if not it backtracks to the previous cell, and continues the search in different path. If the entire word is found, the function returns True, otherwise it returns False after searching the entire grid. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495class Solution: def dfs(self, board, word, i, j, k): # check if current coordinates are out of grid or the current cell doesn&#x27;t match the current character of the word if not 0 &lt;= i &lt; len(board) or not 0 &lt;= j &lt; len(board[0]) or board[i][j] != word[k]: return False # check if we have reached the end of the word if k == len(word) - 1: return True # mark the current cell as visited by replacing it with &#x27;/&#x27; tmp, board[i][j] = board[i][j], &#x27;/&#x27; # check all 4 adjacent cells recursively res = self.dfs(board, word, i + 1, j, k + 1) or \\ self.dfs(board, word, i - 1, j, k + 1) or \\ self.dfs(board, word, i, j + 1, k + 1) or \\ self.dfs(board, word, i, j - 1, k + 1) # backtrack by replacing the current cell with its original value board[i][j] = tmp return res def exist(self, board, word): for i in range(len(board)): for j in range(len(board[0])): # start the search from every cell if board[i][j] == word[0]: # 这一行是我加的，可以减少搜索空间 if self.dfs(board, word, i, j, 0): return True return Falsedef main(): sol = Solution() # Test Case 1 board = [ [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;E&#x27;], [&#x27;S&#x27;, &#x27;F&#x27;, &#x27;C&#x27;, &#x27;S&#x27;], [&#x27;A&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;E&#x27;] ] word = &quot;ABCCED&quot; print(sol.exist(board, word)) # expected output: True # Test Case 2 board = [ [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;E&#x27;], [&#x27;S&#x27;, &#x27;F&#x27;, &#x27;C&#x27;, &#x27;S&#x27;], [&#x27;A&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;E&#x27;] ] word = &quot;SEE&quot; print(sol.exist(board, word)) # expected output: True # Test Case 3 board = [ [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;E&#x27;], [&#x27;S&#x27;, &#x27;F&#x27;, &#x27;C&#x27;, &#x27;S&#x27;], [&#x27;A&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;E&#x27;] ] word = &quot;ABCB&quot; print(sol.exist(board, word)) # expected output: False # Test Case 4 board = [[&#x27;a&#x27;, &#x27;a&#x27;]] word = &quot;aaa&quot; print(sol.exist(board, word)) # expected output: False # Test Case 5 board = [[&#x27;a&#x27;]] word = &quot;a&quot; print(sol.exist(board, word)) # expected output: True # Test Case 6 board = [ [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;], [&#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;], [&#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;], [&#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;], [&#x27;u&#x27;, &#x27;v&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;], [&#x27;z&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;] ] word = &quot;abcde&quot; print(sol.exist(board, word)) # expected output: True # Test Case 7 board = [ [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;], [&#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;], [&#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;], [&#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;], [&#x27;u&#x27;, &#x27;v&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;], [&#x27;z&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;] ] word = &quot;zabcd&quot; print(sol.exist(board, word)) # expected output: Truemain() Time ComplexityThe time complexity of the ‘exist’ function is O(4^n), where is n the length of the word. This is because the function uses a depth-first search (DFS) algorithm to traverse the board, and for each cell in the board, it checks all 4 adjacent cells recursively. The worst-case scenario is when the word is found in the last cell of the board, and in that case, the function will have to check all possible paths from the starting cell to the last cell, which is 4^n possible paths. Space ComplexityThe space complexity of the exist function is O(n), where n is the length of the word. This is because the function uses a DFS algorithm, and the maximum depth of the recursion tree is n. In other words, the maximum number of function calls that will be stored on the call stack at any point in time is n. Sudoku Solver37. Sudoku Solver Design Gurus Problem StatementWrite a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy all of the following rules: Each of the digits 1-9 must occur exactly once in each row. Each of the digits 1-9 must occur exactly once in each column. Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid. The ‘.’ character indicates empty cells. Example 1:Input: 123456789&#123;&#x27;5&#x27;, &#x27;3&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;7&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;&#125;,&#123;&#x27;6&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;1&#x27;, &#x27;9&#x27;, &#x27;5&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;&#125;,&#123;&#x27;.&#x27;, &#x27;9&#x27;, &#x27;8&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;6&#x27;, &#x27;.&#x27;&#125;,&#123;&#x27;8&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;6&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;3&#x27;&#125;,&#123;&#x27;4&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;8&#x27;, &#x27;.&#x27;, &#x27;3&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;1&#x27;&#125;,&#123;&#x27;7&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;2&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;6&#x27;&#125;,&#123;&#x27;.&#x27;, &#x27;6&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;2&#x27;, &#x27;8&#x27;, &#x27;.&#x27;&#125;,&#123;&#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;4&#x27;, &#x27;1&#x27;, &#x27;9&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;5&#x27;&#125;,&#123;&#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;8&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;7&#x27;, &#x27;9&#x27;&#125; Output: 123456789&#123;&#x27;5&#x27;&#x27;, &#x27;3&#x27;&#x27;, &#x27;4&#x27;&#x27;, &#x27;6&#x27;&#x27;, &#x27;7&#x27;&#x27;, &#x27;8&#x27;&#x27;, &#x27;9&#x27;&#x27;, &#x27;1&#x27;&#x27;, &#x27;2&#x27;&#x27;&#125;,&#123;&#x27;6&#x27;&#x27;, &#x27;7&#x27;&#x27;, &#x27;2&#x27;&#x27;, &#x27;1&#x27;&#x27;, &#x27;9&#x27;&#x27;, &#x27;5&#x27;&#x27;, &#x27;3&#x27;&#x27;, &#x27;4&#x27;&#x27;, &#x27;8&#x27;&#x27;&#125;,&#123;&#x27;1&#x27;&#x27;, &#x27;9&#x27;&#x27;, &#x27;8&#x27;&#x27;, &#x27;3&#x27;&#x27;, &#x27;4&#x27;&#x27;, &#x27;2&#x27;&#x27;, &#x27;5&#x27;&#x27;, &#x27;6&#x27;&#x27;, &#x27;7&#x27;&#x27;&#125;,&#123;&#x27;8&#x27;&#x27;, &#x27;5&#x27;&#x27;, &#x27;9&#x27;&#x27;, &#x27;7&#x27;&#x27;, &#x27;6&#x27;&#x27;, &#x27;1&#x27;&#x27;, &#x27;4&#x27;&#x27;, &#x27;2&#x27;&#x27;, &#x27;3&#x27;&#x27;&#125;,&#123;&#x27;4&#x27;&#x27;, &#x27;2&#x27;&#x27;, &#x27;6&#x27;&#x27;, &#x27;8&#x27;&#x27;, &#x27;5&#x27;&#x27;, &#x27;3&#x27;&#x27;, &#x27;7&#x27;&#x27;, &#x27;9&#x27;&#x27;, &#x27;1&#x27;&#x27;&#125;,&#123;&#x27;7&#x27;&#x27;, &#x27;1&#x27;&#x27;, &#x27;3&#x27;&#x27;, &#x27;9&#x27;&#x27;, &#x27;2&#x27;&#x27;, &#x27;4&#x27;&#x27;, &#x27;8&#x27;&#x27;, &#x27;5&#x27;&#x27;, &#x27;6&#x27;&#x27;&#125;,&#123;&#x27;9&#x27;&#x27;, &#x27;6&#x27;&#x27;, &#x27;1&#x27;&#x27;, &#x27;5&#x27;&#x27;, &#x27;3&#x27;&#x27;, &#x27;7&#x27;&#x27;, &#x27;2&#x27;&#x27;, &#x27;8&#x27;&#x27;, &#x27;4&#x27;&#x27;&#125;,&#123;&#x27;2&#x27;&#x27;, &#x27;8&#x27;&#x27;, &#x27;7&#x27;&#x27;, &#x27;4&#x27;&#x27;, &#x27;1&#x27;&#x27;, &#x27;9&#x27;&#x27;, &#x27;6&#x27;&#x27;, &#x27;3&#x27;&#x27;, &#x27;5&#x27;&#x27;&#125;,&#123;&#x27;3&#x27;&#x27;, &#x27;4&#x27;&#x27;, &#x27;5&#x27;&#x27;, &#x27;2&#x27;&#x27;, &#x27;8&#x27;&#x27;, &#x27;6&#x27;&#x27;, &#x27;1&#x27;&#x27;, &#x27;7&#x27;&#x27;, &#x27;9&#x27;&#x27;&#125; Explanation: The given output is the only valid Sudoku solution. Constraints: board.length == 9 board[i].length == 9 board[i][j] is a digit or ‘.’. It is guaranteed that the input board has only one solution. SolutionSudoku is a popular puzzle game that involves filling in a 9x9 grid with numbers such that each column, each row, and each of the nine 3x3 sub-grids that compose the grid contains all of the digits from 1 to 9. One way to solve a sudoku puzzle is by using backtracking, which is a form of brute-force search. Here are the steps to solve a sudoku puzzle using backtracking: Start with an empty 9x9 grid and fill in the numbers that are given in the puzzle. From left to right and top to bottom, find the first empty cell (denoted by a .) in the grid. Try out every number from 1 to 9 as a possible solution for the empty cell. Before filling in a number, check if it is a valid solution by checking if the number is already present in the same row, column, or 3x3 sub-grid. If the number is valid, fill it in the cell and recursively call the function to move to the next empty cell. If the number is not valid, backtrack to the previous state and try a different number. If a valid solution is found, return true. If no solution is found, return false. If the function returns true, the grid is filled with a valid solution. Else, the puzzle is unsolvable. CodeThe function solveSudoku starts by iterating through the board and checking for empty cells represented by ‘.’ character. When an empty cell is found, the function tries every number from 1-9 by using a nested loop. Before filling the cell with a number, the function checks if the number is valid in the current cell by using the helper function isValid. The function isValid checks if the same number is already present in the same row, column or 3x3 box. If the number is valid, the cell is filled with the number and the function recursively calls itself to solve the rest of the board. If the current number doesn’t lead to a solution, the function backtracks by emptying the cell and trying the next number. If all the numbers have been tried and none of them lead to a solution, the function returns false. If the board is completely filled, the function returns true, indicating that a solution has been found. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class Solution: # Helper function to check if a given number is valid in the current cell def isValid(self, board, row, col, num): # Check if we already have the same number in the same row, col or box for x in range(9): if board[row][x] == num: return False # Check if the same number is in the same row if board[x][col] == num: return False # Check if the same number is in the same col if board[(row // 3) * 3 + x // 3][(col // 3) * 3 + x % 3] == num: return False # Check if the same number is in the same 3x3 box return True def solveSudoku(self, board): for row in range(9): for col in range(9): if board[row][col] == &#x27;.&#x27;: # If we find an empty cell for num in range(1, 10): # Try every number from 1-9 if self.isValid(board, row, col, str(num)): # Check if the number is valid in the current cell board[row][col] = str(num) # If it is valid, fill the cell with the number if self.solveSudoku(board): # Recursively call the function to solve the rest of the board return True else: # If the current number doesn&#x27;t lead to a solution, backtrack by emptying the cell board[row][col] = &#x27;.&#x27; return False # If we have tried every number and none of them lead to a solution, return false return True # If the board is completely filled, return truedef main(): sol = Solution() # Test case 1 board = [[&#x27;5&#x27;, &#x27;3&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;7&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;], [&#x27;6&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;1&#x27;, &#x27;9&#x27;, &#x27;5&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;], [&#x27;.&#x27;, &#x27;9&#x27;, &#x27;8&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;6&#x27;, &#x27;.&#x27;], [&#x27;8&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;6&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;3&#x27;], [&#x27;4&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;8&#x27;, &#x27;.&#x27;, &#x27;3&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;1&#x27;], [&#x27;7&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;2&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;6&#x27;], [&#x27;.&#x27;, &#x27;6&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;2&#x27;, &#x27;8&#x27;, &#x27;.&#x27;], [&#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;4&#x27;, &#x27;1&#x27;, &#x27;9&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;5&#x27;], [&#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;8&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;7&#x27;, &#x27;9&#x27;]] print(sol.solveSudoku(board)) # expected output: 5 3 4 6 7 8 9 1 2 # 6 7 2 1 9 5 3 4 8 # 1 9 8 3 4 2 5 6 7 # 8 5 9 7 6 1 4 2 3 # 4 2 6 8 5 3 7 9 1 # 7 1 3 9 2 4 8 5 6 # 9 6 1 5 3 7 2 8 4 # 2 8 7 4 1 9 6 3 5 # 3 4 5 2 8 6 1 7 9 print(board) # Test case 2 board = [[&#x27;8&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;], [&#x27;.&#x27;, &#x27;.&#x27;, &#x27;3&#x27;, &#x27;6&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;], [&#x27;.&#x27;, &#x27;7&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;9&#x27;, &#x27;.&#x27;, &#x27;2&#x27;, &#x27;.&#x27;, &#x27;.&#x27;], [&#x27;.&#x27;, &#x27;5&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;7&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;], [&#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;7&#x27;, &#x27;.&#x27;, &#x27;.&#x27;], [&#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;1&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;3&#x27;, &#x27;.&#x27;], [&#x27;.&#x27;, &#x27;.&#x27;, &#x27;1&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;6&#x27;, &#x27;8&#x27;], [&#x27;.&#x27;, &#x27;.&#x27;, &#x27;8&#x27;, &#x27;5&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;1&#x27;, &#x27;.&#x27;], [&#x27;.&#x27;, &#x27;9&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;4&#x27;, &#x27;.&#x27;, &#x27;.&#x27;]] print(sol.solveSudoku(board)) # expected output: 8 1 2 7 5 3 6 4 9 # 9 4 3 6 8 2 1 7 5 # 6 7 5 4 9 1 2 8 3 # 1 5 4 2 3 7 8 9 6 # 3 6 9 8 4 5 7 2 1 # 2 8 7 1 6 9 5 3 4 # 5 2 1 9 7 4 3 6 8 # 4 3 8 5 2 6 9 1 7 # 7 9 6 3 1 8 4 5 2 print(board)main() Time Complexitysince the board size is fixed, the time complexity is O(1), as there is no variable input. Though let’s discuss the number of operations needed: (9!)^9 Let’s consider one row where we have 9 cells to fill. There are not more than 9 possibilities for the first number to put, not more than 9×8 for the second one, not more than 9×8×7 for the third one, and so on. In total, that results in not more than (9!) possibilities for just one row; this means not more than (9!)^9 operations in total. If we compare the brutefore and backtracking algorithms: 9^81 = 1966270504755529136180759085269121162831034509442147669273154155379663911968099 for the brute force, and (9!)^9 =109110688415571316480344899355894085582848000000000 for the standard backtracking, i.e. the number of operations is reduced in times! Space ComplexityThe board size is fixed, and the space is used to store the board containing 81 cells, hence the time complexity is O(1). Factor Combinationsleetcode 会员 Design Gurus Problem StatementNumbers can be regarded as the product of their factors. For example, 8 = 2 x 2 x 2 = 2 x 4. Given an integer n, return all possible combinations of its factors. You may return the answer in any order. Example 1: 12Input: n = 8 Output: [[2, 2, 2], [2, 4]] Example 2: 12Input: n = 20 Output: [[2, 2, 5], [2, 10], [4, 5]] Constraints: 1 &lt;= n &lt;= 10^7 SolutionWe can use backtracking to find all the factors of a given number . We will start by iterating through all integers from start (2 by default) to the square root of n+1. If the current integer i divides n, we will add i to the list of current factors curr and appends this list along with the corresponding factor of n/i to the list of all factors (result). Then we can recursively call the function with n/i as the new input, i as the new start value, and curr and result as the current factors and results. After each recursive call, we have to pop the last element from curr to backtrack and find other factors. CodeHere is what our algorithm will look like: 12345678910111213141516171819202122232425262728class Solution: def getAllFactors(self, n, start, curr, result): # Iterate through all integers i from start to the square root of n + 1 # This loop is used to find all the factors of the input number n for i in range(start, int(n ** 0.5) + 1): # If n is divisible by i, add i to the curr list of factors # curr is used to store the current factors being calculated if n % i == 0: curr.append(i) # Found a factor, append it to the list of factors # Append the current factors and the corresponding factor of n // i to the result list result.append(list(curr + [n // i])) # Recursively call the function with n // i as the new input, i as the new start value, and curr and result as the current factors and results self.getAllFactors(n // i, i, curr, result) curr.pop() # Pop the last element from curr to backtrack and find other factors return result def getFactors(self, n): return self.getAllFactors(n, 2, [], [])# test casessol = Solution()print(sol.getFactors(8)) # expected: [[2, 2, 2], [2, 4]]print(sol.getFactors(12)) # expected: [[2, 2, 3], [2, 6], [3, 4]]print(sol.getFactors(16)) # expected: [[2, 2, 2, 2], [2, 2, 4], [2, 8], [4, 4]]print(sol.getFactors(20)) # expected: [[2, 2, 5], [2, 10], [4, 5]]print(sol.getFactors(1)) # expected: [] Time ComplexityWe can’t have more than factors of a number n. This means that getAllFactors can be called a maximum of times recursively. The for loop iterates a maximum of . This means that the overall time complexity is or Space ComplexityIgnoring the space needed for the output array, the space complexity will be as we need to save only one factor while in the recursion, and our recursion tree won’t get bigger than steps. Split a String Into the Max Number of Unique Substrings1593. Split a String Into the Max Number of Unique Substrings Design Gurus Problem StatementGiven a string s, return the maximum number of unique substrings that the given string can be split into. You can split string s into any list of non-empty substrings, where the concatenation of the substrings forms the original string. However, you must split the substrings such that all of them are unique. A substring is a contiguous sequence of characters within a string. Example 1: 123Input: s = &quot;aab&quot; Output: 2 Explanation: Two possible ways to split the given string into maximum unique substrings are: [&#x27;a&#x27;, &#x27;ab&#x27;] &amp; [&#x27;aa&#x27;, &#x27;b&#x27;], both have 2 substrings; hence the maximum number of unique substrings in which the given string can be split is 2. Example 2: 123Input: s = &quot;abcabc&quot; Output: 4 Explanation: Four possible ways to split into maximum unique substrings are: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;abc&#x27;] &amp; [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;cab&#x27;, &#x27;c&#x27;] &amp; [&#x27;a&#x27;, &#x27;bca&#x27;, &#x27;b&#x27;, &#x27;c&#x27;] &amp; [&#x27;abc&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], all have 4 substrings. Constraints: 1 &lt;= s.length &lt;= 16 s contains only lower case English letters. SolutionWe can use backtracking to solve this problem. This solution uses a helper function splitAndCount which takes three arguments, the input string s, the current start position and a set set to keep track of the unique substrings that have been split so far. The maxUniqueSplit function calls the splitAndCount function to find the maximum number of unique substrings that the given string can be split into. The splitAndCount function starts with a base case where it returns the size of the set when the current start position is equal to the length of the input string. This means that all substrings have been processed and the size of the set represents the maximum number of unique substrings. The function then uses a for loop to iterate through all possible substrings starting from the current start position. For each substring, it checks if the substring is already in the set. If it is not, the substring is added to the set and the function is recursively called with the new start position being the end of the current substring. This continues until all possible substrings have been processed. After the recursive call, the substring is removed from the set to backtrack. The function keeps track of the maximum number of unique substrings found so far and returns this maximum count when all substrings have been processed. CodeHere is the code of our algorithm: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution: def maxUniqueSplit(self, s: str) -&gt; int: return self.split_and_count(s, 0, set()) def split_and_count(self, s: str, start: int, set) -&gt; int: # base case, if we have reached the end of the input string, return the size of the set if start == len(s): return len(set) count = 0 # loop through all substrings starting from the current start position for i in range(start + 1, len(s) + 1): string = s[start:i] # if the substring is not in the set, add it and recursively call the function with the new start position if string not in set: set.add(string) count = max(count, self.split_and_count(s, i, set)) set.remove(string) # remove the substring from the set and backtrack return count # return the maximum count of unique substrings foundif __name__ == &quot;__main__&quot;: sol = Solution() # Test Case 1 input1 = &quot;abcabc&quot; output1 = sol.maxUniqueSplit(input1) print(&quot;maxUniqueSplit(&quot; + input1 + &quot;) = &quot; + str(output1)) # Expected: 4 # Test Case 2 input2 = &quot;aab&quot; output2 = sol.maxUniqueSplit(input2) print(&quot;maxUniqueSplit(&quot; + input2 + &quot;) = &quot; + str(output2)) # Expected: 2 # Test Case 3 input3 = &quot;ababab&quot; output3 = sol.maxUniqueSplit(input3) print(&quot;maxUniqueSplit(&quot; + input3 + &quot;) = &quot; + str(output3)) # Expected: 4 # Test Case 4 input4 = &quot;&quot; output4 = sol.maxUniqueSplit(input4) print(&quot;maxUniqueSplit(&quot; + input4 + &quot;) = &quot; + str(output4)) # Expected: 0 # Test Case 5 input5 = &quot;a&quot; output5 = sol.maxUniqueSplit(input5) print(&quot;maxUniqueSplit(&quot; + input5 + &quot;) = &quot; + str(output5)) # Expected: 1 Time ComplexityWe can split any given string of length n in 2^n ways. Hence the time complexity will be O(2^n). Space ComplexityThe space complexity will be O(n) as we need to save only one way of splitting the given string while in the recursion, and our recursion tree won’t get bigger than O(n) steps too.","categories":[{"name":"Grokking Interview Pattern","slug":"Grokking-Interview-Pattern","permalink":"https://hasuer.github.io/categories/Grokking-Interview-Pattern/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hasuer.github.io/tags/Interview/"}]},{"title":"21. Pattern  01 Knapsack (Dynamic Programming)","slug":"21. Pattern  01 Knapsack (Dynamic Programming)","date":"2024-05-21T02:10:23.000Z","updated":"2024-05-28T03:30:17.865Z","comments":true,"path":"21-pattern-01-knapsack-dynamic-programming/index.html","link":"","permalink":"https://hasuer.github.io/21-pattern-01-knapsack-dynamic-programming/index.html","excerpt":"","text":"Introduction0/1 Knapsack pattern is based on the famous problem with the same name which is efficiently solved using Dynamic Programming (DP). In this pattern, we will go through a set of problems to develop an understanding of DP. We will always start with a brute-force recursive solution to see the overlapping subproblems, i.e., realizing that we are solving the same problems repeatedly. After the recursive solution, we will modify our algorithm to apply advanced techniques of Memoization and Bottom-Up Dynamic Programming to develop a complete understanding of this pattern. Let’s jump onto our first problem. *0/1 Knapsack (medium)Design Gurus Educative.io IntroductionGiven the weights and profits of ‘N’ items, we are asked to put these items in a knapsack which has a capacity ‘C’. The goal is to get the maximum profit out of the items in the knapsack. Each item can only be selected once, as we don’t have multiple quantities of any item. Let’s take the example of Merry, who wants to carry some fruits in the knapsack to get maximum profit. Here are the weights and profits of the fruits: Items: { Apple, Orange, Banana, Melon }Weights: { 2, 3, 1, 4 }Profits: { 4, 5, 3, 7 }Knapsack capacity: 5 Let’s try to put various combinations of fruits in the knapsack, such that their total weight is not more than 5: Apple + Orange (total weight 5) =&gt; 9 profitApple + Banana (total weight 3) =&gt; 7 profitOrange + Banana (total weight 4) =&gt; 8 profitBanana + Melon (total weight 5) =&gt; 10 profit This shows that Banana + Melon is the best combination as it gives us the maximum profit and the total weight does not exceed the capacity. Problem StatementGiven two integer arrays to represent weights and profits of ‘N’ items, we need to find a subset of these items which will give us maximum profit such that their cumulative weight is not more than a given number ‘C’. Each item can only be selected once, which means either we put an item in the knapsack or we skip it. Basic SolutionA basic brute-force solution could be to try all combinations of the given items (as we did above), allowing us to choose the one with maximum profit and a weight that doesn’t exceed ‘C’. Take the example of four items (A, B, C, and D), as shown in the diagram below. To try all the combinations, our algorithm will look like: Here is a visual representation of our algorithm: All green boxes have a total weight that is less than or equal to the capacity (7), and all the red ones have a weight that is more than 7. The best solution we have is with items [B, D] having a total profit of 22 and a total weight of 7. CodeHere is the code for the brute-force solution: 1234567891011121314151617181920212223242526272829303132class Solution: def solveKnapsack(self, profits, weights, capacity): return self.knapsack_recursive(profits, weights, capacity, 0) def knapsack_recursive(self, profits, weights, capacity, currentIndex): # base checks if capacity &lt;= 0 or currentIndex &gt;= len(profits): return 0 # recursive call after choosing the element at the currentIndex # if the weight of the element at currentIndex exceeds the capacity, we shouldn&#x27;t # process this profit1 = 0 if weights[currentIndex] &lt;= capacity: profit1 = profits[currentIndex] + self.knapsack_recursive( profits, weights, capacity - weights[currentIndex], currentIndex + 1) # recursive call after excluding the element at the currentIndex profit2 = self.knapsack_recursive(profits, weights, capacity, currentIndex + 1) return max(profit1, profit2)def main(): sol = Solution() print(sol.solveKnapsack([1, 6, 10, 16], [1, 2, 3, 5], 7)) print(sol.solveKnapsack([1, 6, 10, 16], [1, 2, 3, 5], 6))main() Time and Space complexityThe time complexity of the above algorithm is exponential O(2^n), where ‘n’ represents the total number of items. This can also be confirmed from the above recursion tree. As we can see, we will have a total of ‘31’ recursive calls – calculated through (2^n) + (2^n) - 1, which is asymptotically equivalent to O(2^n). The space complexity is O(n). This space will be used to store the recursion stack. Since the recursive algorithm works in a depth-first fashion, which means that we can’t have more than ‘n’ recursive calls on the call stack at any time. Overlapping Sub-problems: Let’s visually draw the recursive calls to see if there are any overlapping sub-problems. As we can see, in each recursive call, profits and weights arrays remain constant, and only capacity and currentIndex change. For simplicity, let’s denote capacity with ‘c’ and currentIndex with ‘i’: We can clearly see that ‘c:4, i=3’ has been called twice. Hence we have an overlapping sub-problems pattern. We can use Memoization to efficiently solve overlapping sub-problems. Top-down Dynamic Programming with MemoizationMemoization is when we store the results of all the previously solved sub-problems and return the results from memory if we encounter a problem that has already been solved. Since we have two changing values (capacity and currentIndex) in our recursive function knapsackRecursive(), we can use a two-dimensional array to store the results of all the solved sub-problems. As mentioned above, we need to store results for every sub-array (i.e. for every possible index ‘i’) and for every possible capacity ‘c’. CodeHere is the code with memoization (see changes in the highlighted lines): 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution: def solveKnapsack(self, profits, weights, capacity): # create a two dimensional array for Memoization, each element is initialized to &#x27;-1&#x27; dp = [[-1 for x in range(capacity+1)] for y in range(len(profits))] return self.knapsack_recursive(dp, profits, weights, capacity, 0) def knapsack_recursive(self, dp, profits, weights, capacity, currentIndex): # base checks if capacity &lt;= 0 or currentIndex &gt;= len(profits): return 0 # if we have already solved a similar problem, return the result from memory if dp[currentIndex][capacity] != -1: return dp[currentIndex][capacity] # recursive call after choosing the element at the currentIndex # if the weight of the element at currentIndex exceeds the capacity, we # shouldn&#x27;t process this profit1 = 0 if weights[currentIndex] &lt;= capacity: profit1 = profits[currentIndex] + self.knapsack_recursive( dp, profits, weights, capacity - weights[currentIndex], currentIndex + 1) # recursive call after excluding the element at the currentIndex profit2 = self.knapsack_recursive( dp, profits, weights, capacity, currentIndex + 1) dp[currentIndex][capacity] = max(profit1, profit2) return dp[currentIndex][capacity]def main(): sol = Solution() print(sol.solveKnapsack([1, 6, 10, 16], [1, 2, 3, 5], 7)) print(sol.solveKnapsack([1, 6, 10, 16], [1, 2, 3, 5], 6))main() Time and Space complexitySince our memoization array dp[profits.length][capacity+1] stores the results for all subproblems, we can conclude that we will not have more than N*C subproblems (where ‘N’ is the number of items and ‘C’ is the knapsack capacity). This means that our time complexity will be O(N\\C)*. The above algorithm will use O(N\\C)* space for the memoization array. Other than that we will use O(N) space for the recursion call-stack. So the total space complexity will be O(N\\C + N)*, which is asymptotically equivalent to O(N\\C)*. Bottom-up Dynamic ProgrammingLet’s try to populate our dp[][] array from the above solution by working in a bottom-up fashion. Essentially, we want to find the maximum profit for every sub-array and for every possible capacity. This means that dp[i][c] will represent the maximum knapsack profit for capacity ‘c’ calculated from the first ‘i’ items. So, for each item at index ‘i’ (0 &lt;= i &lt; items.length) and capacity ‘c’ (0 &lt;= c &lt;= capacity), we have two options: Exclude the item at index ‘i’. In this case, we will take whatever profit we get from the sub-array excluding this item =&gt; dp[i-1][c] Include the item at index ‘i’ if its weight is not more than the capacity. In this case, we include its profit plus whatever profit we get from the remaining capacity and from remaining items =&gt; profit[i] + dp[i-1][c-weight[i]] Finally, our optimal solution will be maximum of the above two values: 1dp[i][c] = max (dp[i-1][c], profit[i] + dp[i-1][c-weight[i]]) Let’s draw this visually and start with our base case of zero capacity: CodeHere is the code for our bottom-up dynamic programming approach: 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution: def solveKnapsack(self, profits, weights, capacity): # basic checks n = len(profits) if capacity &lt;= 0 or n == 0 or len(weights) != n: return 0 dp = [[0 for x in range(capacity+1)] for y in range(n)] # populate the capacity = 0 columns, with &#x27;0&#x27; capacity we have &#x27;0&#x27; profit for i in range(0, n): dp[i][0] = 0 # if we have only one weight, we will take it if it is not more than the capacity for c in range(0, capacity+1): if weights[0] &lt;= c: dp[0][c] = profits[0] # process all sub-arrays for all the capacities for i in range(1, n): for c in range(1, capacity+1): profit1, profit2 = 0, 0 # include the item, if it is not more than the capacity if weights[i] &lt;= c: profit1 = profits[i] + dp[i - 1][c - weights[i]] # exclude the item profit2 = dp[i - 1][c] # take maximum dp[i][c] = max(profit1, profit2) # maximum profit will be at the bottom-right corner. return dp[n - 1][capacity]def main(): sol = Solution() print(sol.solveKnapsack([1, 6, 10, 16], [1, 2, 3, 5], 5)) print(sol.solveKnapsack([1, 6, 10, 16], [1, 2, 3, 5], 6)) print(sol.solveKnapsack([1, 6, 10, 16], [1, 2, 3, 5], 7))main() Time and Space complexityThe above solution has the time and space complexity of O(N\\C)*, where ‘N’ represents total items and ‘C’ is the maximum capacity. How can we find the selected items?As we know, the final profit is at the bottom-right corner. Therefore, we will start from there to find the items that will be going into the knapsack. As you remember, at every step we had two options: include an item or skip it. If we skip an item, we take the profit from the remaining items (i.e. from the cell right above it); if we include the item, then we jump to the remaining profit to find more items. Let’s understand this from the above example: ‘22’ did not come from the top cell (which is 17); hence we must include the item at index ‘3’ (which is item ‘D’). Subtract the profit of item ‘D’ from ‘22’ to get the remaining profit ‘6’. We then jump to profit ‘6’ on the same row. ‘6’ came from the top cell, so we jump to row ‘2’. Again ‘6’ came from the top cell, so we jump to row ‘1’. ‘6’ is different than the top cell, so we must include this item (which is item ‘B’). Subtract the profit of ‘B’ from ‘6’ to get profit ‘0’. We then jump to profit ‘0’ on the same row. As soon as we hit zero remaining profit, we can finish our item search. Thus the items going into the knapsack are {B, D}. Let’s write a function to print the set of items included in the knapsack. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution: def solveKnapsack(self, profits, weights, capacity): # basic checks n = len(profits) if capacity &lt;= 0 or n == 0 or len(weights) != n: return 0 dp = [[0 for x in range(capacity+1)] for y in range(n)] # populate the capacity = 0 columns, with &#x27;0&#x27; capacity we have &#x27;0&#x27; profit for i in range(0, n): dp[i][0] = 0 # if we have only one weight, we will take it if it is not more than the capacity for c in range(0, capacity+1): if weights[0] &lt;= c: dp[0][c] = profits[0] # process all sub-arrays for all the capacities for i in range(1, n): for c in range(1, capacity+1): profit1, profit2 = 0, 0 # include the item, if it is not more than the capacity if weights[i] &lt;= c: profit1 = profits[i] + dp[i - 1][c - weights[i]] # exclude the item profit2 = dp[i - 1][c] # take maximum dp[i][c] = max(profit1, profit2) self.print_selected_elements(dp, weights, profits, capacity) # maximum profit will be at the bottom-right corner. return dp[n - 1][capacity] def print_selected_elements(self, dp, weights, profits, capacity): print(&quot;Selected weights are: &quot;, end=&#x27;&#x27;) n = len(weights) totalProfit = dp[n-1][capacity] for i in range(n-1, 0, -1): if totalProfit != dp[i - 1][capacity]: print(str(weights[i]) + &quot; &quot;, end=&#x27;&#x27;) capacity -= weights[i] totalProfit -= profits[i] if totalProfit != 0: print(str(weights[0]) + &quot; &quot;, end=&#x27;&#x27;) print()def main(): sol = Solution() print(&quot;Total knapsack profit: &quot; + str(sol.solveKnapsack([1, 6, 10, 16], [1, 2, 3, 5], 7))) print(&quot;Total knapsack profit: &quot; + str(sol.solveKnapsack([1, 6, 10, 16], [1, 2, 3, 5], 6)))main() ChallengeCan we further improve our bottom-up DP solution? Can you find an algorithm that has space complexity? We only need one previous row to find the optimal solution! 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution: def solveKnapsack(self, profits, weights, capacity): # basic checks n = len(profits) if capacity &lt;= 0 or n == 0 or len(weights) != n: return 0 # we only need one previous row to find the optimal solution, overall we need &#x27;2&#x27; rows # the above solution is similar to the previous solution, the only difference is that # we use `i % 2` instead if `i` and `(i-1) % 2` instead if `i-1` # 注意这里初始化都是0，不然就要单独初始化第一列 dp = [[0 for x in range(capacity + 1)] for y in range(2)] # if we have only one weight, we will take it if it is not more than the capacity for c in range(0, capacity + 1): if weights[0] &lt;= c: dp[0][c] = dp[1][c] = profits[0] # process all sub-arrays for all the capacities for i in range(1, n): for c in range(0, capacity + 1): profit1, profit2 = 0, 0 # include the item, if it is not more than the capacity if weights[i] &lt;= c: profit1 = profits[i] + dp[(i - 1) % 2][c - weights[i]] # exclude the item profit2 = dp[(i - 1) % 2][c] # take maximum dp[i % 2][c] = max(profit1, profit2) return dp[(n - 1) % 2][capacity]def main(): sol = Solution() print(&quot;Total knapsack profit: &quot; + str(sol.solveKnapsack([1, 6, 10, 16], [1, 2, 3, 5], 7))) print(&quot;Total knapsack profit: &quot; + str(sol.solveKnapsack([1, 6, 10, 16], [1, 2, 3, 5], 6)))main() The solution above is similar to the previous solution, the only difference is that we use i%2 instead if i and (i-1)%2 instead if i-1. This solution has a space complexity of O(2\\C) = O(C)*, where ‘C’ is the maximum capacity of the knapsack. This space optimization solution can also be implemented using a single array. It is a bit tricky, but the intuition is to use the same array for the previous and the next iteration! If you see closely, we need two values from the previous iteration: dp[c] and dp[c-weight[i]] Since our inner loop is iterating over c:0--&gt;capacity, let’s see how this might affect our two required values: When we access dp[c], it has not been overridden yet for the current iteration, so it should be fine. dp[c-weight[i]] might be overridden if “weight[i] &gt; 0”. Therefore we can’t use this value for the current iteration. To solve the second case, we can change our inner loop to process in the reverse direction: c:capacity--&gt;0. This will ensure that whenever we change a value in dp[], we will not need it again in the current iteration. Can you try writing this algorithm? 123456789101112131415161718192021222324252627282930313233343536373839class Solution: def solveKnapsack(self, profits, weights, capacity): # basic checks n = len(profits) if capacity &lt;= 0 or n == 0 or len(weights) != n: return 0 dp = [0 for x in range(capacity+1)] # if we have only one weight, we will take it if it is not more than the capacity for c in range(0, capacity+1): if weights[0] &lt;= c: dp[c] = profits[0] # process all sub-arrays for all the capacities for i in range(1, n): for c in range(capacity, -1, -1): profit1, profit2 = 0, 0 # include the item, if it is not more than the capacity if weights[i] &lt;= c: profit1 = profits[i] + dp[c - weights[i]] # exclude the item profit2 = dp[c] # take maximum dp[c] = max(profit1, profit2) return dp[capacity]def main(): sol = Solution() print(&quot;Total knapsack profit: &quot; + str(sol.solveKnapsack([1, 6, 10, 16], [1, 2, 3, 5], 7))) print(&quot;Total knapsack profit: &quot; + str(sol.solveKnapsack([1, 6, 10, 16], [1, 2, 3, 5], 6)))main() Equal Subset Sum Partition (medium)416. Partition Equal Subset Sum Design Gurus Educative.io Problem StatementGiven a set of positive numbers, find if we can partition it into two subsets such that the sum of elements in both subsets is equal. Example 1: 123Input: &#123;1, 2, 3, 4&#125;Output: TrueExplanation: The given set can be partitioned into two subsets with equal sum: &#123;1, 4&#125; &amp; &#123;2, 3&#125; Example 2: 123Input: &#123;1, 1, 3, 4, 7&#125;Output: TrueExplanation: The given set can be partitioned into two subsets with equal sum: &#123;1, 3, 4&#125; &amp; &#123;1, 7&#125; Example 3: 123Input: &#123;2, 3, 4, 6&#125;Output: FalseExplanation: The given set cannot be partitioned into two subsets with equal sum. Constraints: 1 &lt;= nums.length &lt;= 200 1 &lt;= nums[i] &lt;= 100 Basic SolutionThis problem follows the 0/1 Knapsack pattern. A basic brute-force solution could be to try all combinations of partitioning the given numbers into two sets to see if any pair of sets has an equal sum. Assume that S represents the total sum of all the given numbers. Then the two equal subsets must have a sum equal to S/2. This essentially transforms our problem to: “Find a subset of the given numbers that has a total sum of S/2“. So our brute-force algorithm will look like: CodeHere is the code for the brute-force solution: 1234567891011121314151617181920212223242526272829303132333435363738class Solution: def canPartition(self, num): s = sum(num) # if &#x27;s&#x27; is a an odd number, we can&#x27;t have two subsets with equal sum if s % 2 != 0: return False return self.can_partition_recursive(num, s / 2, 0) def can_partition_recursive(self, num, sum, currentIndex): # base check if sum == 0: return True n = len(num) if n == 0 or currentIndex &gt;= n: return False # recursive call after choosing the number at the `currentIndex` # if the number at `currentIndex` exceeds the sum, we shouldn&#x27;t process this if num[currentIndex] &lt;= sum: if(self.can_partition_recursive(num, sum - num[currentIndex], currentIndex + 1)): return True # recursive call after excluding the number at the &#x27;currentIndex&#x27; return self.can_partition_recursive(num, sum, currentIndex + 1)def main(): sol = Solution() print(&quot;Can partition: &quot; + str(sol.canPartition([1, 2, 3, 4]))) print(&quot;Can partition: &quot; + str(sol.canPartition([1, 1, 3, 4, 7]))) print(&quot;Can partition: &quot; + str(sol.canPartition([2, 3, 4, 6])))main() Time and Space complexityThe time complexity of the above algorithm is exponential O(2^n), where ‘n’ represents the total number. The space complexity is O(n), which will be used to store the recursion stack. Top-down Dynamic Programming with MemoizationWe can use memoization to overcome the overlapping sub-problems. As stated in previous lessons, memoization is when we store the results of all the previously solved sub-problems so we can return the results from memory if we encounter a problem that has already been solved. Since we need to store the results for every subset and for every possible sum, therefore we will be using a two-dimensional array to store the results of the solved sub-problems. The first dimension of the array will represent different subsets and the second dimension will represent different ‘sums’ that we can calculate from each subset. These two dimensions of the array can also be inferred from the two changing values (sum and currentIndex) in our recursive function canPartitionRecursive(). CodeHere is the code for Top-down DP with memoization: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution: def canPartition(self, num): s = sum(num) # if &#x27;s&#x27; is a an odd number, we can&#x27;t have two subsets with equal sum if s % 2 != 0: return False # 这里需要注意是s/2+1,需要+1 # initialize the &#x27;dp&#x27; array, -1 for default, 1 for true and 0 for false dp = [[-1 for x in range(int(s / 2) + 1)] for y in range(len(num))] return True if self.can_partition_recursive(dp, num, int(s / 2), 0) == 1 else False def can_partition_recursive(self, dp, num, sum, currentIndex): # base check if sum == 0: return 1 n = len(num) if n == 0 or currentIndex &gt;= n: return 0 # if we have not already processed a similar problem if dp[currentIndex][sum] == -1: # recursive call after choosing the number at the currentIndex # if the number at currentIndex exceeds the sum, we shouldn&#x27;t process this if num[currentIndex] &lt;= sum: if self.can_partition_recursive(dp, num, sum - num[currentIndex], currentIndex + 1) \\ == 1: dp[currentIndex][sum] = 1 return 1 # recursive call after excluding the number at the currentIndex dp[currentIndex][sum] = self.can_partition_recursive( dp, num, sum, currentIndex + 1) return dp[currentIndex][sum]def main(): sol = Solution() print(&quot;Can partition: &quot; + str(sol.canPartition([1, 2, 3, 4]))) print(&quot;Can partition: &quot; + str(sol.canPartition([1, 1, 3, 4, 7]))) print(&quot;Can partition: &quot; + str(sol.canPartition([2, 3, 4, 6])))main() Time and Space complexityThe above algorithm has the time and space complexity of O(N\\S)*, where ‘N’ represents total numbers and ‘S’ is the total sum of all the numbers. Bottom-up Dynamic ProgrammingLet’s try to populate our dp[][] array from the above solution by working in a bottom-up fashion. Essentially, we want to find if we can make all possible sums with every subset. This means, dp[i][s] will be ‘true’ if we can make the sum ‘s’ from the first ‘i’ numbers. So, for each number at index ‘i’ (0 &lt;= i &lt; num.length) and sum ‘s’ (0 &lt;= s &lt;= S/2), we have two options: Exclude the number. In this case, we will see if we can get ‘s’ from the subset excluding this number: dp[i-1][s] Include the number if its value is not more than ‘s’. In this case, we will see if we can find a subset to get the remaining sum: dp[i-1][s-num[i]] If either of the two above scenarios is true, we can find a subset of numbers with a sum equal to ‘s’. Let’s start with our base case of zero capacity: From the above visualization, we can clearly see that it is possible to partition the given set into two subsets with equal sums, as shown by bottom-right cell: dp[3][5] =&gt; T CodeHere is the code for our bottom-up dynamic programming approach: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution: def canPartition(self, num): s = sum(num) # if &#x27;s&#x27; is a an odd number, we can&#x27;t have two subsets with same total if s % 2 != 0: return False # we are trying to find a subset of given numbers that has a total sum of &#x27;s/2&#x27;. s = int(s / 2) n = len(num) # 这里需要注意是s/2+1,需要+1 dp = [[False for x in range(s + 1)] for y in range(n)] # populate the s=0 columns, as we can always for &#x27;0&#x27; sum with an empty set for i in range(0, n): dp[i][0] = True # with only one number, we can form a subset only when the required sum is # equal to its value for j in range(1, s + 1): dp[0][j] = num[0] == j # process all subsets for all sums for i in range(1, n): for j in range(1, s + 1): # if we can get the sum &#x27;j&#x27; without the number at index &#x27;i&#x27; if dp[i - 1][j]: dp[i][j] = dp[i - 1][j] elif j &gt;= num[i]: # else if we can find a subset to get the remaining sum dp[i][j] = dp[i - 1][j - num[i]] # the bottom-right corner will have our answer. return dp[n - 1][s]def main(): sol = Solution() print(&quot;Can partition: &quot; + str(sol.canPartition([1, 2, 3, 4]))) print(&quot;Can partition: &quot; + str(sol.canPartition([1, 1, 3, 4, 7]))) print(&quot;Can partition: &quot; + str(sol.canPartition([2, 3, 4, 6])))main() Time and Space complexityThe above solution the has time and space complexity of O(N\\S)*, where ‘N’ represents total numbers and ‘S’ is the total sum of all the numbers. Subset Sum (medium)Similar | 416. Partition Equal Subset Sum Design Gurus Educative.io Problem StatementGiven a set of positive numbers, determine if a subset exists whose sum is equal to a given number ‘S’. Example 1: 123Input: &#123;1, 2, 3, 7&#125;, S=6Output: TrueThe given set has a subset whose sum is &#x27;6&#x27;: &#123;1, 2, 3&#125; Example 2: 123Input: &#123;1, 2, 7, 1, 5&#125;, S=10Output: TrueThe given set has a subset whose sum is &#x27;10&#x27;: &#123;1, 2, 7&#125; Example 3: 123Input: &#123;1, 3, 4, 8&#125;, S=6Output: FalseThe given set does not have any subset whose sum is equal to &#x27;6&#x27;. Constraints: 1 &lt;= num.length &lt;= 200 1 &lt;= num[i] &lt;= 100 Basic SolutionThis problem follows the 0/1 Knapsack pattern and is quite similar to Equal Subset Sum Partition. A basic brute-force solution could be to try all subsets of the given numbers to see if any set has a sum equal to ‘S’. So our brute-force algorithm will look like: Since this problem is quite similar to Equal Subset Sum Partition, let’s jump directly to the bottom-up dynamic programming solution. Bottom-up Dynamic ProgrammingWe’ll try to find if we can make all possible sums with every subset to populate the array dp[TotalNumbers][S+1]. For every possible sum ‘s’ (where 0 &lt;= s &lt;= S), we have two options: Exclude the number. In this case, we will see if we can get the sum ‘s’ from the subset excluding this number =&gt; dp[index-1][s] Include the number if its value is not more than ‘s’. In this case, we will see if we can find a subset to get the remaining sum =&gt; dp[index-1][s-num[index]] If either of the above two scenarios returns true, we can find a subset with a sum equal to ‘s’. Let’s draw this visually, with the example input {1, 2, 3, 7}, and start with our base case of size zero: CodeHere is the code for our bottom-up dynamic programming approach: 12345678910111213141516171819202122232425262728293031323334353637class Solution: def canPartition(self, num, sum): n = len(num) dp = [[False for x in range(sum+1)] for y in range(n)] # populate the sum = 0 columns, as we can always form &#x27;0&#x27; sum with an empty set for i in range(0, n): dp[i][0] = True # with only one number, we can form a subset only when the required sum is # equal to its value for s in range(1, sum+1): dp[0][s] = True if num[0] == s else False # process all subsets for all sums for i in range(1, n): for s in range(1, sum+1): # if we can get the sum &#x27;s&#x27; without the number at index &#x27;i&#x27; if dp[i - 1][s]: dp[i][s] = dp[i - 1][s] elif s &gt;= num[i]: # else include the number to see if we can find a subset to get the remaining sum dp[i][s] = dp[i - 1][s - num[i]] # the bottom-right corner will have our answer. return dp[n - 1][sum]def main(): sol = Solution() print(&quot;Can partition: &quot; + str(sol.canPartition([1, 2, 3, 7], 6))) print(&quot;Can partition: &quot; + str(sol.canPartition([1, 2, 7, 1, 5], 10))) print(&quot;Can partition: &quot; + str(sol.canPartition([1, 3, 4, 8], 6)))main() Time and Space complexityThe above solution has the time and space complexity of O(N\\S)*, where ‘N’ represents total numbers and ‘S’ is the required sum. ChallengeCan we improve our bottom-up DP solution even further? Can you find an algorithm that has O(S) space complexity? Hint Similar to the space optimized solution for 0/1 Knapsack 12345678910111213141516171819202122232425262728293031323334class Solution: def canPartition(self, num, sum): n = len(num) dp = [False for x in range(sum+1)] # handle sum=0, as we can always have &#x27;0&#x27; sum with an empty set dp[0] = True # with only one number, we can have a subset only when the required sum is equal to # its value for s in range(1, sum+1): dp[s] = num[0] == s # process all subsets for all sums for i in range(1, n): for s in range(sum, -1, -1): # if dp[s]==true, this means we can get the sum &#x27;s&#x27; without num[i], hence we # can move on to the next number else we can include num[i] and see if we # can find a subset to get the remaining sum if not dp[s] and s &gt;= num[i]: dp[s] = dp[s - num[i]] return dp[sum]def main(): sol = Solution() print(&quot;Can partition: &quot; + str(sol.canPartition([1, 2, 3, 7], 6))) print(&quot;Can partition: &quot; + str(sol.canPartition([1, 2, 7, 1, 5], 10))) print(&quot;Can partition: &quot; + str(sol.canPartition([1, 3, 4, 8], 6)))main() Minimum Subset Sum Difference (hard)leetcode 2035 但是没有限制positive num，不太会了 Similar | 2035. Partition Array Into Two Arrays to Minimize Sum Difference Design Gurus Educative.io Problem StatementGiven a set of positive numbers, partition the set into two subsets with minimum difference between their subset sums. Example 1: 1234Input: &#123;1, 2, 3, 9&#125;Output: 3Explanation: We can partition the given set into two subsets where minimum absolute difference between the sum of numbers is &#x27;3&#x27;. Following are the two subsets: &#123;1, 2, 3&#125; &amp; &#123;9&#125;. Example 2: 1234Input: &#123;1, 2, 7, 1, 5&#125;Output: 0Explanation: We can partition the given set into two subsets where minimum absolute difference between the sum of number is &#x27;0&#x27;. Following are the two subsets: &#123;1, 2, 5&#125; &amp; &#123;7, 1&#125;. Example 3: 1234Input: &#123;1, 3, 100, 4&#125;Output: 92Explanation: We can partition the given set into two subsets where minimum absolute difference between the sum of numbers is &#x27;92&#x27;. Here are the two subsets: &#123;1, 3, 4&#125; &amp; &#123;100&#125;. Constraints: 1 &lt;= num.length &lt;= 200 1 &lt;= num[i] &lt;= 100 Basic SolutionThis problem follows the 0/1 Knapsack pattern and can be converted into a Subset Sum problem. Let’s assume S1 and S2 are the two desired subsets. A basic brute-force solution could be to try adding each element either in S1 or S2 in order to find the combination that gives the minimum sum difference between the two sets. So our brute-force algorithm will look like: CodeHere is the code for the brute-force solution: 123456789101112131415161718192021222324252627282930class Solution: def canPartition(self, num): return self.can_partition_recursive(num, 0, 0, 0) def can_partition_recursive(self, num, currentIndex, sum1, sum2): # base check if currentIndex == len(num): return abs(sum1 - sum2) # recursive call after including the number at the currentIndex in the first set diff1 = self.can_partition_recursive( num, currentIndex + 1, sum1 + num[currentIndex], sum2) # recursive call after including the number at the currentIndex in the second set diff2 = self.can_partition_recursive( num, currentIndex + 1, sum1, sum2 + num[currentIndex]) return min(diff1, diff2)def main(): sol = Solution() print(&quot;Can partition: &quot; + str(sol.canPartition([1, 2, 3, 9]))) print(&quot;Can partition: &quot; + str(sol.canPartition([1, 2, 7, 1, 5]))) print(&quot;Can partition: &quot; + str(sol.canPartition([1, 3, 100, 4])))main() Time and Space complexityBecause of the two recursive calls, the time complexity of the above algorithm is exponential O(2^n), where ‘n’ represents the total number. The space complexity is O(n) which is used to store the recursion stack. Top-down Dynamic Programming with MemoizationWe can use memoization to overcome the overlapping sub-problems. We will be using a two-dimensional array to store the results of the solved sub-problems. We can uniquely identify a sub-problem from ‘currentIndex’ and ‘Sum1’ as ‘Sum2’ will always be the sum of the remaining numbers. CodeHere is the code: 123456789101112131415161718192021222324252627282930313233343536class Solution: def canPartition(self, num): s = sum(num) dp = [[-1 for x in range(s+1)] for y in range(len(num))] return self.can_partition_recursive(dp, num, 0, 0, 0) def can_partition_recursive(self, dp, num, currentIndex, sum1, sum2): # base check if currentIndex == len(num): return abs(sum1 - sum2) # check if we have not already processed similar problem if dp[currentIndex][sum1] == -1: # recursive call after including the number at the currentIndex in the first set diff1 = self.can_partition_recursive( dp, num, currentIndex + 1, sum1 + num[currentIndex], sum2) # recursive call after including the number at the currentIndex in the second set diff2 = self.can_partition_recursive( dp, num, currentIndex + 1, sum1, sum2 + num[currentIndex]) dp[currentIndex][sum1] = min(diff1, diff2) return dp[currentIndex][sum1]def main(): sol = Solution() print(&quot;Can partition: &quot; + str(sol.canPartition([1, 2, 3, 9]))) print(&quot;Can partition: &quot; + str(sol.canPartition([1, 2, 7, 1, 5]))) print(&quot;Can partition: &quot; + str(sol.canPartition([1, 3, 100, 4])))main() Bottom-up Dynamic ProgrammingLet’s assume ‘S’ represents the total sum of all the numbers. So, in this problem, we are trying to find a subset whose sum is as close to ‘S/2’ as possible, because if we can partition the given set into two subsets of an equal sum, we get the minimum difference, i.e. zero. This transforms our problem to Subset Sum, where we try to find a subset whose sum is equal to a given number— ‘S/2’ in our case. If we can’t find such a subset, then we will take the subset which has the sum closest to ‘S/2’. This is easily possible, as we will be calculating all possible sums with every subset. Essentially, we need to calculate all the possible sums up to ‘S/2’ for all numbers. So how can we populate the array db[TotalNumbers][S/2+1] in the bottom-up fashion? For every possible sum ‘s’ (where 0 &lt;= s &lt;= S/2), we have two options: Exclude the number. In this case, we will see if we can get the sum ‘s’ from the subset excluding this number =&gt; dp[index-1][s] Include the number if its value is not more than ‘s’. In this case, we will see if we can find a subset to get the remaining sum =&gt; dp[index-1][s-num[index]] If either of the two above scenarios is true, we can find a subset with a sum equal to ‘s’. We should dig into this before we can learn how to find the closest subset. Let’s draw this visually, with the example input {1, 2, 3, 9}. Since the total sum is ‘15’, we will try to find a subset whose sum is equal to the half of it, i.e. ‘7’. The above visualization tells us that it is not possible to find a subset whose sum is equal to ‘7’. So what is the closest subset we can find? We can find the subset if we start moving backwards in the last row from the bottom right corner to find the first ‘T’. The first “T” in the diagram above is the sum ‘6’, which means that we can find a subset whose sum is equal to ‘6’. This means the other set will have a sum of ‘9’ and the minimum difference will be ‘3’. CodeHere is the code for our bottom-up dynamic programming approach: 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution: def canPartition(self, num): s = sum(num) n = len(num) dp = [[False for x in range(int(s/2)+1)] for y in range(n)] # populate the s=0 columns, as we can always form &#x27;0&#x27; sum with an empty set for i in range(0, n): dp[i][0] = True # with only one number, we can form a subset only when the required sum is equal to # that number for j in range(0, int(s/2)+1): dp[0][j] = num[0] == j # process all subsets for all sums for i in range(1, n): for j in range(1, int(s/2)+1): # if we can get the sum &#x27;s&#x27; without the number at index &#x27;i&#x27; if dp[i - 1][j]: dp[i][j] = dp[i - 1][j] elif j &gt;= num[i]: # else include the number and see if we can find a subset to get remaining sum dp[i][j] = dp[i - 1][j - num[i]] sum1 = 0 # find the largest index in the last row which is true for i in range(int(s/2), -1, -1): if dp[n - 1][i]: sum1 = i break sum2 = s - sum1 return abs(sum2 - sum1)def main(): sol = Solution() print(&quot;Can partition: &quot; + str(sol.canPartition([1, 2, 3, 9]))) print(&quot;Can partition: &quot; + str(sol.canPartition([1, 2, 7, 1, 5]))) print(&quot;Can partition: &quot; + str(sol.canPartition([1, 3, 100, 4])))main() Time and Space complexityThe above solution has the time and space complexity of O(N\\S)*, where ‘N’ represents total numbers and ‘S’ is the total sum of all the numbers. Problem Challenge 1Similar | Top Interview 150 | 39. Combination Sum Design Gurus Educative.io Count of Subset Sum (hard)Given a set of positive numbers, find the total number of subsets whose sum is equal to a given number ‘S’. Example 1: 1234Input: &#123;1, 1, 2, 3&#125;, S=4Output: 3The given set has &#x27;3&#x27; subsets whose sum is &#x27;4&#x27;: &#123;1, 1, 2&#125;, &#123;1, 3&#125;, &#123;1, 3&#125;Note that we have two similar sets &#123;1, 3&#125;, because we have two &#x27;1&#x27; in our input. Example 2: 123Input: &#123;1, 2, 7, 1, 5&#125;, S=9Output: 3The given set has &#x27;3&#x27; subsets whose sum is &#x27;9&#x27;: &#123;2, 7&#125;, &#123;1, 7, 1&#125;, &#123;1, 2, 1, 5&#125; Constraints: 1 &lt;= num.length &lt;= 20 0 &lt;= num[i] &lt;= 1000 0 &lt;= sum(num[i]) &lt;= 1000 -1000 &lt;= S &lt;= 1000 Basic SolutionThis problem follows the 0/1 Knapsack pattern and is quite similar to Subset Sum. The only difference in this problem is that we need to count the number of subsets, whereas in Subset Sum we only wanted to know if a subset with the given sum existed. A basic brute-force solution could be to try all subsets of the given numbers to count the subsets that have a sum equal to ‘S’. So our brute-force algorithm will look like: CodeHere is the code for the brute-force solution: 12345678910111213141516171819202122232425262728293031323334class Solution: def countSubsets(self, num, sum): return self.count_subsets_recursive(num, sum, 0) def count_subsets_recursive(self, num, sum, currentIndex): # base checks if sum == 0: return 1 n = len(num) if n == 0 or currentIndex &gt;= n: return 0 # recursive call after selecting the number at the currentIndex # if the number at currentIndex exceeds the sum, we shouldn&#x27;t process this sum1 = 0 if num[currentIndex] &lt;= sum: sum1 = self.count_subsets_recursive( num, sum - num[currentIndex], currentIndex + 1) # recursive call after excluding the number at the currentIndex sum2 = self.count_subsets_recursive(num, sum, currentIndex + 1) return sum1 + sum2def main(): sol = Solution() print(&quot;Total number of subsets &quot; + str(sol.countSubsets([1, 1, 2, 3], 4))) print(&quot;Total number of subsets: &quot; + str(sol.countSubsets([1, 2, 7, 1, 5], 9)))main() Time and Space complexityThe time complexity of the above algorithm is exponential O(2^n), where ‘n’ represents the total number. The space complexity is O(n), this memory is used to store the recursion stack. Top-down Dynamic Programming with MemoizationWe can use memoization to overcome the overlapping sub-problems. We will be using a two-dimensional array to store the results of solved sub-problems. As mentioned above, we need to store results for every subset and for every possible sum. CodeHere is the code: 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution: def countSubsets(self, num, sum): # create a two dimensional array for Memoization, each element is initialized to &#x27;-1&#x27; dp = [[-1 for x in range(sum+1)] for y in range(len(num))] return self.count_subsets_recursive(dp, num, sum, 0) def count_subsets_recursive(self, dp, num, sum, currentIndex): # base checks if sum == 0: return 1 n = len(num) if n == 0 or currentIndex &gt;= n: return 0 # check if we have not already processed a similar problem if dp[currentIndex][sum] == -1: # recursive call after choosing the number at the currentIndex # if the number at currentIndex exceeds the sum, we shouldn&#x27;t process this sum1 = 0 if num[currentIndex] &lt;= sum: sum1 = self.count_subsets_recursive( dp, num, sum - num[currentIndex], currentIndex + 1) # recursive call after excluding the number at the currentIndex sum2 = self.count_subsets_recursive(dp, num, sum, currentIndex + 1) dp[currentIndex][sum] = sum1 + sum2 return dp[currentIndex][sum]def main(): sol = Solution() print(&quot;Total number of subsets &quot; + str(sol.countSubsets([1, 1, 2, 3], 4))) print(&quot;Total number of subsets: &quot; + str(sol.countSubsets([1, 2, 7, 1, 5], 9)))main() Bottom-up Dynamic ProgrammingWe will try to find if we can make all possible sums with every subset to populate the array db[TotalNumbers][S+1]. So, at every step we have two options: Exclude the number. Count all the subsets without the given number up to the given sum =&gt; dp[index-1][sum] Include the number if its value is not more than the ‘sum’. In this case, we will count all the subsets to get the remaining sum =&gt; dp[index-1][sum-num[index]] To find the total sets, we will add both of the above two values: 1dp[index][sum] = dp[index-1][sum] + dp[index-1][sum-num[index]]) Let’s start with our base case of size zero: CodeHere is the code for our bottom-up dynamic programming approach: 1234567891011121314151617181920212223242526272829303132333435class Solution: def countSubsets(self, num, sum): n = len(num) dp = [[-1 for x in range(sum+1)] for y in range(n)] # populate the sum = 0 columns, as we will always have an empty set for zero sum for i in range(0, n): dp[i][0] = 1 # with only one number, we can form a subset only when the required sum is # equal to its value for s in range(1, sum+1): dp[0][s] = 1 if num[0] == s else 0 # process all subsets for all sums for i in range(1, n): for s in range(1, sum+1): # exclude the number dp[i][s] = dp[i - 1][s] # include the number, if it does not exceed the sum if s &gt;= num[i]: dp[i][s] += dp[i - 1][s - num[i]] # the bottom-right corner will have our answer. return dp[n - 1][sum]def main(): sol = Solution() print(&quot;Total number of subsets &quot; + str(sol.countSubsets([1, 1, 2, 3], 4))) print(&quot;Total number of subsets: &quot; + str(sol.countSubsets([1, 2, 7, 1, 5], 9)))main() Time and Space complexityThe above solution has the time and space complexity of O(N\\S)*, where ‘N’ represents total numbers and ‘S’ is the desired sum. ChallengeCan we improve our bottom-up DP solution even further? Can you find an algorithm that has O(S) space complexity? 12345678910111213141516171819202122232425262728class Solution: def countSubsets(self, num, sum): n = len(num) dp = [0 for x in range(sum+1)] dp[0] = 1 # with only one number, we can form a subset only when the required sum is equal # to the number for s in range(1, sum+1): dp[s] = 1 if num[0] == s else 0 # process all subsets for all sums for i in range(1, n): for s in range(sum, -1, -1): if s &gt;= num[i]: dp[s] += dp[s - num[i]] return dp[sum]def main(): sol = Solution() print(&quot;Total number of subsets &quot; + str(sol.countSubsets([1, 1, 2, 3], 4))) print(&quot;Total number of subsets: &quot; + str(sol.countSubsets([1, 2, 7, 1, 5], 9)))main() Problem Challenge 2leetcode 494, leetcode里有0，不太会，尝试了两次都失败了 Similar | 494. Target Sum Design Gurus Educative.io Target Sum (hard)You are given a set of positive numbers and a target sum ‘S’. Each number should be assigned either a ‘+’ or ‘-’ sign. We need to find the total ways to assign symbols to make the sum of the numbers equal to the target ‘S’. Example 1: 123Input: &#123;1, 1, 2, 3&#125;, S=1Output: 3Explanation: The given set has &#x27;3&#x27; ways to make a sum of &#x27;1&#x27;: &#123;+1-1-2+3&#125; &amp; &#123;-1+1-2+3&#125; &amp; &#123;+1+1+2-3&#125; Example 2: 123Input: &#123;1, 2, 7, 1&#125;, S=9Output: 2Explanation: The given set has &#x27;2&#x27; ways to make a sum of &#x27;9&#x27;: &#123;+1+2+7-1&#125; &amp; &#123;-1+2+7+1&#125; Constraints: 1 &lt;= num.length &lt;= 20 0 &lt;= num[i] &lt;= 1000 0 &lt;= sum(num[i]) &lt;= 1000 -1000 &lt;= S &lt;= 1000 SolutionThis problem follows the 0/1 Knapsack pattern and can be converted into Count of Subset Sum. Let’s dig into this. We are asked to find two subsets of the given numbers whose difference is equal to the given target ‘S’. Take the first example above. As we saw, one solution is {+1-1-2+3}. So, the two subsets we are asked to find are {1, 3} &amp; {1, 2} because, 1(1 + 3) - (1 + 2 ) = 1 Now, let’s say ‘Sum(s1)’ denotes the total sum of set ‘s1’, and ‘Sum(s2)’ denotes the total sum of set ‘s2’. So the required equation is: 1Sum(s1) - Sum(s2) = S This equation can be reduced to the subset sum problem. Let’s assume that ‘Sum(num)’ denotes the total sum of all the numbers, therefore: 1Sum(s1) + Sum(s2) = Sum(num) Let’s add the above two equations: 123=&gt; Sum(s1) - Sum(s2) + Sum(s1) + Sum(s2) = S + Sum(num)=&gt; 2 * Sum(s1) = S + Sum(num)=&gt; Sum(s1) = (S + Sum(num)) / 2 Which means that one of the set ‘s1’ has a sum equal to (S + Sum(num)) / 2. This essentially converts our problem to: “Find the count of subsets of the given numbers whose sum is equal to (S + Sum(num)) / 2“ CodeLet’s take the dynamic programming code of Count of Subset Sum and extend it to solve this problem: 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution: def findTargetSubsets(self, num, s): totalSum = sum(num) # if &#x27;s + totalSum&#x27; is odd, we cannot find a subset with the sum equal # to &#x27;(s + totalSum) / 2&#x27; if totalSum &lt; s or (s + totalSum) % 2 == 1: return 0 return self.count_subsets(num, (s + totalSum) // 2) # this function is exactly similar to what we have in &#x27;Count of Subset Sum&#x27; problem. def count_subsets(self, num, s): n = len(num) dp = [[0 for x in range(s+1)] for y in range(n)] # populate the sum = 0 columns, as we will always have an empty set for zero sum for i in range(0, n): dp[i][0] = 1 # with only one number, we can form a subset only when the required sum is # equal to the number for s in range(1, s+1): dp[0][s] = 1 if num[0] == s else 0 # process all subsets for all sums for i in range(1, n): for s in range(1, s+1): dp[i][s] = dp[i - 1][s] if s &gt;= num[i]: dp[i][s] += dp[i - 1][s - num[i]] # the bottom-right corner will have our answer. return dp[n - 1][s]def main(): sol = Solution() print(&quot;Total ways: &quot; + str(sol.findTargetSubsets([1, 1, 2, 3], 1))) print(&quot;Total ways: &quot; + str(sol.findTargetSubsets([1, 2, 7, 1], 9)))main() Time and Space complexityThe above solution has time and space complexity of O(N*S), where ‘N’ represents total numbers and ‘S’ is the desired sum. We can further improve the solution to use only O(S) space. Space Optimized SolutionHere is the code for the space-optimized solution, using only a single array: 123456789101112131415161718192021222324252627282930313233343536373839class Solution: def findTargetSubsets(self, num, s): totalSum = sum(num) # if &#x27;s + totalSum&#x27; is odd, we can&#x27;t find a subset with sum equal to &#x27;(s +totalSum)/2&#x27; if totalSum &lt; s or (s + totalSum) % 2 == 1: return 0 return self.count_subsets(num, (s + totalSum) // 2) # this function is exactly similar to what we have in &#x27;Count of Subset Sum&#x27; problem def count_subsets(self, num, sum): n = len(num) dp = [0 for x in range(sum+1)] dp[0] = 1 # with only one number, we can form a subset only when the required sum is equal to # the number for s in range(1, sum+1): dp[s] = 1 if num[0] == s else 0 # process all subsets for all sums for i in range(1, n): for s in range(sum, -1, -1): if s &gt;= num[i]: dp[s] += dp[s - num[i]] return dp[sum]def main(): sol = Solution() print(&quot;Total ways: &quot; + str(sol.findTargetSubsets([1, 1, 2, 3], 1))) print(&quot;Total ways: &quot; + str(sol.findTargetSubsets([1, 2, 7, 1], 9)))main()","categories":[{"name":"Grokking Interview Pattern","slug":"Grokking-Interview-Pattern","permalink":"https://hasuer.github.io/categories/Grokking-Interview-Pattern/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hasuer.github.io/tags/Interview/"}]},{"title":"20. Pattern Greedy Algorithms","slug":"20. Pattern Greedy Algorithms","date":"2024-05-20T01:58:48.000Z","updated":"2024-05-28T03:30:07.872Z","comments":true,"path":"20-pattern-greedy-algorithms/index.html","link":"","permalink":"https://hasuer.github.io/20-pattern-greedy-algorithms/index.html","excerpt":"","text":"Introduction to Greedy AlgorithmUnderstanding Greedy AlgorithmA Greedy algorithm is used to solve problems in which the best choice is made at each step, and it finds a solution in a minimal step. This approach assumes that choosing a local optimum at each stage will lead to the determination of a global optimum. It’s like making the most beneficial decision at every crossroad, hoping it leads to the ultimate destination efficiently. Purpose of Greedy AlgorithmThe main goal of a greedy algorithm is to solve complex problems by breaking them down into simpler subproblems, solving each one optimally to find a solution that is as close as possible to the overall optimum. It’s particularly useful in scenarios where the problem exhibits the properties of greedy choice and optimal substructure. Properties for Greedy Algorithm Suitability Greedy Choice Property: The local optimal choices lead to a global optimum, meaning the best solution in each small step leads to the best overall solution. Optimal Substructure: A problem has an optimal substructure if an optimal solution to the entire problem contains the optimal solutions to its subproblems. Characteristics of Greedy Method Local Optimization: At every step, the algorithm makes a choice that seems the best at that moment, aiming for local optimality. Irrevocability: Once a choice is made, it cannot be undone or revisited. This is a key characteristic that differentiates greedy methods from dynamic programming, where decisions can be re-evaluated. Components of Greedy Algorithm Candidate Set: The set of choices available at each step. Selection Function: This function helps in choosing the most promising candidate to be added to the current solution. Feasibility Function: It checks if a candidate can be used to contribute to a solution without violating problem constraints. Objective Function: This evaluates the value or quality of the solution at each step. Solution Function: It determines if a complete solution has been reached. Simplified Greedy Algorithm Process Start with an Empty Solution Set: The algorithm begins with no items in the solution set. Iterative Item Selection: In each step, choose the most suitable item based on the current goal. Add Item to Solution Set: The selected item is added to the solution set. Feasibility Check: Determine if the solution set with the new item still meets the problem’s constraints. Accept or Reject the Item: If Feasible: Keep the item in the solution set. If Not Feasible: Remove and permanently discard the item. Repeat Until Complete: Continue this process until a full solution is formed or no feasible solution can be found. Assess Final Solution: Evaluate the completed solution set against the problem’s objectives. Let’s understand the greedy algorithm via the example below. Problem Statement (Boats to Save People)881. Boats to Save People Design Gurus We are given an array people where each element people[i] represents the weight of the i-th person. There is also a weight limit for each boat. Each boat can carry at most two people at a time, but the combined weight of these two people must not exceed limit. The objective is to determine the minimum number of boats required to carry all the people. ExampleInput: people = [10, 55, 70, 20, 90, 85], limit = 100Output: 4Explanation: One way to transport all people using 4 boats is as follows: Boat 1: Carry people with weights 10 and 90 (total weight = 100). Boat 2: Carry a person with weight 85 (total weight = 85). Boat 3: Carry people with weights 20 and 70 (total weight = 90). Boat 4: Carry people with weights 55 (total weight = 55). Algorithm Sort the Array: Sort the people array in ascending order. 1Arrays.sort(people); Initialize Two Pointers: Set two pointers, i at the start (lightest person) and j at the end (heaviest person) of the array. Select Optimal Pairs: Iterate through the array and pair the lightest person with the heaviest person if their combined weight is within the limit. 123if (people[i] + people[j] &lt;= limit) &#123; i++; // Move to the next lightest person&#125; Count Boats: For each iteration, increment the boat count. Move the j pointer to the left (next heaviest person). Repeat Until All Are Accounted For: Continue until all people are accounted for (i.e., until i &lt; j). If i == j, increment the boat count by 1 to arrange boat for last remaining person. Return the Boat Count: The total count of boats is the minimum number required. Algorithm Walkthrough Code123456789101112131415161718192021222324252627class Solution: def numRescueBoats(self, people, limit): people.sort() # Sort the list in ascending order i = 0 # Pointer for the lightest person j = len(people) - 1 # Pointer for the heaviest person boats = 0 # Count of boats while i &lt; j: if people[i] + people[j] &lt;= limit: # If the lightest and heaviest person can share a boat i += 1 # Move to the next lightest person j -= 1 # Move to the next heaviest person boats += 1 # Increment boat count # When last person is left. if i == j: boats += 1 return boats # Return the total number of boats neededsolution = Solution()people = [10, 55, 70, 20, 90, 85]limit = 100result = solution.numRescueBoats(people, limit)print(&quot;Minimum number of boats required:&quot;, result)# Expected output: &quot;Minimum number of boats required: 2&quot; In the above problem, the greedy approach is applied through the strategy of pairing the lightest and heaviest individuals to optimize boat usage. After sorting the people by weight, the algorithm iteratively pairs the lightest person (at the start of the array) with the heaviest (at the end), maximizing the use of each boat’s capacity. This method ensures that each boat carries as much weight as possible without exceeding the limit, effectively reducing the total number of boats needed. The essence of the greedy method here is making the most efficient pairing choice at each step, aiming for an overall optimal solution - the minimum number of boats to transport everyone. Pros of Greedy Approach Efficiency in Time and Space: Greedy algorithms often have lower time and space complexities, making them fast and memory-efficient. Ease of Implementation: They are generally simpler and more straightforward to code than other complex algorithms. Optimal for Certain Problems: In problems with certain structures, like those with greedy-choice property and optimal substructure, greedy algorithms guarantee an optimal solution. Useful for Approximations: When an exact solution is not feasible, greedy algorithms can provide a close approximation quickly. Cons of Greedy Approach with Example Not Always Optimal: Greedy algorithms do not always yield the global optimum solution, especially in problems lacking a greedy-choice property. Shortsighted Approach: They make decisions based only on current information, without considering the overall problem. Example: Consider the below tree where each path has a certain weight, and we need to find the path with the highest weight. 12345 2 / \\ 1 3 / \\ \\20 8 7 In the given tree, a greedy approach, which selects the path with the highest immediate weight at each step, would choose the path 2 → 3 → 7, resulting in a total weight of 12. However, this is not the optimal path. The path 2 → 1 → 20, although starting with a lower weight at the first decision point, leads to a higher total weight of 23. This example demonstrates how the greedy approach can fail to find the best solution, as it overlooks the long-term benefits of initially less attractive choices. Standard Greedy Algorithms Kruskal’s Minimum Spanning Tree Algorithm: Builds a minimum spanning tree by adding the shortest edge that doesn’t form a cycle. Prim’s Minimum Spanning Tree Algorithm: Grows a minimum spanning tree from a starting vertex by adding the nearest vertex. Dijkstra’s Shortest Path Algorithm: Finds the shortest path from a single source to all other vertices in a weighted graph. Huffman Coding: Used for data compression, it builds a binary tree with minimum weighted path lengths for given characters. Fractional Knapsack Problem: Maximizes the total value of items in a knapsack without exceeding its capacity. Activity Selection Problem: Select the maximum number of activities that don’t overlap in time. Greedy Best-First Search: Used in AI for pathfinding and graph traversal, prioritizing paths that seem closest to the goal. Let’s start solving the problem which are based on the greedy algorithm. Valid Palindrome II680. Valid Palindrome II Design Gurus Problem StatementGiven string s, determine whether it’s possible to make a given string palindrome by removing at most one character. A palindrome is a word or phrase that reads the same backward as forward. Examples Example 1: Input: &quot;racecar&quot; Expected Output: true Justification: The string is already a palindrome, so no removals are needed. Example 2: Input: &quot;abeccdeba&quot; Expected Output: true Justification: Removing the character ‘d’ forms the palindrome “abccba”. Example 3: Input: &quot;abcdef&quot; Expected Output: false Justification: No single character removal will make this string a palindrome. Constraints: 1 &lt;= s.length &lt;= 10^5 str consists of lowercase English letters. SolutionTo solve this problem, we use a two-pointer approach that initiates at both ends of the string. These pointers move towards the center, comparing characters at each step. Upon encountering a mismatch, the algorithm decides whether to skip the character at the left or the right pointer. A helper function is used to check if the resulting substring (after skipping a character) forms a palindrome. This process is performed twice, once for each pointer. If either scenario results in a palindrome, the original string can be considered a valid palindrome after removing at most one character. This efficient method determines the feasibility of forming a palindrome with minimal alterations to the string. Initialization: Begin by initializing the left pointer with 0 and the right pointer with n - 1, where n is a string length. Two-Pointer Traversal: Use two pointers, and move these pointers towards the center, comparing the characters at each step. Handling Mismatch: Upon encountering a mismatch, the algorithm checks two scenarios: removing the character at the left pointer or at the right pointer. For each scenario, it checks if the remaining substring forms a palindrome. Greedy Decision Making: If either resulting substring is a palindrome, return true. This decision is based on the greedy principle that choosing the first viable option (resulting in a palindrome) is sufficient. Concluding Result: If neither scenario results in a palindrome, the algorithm concludes that it’s impossible to form a palindrome by removing just one character and returns false. This greedy approach is efficient as it minimizes the number of checks needed to determine if the string can be a valid palindrome with a single character removal. Algorithm WalkthroughInput:- “abeccdeba” Initial Setup: Two pointers are initialized: left at the start (pointing to &#39;a&#39;) and right at the end (pointing to &#39;a&#39;). First Iteration: Compare characters at left and right pointers. Characters are the same (&#39;a&#39;), so move left to the right and right to the left. Second Iteration: Now left points to &#39;b&#39; and right points to &#39;b&#39;. Characters match, so move left and right inward again. Third Iteration: left is now at &#39;e&#39;, and right is at &#39;e&#39;. Characters match, so move left and right inward again. Fourth Iteration: left is now at &#39;c&#39;, and right is at &#39;d&#39;. Characters do not match. This is where a decision is made. Checking Substrings: Remove the character at the left pointer (&#39;c&#39;) and check if the substring &quot;cd&quot; is a palindrome. It is not. Remove the character at the right pointer (&#39;d&#39;) and check if the substring &quot;cc&quot; is a palindrome. It is a palindrome. Conclusion: Since removing the character &#39;d&#39; (at the right pointer) resulted in a palindrome, the answer is true. CodeHere is the code for this algorithm: 12345678910111213141516171819202122232425262728class Solution: def isPalindromePossible(self, s: str) -&gt; bool: &quot;&quot;&quot;Check if it&#x27;s possible to form a palindrome by removing at most one character&quot;&quot;&quot; left, right = 0, len(s) - 1 while left &lt; right: if s[left] != s[right]: # Check if either substring (after removing one char) is a palindrome return self.isPalindrome(s, left + 1, right) or self.isPalindrome(s, left, right - 1) left += 1 right -= 1 return True def isPalindrome(self, s: str, left: int, right: int) -&gt; bool: &quot;&quot;&quot;Helper function to check if a substring is a palindrome&quot;&quot;&quot; while left &lt; right: if s[left] != s[right]: return False left += 1 right -= 1 return Trueif __name__ == &quot;__main__&quot;: solution = Solution() print(solution.isPalindromePossible(&quot;racecar&quot;)) # true print(solution.isPalindromePossible(&quot;abccdba&quot;)) # true print(solution.isPalindromePossible(&quot;abcdef&quot;)) # false Complexity Analysis Time Complexity: O(n) for traversing the string. Space Complexity: O(1) as no extra space is used. Maximum Length of Pair Chain646. Maximum Length of Pair Chain Design Gurus 类似Pattern Merge Intervals. 都要先排序 Problem StatementGiven a collection of pairs where each pair contains two elements [a, b], find the maximum length of a chain you can form using pairs. A pair [a, b] can follow another pair [c, d] in the chain if b &lt; c. You can select pairs in any order and don’t need to use all the given pairs. Examples Example 1: Input: [[1,2], [3,4], [2,3]] Expected Output: 2 Justification: The longest chain is [1,2] -&gt; [3,4]. The chain [1,2] -&gt; [2,3] is invalid because 2 is not smaller than 2. Example 2: Input: [[5,6], [1,2], [8,9], [2,3]] Expected Output: 3 Justification: The chain can be [1,2] -&gt; [5,6] -&gt; [8,9] or [2,3] -&gt; [5,6] -&gt; [8, 9]. Example 3: Input: [[7,8], [5,6], [1,2], [3,5], [4,5], [2,3]] Expected Output: 3 Justification: The longest possible chain is formed by chaining [1,2] -&gt; [3,5] -&gt; [7,8]. Constraints: n == pairs.length 1 &lt;= n &lt;= 1000 -1000 &lt;= lefti &lt; righti &lt;= 1000 SolutionThe greedy approach to solving the problem involves initially sorting the pairs based on their second elements. This step is crucial as it aligns the pairs in a way that the one with the smallest end is considered first, leading to more opportunities for chain extension. After sorting, we iterate through the pairs, maintaining a variable to track the current end of the chain. For each pair, if the first element is greater than the current chain end, we extend the chain by adding this pair and updating the chain end to this pair’s second element. This method ensures that at each step, we’re making the most optimal choice to extend the chain without needing to consider previous pairs, thereby maximizing the number of pairs in the chain with the least end values first, leading to the longest possible chain. Sorting the Pairs: Initially, sort all pairs based on their second element in ascending order. This ensures that as you iterate through the pairs, you are always considering the pair with the next smallest endpoint. Initializing Variables: Start with two variables: one to keep track of the current endpoint of the chain (currentEnd) and another to count the number of pairs in the chain (chainCount). Initialize currentEnd to the lowest possible value (e.g., Integer.MIN_VALUE) and chainCount to 0. Iterating and Choosing Pairs: Iterate through the sorted pairs. For each pair, check if its first element is greater than currentEnd. If it is, it means this pair can be appended to the current chain. Update currentEnd to the second element of this pair and increment chainCount. Result: After iterating through all pairs, chainCount will hold the maximum number of pairs that can be chained. This Greedy approach is effective because it always chooses the option that seems best at the moment (the pair with the smallest endpoint) and this local optimal choice leads to a globally optimal solution in this specific problem context. The logic behind this is that by choosing the pair with the smallest endpoint, you are maximizing the potential for other pairs to be chained afterward. Algorithm Walkthrough Input Pairs: [[7,8], [5,6], [1,2], [3,5], [4,5], [2,3]] After Sorting by Second Element: [[1,2], [2,3], [3,5], [4,5], [5,6], [7,8]] Iterating through Pairs: Start with currentEnd = Integer.MIN_VALUE and chainCount = 0. Pair [1,2]: 1 &gt; Integer.MIN_VALUE. Update currentEnd to 2, chainCount to 1. Pair [2,3]: 2 &gt; 2 is false. Skip. Pair [3,5]: 3 &gt; 2. Update currentEnd to 5, chainCount to 2. Pair [4,5]: 4 &gt; 5 is false. Skip. Pair [5,6]: 5 &gt; 5 is false. Skip. Pair [7,8]: 7 &gt; 5. Update currentEnd to 8, chainCount to 3. Result: chainCount = 3 indicates the maximum number of pairs that can be chained. CodeHere is the code for this algorithm: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 官方原版是对end进行排序，但是我认为也可以对start来排序，但是需要注意，如果按照start排序，就要从后往前遍历class Solution: def findLongestChain(self, pairs): # Sort pairs based on their second element in ascending order pairs.sort(key=lambda x: x[1]) currentEnd = float(&#x27;-inf&#x27;) # Current end of the chain chainCount = 0 # Count of pairs in the chain # Iterate through the sorted pairs for pair in pairs: # Check if the first element of the pair is greater than the current end if pair[0] &gt; currentEnd: # Update the current end and increment the chain count currentEnd = pair[1] chainCount += 1 return chainCount # Return the maximum chain length# Example Test Casessolution = Solution()example1 = [[1, 2], [3, 4], [2, 3]]example2 = [[5, 6], [1, 2], [8, 9], [2, 3]]example3 = [[7, 8], [5, 6], [1, 2], [3, 5], [4, 5], [2, 3]]print(&quot;Example 1:&quot;, solution.findLongestChain(example1)) # Expected Output: 2print(&quot;Example 2:&quot;, solution.findLongestChain(example2)) # Expected Output: 3print(&quot;Example 3:&quot;, solution.findLongestChain(example3)) # Expected Output: 3# 按照start排序，从后往前遍历class Solution: def findLongestChain(self, pairs): # Sort pairs based on their second element in ascending order pairs.sort(key=lambda x: x[0]) current_start = float(&#x27;inf&#x27;) # Current end of the chain chainCount = 0 # Count of pairs in the chain # Iterate through the sorted pairs for pair in reversed(pairs): # Check if the first element of the pair is greater than the current end if pair[1] &lt; current_start: # Update the current end and increment the chain count current_start = pair[0] chainCount += 1 return chainCount # Return the maximum chain length# Example Test Casessolution = Solution()example1 = [[1, 2], [3, 4], [2, 3]]example2 = [[5, 6], [1, 2], [8, 9], [2, 3]]example3 = [[7, 8], [5, 6], [1, 2], [3, 5], [4, 5], [2, 3]]print(&quot;Example 1:&quot;, solution.findLongestChain(example1)) # Expected Output: 2print(&quot;Example 2:&quot;, solution.findLongestChain(example2)) # Expected Output: 3print(&quot;Example 3:&quot;, solution.findLongestChain(example3)) # Expected Output: 3 Complexity Analysis Time Complexity: The code takes (O(n log n)) time to run, mainly due to sorting the input pairs. Space Complexity: It uses (O(n)) additional space due to the input array of pairs. Minimum Add to Make Parentheses Valid921. Minimum Add to Make Parentheses Valid Design Gurus Problem StatementGiven a string str containing ‘(‘ and ‘)’ characters, find the minimum number of parentheses that need to be added to a string of parentheses to make it valid. A valid string of parentheses is one where each opening parenthesis ‘(‘ has a corresponding closing parenthesis ‘)’ and vice versa. The goal is to determine the least amount of additions needed to achieve this balance. Examples Example 1: Input: “(()” Expected Output: 1 Justification: The string has two opening parentheses and one closing parenthesis. Adding one closing parenthesis at the end will balance it. Example 2: Input: “))((“ Expected Output: 4 Justification: There are two closing parentheses at the beginning and two opening at the end. We need two opening parentheses before the first closing and two closing parentheses after the last opening to balance the string. Example 3: Input: “(()())(“ Expected Output: 1 Justification: The string has three opening parentheses and three closing parentheses, with an additional opening parenthesis at the end. Adding one closing parenthesis at the end will balance it. Constraints: 1 &lt;= s.length &lt;= 1000 s[i] is either ‘(‘ or ‘)’. SolutionTo solve this problem, we track the balance of parentheses as we iterate through the string. We initialize two counters: one for the balance of parentheses and another for the count of additions needed. For each character in the string, if it’s an opening parenthesis ‘(‘, we increase the balance. If it’s a closing parenthesis ‘)’, we decrease the balance. If the balance is negative at any point (which means there are more closing parentheses than opening ones), we increment the additions counter and reset the balance to zero. The total number of additions required is the sum of the additions counter and the absolute value of the final balance, ensuring that all unmatched opening parentheses are also accounted for. This approach efficiently computes the minimum number of parentheses to be added for the string to become valid. Initialization: Start with a counter set to zero, representing the number of parentheses needed to balance the string. Iterating through the String: For each character in the string, determine if it’s an opening or closing parenthesis. Handling Opening Parenthesis: Increment the balance counter for each opening parenthesis, indicating a pending closing parenthesis is needed. Handling Closing Parenthesis: For each closing parenthesis, if there is an unmatched opening parenthesis (balance counter &gt; 0), decrement the balance. If not, increment the counter, indicating an additional opening parenthesis is needed. Completion: The final value of the counter represents the total number of additional parentheses required to balance the string. Algorithm WalkthroughLet’s apply the algorithm to the input string “(()())(“: Initialize Variables: balance = 0 counter = 0 Iterate Through the String “(()())(“: First Character ‘(‘ : Increment balance → balance = 1 (1 unmatched opening parenthesis). Second Character ‘(‘ : Increment balance → balance = 2 (2 unmatched opening parentheses). Third Character ‘)’ : Decrement balance → balance = 1 (1 unmatched opening parenthesis). Fourth Character ‘(‘ : Increment balance → balance = 2 (2 unmatched opening parentheses). Fifth Character ‘)’ : Decrement balance → balance = 1 (1 unmatched opening parenthesis). Sixth Character ‘)’ : Decrement balance → balance = 0 (all parentheses matched so far). Seventh Character ‘(‘ : Increment balance → balance = 1 (1 unmatched opening parenthesis). Final Calculation: At the end of the string, balance = 1 and counter = 0. Add counter and balance → 0 + 1 = 1. Return Result: The final result is 1, indicating that 1 additional closing parenthesis is required to make the string “(()())(“ valid. This walkthrough demonstrates that to balance the given string “(()())(“, we need to add just one closing parenthesis. CodeHere is the code for this algorithm: 12345678910111213141516171819202122# 感觉和这个背景类似，但是方法不一样哦# https://hasuer.github.io/15-pattern-subsets/index.html#/Balanced-Parentheses-hardclass Solution: def minAddToMakeValid(self, S: str) -&gt; int: balance, counter = 0, 0 for char in S: # Increment balance for &#x27;(&#x27;, decrement for &#x27;)&#x27; balance += 1 if char == &#x27;(&#x27; else -1 # If balance is negative, we have more &#x27;)&#x27; than &#x27;(&#x27; if balance == -1: counter += 1 # Increment counter for each unmatched &#x27;)&#x27; balance += 1 # Reset balance as we&#x27;ve accounted for the unmatched &#x27;)&#x27; return counter + balance # Sum is the total adjustments neededif __name__ == &quot;__main__&quot;: solution = Solution() # Testing the algorithm with the three examples print(solution.minAddToMakeValid(&quot;(()&quot;)) # Example 1 print(solution.minAddToMakeValid(&quot;))((&quot;)) # Example 2 print(solution.minAddToMakeValid(&quot;(()())(&quot;)) # Example 3 Complexity Analysis Time Complexity: The time complexity of this algorithm is O(n), where n is the length of the string. This is because we iterate through the string once. Space Complexity: The space complexity is O(1), as we only use a fixed amount of additional space (counter and balance variables) regardless of the input size. *Remove Duplicate Letters316. Remove Duplicate Letters Design Gurus Problem StatementGiven a string s, remove all duplicate letters from the input string while maintaining the original order of the letters. Additionally, the returned string should be the smallest in lexicographical order among all possible results. Examples: Input: “bbaac” Expected Output: “bac” Justification: Removing the extra ‘b’ and one ‘a’ from the original string gives ‘bac’, which is the smallest lexicographical string without duplicate letters. Input: “zabccde” Expected Output: “zabcde” Justification: Removing one of the ‘c’s forms ‘zabcde’, the smallest string in lexicographical order without duplicates. Input: “mnopmn” Expected Output: “mnop” Justification: Removing the second ‘m’ and ‘n’ gives ‘mnop’, which is the smallest possible string without duplicate characters. Constraints: 1 &lt;= s.length &lt;= 10^4 s consists of lowercase English letters. SolutionTo solve the given problem, begin by iterating through the string, and calculate the frequency count for each character. We will use the stack to maintain the order of characters and the set to track the uniqueness of characters. Next, start traversing the string, and for every character encountered, check if it’s already in the ‘present’ set. If it’s not, compare it with the top element of the ‘result’ stack. If the stack is not empty, and the current character is lexicographically smaller than the stack’s top, and the top character of the stack appears again in the string (indicated by a non-zero frequency count), repeatedly pop the stack and remove those elements from the ‘present’ set. Then, add the current character to the stack and the ‘present’ set. This process, facilitated by the stack and set, ensures that the stack is built with unique characters in the smallest lexicographical order. After processing the entire string, pop elements from the stack to construct the final string, thereby obtaining the smallest lexicographical sequence without duplicate characters. Frequency Count (count): Initialize a count dictionary (or hash map in some languages) to store the frequency of each character in the string s. Character Presence Tracking (present): Use a set present to keep track of the characters that have been added to the resultant string. This set prevents duplicate characters in the result. Building the Result (result): Create a stack result to construct the final string. For each character c in the string s: If c is not in present, proceed to compare it with the top character of result. While result is not empty, and c is lexicographically smaller than the top character of result, and the frequency of the top character of result is more than 0 (indicating it appears again in the string), pop the top character from result and remove it from present. Push c onto result and add it to present. Decrement the frequency of c in count. Result Construction: The stack result now contains the characters of the final string in reverse order. Pop elements from result to construct the output string in the correct order, from left to right. This approach works because it ensures that the smallest character is placed first, respecting the original order and removing duplicates. The frequency count ensures that characters are not wrongly discarded. Algorithm Walkthrough: Input: “zabccde” Initialization: Calculate the frequency of each character: &#123;&#39;z&#39;: 1, &#39;a&#39;: 1, &#39;b&#39;: 1, &#39;c&#39;: 2, &#39;d&#39;: 1, &#39;e&#39;: 1&#125;. Initialize an empty stack result and a set present to keep track of characters already in result. Iteration Over Characters: ‘z’: Not in present. Add ‘z’ to result, add to present. Decrease frequency of ‘z’. ‘a’: Not in present. As ‘a’ is smaller than ‘z’, but ‘z’ won’t appear again (frequency is now 0), we keep ‘z’. Add ‘a’ to result, add to present. Decrease frequency of ‘a’. ‘b’: Not in present. Add ‘b’ to result, add to present. Decrease frequency of ‘b’. First ‘c’: Not in present. Add ‘c’ to result, add to present. Decrease frequency of ‘c’. Second ‘c’: Already in present. Skip it. ‘d’: Not in present. Add ‘d’ to result, add to present. Decrease frequency of ‘d’. ‘e’: Not in present. Add ‘e’ to result, add to present. Decrease frequency of ‘e’. Result Construction: The result stack now contains [&#39;z&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]. Convert the stack to a string to get the final result: “zabcdef”. Expected Output: “zabcdef” CodeHere is the code for this algorithm: 123456789101112131415161718192021222324252627282930# 本来感觉官方的写法好复杂，但是自己用了min_heap、OrderedDict试了一下是错的from collections import dequeclass Solution: def removeDuplicateLetters(self, s: str) -&gt; str: # Count the frequency of each character count = &#123;char: s.count(char) for char in set(s)&#125; # 这里的顺序是不确定的 stack = deque() # Stack for the result string present = set() # Set to track if a character is in the result for char in s: # Only add character if it&#x27;s not already in the result if char not in present: # Ensure the smallest lexicographical order while stack and char &lt; stack[-1] and count[stack[-1]] &gt; 0: present.remove(stack.pop()) stack.append(char) present.add(char) count[char] -= 1 # Decrease the frequency return &#x27;&#x27;.join(stack)# Test casessol = Solution()print(sol.removeDuplicateLetters(&quot;bbaac&quot;)) # Output: &quot;bac&quot;print(sol.removeDuplicateLetters(&quot;zabccde&quot;)) # Output: &quot;zabcde&quot;print(sol.removeDuplicateLetters(&quot;mnopmn&quot;)) # Output: &quot;mnop&quot; Complexity Analysis: Time Complexity: O(N) where N is the length of the string. Each character is visited once. Space Complexity: O(1) as the extra space used does not depend on the input size. The character count and the stack size are bounded by the character set size (constant). Largest Palindromic Number2384. Largest Palindromic Number Design Gurus 类似 Pattern Hash Maps 中的Longest Palindrome(easy) Problem StatementGiven a string s containing 0 to 9 digits, create the largest possible palindromic number using the string characters. A palindromic number reads the same backward as forward. If it’s not possible to form such a number using all digits of the given string, you can skip some of them. Examples Input: “323211444” Expected Output: “432141234” Justification: This is the largest palindromic number that can be formed from the given digits. Input: “998877” Expected Output: “987789” Justification: “987789” is the largest palindrome that can be formed. Input: “54321” Expected Output: “5” Justification: Only “5” can form a valid palindromic number as other digits cannot be paired. Constraints: 1 &lt;= num.length &lt;= 105 num consists of digits. SolutionTo solve this problem, begin by counting the frequency of each character in the provided string. Next, construct the palindrome in two halves. Start with the first half: for each digit, use half of its total occurrences and add digits in descending order. If a digit occurs an odd number of times, set aside one occurrence for the middle of the palindrome. The middle element should be the largest digit that appears an odd number of times. Once the first half is complete, replicate it in reverse order to form the second half. In cases where there’s no first half but there is a single digit with an odd count, use that digit as the palindrome. If it’s not possible to form any palindrome, return “0”. Count Digit Frequencies: Determine how many times each digit appears in the input. Construct the First Half: Arrange the digits in descending order for the first half, ensuring to use each digit an even number of times. Middle Digit Consideration: Reserve one instance of the largest digit that occurs an odd number of times for the middle of the palindrome. Complete the Palindrome: Mirror the first half to form the second half of the palindrome. This approach is efficient because it maximizes the value of the palindrome by using the largest digits in the most significant positions. Algorithm WalkthroughInput “323211444” Count Digit Frequencies: Iterate over each digit in the string “323211444”. Count the occurrences of each digit. For example, the digit ‘1’ appears twice, ‘2’ appears twice, ‘3’ once, and ‘4’ thrice. Build the First Half of the Palindrome: Start from the largest digit (9) and move down to the smallest (0). Skip digits that do not appear in the count. For each digit that does appear, add half of its occurrences to the first half of the palindrome. For instance, add one ‘4’s, one ‘3’, one ‘2’, and one ‘1’. Reserve one occurrence of the digit with the highest value that appears an odd number of times for the middle of the palindrome if necessary. In this case, ‘4’ appears three times, so one ‘4’ is reserved. Determine the Middle Digit: Identify the largest digit that has an odd frequency. In “312211444”, it’s ‘4’. This will be the middle digit of the palindrome. Complete the Palindrome: Mirror the first half of the palindrome to create the second half. Combine the first half, the middle digit (if any), and the mirrored second half to form the final palindromic number. In this case, the first half is “4321”, the middle digit is ‘4’, and the mirrored second half is “1234”, making the complete palindrome “432141234”. CodeHere is the code for this algorithm: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# 但是这个有点问题，在这一部分上“Handle special cases”，如果是&quot;00001&quot;应该返回的是1，但是现在返回的是0class Solution: def largestPalindromic(self, num: str) -&gt; str: # Count the frequency of each digit in the input number freq = [0] * 10 # Initialize a frequency array for digits 0-9 for digit in num: freq[int(digit)] += 1 # Increment the count for each digit first_half, middle = [], &#x27;&#x27; for i in range(9, -1, -1): # Iterate from the highest digit (9) to the lowest (0) if freq[i] % 2 != 0 and middle == &#x27;&#x27;: # Check if the digit count is odd and middle is empty middle = str(i) # Assign the largest odd-count digit as the middle digit first_half.extend([str(i)] * (freq[i] // 2)) # Add half of the even-count digits to the first half # first_half.append(str(i) * (freq[i] // 2)) # 这个也可以，这是添加元素，上面的是添加数组 # Handle special cases if not first_half: return middle if middle else &#x27;0&#x27; # Return the middle digit or &quot;0&quot; elif all(d == &#x27;0&#x27; for d in first_half): return &#x27;0&#x27; # Case for multiple zeros # Construct the final palindrome return &#x27;&#x27;.join(first_half) + middle + &#x27;&#x27;.join( reversed(first_half)) # Concatenate the first half, middle digit, and the reversed first half# Test Casessolution = Solution()print(solution.largestPalindromic(&quot;323211444&quot;)) # 432141234print(solution.largestPalindromic(&quot;998877&quot;)) # 987789print(solution.largestPalindromic(&quot;54321&quot;)) # 5# 修改之后的版本，这才可以过leetcode,上面那个不能过leetcodeclass Solution: def largestPalindromic(self, num: str) -&gt; str: # Count the frequency of each digit in the input number freq = [0] * 10 # Initialize a frequency array for digits 0-9 for digit in num: freq[int(digit)] += 1 # Increment the count for each digit first_half, middle = [], &#x27;&#x27; for i in range(9, -1, -1): # Iterate from the highest digit (9) to the lowest (0) if freq[i] % 2 != 0 and middle == &#x27;&#x27;: # Check if the digit count is odd and middle is empty middle = str(i) # Assign the largest odd-count digit as the middle digit first_half.extend([str(i)] * (freq[i] // 2)) # Add half of the even-count digits to the first half # first_half.append(str(i) * (freq[i] // 2)) # 这个也可以，这是添加元素，上面的是添加数组 # Handle special cases if not first_half: return middle if middle else &#x27;0&#x27; # Return the middle digit or &quot;0&quot; elif all(d == &#x27;0&#x27; for d in first_half) and middle == &quot;&quot;: return &#x27;0&#x27; # Case for multiple zeros elif all(d == &#x27;0&#x27; for d in first_half): first_half = &quot;&quot; # 这是first-half都是0，但是middle存在的情况 # Construct the final palindrome return &#x27;&#x27;.join(first_half) + middle + &#x27;&#x27;.join( reversed(first_half)) # Concatenate the first half, middle digit, and the reversed first half# Test Casessolution = Solution()print(solution.largestPalindromic(&quot;323211444&quot;)) # 432141234print(solution.largestPalindromic(&quot;998877&quot;)) # 987789print(solution.largestPalindromic(&quot;54321&quot;)) # 5print(solution.largestPalindromic(&quot;00001&quot;)) # 5 Complexity Analysis Time Complexity: O(n), where n is the length of the input string. The algorithm involves iterating over the input string once for frequency counting and then iterating over the frequency array (constant size of 10). Space Complexity: O(1), as the frequency array size is constant and does not depend on the input size. Removing Minimum and Maximum From ArrayRemoving Minimum and Maximum From Array Design Gurus Problem StatementDetermine the minimum number of deletions required to remove the smallest and the largest elements from an array of integers. In each deletion, you are allowed to remove either the first (leftmost) or the last (rightmost) element of the array. Examples Example 1: Input: [3, 2, 5, 1, 4] Expected Output: 3 Justification: The smallest element is 1 and the largest is 5. Removing 4, 1, and then 5 (or 5, 4, and then 1) in three moves is the most efficient strategy. Example 2: Input: [7, 5, 6, 8, 1] Expected Output: 2 Justification: Here, 1 is the smallest, and 8 is the largest. Removing 1 and then 8 in two moves is the optimal strategy. Example 3: Input: [2, 4, 10, 1, 3, 5] Expected Output: 4 Justification: The smallest is 1 and the largest is 10. One strategy is to remove 2, 4, 10, and then 1 in four moves. Constraints: 1 &lt;= nums.length &lt;= 105 -105 &lt;= nums[i] &lt;= 105 The integers in nums are distinct. SolutionTo solve this problem, identify the positions of the minimum and maximum elements in the array. Then, calculate the distance of these elements from both ends of the array. The key is to find the shortest path to remove both elements, considering three scenarios: removing both from the start, both from the end, one from the start and the other from the end. The minimum number of steps among these scenarios is the answer. The steps are: Find Indices of Minimum and Maximum Elements: Iterate through the array to find the indices of the minimum and maximum elements. This step is essential because these positions dictate the strategy for removal. Calculate Distances: Calculate the distances of the minimum and maximum elements from both ends of the array. Evaluate Removal Strategies: There are several strategies to consider, and the goal is to find the one that requires the fewest moves: Removing the minimum and maximum elements starting from the same end of the array. Removing one of them from the start and the other from the end. To find the optimal strategy, compare the total number of moves for each approach. This comparison involves summing up the relevant distances and determining the minimum sum. Return the Minimum Number of Moves: The final step is to return the smallest number of moves required among all evaluated strategies. Algorithm WalkthroughFor the input [3, 2, 5, 1, 4]: Identify the Smallest and Largest Elements: Smallest element: 1 at index 3. Largest element: 5 at index 2. Calculate Distances from Both Ends: Distance of 1 from the start: 4. Distance of 1 from the end: 2. Distance of 5 from the start: 3. Distance of 5 from the end: 3. Determine the Most Efficient Removal Sequence: Option 1: Remove elements from start to reach 5 and then from the end to reach 1. Total moves = 3 (for 5) + 2 (for 1) = 5. Option 2: Remove both elements from the end. Total moves to reach at 5 from the end is equal to 3. Option 3: Remove both elements from the start. Total moves to reach at 1 from the end is equal to 4. Choose the Optimal Sequence: Option 2 provides the optimal result. The total number of moves required is 3. CodeHere is the code for this algorithm: 1234567891011121314151617181920212223242526272829class Solution: def minMoves(self, nums): n = len(nums) # Find the indexes of the minimum and maximum elements minIndex = nums.index(min(nums)) maxIndex = nums.index(max(nums)) # Calculate distances from both ends minDistStart = minIndex + 1 minDistEnd = n - minIndex maxDistStart = maxIndex + 1 maxDistEnd = n - maxIndex # Determine the most efficient sequence of moves totalMoves = min( max(minDistStart, maxDistStart), # Both from start min(minDistStart + maxDistEnd, minDistEnd + maxDistStart), # One from each end max(minDistEnd, maxDistEnd) # Both from end ) return totalMoves# Testing the algorithm with example inputssol = Solution()print(sol.minMoves([3, 2, 5, 1, 4])) # Output: 3print(sol.minMoves([7, 5, 6, 8, 1])) # Output: 2print(sol.minMoves([2, 4, 10, 1, 3, 5])) # Output: 4 Complexity Analysis Time Complexity: The algorithm primarily involves finding the minimum and maximum elements and calculating their distances from both ends. This is a linear operation, resulting in a time complexity of O(n), where n is the length of the array. Space Complexity: Since no additional data structures are used that grow with the input size, the space complexity is O(1).","categories":[{"name":"Grokking Interview Pattern","slug":"Grokking-Interview-Pattern","permalink":"https://hasuer.github.io/categories/Grokking-Interview-Pattern/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hasuer.github.io/tags/Interview/"}]},{"title":"19. Pattern K-way merge","slug":"19. Pattern K-way merge","date":"2024-05-19T09:40:47.000Z","updated":"2024-05-28T03:29:55.556Z","comments":true,"path":"19-pattern-k-way-merge/index.html","link":"","permalink":"https://hasuer.github.io/19-pattern-k-way-merge/index.html","excerpt":"","text":"IntroductionThis pattern helps us solve problems that involve a list of sorted arrays. Whenever we are given ‘K’ sorted arrays, we can use a Heap to efficiently perform a sorted traversal of all the elements of all arrays. We can push the smallest (first) element of each sorted array in a Min Heap to get the overall minimum. While inserting elements to the Min Heap we keep track of which array the element came from. We can, then, remove the top element from the heap to get the smallest element and push the next element from the same array, to which this smallest element belonged, to the heap. We can repeat this process to make a sorted traversal of all elements. Let’s see this pattern in action. Merge K Sorted Lists (medium)Top Interview 150 | 23. Merge k Sorted Lists Design Gurus Educative.io Problem StatemenGiven an array of ‘K’ sorted LinkedLists, merge them into one sorted list. Example 1: 12Input: L1=[2, 6, 8], L2=[3, 6, 7], L3=[1, 3, 4]Output: [1, 2, 3, 3, 4, 6, 6, 7, 8] Example 2: 12Input: L1=[5, 8, 9], L2=[1, 7]Output: [1, 5, 7, 8, 9] Constraints: k == lists.length 0 &lt;= k &lt;= 10^4 0 &lt;= lists[i].length &lt;= 500 -10^4 &lt;= lists[i][j] &lt;= 10^4 lists[i] is sorted in ascending order. The sum of lists[i].length will not exceed 10^4. SolutionA brute force solution could be to add all elements of the given ‘K’ lists to one list and sort it. If there are a total of ‘N’ elements in all the input lists, then the brute force solution will have a time complexity of O(NlogN) as we will need to sort the merged list. Can we do better than this? How can we utilize the fact that the input lists are individually sorted? If we have to find the smallest element of all the input lists, we have to compare only the smallest (i.e. the first) element of all the lists. Once we have the smallest element, we can put it in the merged list. Following a similar pattern, we can then find the next smallest element of all the lists to add it to the merged list. The best data structure that comes to mind to find the smallest number among a set of ‘K’ numbers is a Heap). Let’s see how can we use a heap to find a better algorithm. We can insert the first element of each array in a Min Heap. After this, we can take out the smallest (top) element from the heap and add it to the merged list. After removing the smallest element from the heap, we can insert the next element of the same list into the heap. We can repeat steps 2 and 3 to populate the merged list in sorted order. Let’s take the Example-1 mentioned above to go through each step of our algorithm: Given lists: L1=[2, 6, 8], L2=[3, 6, 7],L3=[1, 3, 4] After inserting the 1st element of each list, the heap will have the following elements: We’ll take the top number from the heap, insert it into the merged list and add the next number in the heap. Again, we’ll take the top element of the heap, insert it into the merged list and add the next number to the heap. Repeating the above step, take the top element of the heap, insert it into the merged list and add the next number to the heap. As there are two 3s in the heap, we can pick anyone but we need to take the next element from the corresponding list to insert in the heap. We’ll repeat the above step to populate our merged array. CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121from heapq import *# class Node:# def __init__(self, val):# self.val = val# self.next = None# # used for the min-heap# def __lt__(self, other):# return self.val &lt; other.valclass Solution: def merge(self, lists): minHeap = [] # put the root of each list in the min heap for root in lists: if root is not None: # 这里pycharm可以自动根据root的值排序，但是leetcode不行，所以这种写法不能过leetcode heappush(minHeap, root) # take the smallest(top) element form the min-heap and add it to the result # if the top element has a next element add it to the heap resultHead, resultTail = None, None while minHeap: node = heappop(minHeap) if resultHead is None: resultHead = resultTail = node else: resultTail.next = node resultTail = resultTail.next if node.next is not None: heappush(minHeap, node.next) return resultHeaddef main(): sol = Solution() l1 = Node(2) l1.next = Node(6) l1.next.next = Node(8) l2 = Node(3) l2.next = Node(6) l2.next.next = Node(7) l3 = Node(1) l3.next = Node(3) l3.next.next = Node(4) result = sol.merge([l1, l2, l3]) print(&quot;Here are the elements form the merged list: &quot;, end=&#x27;&#x27;) while result is not None: print(str(result.val) + &quot; &quot;, end=&#x27;&#x27;) result = result.nextmain()#=====================================leetcode==========================================from heapq import *class ListNode: def __init__(self, value): self.value = value self.next = None def __lt__(self, other): return self.value &lt; other.valuedef merge_lists(lists): min_heap = [] # put the root of each list in the min heap for root in lists: if root: heappush(min_heap, (root.value, root)) # take the smallest(top)element form the min-heap and add it to the result # if the top element has a next element add it to the heap result_head, result_tail = None, None while min_heap: node = heappop(min_heap)[1] if result_head is None: result_head = result_tail = node else: result_tail.next = node result_tail = result_tail.next if node.next: heappush(min_heap, (node.next.value, node.next)) return result_headdef main(): l1 = ListNode(1) l1.next = ListNode(4) l1.next.next = ListNode(5) l2 = ListNode(1) l2.next = ListNode(3) l2.next.next = ListNode(4) l3 = ListNode(2) l3.next = ListNode(6) result = merge_lists([l1, l2, l3]) while result: print(str(result.value), end=&quot; &quot;) result = result.nextif __name__ == &#x27;__main__&#x27;: main() Time complexitySince we’ll be going through all the elements of all arrays and will be removing/adding one element to the heap in each step, the time complexity of the above algorithm will be O(N\\logK)*, where ‘N’ is the total number of elements in all the ‘K’ input arrays. Space complexityThe space complexity will be O(K) because, at any time, our min-heap will be storing one number from all the ‘K’ input arrays. Kth Smallest Number in M Sorted Lists (Medium)Similar | 378. Kth Smallest Element in a Sorted Matrix Design Gurus Educative.io Problem StatementGiven ‘M’ sorted arrays, find the K’th smallest number among all the arrays. Example 1: 1234Input: L1=[2, 6, 8], L2=[3, 6, 7], L3=[1, 3, 4], K=5Output: 4Explanation: The 5th smallest number among all the arrays is 4, this can be verified from the merged list of all the arrays: [1, 2, 3, 3, 4, 6, 6, 7, 8] Example 2: 123Input: L1=[5, 8, 9], L2=[1, 7], K=3Output: 7Explanation: The 3rd smallest number among all the arrays is 7. SolutionThis problem follows the K-way merge pattern and we can follow a similar approach as discussed in Merge K Sorted Lists. We can start merging all the arrays, but instead of inserting numbers into a merged list, we will keep count to see how many elements have been inserted in the merged list. Once that count is equal to ‘K’, we have found our required number. A big difference from Merge K Sorted Lists is that in this problem, the input is a list of arrays compared to LinkedLists. This means that when we want to push the next number in the heap we need to know what the index of the current number in the current array was. To handle this, we will need to keep track of the array and the element indices. CodeHere is what our algorithm will look like: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667from heapq import *class Solution: def findKthSmallest(self, lists, k): # 注意，这里和之前不一样，这里应该使用的是minheap,如果还是max_heap，那就相当于每个数组都要全部遍历，这样的时间复杂度会上去 minHeap = [] # put the 1st element of each list in the min heap for i in range(len(lists)): heappush(minHeap, (lists[i][0], 0, lists[i])) # take the smallest(top) element form the min heap, if the running count is equal to k # return the number numberCount, number = 0, 0 while minHeap: number, i, list = heappop(minHeap) numberCount += 1 if numberCount == k: # 当然，这里也可以直接return num,在while循环外面的return num改成return 0也可以（参考上面我的写法） break # if the array of the top element has more elements, add the next element to the heap if len(list) &gt; i + 1: heappush(minHeap, (list[i + 1], i + 1, list)) return numberdef main(): sol = Solution() print(&quot;Kth smallest number is: &quot; + str(sol.findKthSmallest([[2, 6, 8], [3, 6, 7], [1, 3, 4]], 5)))main()================================leetcode=================================# 这个也能过leetcodefrom heapq import *def find_kth_smallest(lists, k): # 注意，这里和之前不一样，这里应该使用的是minheap,如果还是max_heap，那就相当于每个数组都要全部遍历，这样的时间复杂度会上去 min_heap = [] for i in range(len(lists)): heappush(min_heap, (lists[i][0], i, 0)) while min_heap and k: num, list_index, index = heappop(min_heap) k -= 1 if k == 0: return num if index != len(lists[list_index]) - 1: heappush(min_heap, (lists[list_index][index + 1], list_index, index + 1)) return 0def main(): res = find_kth_smallest([[2, 6, 8], [3, 6, 7], [1, 3, 4]], 5) print(str(res)) res = find_kth_smallest([[5, 8, 9], [1, 7]], 3) print(str(res))if __name__ == &#x27;__main__&#x27;: main() Time complexitySince we’ll be going through at most ‘K’ elements among all the arrays, and we will remove/add one element in the heap in each step, the time complexity of the above algorithm will be O(KlogM)O(K∗log*M) where ‘M’ is the total number of input arrays. Space complexityThe space complexity will be O(M)O(M) because, at any time, our min-heap will be storing one number from all the ‘M’ input arrays. Similar ProblemsSimilar | Top Interview 150 | 4. Median of Two Sorted Arrays Design Gurus Educative.io Problem 1: Given ‘M’ sorted arrays, find the median number among all arrays. Solution: This problem is similar to our parent problem with K=Median. So if there are ‘N’ total numbers in all the arrays we need to find the K’th minimum number where K=N/2. Problem 2: Given a list of ‘K’ sorted arrays, merge them into one sorted list. Solution: This problem is similar to Merge K Sorted Lists except that the input is a list of arrays compared to LinkedLists. To handle this, we can use a similar approach as discussed in our parent problem by keeping a track of the array and the element indices. #Kth Smallest Number in a Sorted Matrix (Hard)378. Kth Smallest Element in a Sorted Matrix Design Gurus Educative.io Problem StatementGiven an N\\ N matrix where *each row and column is sorted in ascending order, find the Kth smallest element in the matrix. Example 1: 12345678Input: Matrix=[ [2, 6, 8], [3, 7, 10], [5, 8, 11] ], K=5Output: 7Explanation: The 5th smallest number in the matrix is 7. Constraints: n == matrix.length == matrix[i].length 1 &lt;= n &lt;= 300 -10^9 &lt;= matrix[i][j] &lt;= 10^9 All the rows and columns of matrix are guaranteed to be sorted in non-decreasing order. 1 &lt;= k &lt;= n^2 SolutionThis problem follows the K-way merge pattern and can be easily converted to Kth Smallest Number in M Sorted Lists. As each row (or column) of the given matrix can be seen as a sorted list, we essentially need to find the Kth smallest number in ‘N’ sorted lists. CodeHere is what our algorithm will look like: 12345678910111213141516171819202122232425262728293031323334# 和上面一道题一摸一样from heapq import *class Solution: def findKthSmallest(self, matrix, k): minHeap = [] # put the 1st element of each row in the min heap # we don&#x27;t need to push more than &#x27;k&#x27; elements in the heap for i in range(min(k, len(matrix))): heappush(minHeap, (matrix[i][0], 0, matrix[i])) # take the smallest(top) element form the min heap, if the running count is equal to # &#x27;k&#x27; return the number. If the row of the top element has more elements, add the # next element to the heap numberCount, number = 0, 0 while minHeap: number, i, row = heappop(minHeap) numberCount += 1 if numberCount == k: break if len(row) &gt; i+1: heappush(minHeap, (row[i+1], i+1, row)) return numberdef main(): sol = Solution() print(&quot;Kth smallest number is: &quot; + str(sol.findKthSmallest([[2, 6, 8], [3, 7, 10], [5, 8, 11]], 5)))main() Time complexityFirst, we inserted at most ‘K’ or one element from each of the ‘N’ rows, which will take O(min(K, N)). Then we went through at most ‘K’ elements in the matrix and remove/add one element in the heap in each step. As we can’t have more than ‘N’ elements in the heap in any condition, therefore, the overall time complexity of the above algorithm will be O(min(K, N) + K\\logN)*. Space complexityThe space complexity will be O(N) because, in the worst case, our min-heap will be storing one number from each of the ‘N’ rows. An Alternate SolutionSince each row and column of the matrix is sorted, is it possible to use Binary Search to find the Kth smallest number? The biggest problem to use Binary Search, in this case, is that we don’t have a straightforward sorted array, instead, we have a matrix. As we remember, in Binary Search, we calculate the middle index of the search space (‘1’ to ‘N’) and see if our required number is pointed out by the middle index; if not we either search in the lower half or the upper half. In a sorted matrix, we can’t really find a middle. Even if we do consider some index as middle, it is not straightforward to find the search space containing numbers bigger or smaller than the number pointed out by the middle index. An alternative could be to apply the Binary Search on the “number range” instead of the “index range”. As we know that the smallest number of our matrix is at the top left corner and the biggest number is at the bottom right corner. These two numbers can represent the “range” i.e., the start and the end for the Binary Search. Here is how our algorithm will work: Start the Binary Search with start = matrix[0][0] and end = matrix[n-1][n-1]. Find middle of the start and the end. This middle number is NOT necessarily an element in the matrix. Count all the numbers smaller than or equal to middle in the matrix. As the matrix is sorted, we can do this in O(N). While counting, we can keep track of the “smallest number greater than the middle” (let’s call it n1) and at the same time the “biggest number less than or equal to the middle” (let’s call it n2). These two numbers will be used to adjust the “number range” for the Binary Search in the next iteration. If the count is equal to ‘K’, n1 will be our required number as it is the “biggest number less than or equal to the middle”, and is definitely present in the matrix. If the count is less than ‘K’, we can update start = n2 to search in the higher part of the matrix and if the count is greater than ‘K’, we can update end = n1 to search in the lower part of the matrix in the next iteration. Here is the visual representation of our algorithm: Here is what our algorithm will look like: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution: def findKthSmallest(self, matrix, k): n = len(matrix) start, end = matrix[0][0], matrix[n - 1][n - 1] while start &lt; end: mid = start + (end - start) / 2 smaller, larger = (matrix[0][0], matrix[n - 1][n - 1]) count, smaller, larger = self.count_less_equal(matrix, mid, smaller, larger) if count == k: return smaller if count &lt; k: start = larger # search higher else: end = smaller # search lower return start def count_less_equal(self, matrix, mid, smaller, larger): count, n = 0, len(matrix) row, col = n - 1, 0 while row &gt;= 0 and col &lt; n: if matrix[row][col] &gt; mid: # as matrix[row][col] is bigger than the mid, let&#x27;s keep track of the # smallest number greater than the mid larger = min(larger, matrix[row][col]) row -= 1 else: # as matrix[row][col] is less than or equal to the mid, let&#x27;s keep track of the # biggest number less than or equal to the mid smaller = max(smaller, matrix[row][col]) count += row + 1 col += 1 return count, smaller, largerdef main(): sol = Solution() print(&quot;Kth smallest number is: &quot; + str(sol.findKthSmallest([[1, 4], [2, 5]], 2))) print(&quot;Kth smallest number is: &quot; + str(sol.findKthSmallest([[-5]], 1))) print(&quot;Kth smallest number is: &quot; + str(sol.findKthSmallest([[2, 6, 8], [3, 7, 10], [5, 8, 11]], 5))) print(&quot;Kth smallest number is: &quot; + str(sol.findKthSmallest([[1, 5, 9], [10, 11, 13], [12, 13, 15]], 8)))main() Time complexityThe Binary Search could take O(log(max-min )) iterations where ‘max’ is the largest and ‘min’ is the smallest element in the matrix and in each iteration we take O(N) for counting, therefore, the overall time complexity of the algorithm will be O(N\\log(max-min))*. Space complexityThe algorithm runs in constant space O(1). Smallest Number Range (Hard)632. Smallest Range Covering Elements from K Lists Design Gurus Educative.io Problem StatementGiven ‘M’ sorted arrays, find the smallest range that includes at least one number from each of the ‘M’ lists. Example 1: 123Input: L1=[1, 5, 8], L2=[4, 12], L3=[7, 8, 10]Output: [4, 7]Explanation: The range [4, 7] includes 5 from L1, 4 from L2 and 7 from L3. Example 2: 123Input: L1=[1, 9], L2=[4, 12], L3=[7, 10, 16]Output: [9, 12]Explanation: The range [9, 12] includes 9 from L1, 12 from L2 and 10 from L3. SolutionThis problem follows the K-way merge pattern and we can follow a similar approach as discussed in Merge K Sorted Lists. We can start by inserting the first number from all the arrays in a min-heap. We will keep track of the largest number that we have inserted in the heap (let’s call it currentMaxNumber). In a loop, we’ll take the smallest (top) element from the min-heap andcurrentMaxNumber has the largest element that we inserted in the heap. If these two numbers give us a smaller range, we’ll update our range. Finally, if the array of the top element has more elements, we’ll insert the next element to the heap. We can finish searching the minimum range as soon as an array is completed or, in other terms, the heap has less than ‘M’ elements. CodeHere is what our algorithm will look like: 1234567891011121314151617181920212223242526272829303132333435363738394041from heapq import *import mathclass Solution: def findSmallestRange(self, lists): minHeap = [] rangeStart, rangeEnd = 0, math.inf currentMaxNumber = -math.inf # put the 1st element of each array in the max heap for arr in lists: heappush(minHeap, (arr[0], 0, arr)) currentMaxNumber = max(currentMaxNumber, arr[0]) # take the smallest(top) element form the min heap, if it gives us smaller range, # update the ranges, if the array of the top element has more elements, insert the # next element in the heap # 思路一样，但是当时没有想到这个while循环的条件 while len(minHeap) == len(lists): num, i, arr = heappop(minHeap) if rangeEnd - rangeStart &gt; currentMaxNumber - num: rangeStart = num rangeEnd = currentMaxNumber if len(arr) &gt; i + 1: # insert the next element in the heap heappush(minHeap, (arr[i + 1], i + 1, arr)) currentMaxNumber = max(currentMaxNumber, arr[i + 1]) return [rangeStart, rangeEnd]def main(): sol = Solution() print(&quot;Smallest range is: &quot; + str(sol.findSmallestRange([[1, 5, 8], [4, 12], [7, 8, 10]])))main() Time complexitySince, at most, we’ll be going through all the elements of all the arrays and will remove/add one element in the heap in each step, the time complexity of the above algorithm will be O(N\\logM)* where ‘N’ is the total number of elements in all the ‘M’ input arrays. Space complexityThe space complexity will be O(M) because, at any time, our min-heap will be store one number from all the ‘M’ input arrays. Problem Challenge 1Similar | Top Interview 150 | 373. Find K Pairs with Smallest Sums Design Gurus Educative.io K Pairs with Largest Sums (Hard)Given two sorted arrays in descending order, find ‘K’ pairs with the largest sum where each pair consists of numbers from both the arrays. Example 1: 123Input: L1=[9, 8, 2], L2=[6, 3, 1], K=3Output: [9, 3], [9, 6], [8, 6] Explanation: These 3 pairs have the largest sum. No other pair has a sum larger than any of these. Example 2: 12Input: L1=[5, 2, 1], L2=[2, -1], K=3Output: [5, 2], [5, -1], [2, 2] Constraints: 1 &lt;= nums1.length, nums2.length &lt;= 10^5 -10^9 &lt;= nums1[i], nums2[i] &lt;= 10^9 nums1 and nums2 both are sorted in non-decreasing order. 1 &lt;= k &lt;= 10^4 k &lt;= nums1.length * nums2.length SolutionThis problem follows the K-way merge pattern and we can follow a similar approach as discussed in Merge K Sorted Lists. We can go through all the numbers of the two input arrays to create pairs and initially insert them all in the heap until we have ‘K’ pairs in Min Heap. After that, if a pair is bigger than the top (smallest) pair in the heap, we can remove the smallest pair and insert this pair in the heap. We can optimize our algorithms in two ways: Instead of iterating over all the numbers of both arrays, we can iterate only the first ‘K’ numbers from both arrays. Since the arrays are sorted in descending order, the pairs with the maximum sum will be constituted by the first ‘K’ numbers from both the arrays. As soon as we encounter a pair with a sum that is smaller than the smallest (top) element of the heap, we don’t need to process the next elements of the array. Since the arrays are sorted in descending order, we won’t be able to find a pair with a higher sum moving forward. CodeHere is what our algorithm will look like: 1234567891011121314151617181920212223242526272829303132333435from heapq import *class Solution: def findKLargestPairs(self, nums1, nums2, k): minHeap = [] for i in range(0, min(k, len(nums1))): for j in range(min(k, len(nums2))): if len(minHeap) &lt; k: heappush(minHeap, (nums1[i] + nums2[j], i, j)) else: # if the sum of the two numbers from the two arrays is smaller than the # smallest(top) element of the heap, we can &#x27;break&#x27; here. Since the arrays are # sorted in the descending order, we&#x27;ll not be able to find a pair with a higher # sum moving forward if nums1[i] + nums2[j] &lt; minHeap[0][0]: break else: # we&#x27;ve a pair with a larger sum, remove top and insert this pair in heap heappop(minHeap) heappush(minHeap, (nums1[i] + nums2[j], i, j)) result = [] for (num, i, j) in minHeap: result.append([nums1[i], nums2[j]]) return resultdef main(): sol = Solution() print(&quot;Pairs with largest sum are: &quot; + str(sol.findKLargestPairs([9, 8, 2], [6, 3, 1], 3)))main() Time ComplexitySince, at most, we’ll be going through all the elements of both arrays and we will add/remove one element in the heap in each step, the time complexity of the above algorithm will be O(NMlogK) where ‘N’ and ‘M’ are the total number of elements in both arrays, respectively. If we assume that both arrays have at least ‘K’ elements then the time complexity can be simplified to O(K^2logK), because we are not iterating more than ‘K’ elements in both arrays. Space ComplexityThe space complexity will be O(K) because, at any time, our Min Heap will be storing ‘K’ largest pairs.","categories":[{"name":"Grokking Interview Pattern","slug":"Grokking-Interview-Pattern","permalink":"https://hasuer.github.io/categories/Grokking-Interview-Pattern/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hasuer.github.io/tags/Interview/"}]},{"title":"18. Pattern Top 'K' Elements","slug":"18. Pattern Top 'K' Elements","date":"2024-05-18T08:53:51.000Z","updated":"2024-05-28T03:29:44.825Z","comments":true,"path":"18-pattern-top-k-elements/index.html","link":"","permalink":"https://hasuer.github.io/18-pattern-top-k-elements/index.html","excerpt":"","text":"IntroductionAny problem that asks us to find the top/smallest/frequent ‘K’ elements among a given set falls under this pattern. The best data structure that comes to mind to keep track of ‘K’ elements is Heap). This pattern will make use of the Heap to solve multiple problems dealing with ‘K’ elements at a time from a set of given elements. Let’s jump onto our first problem to develop an understanding of this pattern. 123456做这种pattern的题目有三种方式# 1. 先全部塞进去，最后在弹出指定数量作为答案，这样可以保证相同的排序条件，先进去的被取出来# 2. 先塞进去指定数量，然后每满足条件就替换，如果排序条件已经存在（带比较的数的条件和heap[0]的条件一样），那就不会替换，这样# 也可以保证答案中会优先包含先进去的数# 3. 每塞进去一个就判断是不是已经超过了指定长度，如果超过了就弹出一个，这样就会导致相同的排序条件，会优先保留后进来的，这是我们不想要的。# 所以这道题选择第一种和第二种是合理的 Top ‘K’ Numbers (easy)Design Gurus Educative.io Problem StatementGiven an unsorted array of numbers, find the ‘K’ largest numbers in it. Note: For a detailed discussion about different approaches to solve this problem, take a look at Kth Smallest Number(这是Miscellaneous类别的） Example 1: 12Input: [3, 1, 5, 12, 2, 11], K = 3Output: [5, 12, 11] Example 2: 12Input: [5, 12, 11, -1, 12], K = 3Output: [12, 11, 12] Constraints: 1 &lt;= nums.length &lt;= 10^5 -10^5 &lt;= nums[i] &lt;= 10^5 k is in the range [1, the number of unique elements in the array]. It is guaranteed that the answer is unique. SolutionA brute force solution could be to sort the array and return the largest K numbers. The time complexity of such an algorithm will be O(N\\logN)* as we need to use a sorting algorithm like Timsort if we use Java’s Collection.sort(). Can we do better than that? The best data structure that comes to mind to keep track of top ‘K’ elements is Heap). Let’s see if we can use a heap to find a better algorithm. If we iterate through the array one element at a time and keep ‘K’ largest numbers in a heap such that each time we find a larger number than the smallest number in the heap, we do two things: Take out the smallest number from the heap, and Insert the larger number into the heap. This will ensure that we always have ‘K’ largest numbers in the heap. The most efficient way to repeatedly find the smallest number among a set of numbers will be to use a min-heap. As we know, we can find the smallest number in a min-heap in constant time O(1), since the smallest number is always at the root of the heap. Extracting the smallest number from a min-heap will take O(logN) (if the heap has ‘N’ elements) as the heap needs to readjust after the removal of an element. Let’s take Example-1 to go through each step of our algorithm: Given array: [3, 1, 5, 12, 2, 11], and K=3 First, let’s insert ‘K’ elements in the min-heap. After the insertion, the heap will have three numbers [3, 1, 5] with ‘1’ being the root as it is the smallest element. We’ll iterate through the remaining numbers and perform the above-mentioned two steps if we find a number larger than the root of the heap. The 4th number is ‘12’ which is larger than the root (which is ‘1’), so let’s take out ‘1’ and insert ‘12’. Now the heap will have [3, 5, 12] with ‘3’ being the root as it is the smallest element. The 5th number is ‘2’ which is not bigger than the root of the heap (‘3’), so we can skip this as we already have top three numbers in the heap. The last number is ‘11’ which is bigger than the root (which is ‘3’), so let’s take out ‘3’ and insert ‘11’. Finally, the heap has the largest three numbers: [5, 12, 11] As discussed above, it will take us O(logK) to extract the minimum number from the min-heap. So the overall time complexity of our algorithm will be O(K\\logK+(N-K)*logK)* since, first, we insert ‘K’ numbers in the heap and then iterate through the remaining numbers and at every step, in the worst case, we need to extract the minimum number and insert a new number in the heap. This algorithm is better than O(N\\logN)*. Here is the visual representation of our algorithm: 1234567891011121314151617181920212223242526272829303132from heapq import *class Solution: def findKLargestNumbers(self, nums, k): minHeap = [] # put first &#x27;K&#x27; numbers in the min heap for i in range(k): heappush(minHeap, nums[i]) # go through the remaining numbers of the array, if the number from the array is # bigger than the top(smallest) number of the min-heap, remove the top number from # heap and add the number from array for i in range(k, len(nums)): if nums[i] &gt; minHeap[0]: heappop(minHeap) heappush(minHeap, nums[i]) # the heap has the top &#x27;K&#x27; numbers return minHeapdef main(): sol = Solution() print(&quot;Here are the top K numbers: &quot; + str(sol.findKLargestNumbers([3, 1, 5, 12, 2, 11], 3))) print(&quot;Here are the top K numbers: &quot; + str(sol.findKLargestNumbers([5, 12, 11, -1, 12], 3)))main() Time complexityAs discussed above, the time complexity of this algorithm is O(KlogK+(N-K)logK), which is asymptotically equal to O(NlogK) Space complexityThe space complexity will be O(K) since we need to store the top ‘K’ numbers in the heap. Kth Smallest Number (easy)Top Interview 150 | 215. Kth Largest Element in an Array Design Gurus Educative.io Problem StatementGiven an unsorted array of numbers, find Kth smallest number in it. Please note that it is the Kth smallest number in the sorted order, not the Kth distinct element. Note: For a detailed discussion about different approaches to solve this problem, take a look at Kth Smallest Number. Example 1: 123Input: [1, 5, 12, 2, 11, 5], K = 3Output: 5Explanation: The 3rd smallest number is &#x27;5&#x27;, as the first two smaller numbers are [1, 2]. Example 2: 123Input: [1, 5, 12, 2, 11, 5], K = 4Output: 5Explanation: The 4th smallest number is &#x27;5&#x27;, as the first three small numbers are [1, 2, 5]. Example 3: 123Input: [5, 12, 11, -1, 12], K = 3Output: 11Explanation: The 3rd smallest number is &#x27;11&#x27;, as the first two small numbers are [5, -1]. Constraints: 1 &lt;= k &lt;= nums.length &lt;= 10^5 -10^4 &lt;= nums[i] &lt;= 10^4 SolutionThis problem follows the Top ‘K’ Numbers pattern but has two differences: Here we need to find the Kth smallest number, whereas in Top ‘K’ Numbers we were dealing with ‘K’ largest numbers. In this problem, we need to find only one number (Kth smallest) compared to finding all ‘K’ largest numbers. We can follow the same approach as discussed in the ‘Top K Elements’ problem. To handle the first difference mentioned above, we can use a max-heap instead of a min-heap. As we know, the root is the biggest element in the max heap. So, since we want to keep track of the ‘K’ smallest numbers, we can compare every number with the root while iterating through all numbers, and if it is smaller than the root, we’ll take the root out and insert the smaller number. CodeHere is what our algorithm will look like: 12345678910111213141516171819202122232425262728293031323334353637from heapq import *class Solution: def findKthSmallestNumber(self, nums, k): maxHeap = [] # put first k numbers in the max heap for i in range(k): heappush(maxHeap, -nums[i]) # go through the remaining numbers of the array, if the number from the array is # smaller than the top(biggest) number of the heap, remove the top number from heap # and add the number from array for i in range(k, len(nums)): if -nums[i] &gt; maxHeap[0]: heappop(maxHeap) heappush(maxHeap, -nums[i]) # the root of the heap has the Kth smallest number return -maxHeap[0]def main(): sol = Solution() print(&quot;Kth smallest number is: &quot; + str(sol.findKthSmallestNumber([1, 5, 12, 2, 11, 5], 3))) # since there are two 5s in the input array, our 3rd and 4th smallest numbers should # be a &#x27;5&#x27; print(&quot;Kth smallest number is: &quot; + str(sol.findKthSmallestNumber([1, 5, 12, 2, 11, 5], 4))) print(&quot;Kth smallest number is: &quot; + str(sol.findKthSmallestNumber([5, 12, 11, -1, 12], 3)))main() Time complexityThe time complexity of this algorithm is O(KlogK+(N-K)logK), which is asymptotically equal to O(N\\logK)* Space complexityThe space complexity will be O(K) because we need to store ‘K’ smallest numbers in the heap. An Alternate ApproachAlternatively, we can use a Min Heap to find the Kth smallest number. We can insert all the numbers in the min-heap and then extract the top ‘K’ numbers from the heap to find the Kth smallest number. Initializing the min-heap with all numbers will take O(N) and extracting ‘K’ numbers will take O(KlogN). Overall, the time complexity of this algorithm will be O(N+KlogN) and the space complexity will be O(N). ‘K’ Closest Points to the Origin (easy)973. K Closest Points to Origin Design Gurus Educative.io Problem StatementGiven an array of points in the a 2D plane, find ‘K’ closest points to the origin. Example 1: 12345Input: points = [[1,2],[1,3]], K = 1Output: [[1,2]]Explanation: The Euclidean distance between (1, 2) and the origin is sqrt(5).The Euclidean distance between (1, 3) and the origin is sqrt(10).Since sqrt(5) &lt; sqrt(10), therefore (1, 2) is closer to the origin. Example 2: 12Input: point = [[1, 3], [3, 4], [2, -1]], K = 2Output: [[1, 3], [2, -1]] Constraints: 1 &lt;= k &lt;= points.length &lt;= 10^4 -10^4 &lt;= xi, yi &lt;= 10^4 SolutionThe Euclidean distance of a point P(x,y) from the origin can be calculated through the following formula: \\sqrt{x^2 + y^2}√x2+y2 This problem follows the Top ‘K’ Numbers pattern. The only difference in this problem is that we need to find the closest point (to the origin) as compared to finding the largest numbers. Following a similar approach, we can use a Max Heap to find ‘K’ points closest to the origin. While iterating through all points, if a point (say ‘P’) is closer to the origin than the top point of the max-heap, we will remove that top point from the heap and add ‘P’ to always keep the closest points in the heap. CodeHere is what our algorithm will look like: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# 如果要构造kth closest的point,也是构造大顶堆，只不过返回的时候返回第一个就可以# 如果要构造kth farest的point, 就要构造小顶堆，返回的时候返回第一个就可以，越小的排在越前面，def __lt__(self, other)中就要改成return self.distance_from_origin() &lt; other.distance_from_origin()from heapq import *# class Point: # def __init__(self, x, y): # self.x = x # self.y = y # # Define a custom comparison method for max-heap. # def __lt__(self, other): # return self.distance_from_origin() &gt; other.distance_from_origin() # def distance_from_origin(self): # # Calculate the distance from the origin (squared for comparison). # return (self.x * self.x) + (self.y * self.y)class Solution: def findClosestPoints(self, points, k): maxHeap = [] # Initialize the max-heap with the first &#x27;k&#x27; points. for i in range(k): heappush(maxHeap, (-points[i].distance_from_origin(), points[i])) for i in range(k, len(points)): distance = points[i].distance_from_origin() # If the current point is closer to the origin than the farthest point in max-heap, replace it. if distance &lt; -maxHeap[0][0]: heappop(maxHeap) heappush(maxHeap, (-distance, points[i])) closestPoints = [] # Extract the closest points from the max-heap. while maxHeap: closestPoints.append(maxHeap[0][1]) heappop(maxHeap) return closestPoints @staticmethod def print_point(point): print(&quot;[&quot; + str(point.x) + &quot;, &quot; + str(point.y) + &quot;] &quot;, end=&#x27;&#x27;)def main(): sol = Solution() result = sol.findClosestPoints([Point(1, 3), Point(3, 4), Point(2, -1)], 2) print(&quot;Here are the k points closest to the origin: &quot;, end=&#x27;&#x27;) for point in result: Solution.print_point(point) # Call the static method correctlymain() # ==================================leetcode======================================class Solution(object): def distance_from_origin(self, point): return pow(point[0], 2) + pow(point[1], 2) def kClosest(self, points, k): &quot;&quot;&quot; :type points: List[List[int]] :type k: int :rtype: List[List[int]] &quot;&quot;&quot; max_heap = [] for i in range(k): heappush(max_heap, (-self.distance_from_origin(points[i]), points[i])) for i in range(k, len(points)): if self.distance_from_origin(points[i]) &lt; self.distance_from_origin(max_heap[0][1]): heappop(max_heap) heappush(max_heap, (-self.distance_from_origin(points[i]), points[i])) res =[] while max_heap: res.append(heappop(max_heap)[1]) return res Time complexityThe time complexity of this algorithm is (N\\logK)* as we iterating all points and pushing them into the heap. Space complexityThe space complexity will be O(K) because we need to store ‘K’ point in the heap. Connect Ropes (easy)Leetcode 1167 会员 Design Gurus Educative.io Problem StatementGiven ‘N’ ropes with different lengths, we need to connect these ropes into one big rope with minimum cost. The cost of connecting two ropes is equal to the sum of their lengths. Example 1: 123Input: [1, 3, 11, 5]Output: 33Explanation: First connect 1+3(=4), then 4+5(=9), and then 9+11(=20). So the total cost is 33 (4+9+20) Example 2: 123Input: [3, 4, 5, 6]Output: 36Explanation: First connect 3+4(=7), then 5+6(=11), 7+11(=18). Total cost is 36 (7+11+18) Example 3: 123Input: [1, 3, 11, 5, 2]Output: 42Explanation: First connect 1+2(=3), then 3+3(=6), 6+5(=11), 11+11(=22). Total cost is 42 (3+6+11+22) Constraints: 1 &lt;= ropLengths.length &lt;= 10^4 1 &lt;= ropLengths[i] &lt;= 10^4 SolutionIn this problem, following a greedy approach to connect the smallest ropes first will ensure the lowest cost. We can use a Min Heap to find the smallest ropes following a similar approach as discussed in Kth Smallest Number. Once we connect two ropes, we need to insert the resultant rope back in the Min Heap so that we can connect it with the remaining ropes. CodeHere is what our algorithm will look like: 1234567891011121314151617181920212223242526272829303132from heapq import *class Solution: def minimumCostToConnectRopes(self, ropeLengths): minHeap = [] # add all ropes to the min heap for i in ropeLengths: heappush(minHeap, i) # go through the values of the heap, in each step take top (lowest) rope lengths from # the min heap connect them and push the result back to the min heap. # keep doing this until the heap is left with only one rope result, temp = 0, 0 while len(minHeap) &gt; 1: temp = heappop(minHeap) + heappop(minHeap) result += temp heappush(minHeap, temp) return resultdef main(): sol = Solution() print(&quot;Minimum cost to connect ropes: &quot; + str(sol.minimumCostToConnectRopes([1, 3, 11, 5]))) print(&quot;Minimum cost to connect ropes: &quot; + str(sol.minimumCostToConnectRopes([3, 4, 5, 6]))) print(&quot;Minimum cost to connect ropes: &quot; + str(sol.minimumCostToConnectRopes([1, 3, 11, 5, 2])))main() Time complexityGiven ‘N’ ropes, we need O(N\\logN)* to insert all the ropes in the heap. In each step, while processing the heap, we take out two elements from the heap and insert one. This means we will have a total of ‘N’ steps, having a total time complexity of O(N\\logN)*. Space complexityThe space complexity will be O(N) because we need to store all the ropes in the heap. Top ‘K’ Frequent Numbers (medium)347. Top K Frequent Elements Design Gurus Educative.io Problem StatementGiven an unsorted array of numbers, find the top ‘K’ frequently occurring numbers in it. Example 1: 123Input: [1, 3, 5, 12, 11, 12, 11], K = 2Output: [12, 11]Explanation: Both &#x27;11&#x27; and &#x27;12&#x27; apeared twice. Example 2: 123Input: [5, 12, 11, 3, 11], K = 2Output: [11, 5] or [11, 12] or [11, 3]Explanation: Only &#x27;11&#x27; appeared twice, all other numbers appeared once. Constraints: 1 &lt;= nums.length &lt;= 10^5 -10^5 &lt;= nums[i] &lt;= 10^5 k is in the range [1, the number of unique elements in the array]. It is guaranteed that the answer is unique. SolutionThis problem follows Top ‘K’ Numbers. The only difference is that in this problem, we need to find the most frequently occurring number compared to finding the largest numbers. We can follow the same approach as discussed in the Top K Elements problem. However, in this problem, we first need to know the frequency of each number, for which we can use a HashMap. Once we have the frequency map, we can use a Min Heap to find the ‘K’ most frequently occurring number. In the Min Heap, instead of comparing numbers we will compare their frequencies in order to get frequently occurring numbers CodeHere is what our algorithm will look like: 12345678910111213141516171819202122232425262728293031323334353637383940414243from heapq import *class Solution: def findTopKFrequentNumbers(self, nums, k): # find the frequency of each number numFrequencyMap = &#123;&#125; for num in nums: numFrequencyMap[num] = numFrequencyMap.get(num, 0) + 1 minHeap = [] # 2024.4.12 note: 建议使用方法1：先全部塞进去在去除前面的n-k个，理由见“&#x27;K&#x27; Closest Numbers”这道题，因为要是像这样写，答案就会不唯一，不过这道题的 # example中允许有不唯一的时候输出其中任何一个就可以，所以问题不大 # go through all numbers of the numFrequencyMap and push them in the minHeap, which # will have top k frequent numbers. If the heap size is more than k, we remove the # smallest(top) number for num, frequency in numFrequencyMap.items(): heappush(minHeap, (frequency, num)) # 2024.4.11 note:可以使用方法2：像之前一样，先push k 个，然后新的比heap[0]大的话，就替换heap[0]，但是在这个例子就比较麻烦 if len(minHeap) &gt; k: heappop(minHeap) # create a list of top k numbers topNumbers = [] while minHeap: topNumbers.append(heappop(minHeap)[1]) return topNumbersdef main(): sol = Solution() print(&quot;Here are the K frequent numbers: &quot; + str(sol.findTopKFrequentNumbers([1, 3, 5, 12, 11, 12, 11], 2))) print(&quot;Here are the K frequent numbers: &quot; + str(sol.findTopKFrequentNumbers([5, 12, 11, 3, 11], 2)))main() Time complexityThe time complexity of the above algorithm is O(N+N\\logK)*. Space complexityThe space complexity will be O(N). Even though we are storing only ‘K’ numbers in the heap. For the frequency map, however, we need to store all the ‘N’ numbers. Frequency Sort (medium)451. Sort Characters By Frequency Design Gurus Educative.io Problem StatementGiven a string, sort it based on the decreasing frequency of its characters. Example 1: 123Input: &quot;Programming&quot;Output: &quot;rrggmmPiano&quot;Explanation: &#x27;r&#x27;, &#x27;g&#x27;, and &#x27;m&#x27; appeared twice, so they need to appear before any other character. Example 2: 123Input: &quot;abcbab&quot;Output: &quot;bbbaac&quot;Explanation: &#x27;b&#x27; appeared three times, &#x27;a&#x27; appeared twice, and &#x27;c&#x27; appeared only once. Constraints: 1 &lt;= str.length &lt;= 5 * 10^5 str consists of uppercase and lowercase English letters and digits. SolutionThis problem follows the Top ‘K’ Elements pattern, and shares similarities with Top ‘K’ Frequent Numbers. We can follow the same approach as discussed in the Top ‘K’ Frequent Numbers problem. First, we will find the frequencies of all characters, then use a max-heap to find the most occurring characters. CodeHere is what our algorithm will look like: 12345678910111213141516171819202122232425262728293031323334353637from heapq import *class Solution: def sortCharacterByFrequency(self, str): # find the frequency of each character charFrequencyMap = &#123;&#125; for char in str: charFrequencyMap[char] = charFrequencyMap.get(char, 0) + 1 maxHeap = [] # 这个就是方法1， 先全部塞进去，这样就可以保证，相同的排序条件（这题中是频数），先出现的字母会依旧在前面 # add all characters to the max heap for char, frequency in charFrequencyMap.items(): heappush(maxHeap, (-frequency, char)) # build a string, appending the most occurring characters first sortedString = [] while maxHeap: frequency, char = heappop(maxHeap) for _ in range(-frequency): sortedString.append(char) return &#x27;&#x27;.join(sortedString)def main(): sol = Solution() print(&quot;String after sorting characters by frequency: &quot; + sol.sortCharacterByFrequency(&quot;Programming&quot;)) print(&quot;String after sorting characters by frequency: &quot; + sol.sortCharacterByFrequency(&quot;abcbab&quot;))main() Time complexityThe time complexity of the above algorithm is O(D\\logD)* where ‘D’ is the number of distinct characters in the input string. This means, in the worst case, when all characters are unique the time complexity of the algorithm will be O(N\\logN)* where ‘N’ is the total number of characters in the string. Space complexityThe space complexity will be O(N), as in the worst case, we need to store all the ‘N’ characters in the HashMap. Kth Largest Number in a Stream (medium)leetcode 703 一样的代码，leetcode报错，感觉是leetcode内部问题 703. Kth Largest Element in a Stream Design Gurus Educative.io Problem StatementDesign a class to efficiently find the Kth largest element in a stream of numbers. The class should have the following two things: The constructor of the class should accept an integer array containing initial numbers from the stream and an integer ‘K’. The class should expose a function add(int num) which will store the given number and return the Kth largest number. Example 1: 12345Input: [3, 1, 5, 12, 2, 11], K = 41. Calling add(6) should return &#x27;5&#x27;.2. Calling add(13) should return &#x27;6&#x27;.2. Calling add(4) should still return &#x27;6&#x27;. Constraints: 1 &lt;= k &lt;= 10^4 0 &lt;= nums.length &lt;= 10^4 -10^4 &lt;= nums[i] &lt;= 10^4 -10^4 &lt;= val &lt;= 10^4 At most 10^4 calls will be made to add. It is guaranteed that there will be at least k elements in the array when you search for the kth element. SolutionThis problem follows the Top ‘K’ Elements pattern and shares similarities with Kth Smallest number. We can follow the same approach as discussed in the ‘Kth Smallest number’ problem. However, we will use a Min Heap (instead of a Max Heap) as we need to find the Kth largest number. CodeHere is what our algorithm will look like: 1234567891011121314151617181920212223242526272829303132333435from heapq import *class Solution: def __init__(self, nums, k): self.minHeap = [] self.k = k # add the numbers in the min heap for num in nums: self.add(num) def add(self, num): # add the new number in the min heap heappush(self.minHeap, num) # if heap has more than &#x27;k&#x27; numbers, remove one number if len(self.minHeap) &gt; self.k: heappop(self.minHeap) # return the &#x27;Kth largest number return self.minHeap[0]def main(): sol = Solution([3, 1, 5, 12, 2, 11], 4) print(&quot;4th largest number is: &quot; + str(sol.add(6))) print(&quot;4th largest number is: &quot; + str(sol.add(13))) print(&quot;4th largest number is: &quot; + str(sol.add(4)))main() Time complexityThe time complexity of the add() function will be O(logK) since we are inserting the new number in the heap. Space complexityThe space complexity will be O(K) for storing numbers in the heap. ‘K’ Closest Numbers (medium)658. Find K Closest Elements Design Gurus Educative.io Problem StatementGiven a sorted number array and two integers ‘K’ and ‘X’, find ‘K’ closest numbers to ‘X’ in the array. Return the numbers in the sorted order. ‘X’ is not necessarily present in the array. Example 1: 12Input: [5, 6, 7, 8, 9], K = 3, X = 7Output: [6, 7, 8] Example 2: 12Input: [2, 4, 5, 6, 9], K = 3, X = 6Output: [4, 5, 6] Example 3: 12Input: [2, 4, 5, 6, 9], K = 3, X = 10Output: [5, 6, 9] SolutionThis problem follows the Top ‘K’ Numbers pattern. The biggest difference in this problem is that we need to find the closest (to ‘X’) numbers compared to finding the overall largest numbers. Another difference is that the given array is sorted. Utilizing a similar approach, we can find the numbers closest to ‘X’ through the following algorithm: Since the array is sorted, we can first find the number closest to ‘X’ through Binary Search. Let’s say that number is ‘Y’（Y不需要一定是最接近的，如果arr中不存在x,那么只要是x的左右邻居就可以）. The ‘K’ closest numbers to ‘Y’ will be adjacent to ‘Y’ in the array. We can search in both directions of ‘Y’ to find the closest numbers. We can use a heap to efficiently search for the closest numbers. We will take ‘K’ numbers in both directions of ‘Y’ and push them in a Min Heap sorted by their absolute difference from ‘X’. This will ensure that the numbers with the smallest difference from ‘X’ (i.e., closest to ‘X’) can be extracted easily from the Min Heap. Finally, we will extract the top ‘K’ numbers from the Min Heap to find the required numbers. CodeHere is what our algorithm will look like: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from heapq import *class Solution: def findClosestElements(self, arr, K, X): index = self.binary_search(arr, X) low, high = index - K, index + K low = max(low, 0) # &#x27;low&#x27; should not be less than zero # &#x27;high&#x27; should not be greater the size of the array high = min(high, len(arr) - 1) minHeap = [] # add all candidate elements to the min heap, sorted by their absolute difference # from &#x27;X&#x27; for i in range(low, high + 1): heappush(minHeap, (abs(arr[i] - X), arr[i])) # we need the top &#x27;K&#x27; elements having smallest difference from &#x27;X&#x27; result = [] for _ in range(K): result.append(heappop(minHeap)[1]) result.sort() return result def binary_search(self, arr, target): low, high = 0, len(arr) - 1 while low &lt;= high: mid = int(low + (high - low) / 2) if arr[mid] == target: return mid if arr[mid] &lt; target: low = mid + 1 else: high = mid - 1 # 如果不存在这个的话，如果end != -1 and low != len(arr), 那么arr[high] &lt; target &lt; arr[low] if high &lt; 0: return low else: return highdef main(): sol = Solution() print(&quot;&#x27;K&#x27; closest numbers to &#x27;X&#x27; are: &quot; + str(sol.findClosestElements([5, 6, 7, 8, 9], 3, 7))) print(&quot;&#x27;K&#x27; closest numbers to &#x27;X&#x27; are: &quot; + str(sol.findClosestElements([2, 4, 5, 6, 9], 3, 6))) print(&quot;&#x27;K&#x27; closest numbers to &#x27;X&#x27; are: &quot; + str(sol.findClosestElements([2, 4, 5, 6, 9], 3, 10)))main() Time complexityThe time complexity of the above algorithm is O(logN + K\\logK)*. We need O(logN) for Binary Search and O(K\\logK)* to insert the numbers in the Min Heap, as well as to sort the output array. Space complexityThe space complexity will be O(K), as we need to put a maximum of 2K numbers in the heap. Alternate Solution using Two PointersAfter finding the number closest to ‘X’ through Binary Search, we can use the Two Pointers approach to find the ‘K’ closest numbers. Let’s say the closest number is ‘Y’. We can have a left pointer to move back from ‘Y’ and a right pointer to move forward from ‘Y’. At any stage, whichever number pointed out by the left or the right pointer gives the smaller difference from ‘X’ will be added to our result list. To keep the resultant list sorted we can use a Queue. So whenever we take the number pointed out by the left pointer, we will append it at the beginning of the list and whenever we take the number pointed out by the right pointer we will append it at the end of the list. Here is what our algorithm will look like: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667from collections import dequeclass Solution: def findClosestElements(self, arr, K, X): result = deque() # Binary search to find the index of the element closest to X index = self.binary_search(arr, X) # 如果不存在x,返回的index是x左边的那个数的index(index &gt;=0的时候) # 不然就是end，e.g. arr = [2,4,5,7], x = 1 leftPointer, rightPointer = index, index + 1 n = len(arr) for i in range(K): # Check if there are elements on both sides of the chosen element if leftPointer &gt;= 0 and rightPointer &lt; n: diff1 = abs(X - arr[leftPointer]) diff2 = abs(X - arr[rightPointer]) # Choose the element with the smaller absolute difference if diff1 &lt;= diff2: # 这里的等于很重要，因为如果排序条件一样，优先返回左边的 result.appendleft(arr[leftPointer]) # Add the left element to the result leftPointer -= 1 else: result.append(arr[rightPointer]) # Add the right element to the result rightPointer += 1 # If there are no elements on one side, add elements from the other side elif leftPointer &gt;= 0: # 优先left result.appendleft(arr[leftPointer]) leftPointer -= 1 elif rightPointer &lt; n: result.append(arr[rightPointer]) rightPointer += 1 return result # Binary search method to find the index of the closest element to the target def binary_search(self, arr, target): low, high = 0, len(arr) - 1 while low &lt;= high: mid = int(low + (high - low) / 2) if arr[mid] == target: return mid if arr[mid] &lt; target: low = mid + 1 else: high = mid - 1 # 如果不存在这个的话，如果end != -1 and low != len(arr), 那么arr[high] &lt; target &lt; arr[low] if high &lt; 0: return low else: return highdef main(): sol = Solution() print(&quot;&#x27;K&#x27; closest numbers to &#x27;X&#x27; are: &quot; + str(sol.findClosestElements([5, 6, 7, 8, 9], 3, 7))) print(&quot;&#x27;K&#x27; closest numbers to &#x27;X&#x27; are: &quot; + str(sol.findClosestElements([2, 4, 5, 6, 9], 3, 6))) print(&quot;&#x27;K&#x27; closest numbers to &#x27;X&#x27; are: &quot; + str(sol.findClosestElements([2, 4, 5, 6, 9], 3, 10)))main() Time complexityThe time complexity of the above algorithm is O(logN + K). We need O(logN) for Binary Search and O(K) for finding the ‘K’ closest numbers using the two pointers. Space complexityIf we ignoring the space required for the output list, the algorithm runs in constant space O(1). Maximum Distinct Elements (medium)Similar | 题目意思怪怪的，看例子也不是标题中的unique | 1481. Least Number of Unique Integers after K Removals Design Gurus Educative.io Problem StatementGiven an array of numbers and a number ‘K’, we need to remove ‘K’ numbers from the array such that we are left with maximum distinct numbers. Example 1: 123456Input: [7, 3, 5, 8, 5, 3, 3], and K=2Output: 3Explanation: We can remove two occurrences of 3 to be left with 3 distinct numbers [7, 3, 8], we have to skip 5 because it is not distinct and occurred twice. Another solution could be to remove one instance of &#x27;5&#x27; and &#x27;3&#x27; each to be left with three distinct numbers [7, 5, 8], in this case, we have to skip 3 because it occurred twice. Example 2: 1234Input: [3, 5, 12, 11, 12], and K=3Output: 2Explanation: We can remove one occurrence of 12, after which all numbers will become distinct. Then we can delete any two numbers which will leave us 2 distinct numbers in the result. Example 3: 123Input: [1, 2, 3, 3, 3, 3, 4, 4, 5, 5, 5], and K=2Output: 3Explanation: We can remove one occurrence of &#x27;4&#x27; to get three distinct numbers. Constraints: 1 &lt;= arr.length &lt;= 10^5 1 &lt;= arr[i] &lt;= 10^9 0 &lt;= k &lt;= arr.length SolutionThis problem follows the Top ‘K’ Numbers pattern, and shares similarities with Top ‘K’ Frequent Numbers. We can following a similar approach as discussed in Top ‘K’ Frequent Numbers problem: First, we will find the frequencies of all the numbers. Then, push all numbers that are not distinct (i.e., have a frequency higher than one) in a Min Heap based on their frequencies. At the same time, we will keep a running count of all the distinct numbers. Following a greedy approach, in a stepwise fashion, we will remove the least frequent number from the heap (i.e., the top element of the min-heap), and try to make it distinct. We will see if we can remove all occurrences of a number except one. If we can, we will increment our running count of distinct numbers. We have to also keep a count of how many removals we have done. If after removing elements from the heap, we are still left with some deletions, we have to remove some distinct elements. CodeHere is what our algorithm will look like: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from heapq import *class Solution: def findMaximumDistinctElements(self, nums, k): distinctElementsCount = 0 if len(nums) &lt;= k: return distinctElementsCount # find the frequency of each number numFrequencyMap = &#123;&#125; for i in nums: numFrequencyMap[i] = numFrequencyMap.get(i, 0) + 1 minHeap = [] # insert all numbers with frequency greater than &#x27;1&#x27; into the min-heap for num, frequency in numFrequencyMap.items(): if frequency == 1: distinctElementsCount += 1 else: heappush(minHeap, (frequency, num)) # following a greedy approach, try removing the least frequent numbers first from # the min-heap while k &gt; 0 and minHeap: frequency, num = heappop(minHeap) # to make an element distinct, we need to remove all of its occurrences except one k -= frequency - 1 if k &gt;= 0: distinctElementsCount += 1 # if k &gt; 0, this means we have to remove some distinct numbers if k &gt; 0: distinctElementsCount -= k return distinctElementsCountdef main(): sol = Solution() print(&quot;Maximum distinct numbers after removing K numbers: &quot; + str(sol.findMaximumDistinctElements([7, 3, 5, 8, 5, 3, 3], 2))) print(&quot;Maximum distinct numbers after removing K numbers: &quot; + str(sol.findMaximumDistinctElements([3, 5, 12, 11, 12], 3))) print(&quot;Maximum distinct numbers after removing K numbers: &quot; + str(sol.findMaximumDistinctElements([1, 2, 3, 3, 3, 3, 4, 4, 5, 5, 5], 2)))main() Time complexitySince we will insert all numbers in a HashMap and a Min Heap, this will take O(N\\logN)* where ‘N’ is the total input numbers. While extracting numbers from the heap, in the worst case, we will need to take out ‘K’ numbers. This will happen when we have at least ‘K’ numbers with a frequency of two. Since the heap can have a maximum of ‘N/2’ numbers, therefore, extracting an element from the heap will take O(logN) and extracting ‘K’ numbers will take O(KlogN). So overall, the time complexity of our algorithm will be O(N\\logN + KlogN)*. We can optimize the above algorithm and only push ‘K’ elements in the heap, as in the worst case we will be extracting ‘K’ elements from the heap. This optimization will reduce the overall time complexity to O(N\\logK + KlogK)*. Space complexityThe space complexity will be O(N) as, in the worst case, we need to store all the ‘N’ characters in the HashMap. Sum of Elements (medium)Design Gurus Educative.io Problem StatementGiven an array, find the sum of all numbers between the K1’th and K2’th smallest elements of that array. Example 1: 1234Input: [1, 3, 12, 5, 15, 11], and K1=3, K2=6Output: 23Explanation: The 3rd smallest number is 5 and 6th smallest number 15. The sum of numbers comingbetween 5 and 15 is 23 (11+12). Example 2: 1234Input: [3, 5, 8, 7], and K1=1, K2=4Output: 12Explanation: The sum of the numbers between the 1st smallest number (3) and the 4th smallest number (8) is 12 (5+7). SolutionThis problem follows the Top ‘K’ Numbers pattern, and shares similarities with Kth Smallest Number. We can find the sum of all numbers coming between the K1’th and K2’th smallest numbers in the following steps: First, insert all numbers in a min-heap. Remove the first K1 smallest numbers from the min-heap. Now take the next K2-K1-1 numbers out of the heap and add them. This sum will be our required output. CodeHere is what our algorithm will look like: 1234567891011121314151617181920212223242526272829303132# 直观想到的就是直接sort排序，时间复杂度也是nlognfrom heapq import *class Solution: def findSumOfElements(self, nums, k1, k2): minHeap = [] # insert all numbers to the min heap for num in nums: heappush(minHeap, num) # remove k1 small numbers from the min heap for _ in range(k1): heappop(minHeap) elementSum = 0 # sum next k2-k1-1 numbers for _ in range(k2 - k1 - 1): elementSum += heappop(minHeap) return elementSumdef main(): sol = Solution() print(&quot;Sum of all numbers between k1 and k2 smallest numbers: &quot; + str(sol.findSumOfElements([1, 3, 12, 5, 15, 11], 3, 6))) print(&quot;Sum of all numbers between k1 and k2 smallest numbers: &quot; + str(sol.findSumOfElements([3, 5, 8, 7], 1, 4)))main() Time complexitySince we need to put all the numbers in a min-heap, the time complexity of the above algorithm will be O(N\\logN)* where ‘N’ is the total input numbers. Space complexityThe space complexity will be O(N), as we need to store all the ‘N’ numbers in the heap. Alternate SolutionWe can iterate the array and use a max-heap to keep track of the top K2 numbers. We can, then, add the top K2-K1-1 numbers in the max-heap to find the sum of all numbers coming between the K1’th and K2’th smallest numbers. Here is what the algorithm will look like: 1234567891011121314151617181920212223242526272829303132from heapq import *class Solution: def findSumOfElements(self, nums, k1, k2): maxHeap = [] # keep smallest k2 numbers in the max heap for i in range(len(nums)): if i &lt; k2 - 1: heappush(maxHeap, -nums[i]) elif nums[i] &lt; -maxHeap[0]: heappop(maxHeap) # as we are interested only in the smallest k2 numbers heappush(maxHeap, -nums[i]) # get the sum of numbers between k1 and k2 indices # these numbers will be at the top of the max heap elementSum = 0 for _ in range(k2 - k1 - 1): elementSum += -heappop(maxHeap) return elementSumdef main(): sol = Solution() print(&quot;Sum of all numbers between k1 and k2 smallest numbers: &quot; + str(sol.findSumOfElements([1, 3, 12, 5, 15, 11], 3, 6))) print(&quot;Sum of all numbers between k1 and k2 smallest numbers: &quot; + str(sol.findSumOfElements([3, 5, 8, 7], 1, 4)))main() Time complexitySince we need to put only the top K2 numbers in the max-heap at any time, the time complexity of the above algorithm will be O(N\\logK2)*. Space complexityThe space complexity will be O(K2), as we need to store the smallest ‘K2’ numbers in the heap. *Rearrange String (hard)767. Reorganize String Design Gurus Educative.io Problem StatementGiven a string, find if its letters can be rearranged in such a way that no two same characters come next to each other. Example 1: 123Input: &quot;aappp&quot;Output: &quot;papap&quot;Explanation: In &quot;papap&quot;, none of the repeating characters come next to each other. Example 2: 123Input: &quot;Programming&quot;Output: &quot;rgmrgmPiano&quot; or &quot;gmringmrPoa&quot; or &quot;gmrPagimnor&quot;, etc.Explanation: None of the repeating characters come next to each other. Example 3: 123Input: &quot;aapa&quot;Output: &quot;&quot;Explanation: In all arrangements of &quot;aapa&quot;, atleast two &#x27;a&#x27; will come together e.g., &quot;apaa&quot;, &quot;paaa&quot;. Constraints: 1 &lt;= s.length &lt;= 500 s consists of lowercase English letters. SolutionThis problem follows the Top ‘K’ Numbers pattern. We can follow a greedy approach to find an arrangement of the given string where no two same characters come next to each other. We can work in a stepwise fashion to create a string with all characters from the input string. Following a greedy approach, we should first append the most frequent characters to the output strings, for which we can use a Max Heap. By appending the most frequent character first, we have the best chance to find a string where no two same characters come next to each other. So in each step, we should append one occurrence of the highest frequency character to the output string. We will not put this character back in the heap to ensure that no two same characters are adjacent to each other. In the next step, we should process the next most frequent character from the heap in the same way and then, at the end of this step, insert the character from the previous step back to the heap after decrementing its frequency. Following this algorithm, if we can append all the characters from the input string to the output string, we would have successfully found an arrangement of the given string where no two same characters appeared adjacent to each other. CodeHere is what our algorithm will look like: 1234567891011121314151617181920212223242526272829303132333435363738from heapq import *class Solution: def rearrangeString(self, str1): charFrequencyMap = &#123;&#125; for char in str1: charFrequencyMap[char] = charFrequencyMap.get(char, 0) + 1 maxHeap = [] # add all characters to the max heap for char, frequency in charFrequencyMap.items(): heappush(maxHeap, (-frequency, char)) previousChar, previousFrequency = None, 0 resultString = [] while maxHeap: frequency, char = heappop(maxHeap) # add the previous entry back in the heap if its frequency is greater than zero if previousChar and -previousFrequency &gt; 0: heappush(maxHeap, (previousFrequency, previousChar)) # append the current character to the result string and decrement its count resultString.append(char) previousChar = char previousFrequency = frequency+1 # decrement the frequency # if we were successful in appending all the characters to the result string, return it return &#x27;&#x27;.join(resultString) if len(resultString) == len(str1) else &quot;&quot;def main(): sol = Solution() print(&quot;Rearranged string: &quot; + sol.rearrangeString(&quot;aappp&quot;)) print(&quot;Rearranged string: &quot; + sol.rearrangeString(&quot;Programming&quot;)) print(&quot;Rearranged string: &quot; + sol.rearrangeString(&quot;aapa&quot;))main() Time complexityThe time complexity of the above algorithm is O(N\\logN)* where ‘N’ is the number of characters in the input string. Space complexityThe space complexity will be O(N), as in the worst case, we need to store all the ‘N’ characters in the HashMap. Problem Challenge 1Leetcode 358 会员 Design Gurus Educative.io Rearrange String K Distance Apart (hard)Given a string and a number ‘K’, find if the string can be rearranged such that the same characters are at least ‘K’ distance apart from each other. Example 1: 123Input: &quot;mmpp&quot;, K=2Output: &quot;mpmp&quot; or &quot;pmpm&quot;Explanation: All same characters are 2 distance apart. Example 2: 123Input: &quot;Programming&quot;, K=3Output: &quot;rgmPrgmiano&quot; or &quot;gmringmrPoa&quot; or &quot;gmrPagimnor&quot; and a few moreExplanation: All same characters are 3 distance apart. Example 3: 123Input: &quot;aab&quot;, K=2Output: &quot;aba&quot;Explanation: All same characters are 2 distance apart. Example 4: 123Input: &quot;aappa&quot;, K=3Output: &quot;&quot;Explanation: We cannot find an arrangement of the string where any two &#x27;a&#x27; are 3 distance apart. Constraints: 1 &lt;= str.length &lt;= 3 * 10^5 str consists of only lowercase English letters. 0 &lt;= k &lt;= str.length SolutionThis problem follows the Top ‘K’ Numbers pattern and is quite similar to Rearrange String. The only difference is that in the ‘Rearrange String’ the same characters need not be adjacent i.e., they should be at least ‘2’ distance apart (in other words, there should be at least one character between two same characters), while in the current problem, the same characters should be ‘K’ distance apart. Following a similar approach, since we were inserting a character back in the heap in the next iteration, in this problem, we will re-insert the character after ‘K’ iterations. We can keep track of previous characters in a queue to insert them back in the heap after ‘K’ iterations. CodeHere is what our algorithm will look like: 1234567891011121314151617181920212223242526272829303132333435363738394041424344from heapq import *from collections import dequeclass Solution: def reorganizeString(self, str, k): if k &lt;= 1: return str charFrequencyMap = &#123;&#125; for char in str: charFrequencyMap[char] = charFrequencyMap.get(char, 0) + 1 maxHeap = [] # add all characters to the max heap for char, frequency in charFrequencyMap.items(): heappush(maxHeap, (-frequency, char)) queue = deque() resultString = [] while maxHeap: frequency, char = heappop(maxHeap) # append the current character to the result string and decrement its count resultString.append(char) # decrement the frequency and append to the queue queue.append((char, frequency+1)) if len(queue) == k: char, frequency = queue.popleft() if -frequency &gt; 0: heappush(maxHeap, (frequency, char)) # if we were successful in appending all the characters to the result string, return it return &#x27;&#x27;.join(resultString) if len(resultString) == len(str) else &quot;&quot;def main(): sol = Solution() print(&quot;Reorganized string: &quot; + sol.reorganizeString(&quot;Programming&quot;, 3)) print(&quot;Reorganized string: &quot; + sol.reorganizeString(&quot;mmpp&quot;, 2)) print(&quot;Reorganized string: &quot; + sol.reorganizeString(&quot;aab&quot;, 2)) print(&quot;Reorganized string: &quot; + sol.reorganizeString(&quot;aapa&quot;, 3))main() Time complexityThe time complexity of the above algorithm is O(N\\logN)* where ‘N’ is the number of characters in the input string. Space complexityThe space complexity will be O(N), as in the worst case, we need to store all the ‘N’ characters in the HashMap. #Problem Challenge 2621. Task Scheduler Design Gurus Educative.io Scheduling Tasks (hard)You are given a list of tasks that need to be run, in any order, on a server. Each task will take one CPU interval to execute but once a task has finished, it has a cooling period during which it can’t be run again. If the cooling period for all tasks is ‘K’ intervals, find the minimum number of CPU intervals that the server needs to finish all tasks. If at any time the server can’t execute any task then it must stay idle. Example 1: 123Input: [a, a, a, b, c, c], K=2Output: 7Explanation: a -&gt; c -&gt; b -&gt; a -&gt; c -&gt; idle -&gt; a Example 2: 123Input: [a, b, a], K=3Output: 5Explanation: a -&gt; b -&gt; idle -&gt; idle -&gt; a Constraints: 1 &lt;= tasks.length &lt;= 10^4 tasks[i] is an uppercase English letter. 0 &lt;= k &lt;= 100 SolutionThis problem follows the Top &#39;K&#39; Numbers pattern and is quite similar to Rearrange String K Distance Apart. We need to rearrange tasks such that same tasks are ‘K’ distance apart. Following a similar approach, we will use a Max Heap to execute the highest frequency task first. After executing a task we decrease its frequency and put it in a waiting list. In each iteration, we will try to execute as many as k+1 tasks. For the next iteration, we will put all the waiting tasks back in the Max Heap. If, for any iteration, we are not able to execute k+1 tasks, the CPU has to remain idle for the remaining time in the next iteration. CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233343536373839404142434445from heapq import *class Solution: def scheduleTasks(self, tasks, k): intervalCount = 0 taskFrequencyMap = &#123;&#125; for char in tasks: taskFrequencyMap[char] = taskFrequencyMap.get(char, 0) + 1 maxHeap = [] # add all tasks to the max heap for char, frequency in taskFrequencyMap.items(): heappush(maxHeap, (-frequency, char)) while maxHeap: waitList = [] n = k + 1 # try to execute as many as &#x27;k+1&#x27; tasks from the max-heap while n &gt; 0 and maxHeap: intervalCount += 1 frequency, char = heappop(maxHeap) if -frequency &gt; 1: # decrement the frequency and add to the waitList waitList.append((frequency+1, char)) n -= 1 # put all the waiting list back on the heap for frequency, char in waitList: heappush(maxHeap, (frequency, char)) if maxHeap: intervalCount += n # we&#x27;ll be having &#x27;n&#x27; idle intervals for the next iteration return intervalCountdef main(): sol = Solution() print(&quot;Minimum intervals needed to execute all tasks: &quot; + str(sol.scheduleTasks([&#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;c&#x27;], 2))) print(&quot;Minimum intervals needed to execute all tasks: &quot; + str(sol.scheduleTasks([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;a&#x27;], 3)))main() Time complexityThe time complexity of the above algorithm is O(N\\logN)* where ‘N’ is the number of tasks. Our while loop will iterate once for each occurrence of the task in the input (i.e. ‘N’) and in each iteration we will remove a task from the heap which will take O(logN) time. Hence the overall time complexity of our algorithm is O(N\\logN)*. Space complexityThe space complexity will be O(N), as in the worst case, we need to store all the ‘N’ tasks in the HashMap. Problem Challenge 3895. Maximum Frequency Stack Design Gurus Educative.io Frequency Stack (hard)Design a class that simulates a Stack data structure, implementing the following two operations: push(int num): Pushes the number ‘num’ on the stack. pop(): Returns the most frequent number in the stack. If there is a tie, return the number which was pushed later. Example: 12345After following push operations: push(1), push(2), push(3), push(2), push(1), push(2), push(5) 1. pop() should return 2, as it is the most frequent number2. Next pop() should return 13. Next pop() should return 2 Constraints: 0 &lt;= val &lt;= 10^9 At most 2 * 10^4 calls will be made to push and pop. It is guaranteed that there will be at least one element in the stack before calling pop. SolutionThis problem follows the Top ‘K’ Elements pattern, and shares similarities with Top ‘K’ Frequent Numbers. We can use a Max Heap to store the numbers. Instead of comparing the numbers we will compare their frequencies so that the root of the heap is always the most frequently occurring number. There are two issues that need to be resolved though: How can we keep track of the frequencies of numbers in the heap? When we are pushing a new number to the Max Heap, we don’t know how many times the number has already appeared in the Max Heap. To resolve this, we will maintain a HashMap to store the current frequency of each number. Thus whenever we push a new number in the heap, we will increment its frequency in the HashMap and when we pop, we will decrement its frequency. If two numbers have the same frequency, we will need to return the number which was pushed later while popping. To resolve this, we need to attach a sequence number to every number to know which number came first. In short, we will keep three things with every number that we push to the heap: 1231. number // value of the number2. frequency // current frequency of the number when it was pushed to the heap3. sequenceNumber // a sequence number, to know what number came first CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107# 需要注意的是，在pop之后，已经在heap中的三元组中的frequency_map[num]的值还是旧的，但是没有问题，因为在栈中的顺序不会改变from heapq import *class Element: def __init__(self, number, frequency, sequenceNumber): self.number = number self.frequency = frequency self.sequenceNumber = sequenceNumber def __lt__(self, other): # higher frequency wins if self.frequency != other.frequency: return self.frequency &gt; other.frequency # if both elements have same frequency, return the element that was pushed later return self.sequenceNumber &gt; other.sequenceNumberclass Solution: def __init__(self): self.sequenceNumber = 0 self.maxHeap = [] self.frequencyMap = &#123;&#125; def push(self, num): self.frequencyMap[num] = self.frequencyMap.get(num, 0) + 1 heappush(self.maxHeap, Element( num, self.frequencyMap[num], self.sequenceNumber)) self.sequenceNumber += 1 def pop(self): num = heappop(self.maxHeap).number # decrement the frequency or remove if this is the last number if self.frequencyMap[num] &gt; 1: self.frequencyMap[num] -= 1 else: del self.frequencyMap[num] return numdef main(): sol = Solution() sol.push(1) sol.push(2) sol.push(3) sol.push(2) sol.push(1) sol.push(2) sol.push(5) print(sol.pop()) print(sol.pop()) print(sol.pop())main()#=======================leetcode=========================from heapq import *class FrequencyStack: def __init__(self): self.sequence_number = 0 self.max_heap = [] self.frequency_map = &#123;&#125; def push(self, num): self.frequency_map[num] = self.frequency_map.get(num, 0) + 1 heappush(self.max_heap, (-self.frequency_map[num], -self.sequence_number, num)) self.sequence_number += 1 def pop(self): num = heappop(self.max_heap)[2] if self.frequency_map[num] &gt; 1: self.frequency_map[num] -= 1 else: del self.frequency_map[num] return numdef main(): stack = FrequencyStack() stack.push(1) stack.push(2) stack.push(3) stack.push(2) stack.push(1) stack.push(2) stack.push(5) print(stack.pop()) print(stack.pop()) print(stack.pop()) print(stack.pop()) print(stack.pop()) print(stack.pop()) print(stack.pop())if __name__ == &#x27;__main__&#x27;: main()","categories":[{"name":"Grokking Interview Pattern","slug":"Grokking-Interview-Pattern","permalink":"https://hasuer.github.io/categories/Grokking-Interview-Pattern/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hasuer.github.io/tags/Interview/"}]},{"title":"17. Pattern Bitwise XOR","slug":"17. Pattern Bitwise XOR","date":"2024-05-17T08:19:24.000Z","updated":"2024-05-28T03:29:34.090Z","comments":true,"path":"17-pattern-bitwise-xor/index.html","link":"","permalink":"https://hasuer.github.io/17-pattern-bitwise-xor/index.html","excerpt":"","text":"Introduction再看这篇文章之前可以看一下这个知乎 XOR is a logical bitwise operator that returns 0 (false) if both bits are the same and returns 1 (true) otherwise. In other words, it only returns 1 if exactly one bit is set to 1 out of the two bits in comparison. It is surprising to know the approaches that the XOR operator enables us to solve certain problems. For example, let’s take a look at the following problem: Given an array of n-1 integers in the range from 1 to n, find the one number that is missing from the array. Example: 12Input: 1, 5, 2, 6, 4Answer: 3 A straight forward approach to solve this problem can be: Find the sum of all integers from 1 to n; let’s call it s1. Subtract all the numbers in the input array from s1; this will give us the missing number. Another approach is introduced in 6. Pattern Cyclic Sort\\3. Find the Missing Number (easy). This is what the algorithm will look like: 12345678910111213141516171819202122class Solution: def findMissingNumber(self, arr): n = len(arr) + 1 # find sum of all numbers from 1 to n. s1 = 0 for i in range (1, n+1): s1 += i # subtract all numbers in input from sum. for i in arr: s1 -= i # s1, now, is the missing number return s1def main(): sol = Solution() arr = [1, 5, 2, 6, 4] print(&#x27;Missing number is:&#x27; + str(sol.findMissingNumber(arr)))main() Time &amp; Space complexity: The time complexity of the above algorithm is O(n) and the space complexity is O(1). What could go wrong with the above algorithm? While finding the sum of numbers from 1 to n, we can get integer overflow when n is large. How can we avoid this? Can XOR help us here? Remember the important property of XOR that it returns 0 if both the bits in comparison are the same. In other words, XOR of a number with itself will always result in 0. This means that if we XOR all the numbers in the input array with all numbers from the range 1 to n then each number in the input is going to get zeroed out except the missing number. Following are the set of steps to find the missing number using XOR: XOR all the numbers from 1 to n, let’s call it x1. XOR all the numbers in the input array, let’s call it x2. The missing number can be found by x1 XOR x2. Here is what the algorithm will look like: 1234567891011121314151617181920212223class Solution: def findMissingNumber(self, arr): n = len(arr) + 1 # x1 represents XOR of all values from 1 to n x1 = 1 for i in range(2, n+1): x1 = x1 ^ i # x2 represents XOR of all values in arr x2 = arr[0] for i in range(1, n-1): x2 = x2 ^ arr[i] # missing number is the xor of x1 and x2 return x1 ^ x2def main(): sol = Solution() arr = [1, 5, 2, 6, 4] print(&#x27;Missing number is:&#x27; + str(sol.findMissingNumber(arr)))main() Time &amp; Space complexity: The time complexity of the above algorithm is O(n)O(n) and the space complexity is O(1)O(1). The time and space complexities are the same as that of the previous solution but, in this algorithm, we will not have any integer overflow problem. Important properties of XOR to rememberFollowing are some important properties of XOR to remember: Taking XOR of a number with itself returns 0, e.g., 1 ^ 1 = 0 29 ^ 29 = 0 Taking XOR of a number with 0 returns the same number, e.g., 1 ^ 0 = 1 31 ^ 0 = 31 XOR is Associative &amp; Commutative, which means: (a ^ b) ^ c = a ^ (b ^ c) a ^ b = b ^ a In the following chapters, we will apply the XOR pattern to solve some interesting problems. Single Number (easy)Top Interview 150 | 136. Single Number Design Gurus Educative.io Problem StatementIn a non-empty array of integers, every number appears twice except for one, find that single number. Example 1: 12Input: 1, 4, 2, 1, 3, 2, 3Output: 4 Example 2: 12Input: 7, 9, 7Output: 9 Constraints: 1 &lt;= nums.length &lt;= 3 * 10^4 -3 10^4 &lt;= nums[i] &lt;= 3 10^4 Each element in the array appears twice except for one element which appears only once. SolutionOne straight forward solution can be to use a HashMap kind of data structure and iterate through the input: If number is already present in HashMap, remove it. If number is not present in HashMap, add it. In the end, only number left in the HashMap is our required single number. Time and space complexity Time Complexity of the above solution will be O(n) and space complexity will also be O(n). Can we do better than this using the XOR Pattern? Solution with XORRecall the following two properties of XOR: It returns zero if we take XOR of two same numbers. It returns the same number if we XOR with zero. So we can XOR all the numbers in the input; duplicate numbers will zero out each other and we will be left with the single number. CodeHere is what our algorithm will look like: 1234567891011121314class Solution: def findSingleNumber(self, arr): num = 0 # Initialize a variable to store the result for i in arr: num ^= i # XOR operation to find the single number return numdef main(): sol = Solution() arr = [1, 4, 2, 1, 3, 2, 3] print(sol.findSingleNumber(arr))main() Time ComplexityTime complexity of this solution is O(n) as we iterate through all numbers of the input once. Space ComplexityThe algorithm runs in constant space O(1). *Two Single Numbers (medium)260. Single Number III Design Gurus Educative.io Problem StatementIn a non-empty array of numbers, every number appears exactly twice except two numbers that appear only once. Find the two numbers that appear only once. Example 1: 12Input: [1, 4, 2, 1, 3, 5, 6, 2, 3, 5]Output: [4, 6] Example 2: 12Input: [2, 1, 3, 2]Output: [1, 3] Constraints: 1 &lt;= nums.length &lt;= 3 * 10^4 -3 10^4 &lt;= nums[i] &lt;= 3 10^4 Each element in the array appears twice except for two element which appears only once. SolutionThis problem is quite similar to Single Number, the only difference is that, in this problem, we have two single numbers instead of one. Can we still use XOR to solve this problem? Let’s assume num1 and num2 are the two single numbers. If we do XOR of all elements of the given array, we will be left with XOR of num1 and num2 as all other numbers will cancel each other because all of them appeared twice. Let’s call this XOR n1xn2. Now that we have XOR of num1 and num2, how can we find these two single numbers? As we know that num1 and num2 are two different numbers, therefore, they should have at least one bit different between them. If a bit in n1xn2 is ‘1’, this means that num1 and num2 have different bits in that place, as we know that we can get ‘1’ only when we do XOR of two different bits, i.e., 11 XOR 0 = 0 XOR 1 = 1 We can take any bit which is ‘1’ in n1xn2 and partition all numbers in the given array into two groups based on that bit. One group will have all those numbers with that bit set to ‘0’ and the other with the bit set to ‘1’. This will ensure that num1 will be in one group and num2 will be in the other. We can take XOR of all numbers in each group separately to get num1 and num2, as all other numbers in each group will cancel each other. Here are the steps of our algorithm: Taking XOR of all numbers in the given array will give us XOR of num1 and num2, calling this XOR as n1xn2. Find any bit which is set in n1xn2. We can take the rightmost bit which is ‘1’. Let’s call this rightmostSetBit. Iterate through all numbers of the input array to partition them into two groups based on rightmostSetBit. Take XOR of all numbers in both the groups separately. Both these XORs are our required numbers. CodeHere is what our algorithm will look like: 12345678910111213141516171819202122232425262728293031class Solution: def findSingleNumbers(self, nums): # get the XOR of the all the numbers n1xn2 = 0 for num in nums: n1xn2 ^= num # get the rightmost bit that is &#x27;1&#x27; rightmost_set_bit = 1 while (rightmost_set_bit &amp; n1xn2) == 0: rightmost_set_bit = rightmost_set_bit &lt;&lt; 1 num1, num2 = 0, 0 for num in nums: if (num &amp; rightmost_set_bit) != 0: # the bit is set num1 ^= num else: # the bit is not set num2 ^= num return [num1, num2]def main(): sol = Solution() print(&#x27;Single numbers are:&#x27; + str(sol.findSingleNumbers([1, 4, 2, 1, 3, 5, 6, 2, 3, 5]))) print(&#x27;Single numbers are:&#x27; + str(sol.findSingleNumbers([2, 1, 3, 2])))main() Time ComplexityThe time complexity of this solution is O(n) where ‘n’ is the number of elements in the input array. Space ComplexityThe algorithm runs in constant space O(1). *Complement of Base 10 Number (medium)1009. Complement of Base 10 Integer Design Gurus Educative.io Problem StatementEvery non-negative integer N has a binary representation, for example, 8 can be represented as “1000” in binary and 7 as “0111” in binary. The complement of a binary representation is the number in binary that we get when we change every 1 to a 0 and every 0 to a 1. For example, the binary complement of “1010” is “0101”. For a given positive number N in base-10, return the complement of its binary representation as a base-10 integer. Example 1: 123Input: 8Output: 7Explanation: 8 is 1000 in binary, its complement is 0111 in binary, which is 7 in base-10. Example 2: 123Input: 10Output: 5Explanation: 10 is 1010 in binary, its complement is 0101 in binary, which is 5 in base-10. Constraints: 0 &lt;= n &lt; 10^9 SolutionRecall the following properties of XOR: It will return 1 if we take XOR of two different bits i.e. 1^0 = 0^1 = 1. It will return 0 if we take XOR of two same bits i.e. 0^0 = 1^1 = 0. In other words, XOR of two same numbers is 0. It returns the same number if we XOR with 0. From the above-mentioned first property, we can conclude that XOR of a number with its complement will result in a number that has all of its bits set to 1. For example, the binary complement of “101” is “010”; and if we take XOR of these two numbers, we will get a number with all bits set to 1, i.e., 101 ^ 010 = 111 We can write this fact in the following equation: 1number ^ complement = all_bits_set Let’s add ‘number’ on both sides: 1number ^ number ^ complement = number ^ all_bits_set From the above-mentioned second property: 10 ^ complement = number ^ all_bits_set From the above-mentioned third property: 1complement = number ^ all_bits_set We can use the above fact to find the complement of any number. How do we calculate ‘all_bits_set’? One way to calculate all_bits_set will be to first count the bits required to store the given number. We can then use the fact that for a number which is a complete power of ‘2’ i.e., it can be written as pow(2, n), if we subtract ‘1’ from such a number, we get a number which has ‘n’ least significant bits set to ‘1’. For example, ‘4’ which is a complete power of ‘2’, and ‘3’ (which is one less than 4) has a binary representation of ‘11’ i.e., it has ‘2’ least significant bits set to ‘1’. CodeHere is what our algorithm will look like: 1234567891011121314151617181920212223class Solution: def bitwiseComplement(self, num): # count number of total bits in &#x27;num&#x27; bit_count = 0 n = num while n &gt; 0: bit_count += 1 n = n &gt;&gt; 1 # for a number which is a complete power of &#x27;2&#x27; i.e., it can be written as pow(2, n), # if we subtract &#x27;1&#x27; from such a number, we get a number which has &#x27;n&#x27; least # significant bits set to &#x27;1&#x27;. For example, &#x27;4&#x27; which is a complete power of &#x27;2&#x27;, and # &#x27;3&#x27; (which is one less than 4) has a binary representation of &#x27;11&#x27; i.e., it has &#x27;2&#x27; # least significant bits set to &#x27;1&#x27; all_bits_set = pow(2, bit_count) - 1 # from the solution description: complement = number ^ all_bits_set return num ^ all_bits_setsol = Solution()print(&#x27;Bitwise complement is: &#x27; + str(sol.bitwiseComplement(8)))print(&#x27;Bitwise complement is: &#x27; + str(sol.bitwiseComplement(10))) Time ComplexityTime complexity of this solution is O(b) where ‘b’ is the number of bits required to store the given number. Space ComplexitySpace complexity of this solution is O(1) #Problem Challenge 1832. Flipping an Image Design Gurus Educative.io Problem StatementGiven a binary matrix representing an image, we want to flip the image horizontally, then invert it. To flip an image horizontally means that each row of the image is reversed. For example, flipping [0, 1, 1] horizontally results in [1, 1, 0]. To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0. For example, inverting [1, 1, 0] results in [0, 0, 1]. Example 1: 12345678910Input: [ [1,0,1], [1,1,1], [0,1,1]]Output: [ [0,1,0], [0,0,0], [0,0,1]] Explanation: First reverse each row: [[1,0,1],[1,1,1],[1,1,0]]. Then, invert the image: [[0,1,0],[0,0,0],[0,0,1]] Example 2: 123456789101112Input: [ [1,1,0,0], [1,0,0,1], [0,1,1,1], [1,0,1,0]]Output: [ [1,1,0,0], [0,1,1,0], [0,0,0,1], [1,0,1,0]] Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]. Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] Constraints: n == arr.length n == arr[i].length 1 &lt;= n &lt;= 20 arr[i][j] is either 0 or 1. Try it yourselfTry solving this question here: 12345678910111213141516171819# 看solution写的def flip_an_invert_image(matrix): for row in matrix: C = len(row) for i in range((C + 1) // 2): row[i], row[C - i - 1] = row[C - i - 1] ^ 1, row[i] ^ 1 return matrixdef main(): res = flip_an_invert_image([[1, 0, 1], [1, 1, 1], [1, 1, 0]]) print(str(res)) res = flip_an_invert_image([[0, 0, 1, 1], [1, 0, 0, 1], [1, 1, 1, 0], [0, 1, 0, 1]]) print(str(res))if __name__ == &#x27;__main__&#x27;: main() Solution Flip: We can flip the image in place by replacing ith element from left with the ith element from the right. Invert: We can take XOR of each element with 1. If it is 1 then it will become 0 and if it is 0 then it will become 1. CodeHere is what our algorithm will look like: 1234567891011121314151617class Solution: def flipAndInvertImage(self, matrix): C = len(matrix[0]) # Get the number of columns in the matrix for row in matrix: for i in range((C+1)//2): # Iterate through the first half of the row # Swap and invert elements symmetrically from the beginning and end of the row row[i], row[C - i - 1] = row[C - i - 1] ^ 1, row[i] ^ 1 return matrixdef main(): sol = Solution() print(sol.flipAndInvertImage([[1,0,1], [1,1,1], [0,1,1]])) print(sol.flipAndInvertImage([[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]))main() Time ComplexityThe time complexity of this solution is O(n)as we iterate through all elements of the input. Space ComplexityThe space complexity of this solution is O(1).","categories":[{"name":"Grokking Interview Pattern","slug":"Grokking-Interview-Pattern","permalink":"https://hasuer.github.io/categories/Grokking-Interview-Pattern/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hasuer.github.io/tags/Interview/"}]},{"title":"16. Pattern Modified Binary Search","slug":"16. Pattern Modified Binary Search","date":"2024-05-16T07:26:29.000Z","updated":"2024-05-28T03:29:25.338Z","comments":true,"path":"16-pattern-modified-binary-search/index.html","link":"","permalink":"https://hasuer.github.io/16-pattern-modified-binary-search/index.html","excerpt":"","text":"IntroductionAs we know, whenever we are given a sorted Array or LinkedList or Matrix, and we are asked to find a certain element, the best algorithm we can use is the Binary Search. This pattern describes an efficient way to handle all problems involving Binary Search. We will go through a set of problems that will help us build an understanding of this pattern so that we can apply this technique to other problems we might come across in the interviews. Let’s start with our first problem. Order-agnostic Binary Search (easy) 704. Binary Search Design Gurus Educative.io Problem StatementGiven a sorted array of numbers, find if a given number ‘key’ is present in the array. Though we know that the array is sorted, we don’t know if it’s sorted in ascending or descending order. You should assume that the array can have duplicates. Write a function to return the index of the ‘key’ if it is present in the array, otherwise return -1. Example 1: 12Input: [4, 6, 10], key = 10Output: 2 Example 2: 12Input: [1, 2, 3, 4, 5, 6, 7], key = 5Output: 4 Example 3: 12Input: [10, 6, 4], key = 10Output: 0 Example 4: 12Input: [10, 6, 4], key = 4Output: 2 Constraints: 1 &lt;= nums.length &lt;= 10^4 -10^4 &lt; nums[i], target &lt; 10^4 SolutionTo make things simple, let’s first solve this problem assuming that the input array is sorted in ascending order. Here are the set of steps for Binary Search: Let’s assume start is pointing to the first index and end is pointing to the last index of the input array (let’s call it arr). This means: 12int start = 0;int end = arr.length - 1; First, we will find the middle of start and end. An easy way to find the middle would be: middle=(start+end)/2. For Java and C++, this equation will work for most cases, but when start or end is large, this equation will give us the wrong result due to integer overflow. Imagine that start is equal to the maximum range of an integer (e.g. for Java: int start = Integer.MAX_VALUE). Now adding anything to start will result in an integer overflow. Since we need to add both the numbers first to evaluate our equation, an overflow might occur. The safest way to find the middle of two numbers without getting an overflow is as follows: 1middle = start + (end-start)/2 The above discussion is not relevant for Python, as we don’t have the integer overflow problem in pure Python. Next, we will see if the ‘key’ is equal to the number at index middle. If it is equal we return middle as the required index. If ‘key’ is not equal to number at index middle, we have to check two things: If key &lt; arr[middle], then we can conclude that the key will be smaller than all the numbers after index middle as the array is sorted in the ascending order. Hence, we can reduce our search to end = mid - 1. If key &gt; arr[middle], then we can conclude that the key will be greater than all numbers before index middle as the array is sorted in the ascending order. Hence, we can reduce our search to start = mid + 1. We will repeat steps 2-4 with new ranges of start to end. If at any time start becomes greater than end, this means that we can’t find the ‘key’ in the input array and we must return ‘-1’. Here is the visual representation of Binary Search for the Example-2: If the array is sorted in the descending order, we have to update the step 4 above as: If key &gt; arr[middle], then we can conclude that the key will be greater than all numbers after index middle as the array is sorted in the descending order. Hence, we can reduce our search to end = mid - 1. If key &lt; arr[middle], then we can conclude that the key will be smaller than all the numbers before index middle as the array is sorted in the descending order. Hence, we can reduce our search to start = mid + 1. Finally, how can we figure out the sort order of the input array? We can compare the numbers pointed out by start and end index to find the sort order. If arr[start] &lt; arr[end], it means that the numbers are sorted in ascending order otherwise they are sorted in the descending order. CodeHere is what our algorithm will look like: 1234567891011121314151617181920212223242526272829303132333435class Solution: def search(self, arr, key): start, end = 0, len(arr) - 1 isAscending = arr[start] &lt; arr[end] while start &lt;= end: # calculate the middle of the current range mid = start + (end - start) // 2 if key == arr[mid]: return mid if isAscending: # ascending order if key &lt; arr[mid]: end = mid - 1 # the &#x27;key&#x27; can be in the first half else: # key &gt; arr[mid] start = mid + 1 # the &#x27;key&#x27; can be in the second half else: # descending order if key &gt; arr[mid]: end = mid - 1 # the &#x27;key&#x27; can be in the first half else: # key &lt; arr[mid] start = mid + 1 # the &#x27;key&#x27; can be in the second half return -1 # element not founddef main(): sol = Solution() print(sol.search([4, 6, 10], 10)) print(sol.search([1, 2, 3, 4, 5, 6, 7], 5)) print(sol.search([10, 6, 4], 10)) print(sol.search([10, 6, 4], 4))main() Time complexitySince, we are reducing the search range by half at every step, this means that the time complexity of our algorithm will be O(logN) where ‘N’ is the total elements in the given array. Space complexityThe algorithm runs in constant space O(1). Ceiling of a Number (medium)Similar | Top Interview 150 | 35. Search Insert Position Design Gurus Educative.io Problem StatementGiven an array of numbers sorted in an ascending order, find the ceiling of a given number ‘key’. The ceiling of the ‘key’ will be the smallest element in the given array greater than or equal to the ‘key’. Write a function to return the index of the ceiling of the ‘key’. If there isn’t any ceiling return -1. Example 1: 123Input: [4, 6, 10], key = 6Output: 1Explanation: The smallest number greater than or equal to &#x27;6&#x27; is &#x27;6&#x27; having index &#x27;1&#x27;. Example 2: 123Input: [1, 3, 8, 10, 15], key = 12Output: 4Explanation: The smallest number greater than or equal to &#x27;12&#x27; is &#x27;15&#x27; having index &#x27;4&#x27;. Example 3: 123Input: [4, 6, 10], key = 17Output: -1Explanation: There is no number greater than or equal to &#x27;17&#x27; in the given array. Example 4: 123Input: [4, 6, 10], key = -1Output: 0Explanation: The smallest number greater than or equal to &#x27;-1&#x27; is &#x27;4&#x27; having index &#x27;0&#x27;. Constraints: 1 &lt;= arr.length &lt;= 10^4 -10^4 &lt; arr[i], key &lt; 10^4 SolutionThis problem follows the Binary Search pattern. Since Binary Search helps us find a number in a sorted array efficiently, we can use a modified version of the Binary Search to find the ceiling of a number. We can use a similar approach as discussed in Order-agnostic Binary Search. We will try to search for the ‘key’ in the given array. If we find the ‘key’, we return its index as the ceiling. If we can’t find the ‘key’, the next big number will be pointed out by the index start. Consider Example-2 mentioned above: Since we are always adjusting our range to find the ‘key’, when we exit the loop, the start of our range will point to the smallest number greater than the ‘key’ as shown in the above picture. We can add a check in the beginning to see if the ‘key’ is bigger than the biggest number in the input array. If so, we can return ‘-1’. CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233# 如果不存在key,那么退出循环的时候arr[start] &gt; key &gt; arr[end]class Solution: def searchCeilingOfANumber(self, arr, key): n = len(arr) if key &gt; arr[n - 1]: # if the &#x27;key&#x27; is bigger than the biggest element return -1 start, end = 0, n - 1 while start &lt;= end: mid = start + (end - start) // 2 if key &lt; arr[mid]: end = mid - 1 elif key &gt; arr[mid]: start = mid + 1 else: # found the key return mid # since the loop is running until &#x27;start &lt;= end&#x27;, so at the end of the while loop, # &#x27;start == end+1&#x27; we are not able to find the element in the given array, so the next # big number will be arr[start] return startdef main(): sol = Solution() print(sol.searchCeilingOfANumber([4, 6, 10], 6)) print(sol.searchCeilingOfANumber([1, 3, 8, 10, 15], 12)) print(sol.searchCeilingOfANumber([4, 6, 10], 17)) print(sol.searchCeilingOfANumber([4, 6, 10], -1))main() Time complexitySince we are reducing the search range by half at every step, this means that the time complexity of our algorithm will be O(logN) where ‘N’ is the total elements in the given array. Space complexityThe algorithm runs in constant space O(1). Similar ProblemsProblem 1Given an array of numbers sorted in ascending order, find the floor of a given number ‘key’. The floor of the ‘key’ will be the biggest element in the given array smaller than or equal to the ‘key’ Write a function to return the index of the floor of the ‘key’. If there isn’t a floor, return -1. Example 1: 123Input: [4, 6, 10], key = 6Output: 1Explanation: The biggest number smaller than or equal to &#x27;6&#x27; is &#x27;6&#x27; having index &#x27;1&#x27;. Example 2: 123Input: [1, 3, 8, 10, 15], key = 12Output: 3Explanation: The biggest number smaller than or equal to &#x27;12&#x27; is &#x27;10&#x27; having index &#x27;3&#x27;. Example 3: 123Input: [4, 6, 10], key = 17Output: 2Explanation: The biggest number smaller than or equal to &#x27;17&#x27; is &#x27;10&#x27; having index &#x27;2&#x27;. Example 4: 123Input: [4, 6, 10], key = -1Output: -1Explanation: There is no number smaller than or equal to &#x27;-1&#x27; in the given array. CodeThe code is quite similar to the above solution; only the highlighted lines have changed: 12345678910111213141516171819202122232425262728293031class Solution: def searchFloorOfANumber(self, arr, key): if key &lt; arr[0]: # if the &#x27;key&#x27; is smaller than the smallest element return -1 start, end = 0, len(arr) - 1 while start &lt;= end: mid = start + (end - start) // 2 if key &lt; arr[mid]: end = mid - 1 elif key &gt; arr[mid]: start = mid + 1 else: # found the key return mid # since the loop is running until &#x27;start &lt;= end&#x27;, so at the end of the while loop, # &#x27;start == end+1&#x27; we are not able to find the element in the given array, so the next # smaller number will be arr[end] return enddef main(): sol = Solution() print(sol.searchFloorOfANumber([4, 6, 10], 6)) print(sol.searchFloorOfANumber([1, 3, 8, 10, 15], 12)) print(sol.searchFloorOfANumber([4, 6, 10], 17)) print(sol.searchFloorOfANumber([4, 6, 10], -1))main() Next Letter (medium) 744. Find Smallest Letter Greater Than Target Design Gurus Educative.io Problem StatementGiven an array of lowercase letters sorted in ascending order, find the smallest letter in the given array greater than a given ‘key’. Assume the given array is a circular list, which means that the last letter is assumed to be connected with the first letter. This also means that the smallest letter in the given array is greater than the last letter of the array and is also the first letter of the array. Write a function to return the next letter of the given ‘key’. Example 1: 123Input: [&#x27;a&#x27;, &#x27;c&#x27;, &#x27;f&#x27;, &#x27;h&#x27;], key = &#x27;f&#x27;Output: &#x27;h&#x27;Explanation: The smallest letter greater than &#x27;f&#x27; is &#x27;h&#x27; in the given array. Example 2: 123Input: [&#x27;a&#x27;, &#x27;c&#x27;, &#x27;f&#x27;, &#x27;h&#x27;], key = &#x27;b&#x27;Output: &#x27;c&#x27;Explanation: The smallest letter greater than &#x27;b&#x27; is &#x27;c&#x27;. Example 3: 123Input: [&#x27;a&#x27;, &#x27;c&#x27;, &#x27;f&#x27;, &#x27;h&#x27;], key = &#x27;m&#x27;Output: &#x27;a&#x27;Explanation: As the array is assumed to be circular, the smallest letter greater than &#x27;m&#x27; is &#x27;a&#x27;. Example 4: 123Input: [&#x27;a&#x27;, &#x27;c&#x27;, &#x27;f&#x27;, &#x27;h&#x27;], key = &#x27;h&#x27;Output: &#x27;a&#x27;Explanation: As the array is assumed to be circular, the smallest letter greater than &#x27;h&#x27; is &#x27;a&#x27;. Constraints: 2 &lt;= letters.length &lt;= 10^4 letters[i] is a lowercase English letter. letters is sorted in non-decreasing order. letters contains at least two different characters. key is a lowercase English letter. SolutionThe problem follows the Binary Search pattern. Since Binary Search helps us find an element in a sorted array efficiently, we can use a modified version of it to find the next letter. We can use a similar approach as discussed in Ceiling of a Number. There are a couple of differences though: The array is considered circular, which means if the ‘key’ is bigger than the last letter of the array or if it is smaller than the first letter of the array, the key’s next letter will be the first letter of the array. The other difference is that we have to find the next biggest letter which can’t be equal to the ‘key’. This means that we will ignore the case where key == arr[middle]. To handle this case, we can update our start range to start = middle +1. In the end, instead of returning the element pointed out by start, we have to return the letter pointed out by start % array_length. This is needed because of point 2 discussed above. Imagine that the last letter of the array is equal to the ‘key’. In that case, we have to return the first letter of the input array. CodeHere is what our algorithm will look like; the most important changes are in the highlighted lines: 1234567891011121314151617181920212223242526272829# 如果存在多个key,那么推出循环的时候letters[start] = key &gt; letters[end]class Solution: def searchNextLetter(self, letters, key): n = len(letters) start, end = 0, n - 1 while start &lt;= end: mid = start + (end - start) // 2 if key &lt; letters[mid]: end = mid - 1 else: # key &gt;= letters[mid]: # 要是把key == letters[mid] 单独提出来，会有问题 # 比如这个例子[&quot;e&quot;, &quot;e&quot;, &quot;e&quot;, &quot;e&quot;, &quot;e&quot;, &quot;e&quot;, &quot;n&quot;, &quot;n&quot;, &quot;n&quot;, &quot;n&quot;], &#x27;e&#x27; start = mid + 1 # since the loop is running until &#x27;start &lt;= end&#x27;, so at the end of the while loop, # &#x27;start == end+1&#x27; return letters[start % n]def main(): sol = Solution() print(sol.searchNextLetter([&#x27;a&#x27;, &#x27;c&#x27;, &#x27;f&#x27;, &#x27;h&#x27;], &#x27;f&#x27;)) print(sol.searchNextLetter([&#x27;a&#x27;, &#x27;c&#x27;, &#x27;f&#x27;, &#x27;h&#x27;], &#x27;b&#x27;)) print(sol.searchNextLetter([&#x27;a&#x27;, &#x27;c&#x27;, &#x27;f&#x27;, &#x27;h&#x27;], &#x27;m&#x27;))main() Time complexitySince, we are reducing the search range by half at every step, this means that the time complexity of our algorithm will be O(logN) where ‘N’ is the total elements in the given array. Space complexityThe algorithm runs in constant space O(1). #Number Range (medium) Top Interview 150 | 34. Find First and Last Position of Element in Sorted Array Design Gurus Educative.io Problem StatementGiven an array of numbers sorted in ascending order, find the range of a given number ‘key’. The range of the ‘key’ will be the first and last position of the ‘key’ in the array. Write a function to return the range of the ‘key’. If the ‘key’ is not present return [-1, -1]. Example 1: 12Input: [4, 6, 6, 6, 9], key = 6Output: [1, 3] Example 2: 12Input: [1, 3, 8, 10, 15], key = 10Output: [3, 3] Example 3: 12Input: [1, 3, 8, 10, 15], key = 12Output: [-1, -1] Constraints: 0 &lt;= nums.length &lt;= 10^5 -10^9 &lt;= nums[i] &lt;= 10^9 nums is a non-decreasing array. -10^9 &lt;= target &lt;= 10^9 SolutionThe problem follows the Binary Search pattern. Since Binary Search helps us find a number in a sorted array efficiently, we can use a modified version of the Binary Search to find the first and the last position of a number. We can use a similar approach as discussed in Order-agnostic Binary Search. We will try to search for the ‘key’ in the given array; if the ‘key’ is found (i.e. key == arr[middle) we have two options: When trying to find the first position of the ‘key’, we can update end = middle - 1 to see if the key is present before middle. When trying to find the last position of the ‘key’, we can update start = middle + 1 to see if the key is present after middle. In both cases, we will keep track of the last position where we found the ‘key’. These positions will be the required range. CodeHere is what our algorithm will look like: 12345678910111213141516171819202122232425262728293031323334353637class Solution: def findRange(self, arr, key): result = [- 1, -1] result[0] = self.binary_search(arr, key, False) if result[0] != -1: # no need to search, if &#x27;key&#x27; is not present in the input array result[1] = self.binary_search(arr, key, True) return result # modified Binary Search def binary_search(self, arr, key, findMaxIndex): keyIndex = -1 start, end = 0, len(arr) - 1 while start &lt;= end: mid = start + (end - start) // 2 if key &lt; arr[mid]: end = mid - 1 elif key &gt; arr[mid]: start = mid + 1 else: # key == arr[mid] keyIndex = mid if findMaxIndex: start = mid + 1 # search ahead to find the last index of &#x27;key&#x27; else: end = mid - 1 # search behind to find the first index of &#x27;key&#x27; return keyIndexdef main(): sol = Solution() print(sol.findRange([4, 6, 6, 6, 9], 6)) print(sol.findRange([1, 3, 8, 10, 15], 10)) print(sol.findRange([1, 3, 8, 10, 15], 12))main() Time complexitySince, we are reducing the search range by half at every step, this means that the time complexity of our algorithm will be O(logN) where ‘N’ is the total elements in the given array. Space complexityThe algorithm runs in constant space O(1). #Search in a Sorted Infinite Array (medium) Leetcode 702 会员 Design Gurus Educative.io Problem StatementGiven an infinite sorted array (or an array with unknown size), find if a given number ‘key’ is present in the array. Write a function to return the index of the ‘key’ if it is present in the array, otherwise return -1. Since it is not possible to define an array with infinite (unknown) size, you will be provided with an interface ArrayReader to read elements of the array. ArrayReader.get(index) will return the number at index; if the array’s size is smaller than the index, it will return Integer.MAX_VALUE. Example 1: 123Input: [4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30], key = 16Output: 6Explanation: The key is present at index &#x27;6&#x27; in the array. Example 2: 123Input: [4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30], key = 11Output: -1Explanation: The key is not present in the array. Example 3: 123Input: [1, 3, 8, 10, 15], key = 15Output: 4Explanation: The key is present at index &#x27;4&#x27; in the array. Example 4: 123Input: [1, 3, 8, 10, 15], key = 200Output: -1Explanation: The key is not present in the array. Constraints: 1 &lt;= reader.length &lt;= 10^4 -10^4 &lt;= reader[i], target &lt;= 10^4 reader is sorted in a strictly increasing order. SolutionThe problem follows the Binary Search pattern. Since Binary Search helps us find a number in a sorted array efficiently, we can use a modified version of the Binary Search to find the ‘key’ in an infinite sorted array. The only issue with applying binary search in this problem is that we don’t know the bounds of the array. To handle this situation, we will first find the proper bounds of the array where we can perform a binary search. An efficient way to find the proper bounds is to start at the beginning of the array with the bound’s size as ‘1’ and exponentially increase the bound’s size (i.e., double it) until we find the bounds that can have the key. Consider Example-1 mentioned above: Once we have searchable bounds we can apply the binary search. CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import math# class ArrayReader:# def __init__(self, arr):# self.arr = arr# def get(self, index):# if index &gt;= len(self.arr):# return math.inf# return self.arr[index]class Solution: def searchInfiniteSortedArray(self, reader, key): # find the proper bounds first start, end = 0, 1 while reader.get(end) &lt; key: newStart = end + 1 end += (end - start + 1) * 2 # increase to double the bounds size start = newStart return self.binary_search(reader, key, start, end) def binary_search(self, reader, key, start, end): while start &lt;= end: mid = start + (end - start) // 2 if key &lt; reader.get(mid): end = mid - 1 elif key &gt; reader.get(mid): start = mid + 1 else: # found the key return mid return -1def main(): sol = Solution() reader = ArrayReader([4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30]) print(sol.searchInfiniteSortedArray(reader, 16)) print(sol.searchInfiniteSortedArray(reader, 11)) reader = ArrayReader([1, 3, 8, 10, 15]) print(sol.searchInfiniteSortedArray(reader, 15)) print(sol.searchInfiniteSortedArray(reader, 200))main() Time complexityThere are two parts of the algorithm. In the first part, we keep increasing the bound’s size exponentially (double it every time) while searching for the proper bounds. Therefore, this step will take O(logN) assuming that the array will have maximum ‘N’ numbers. In the second step, we perform the binary search which will take O(logN), so the overall time complexity of our algorithm will be O(logN + logN) which is asymptotically equivalent to O(logN). Space complexityThe algorithm runs in constant space O(1). Minimum Difference Element (medium)Design Gurus Educative.io Problem StatementGiven an array of numbers sorted in ascending order, find the element in the array that has the minimum difference with the given ‘key’. Example 1: 123Input: [4, 6, 10], key = 7Output: 6Explanation: The difference between the key &#x27;7&#x27; and &#x27;6&#x27; is minimum than any other number in the array Example 2: 12Input: [4, 6, 10], key = 4Output: 4 Example 3: 12Input: [1, 3, 8, 10, 15], key = 12Output: 10 Example 4: 12Input: [4, 6, 10], key = 17Output: 10 SolutionThe problem follows the Binary Search pattern. Since Binary Search helps us find a number in a sorted array efficiently, we can use a modified version of the Binary Search to find the number that has the minimum difference with the given ‘key’. We can use a similar approach as discussed in Order-agnostic Binary Search. We will try to search for the ‘key’ in the given array. If we find the ‘key’ we will return it as the minimum difference number. If we can’t find the ‘key’, (at the end of the loop) we can find the differences between the ‘key’ and the numbers pointed out by indices start and end, as these two numbers will be closest to the ‘key’. The number that gives minimum difference will be our required number. CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233343536class Solution: def searchMinDiffElement(self, arr, key): if key &lt; arr[0]: return arr[0] n = len(arr) if key &gt; arr[n - 1]: return arr[n - 1] start, end = 0, n - 1 while start &lt;= end: mid = start + (end - start) // 2 if key &lt; arr[mid]: end = mid - 1 elif key &gt; arr[mid]: start = mid + 1 else: return arr[mid] # at the end of the while loop, &#x27;start == end+1&#x27; # we are not able to find the element in the given array # return the element which is closest to the &#x27;key&#x27; if (arr[start] - key) &lt; (key - arr[end]): return arr[start] return arr[end]def main(): sol = Solution() print(sol.searchMinDiffElement([4, 6, 10], 7)) print(sol.searchMinDiffElement([4, 6, 10], 4)) print(sol.searchMinDiffElement([1, 3, 8, 10, 15], 12)) print(sol.searchMinDiffElement([4, 6, 10], 17))main() Time complexitySince, we are reducing the search range by half at every step, this means the time complexity of our algorithm will be O(logN) where ‘N’ is the total elements in the given array. Space complexityThe algorithm runs in constant space O(1). #Bitonic Array Maximum (easy) 852. Peak Index in a Mountain Array Design Gurus Educative.io Problem StatementFind the maximum value in a given Bitonic array. An array is considered bitonic if it is monotonically increasing and then monotonically decreasing. Monotonically increasing or decreasing means that for any index i in the array arr[i] != arr[i+1]. Example 1: 123Input: [1, 3, 8, 12, 4, 2]Output: 12Explanation: The maximum number in the input bitonic array is &#x27;12&#x27;. Example 2: 12Input: [3, 8, 3, 1]Output: 8 Example 3: 12Input: [1, 3, 8, 12]Output: 12 Example 4: 12Input: [10, 9, 8]Output: 10 Constraints: 1 &lt;= arr.length &lt;= 10^5 -105 &lt;= arr[i] &lt;= 10^5 SolutionA bitonic array is a sorted array; the only difference is that its first part is sorted in ascending order and the second part is sorted in descending order. We can use a similar approach as discussed in Order-agnostic Binary Search. Since no two consecutive numbers are same (as the array is monotonically increasing or decreasing), whenever we calculate the middle, we can compare the numbers pointed out by the index middle and middle+1 to find if we are in the ascending or the descending part. So: If arr[middle] &gt; arr[middle + 1], we are in the second (descending) part of the bitonic array. Therefore, our required number could either be pointed out by middle or will be before middle. This means we will be doing: end = middle. If arr[middle] &lt;= arr[middle + 1], we are in the first (ascending) part of the bitonic array. Therefore, the required number will be after middle. This means we will be doing: start = middle + 1. We can break when start == end. Due to the two points mentioned above, both start and end will be pointing at the maximum number of the bitonic array. CodeHere is what our algorithm will look like: 12345678910111213141516171819202122232425class Solution: def findMax(self, arr): start, end = 0, len(arr) - 1 # 注意这里是&lt;,而不是&lt;=,不然会死循环 while start &lt; end: mid = start + (end - start) // 2 if arr[mid] &gt; arr[mid + 1]: end = mid else: start = mid + 1 # at the end of the while loop, &#x27;start == end&#x27; return arr[start]def main(): sol = Solution() print(sol.findMax([1, 3, 8, 12, 4, 2])) print(sol.findMax([3, 8, 3, 1])) print(sol.findMax([1, 3, 8, 12])) print(sol.findMax([10, 9, 8]))main() Time complexitySince we are reducing the search range by half at every step, this means that the time complexity of our algorithm will be O(logN) where ‘N’ is the total elements in the given array. Space complexityThe algorithm runs in constant space O(1). Problem Challenge 1Design Gurus Educative.io Search Bitonic Array (medium)Given a Bitonic array, find if a given ‘key’ is present in it. An array is considered bitonic if it is monotonically increasing and then monotonically decreasing. Monotonically increasing or decreasing means that for any index i in the array arr[i] != arr[i+1]. Write a function to return the index of the ‘key’. If the ‘key’ is not present, return -1. Example 1: 12Input: [1, 3, 8, 4, 3], key=4Output: 3 Example 2: 12Input: [3, 8, 3, 1], key=8Output: 1 Example 3: 12Input: [1, 3, 8, 12], key=12Output: 3 Example 4: 12Input: [10, 9, 8], key=10Output: 0 SolutionThe problem follows the Binary Search pattern. Since Binary Search helps us efficiently find a number in a sorted array we can use a modified version of the Binary Search to find the ‘key’ in the bitonic array. Here is how we can search in a bitonic array: First, we can find the index of the maximum value of the bitonic array, similar to Bitonic Array Maximum. Let’s call the index of the maximum number maxIndex. Now, we can break the array into two sub-arrays: Array from index ‘0’ to maxIndex, sorted in ascending order. Array from index maxIndex+1 to array_length-1, sorted in descending order. We can then call Binary Search separately in these two arrays to search the ‘key’. We can use the same Order-agnostic Binary Search for searching. CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution: def search(self, arr, key): maxIndex = self.find_max(arr) keyIndex = self.binary_search(arr, key, 0, maxIndex) if keyIndex != -1: return keyIndex # max_index + 1 也可以，如果没有右边的区间，就会返回-1 return self.binary_search(arr, key, maxIndex + 1, len(arr) - 1) # find index of the maximum value in a bitonic array def find_max(self, arr): start, end = 0, len(arr) - 1 while start &lt; end: mid = start + (end - start) // 2 if arr[mid] &gt; arr[mid + 1]: end = mid else: start = mid + 1 # at the end of the while loop, &#x27;start == end&#x27; return start # order-agnostic binary search def binary_search(self, arr, key, start, end): while start &lt;= end: mid = int(start + (end - start) / 2) if key == arr[mid]: return mid if arr[start] &lt; arr[end]: # ascending order if key &lt; arr[mid]: end = mid - 1 else: # key &gt; arr[mid] start = mid + 1 else: # descending order if key &gt; arr[mid]: end = mid - 1 else: # key &lt; arr[mid] start = mid + 1 return -1 # element is not founddef main(): sol = Solution() print(sol.search([1, 3, 8, 4, 3], 4)) print(sol.search([3, 8, 3, 1], 8)) print(sol.search([1, 3, 8, 12], 12)) print(sol.search([10, 9, 8], 10))main() Time complexitySince we are reducing the search range by half at every step, this means that the time complexity of our algorithm will be O(logN) where ‘N’ is the total elements in the given array. Space complexityThe algorithm runs in constant space O(1). Problem Challenge 2Top Interview 150 | 33. Search in Rotated Sorted Array Design Gurus Educative.io Search in Rotated Array (medium)Given an array of numbers which is sorted in ascending order and also rotated by some arbitrary number, find if a given ‘key’ is present in it. Write a function to return the index of the ‘key’ in the rotated array. If the ‘key’ is not present, return -1. You can assume that the given array does not have any duplicates. Example 1: 123Input: [10, 15, 1, 3, 8], key = 15Output: 1Explanation: &#x27;15&#x27; is present in the array at index &#x27;1&#x27;. Example 2: 123Input: [4, 5, 7, 9, 10, -1, 2], key = 10Output: 4Explanation: &#x27;10&#x27; is present in the array at index &#x27;4&#x27;. Constraints: 1 &lt;= arr.length &lt;= 5000 -10^4 &lt;= arr[i] &lt;= 10^4 All values of nums are unique. arr is an ascending array that is possibly rotated. -10^4 &lt;= key &lt;= 10^4 SolutionThe problem follows the Binary Search pattern. We can use a similar approach as discussed in Order-agnostic Binary Search and modify it similar to Search Bitonic Array to search for the ‘key’ in the rotated array. After calculating the middle, we can compare the numbers at indices start and middle. This will give us two options: If arr[start] &lt;= arr[middle], the numbers from start to middle are sorted in ascending order. Else, the numbers from middle+1 to end are sorted in ascending order. Once we know which part of the array is sorted, it is easy to adjust our ranges. For example, if option-1 is true, we have two choices: By comparing the ‘key’ with the numbers at index start and middle we can easily find out if the ‘key’ lies between indices start and middle; if it does, we can skip the second part =&gt; end = middle -1. Else, we can skip the first part =&gt; start = middle + 1. Let’s visually see this with the above-mentioned Example-2: Since there are no duplicates in the given array, it is always easy to skip one part of the array in each iteration. However, if there are duplicates, it is not always possible to know which part is sorted. We will look into this case in the ‘Similar Problems’ section. CodeHere is what our algorithm will look like: 1234567891011121314151617181920212223242526272829303132class Solution: def search(self, arr, key): start, end = 0, len(arr) - 1 while start &lt;= end: mid = start + (end - start) // 2 if arr[mid] == key: return mid # 注意 虽然题目中说没有重复的数字，但是这里还是&lt;= 不然这个用例失败：[3,1] key = 1 if arr[start] &lt;= arr[mid]: # left side is sorted in ascending order if key &gt;= arr[start] and key &lt; arr[mid]: end = mid - 1 else: # key &gt; arr[mid] start = mid + 1 else: # right side is sorted in ascending order if key &gt; arr[mid] and key &lt;= arr[end]: start = mid + 1 else: end = mid - 1 # we are not able to find the element in the given array return -1def main(): sol = Solution() print(sol.search([10, 15, 1, 3, 8], 15)) print(sol.search([4, 5, 7, 9, 10, -1, 2], 10))main() Time complexitySince we are reducing the search range by half at every step, this means that the time complexity of our algorithm will be O(logN) where ‘N’ is the total elements in the given array. Space complexityThe algorithm runs in constant space O(1). Similar ProblemsSimilar | 81. Search in Rotated Sorted Array II Design Gurus Educative.io Problem 1How do we search in a sorted and rotated array that also has duplicates? The code above will fail in the following example! Example 1: 123Input: [3, 7, 3, 3, 3], key = 7Output: 1Explanation: &#x27;7&#x27; is present in the array at index &#x27;1&#x27;. SolutionThe only problematic scenario is when the numbers at indices start, middle, and end are the same, as in this case, we can’t decide which part of the array is sorted. In such a case, the best we can do is to skip one number from both ends: start = start + 1 &amp; end = end - 1. CodeThe code is quite similar to the above solution. Only the highlighted lines have changed: 12345678910111213141516171819202122232425262728293031323334353637class Solution: def search(self, arr, key): start, end = 0, len(arr) - 1 while start &lt;= end: mid = start + (end - start) // 2 if arr[mid] == key: return mid # the only difference from the previous solution, # if numbers at indexes start, mid, and end are same, we can&#x27;t choose a side # the best we can do, is to skip one number from both ends as key != arr[mid] if arr[start] == arr[mid] and arr[end] == arr[mid]: start += 1 end -= 1 elif arr[start] &lt;= arr[mid]: # left side is sorted in ascending order if key &gt;= arr[start] and key &lt; arr[mid]: end = mid - 1 else: # key &gt; arr[mid] start = mid + 1 else: # right side is sorted in ascending order if key &gt; arr[mid] and key &lt;= arr[end]: start = mid + 1 else: end = mid - 1 # we are not able to find the element in the given array return -1def main(): sol = Solution() print(sol.search([3, 7, 3, 3, 3], 7))main() Time complexityThis algorithm will run most of the times in O(logN). However, since we only skip two numbers in case of duplicates instead of half of the numbers, the worst case time complexity will become O(N). Space complexityThe algorithm runs in constant space O(1). Problem Challenge 3Top Interview 150 | 153. Find Minimum in Rotated Sorted Array Design Gurus Educative.io Rotation Count (medium)Given an array of numbers which is sorted in ascending order and is rotated ‘k’ times around a pivot, find ‘k’. You can assume that the array does not have any duplicates. Example 1: 123Input: [10, 15, 1, 3, 8]Output: 2Explanation: The array has been rotated 2 times. Example 2: 123Input: [4, 5, 7, 9, 10, -1, 2]Output: 5Explanation: The array has been rotated 5 times. Example 3: 123Input: [1, 3, 8, 10]Output: 0Explanation: The array has been not been rotated. Constraints: 1 &lt;= arr.length &lt;= 5000 -10^4 &lt;= arr[i] &lt;= 10^4 All values of nums are unique. arr is an ascending array that is possibly rotated. SolutionThis problem follows the Binary Search pattern. We can use a similar strategy as discussed in Search in Rotated Array. In this problem, actually, we are asked to find the index of the minimum element. The number of times the minimum element is moved to the right will be equal to the number of rotations. An interesting fact about the minimum element is that it is the only element in the given array which is smaller than its previous element. Since the array is sorted in ascending order, all other elements are bigger than their previous element. After calculating the middle, we can compare the number at index middle with its previous and next number. This will give us two options: If arr[middle] &gt; arr[middle + 1], then the element at middle + 1 is the smallest. If arr[middle - 1] &gt; arr[middle], then the element at middle is the smallest. To adjust the ranges we can follow the same approach as discussed in Search in Rotated Array. Comparing the numbers at indices start and middle will give us two options: If arr[start] &lt; arr[middle], the numbers from start to middle are sorted. Else, the numbers from middle + 1 to end are sorted. CodeHere is what our algorithm will look like: 1234567891011121314151617181920212223242526272829303132class Solution: def countRotations(self, arr): start, end = 0, len(arr) - 1 while start &lt;= end: # while start &lt; end: # code给的是&lt;,但是上面的&lt;=过了leetcode mid = start + (end - start) // 2 # if mid is greater than the next element if mid &lt; end and arr[mid] &gt; arr[mid + 1]: return mid + 1 # if mid is smaller than the previous element if mid &gt; start and arr[mid - 1] &gt; arr[mid]: return mid if arr[start] &lt; arr[mid]: # left side is sorted, so the pivot is on right side start = mid + 1 else: # right side is sorted, so the pivot is on the left side end = mid - 1 return 0 # the array has not been rotateddef main(): sol = Solution() print(sol.countRotations([10, 15, 1, 3, 8])) print(sol.countRotations([4, 5, 7, 9, 10, -1, 2])) print(sol.countRotations([1, 3, 8, 10]))main() Time complexitySince we are reducing the search range by half at every step, this means that the time complexity of our algorithm will be O(logN) where ‘N’ is the total elements in the given array. Space complexityThe algorithm runs in constant space O(1). Similar Problems没看懂leetcode的例子 | 154. Find Minimum in Rotated Sorted Array II Design Gurus Educative.io Problem 1How do we find the rotation count of a sorted and rotated array that has duplicates too? The above code will fail on the following example! Example 1: 123Input: [3, 3, 7, 3]Output: 3Explanation: The array has been rotated 3 times SolutionWe can follow the same approach as discussed in Search in Rotated Array. The only difference is that before incrementing start or decrementing end, we will check if either of them is the smallest number. 123456789101112131415161718192021222324252627282930313233343536373839class Solution: def countRotations(self, arr): start, end = 0, len(arr) - 1 while start &lt; end: mid = start + (end - start) // 2 # if element at mid is greater than the next element if mid &lt; end and arr[mid] &gt; arr[mid + 1]: return mid + 1 # if element at mid is smaller than the previous element if mid &gt; start and arr[mid - 1] &gt; arr[mid]: return mid # this is the only difference from the previous solution # if numbers at indices start, mid, and end are same, we can&#x27;t choose a side # the best we can do is to skip one number from both ends if they are not the # smallest number if arr[start] == arr[mid] and arr[end] == arr[mid]: if arr[start] &gt; arr[start + 1]: # if element at start+1 is not the smallest return start + 1 start += 1 if arr[end - 1] &gt; arr[end]: # if the element at end is not the smallest return end end -= 1 # left side is sorted, so the pivot is on right side elif arr[start] &lt; arr[mid] or (arr[start] == arr[mid] and arr[mid] &gt; arr[end]): start = mid + 1 else: # right side is sorted, so the pivot is on the left side end = mid - 1 return 0 # the array has not been rotateddef main(): sol = Solution() print(sol.countRotations([3, 3, 7, 3]))main() Time complexityThis algorithm will run in O(logN) most of the times, but since we only skip two numbers in case of duplicates instead of the half of the numbers, therefore the worst case time complexity will become O(N). Space complexityThe algorithm runs in constant space O(1).","categories":[{"name":"Grokking Interview Pattern","slug":"Grokking-Interview-Pattern","permalink":"https://hasuer.github.io/categories/Grokking-Interview-Pattern/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hasuer.github.io/tags/Interview/"}]},{"title":"15. Pattern Subsets","slug":"15. Pattern Subsets","date":"2024-05-15T03:19:01.000Z","updated":"2024-05-28T03:29:16.091Z","comments":true,"path":"15-pattern-subsets/index.html","link":"","permalink":"https://hasuer.github.io/15-pattern-subsets/index.html","excerpt":"","text":"Introduction to Subsets PatternA huge number of coding interview problems involve dealing with Permutations and Combinations of a given set of elements. This pattern describes an efficient Breadth First Search (BFS) approach to handle all these problems. Let’s jump onto our first problem to develop an understanding of this pattern. *Subsets (easy) 78. Subsets Design Gurus Educative.io Problem StatementGiven a set with distinct elements, find all of its distinct subsets. Example 1: 12Input: [1, 3]Output: [], [1], [3], [1,3] Example 2: 12Input: [1, 5, 3]Output: [], [1], [5], [3], [1,5], [1,3], [5,3], [1,5,3] Constraints: 1 &lt;= nums.length &lt;= 10 -10 &lt;= nums[i] &lt;= 10 All the numbers of nums are unique. SolutionTo generate all subsets of the given set, we can use the Breadth First Search (BFS) approach. We can start with an empty set, iterate through all numbers one-by-one, and add them to existing sets to create new subsets. Let’s take the example-2 mentioned above to go through each step of our algorithm: Given set: [1, 5, 3] Start with an empty set: [[]] Add the first number (1) to all the existing subsets to create new subsets: [[], [1]]; Add the second number (5) to all the existing subsets: [[], [1], [5], [1,5]]; Add the third number (3) to all the existing subsets: [[], [1], [5], [1,5], [3], [1,3], [5,3], [1,5,3]]. Here is the visual representation of the above steps: Since the input set has distinct elements, the above steps will ensure that we will not have any duplicate subsets. CodeHere is what our algorithm will look like: 1234567891011121314151617181920212223242526class Solution: def findSubsets(self, nums): subsets = [] # start by adding the empty subset subsets.append([]) for currentNumber in nums: # we will take all existing subsets and insert the current number in them to create # new subsets n = len(subsets) for i in range(n): # create a new subset from the existing subset and insert the current element to it set1 = list(subsets[i]) set1.append(currentNumber) subsets.append(set1) return subsetsdef main(): sol = Solution() print(&quot;Here is the list of subsets: &quot; + str(sol.findSubsets([1, 3]))) print(&quot;Here is the list of subsets: &quot; + str(sol.findSubsets([1, 5, 3])))main() Time complexitySince, in each step, the number of subsets doubles as we add each element to all the existing subsets, the time complexity of the above algorithm is O(2^N), where ‘N’ is the total number of elements in the input set. This also means that, in the end, we will have a total of O(2^N) subsets. Space complexityAll the additional space used by our algorithm is for the output list. Since we will have a total of O(2^N) subsets, the space complexity of our algorithm is also O(2^N). Subsets With Duplicates (easy) 90. Subsets II Design Gurus Educative.io Problem StatementGiven a set of numbers that might contain duplicates, find all of its distinct subsets. Example 1:l9 12Input: [1, 3, 3]Output: [], [1], [3], [1,3], [3,3], [1,3,3] Example 2: 12Input: [1, 5, 3, 3]Output: [], [1], [5], [3], [1,5], [1,3], [5,3], [1,5,3], [3,3], [1,3,3], [3,3,5], [1,5,3,3] Constraints: 1 &lt;= nums.length &lt;= 10 -10 &lt;= nums[i] &lt;= 10 SolutionThis problem follows the Subsets pattern and we can follow a similar Breadth First Search (BFS) approach. The only additional thing we need to do is handle duplicates. Since the given set can have duplicate numbers, if we follow the same approach discussed in Subsets, we will end up with duplicate subsets, which is not acceptable. To handle this, we will do two extra things: Sort all numbers of the given set. This will ensure that all duplicate numbers are next to each other. Follow the same BFS approach but whenever we are about to process a duplicate (i.e., when the current and the previous numbers are same), instead of adding the current number (which is a duplicate) to all the existing subsets, only add it to the subsets which were created in the previous step. Let’s take Example-2 mentioned above to go through each step of our algorithm: 12Given set: [1, 5, 3, 3] Sorted set: [1, 3, 3, 5] Start with an empty set: [[]] Add the first number (1) to all the existing subsets to create new subsets: [[], [1]]; Add the second number (3) to all the existing subsets: [[], [1], [3], [1,3]]. The next number (3) is a duplicate. If we add it to all existing subsets we will get: 123 [[], [1], [3], [1,3], [3], [1,3], [3,3], [1,3,3]]We got two duplicate subsets: [3], [1,3] Whereas we only needed the new subsets: [3,3], [1,3,3] To handle this instead of adding (3) to all the existing subsets, we only add it to the new subsets which were created in the previous (3rd) step: 1[[], [1], [3], [1,3], [3,3], [1,3,3]] Finally, add the forth number (5) to all the existing subsets: [[], [1], [3], [1,3], [3,3], [1,3,3], [5], [1,5], [3,5], [1,3,5], [3,3,5], [1,3,3,5]] Here is the visual representation of the above steps: CodeHere is what our algorithm will look like: 12345678910111213141516171819202122232425262728293031class Solution: def findSubsets(self, nums): # sort the numbers to handle duplicates list.sort(nums) # 或者nums.sort() subsets = [] subsets.append([]) start_index, end_index = 0, 1 # 表示上一步中加入到subsets中的元素的start和end+1 for i in range(len(nums)): startIndex = 0 # 每次都要重置 # if current and the previous elements are same, create new subsets only from the # subsets added in the previous step if i &gt; 0 and nums[i] == nums[i - 1]: startIndex = endIndex endIndex = len(subsets) for j in range(startIndex, endIndex): # 这里的list很重要，这样才是重新复制了一个 # create a new subset from the existing subset and add the current element to it set1 = list(subsets[j]) set1.append(nums[i]) subsets.append(set1) return subsetsdef main(): sol = Solution() print(&quot;Here is the list of subsets: &quot; + str(sol.findSubsets([1, 3, 3]))) print(&quot;Here is the list of subsets: &quot; + str(sol.findSubsets([1, 5, 3, 3])))main() Time complexitySince, in each step, the number of subsets could double (if not duplicate) as we add each element to all the existing subsets, the time complexity of the above algorithm is O(2^N), where ‘N’ is the total number of elements in the input set. This also means that, in the end, we will have a total of O(2^N) subsets at the most. Space complexityAll the additional space used by our algorithm is for the output list. Since at most we will have a total of O(2^N) subsets, the space complexity of our algorithm is also O(2^N). *Permutations (medium)Top Interview 150 | 46. Permutations Design Gurus Educative.io Problem StatementGiven a set of distinct numbers, find all of its permutations. Permutation is defined as the re-arranging of the elements of the set. For example, {1, 2, 3} has the following six permutations: {1, 2, 3} {1, 3, 2} {2, 1, 3} {2, 3, 1} {3, 1, 2} {3, 2, 1} If a set has ‘n’ distinct elements it will have n!n! permutations. Example 1: 12Input: [1,3,5]Output: [1,3,5], [1,5,3], [3,1,5], [3,5,1], [5,1,3], [5,3,1] Constraints: 1 &lt;= nums.length &lt;= 6 -10 &lt;= nums[i] &lt;= 10 All the numbers of nums are unique. SolutionThis problem follows the Subsets pattern and we can follow a similar Breadth First Search (BFS) approach. However, unlike Subsets, every permutation must contain all the numbers. Let’s take the example-1 mentioned above to generate all the permutations. Following a BFS approach, we will consider one number at a time: If the given set is empty then we have only an empty permutation set: [] Let’s add the first element (1), the permutations will be: [1] Let’s add the second element (3), the permutations will be: [3,1], [1,3] Let’s add the third element (5), the permutations will be: [5,3,1], [3,5,1], [3,1,5], [5,1,3], [1,5,3], [1,3,5] Let’s analyze the permutations in the 3rd and 4th step. How can we generate permutations in the 4th step from the permutations of the 3rd step? If we look closely, we will realize that when we add a new number (5), we take each permutation of the previous step and insert the new number in every position to generate the new permutations. For example, inserting ‘5’ in different positions of [3,1] will give us the following permutations: Inserting ‘5’ before ‘3’: [5,3,1] Inserting ‘5’ between ‘3’ and ‘1’: [3,5,1] Inserting ‘5’ after ‘1’: [3,1,5] Here is the visual representation of this algorithm: CodeHere is what our algorithm will look like: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# 觉得的solution code有可以优化的地方，也过了leetcodefrom collections import dequeclass Solution: def findPermutations(self, nums): permutations = deque() permutations.append([]) for currentNumber in nums: # we will take all existing permutations and add the current number to create # new permutations n = len(permutations) for _ in range(n): oldPermutation = permutations.popleft() # 这里的+1要记得写上，不然会有问题 # create a new permutation by adding the current number at every position for j in range(len(oldPermutation) + 1): newPermutation = list(oldPermutation) newPermutation.insert(j, currentNumber) permutations.append(newPermutation) return permutationsdef main(): sol = Solution() print(&quot;Here are all the permutations: &quot; + str(sol.findPermutations([1, 3, 5])))main()# 官方版本from collections import dequeclass Solution: def findPermutations(self, nums): numsLength = len(nums) result = [] permutations = deque() permutations.append([]) for currentNumber in nums: # we will take all existing permutations and add the current number to create # new permutations n = len(permutations) for _ in range(n): oldPermutation = permutations.popleft() # 这里的+1要记得写上，不然会有问题 # create a new permutation by adding the current number at every position for j in range(len(oldPermutation) + 1): newPermutation = list(oldPermutation) newPermutation.insert(j, currentNumber) # 这里如果直接放到permutations里面，最后返回的时候，permutations里的就是答案 # 所以其实没有必要再用一个result,这样可以节约空间复杂度 if len(newPermutation) == numsLength: result.append(newPermutation) else: permutations.append(newPermutation) return resultdef main(): sol = Solution() print(&quot;Here are all the permutations: &quot; + str(sol.findPermutations([1, 3, 5])))main() Time complexityWe know that there are a total of N!N! permutations of a set with ‘N’ numbers. In the algorithm above, we are iterating through all of these permutations with the help of the two ‘for’ loops. In each iteration, we go through all the current permutations to insert a new number in them on line 17 (line 23 for C++ solution). To insert a number into a permutation of size ‘N’ will take O(N), which makes the overall time complexity of our algorithm O(N\\N!)*. Space complexityAll the additional space used by our algorithm is for the result list and the queue to store the intermediate permutations. If you see closely, at any time, we don’t have more than N!N! permutations between the result list and the queue. Therefore the overall space complexity to store N!N! permutations each containing NN elements will be O(N\\N!)*. Recursive SolutionHere is the recursive algorithm following a similar approach: 12345678910111213141516171819202122232425class Solution: def generate_permutations(self, nums): result = [] self.generate_permutations_recursive(nums, 0, [], result) return result def generate_permutations_recursive(self, nums, index, currentPermutation, result): if index == len(nums): result.append(currentPermutation) else: # create a new permutation by adding the current number at every position for i in range(len(currentPermutation) + 1): newPermutation = list(currentPermutation) newPermutation.insert(i, nums[index]) self.generate_permutations_recursive( nums, index + 1, newPermutation, result)def main(): sol = Solution() print(&quot;Here are all the permutations: &quot; + str(sol.generate_permutations([1, 3, 5])))main() String Permutations by changing case (medium)784. Letter Case Permutation Design Gurus Educative.io Problem StatementGiven a string, find all of its permutations preserving the character sequence but changing case. Example 1: 12Input: &quot;ad52&quot;Output: &quot;ad52&quot;, &quot;Ad52&quot;, &quot;aD52&quot;, &quot;AD52&quot; Example 2: 12Input: &quot;ab7c&quot;Output: &quot;ab7c&quot;, &quot;Ab7c&quot;, &quot;aB7c&quot;, &quot;AB7c&quot;, &quot;ab7C&quot;, &quot;Ab7C&quot;, &quot;aB7C&quot;, &quot;AB7C&quot; Constraints: 1 &lt;= str.length &lt;= 12 str consists of lowercase English letters, uppercase English letters, and digits. SolutionThis problem follows the Subsets pattern and can be mapped to Permutations. Let’s take Example-2 mentioned above to generate all the permutations. Following a BFS approach, we will consider one character at a time. Since we need to preserve the character sequence, we can start with the actual string and process each character (i.e., make it upper-case or lower-case) one by one: Starting with the actual string: &quot;ab7c&quot; Processing the first character (‘a’), we will get two permutations: &quot;ab7c&quot;, &quot;Ab7c&quot; Processing the second character (‘b’), we will get four permutations: &quot;ab7c&quot;, &quot;Ab7c&quot;, &quot;aB7c&quot;, &quot;AB7c&quot; Since the third character is a digit, we can skip it. Processing the fourth character (‘c’), we will get a total of eight permutations: &quot;ab7c&quot;, &quot;Ab7c&quot;, &quot;aB7c&quot;, &quot;AB7c&quot;, &quot;ab7C&quot;, &quot;Ab7C&quot;, &quot;aB7C&quot;, &quot;AB7C&quot; Let’s analyze the permutations in the 3rd and the 5th step. How can we generate the permutations in the 5th step from the permutations in the 3rd step? If we look closely, we will realize that in the 5th step, when we processed the new character (‘c’), we took all the permutations of the previous step (3rd) and changed the case of the letter (‘c’) in them to create four new permutations. Here is the visual representation of this algorithm: CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233class Solution: def findLetterCaseStringPermutations(self, str): permutations = [string] # 下面两句等于这句 # permutations = [] # permutations.append(string) # process every character of the string one by one for i in range(len(str)): if str[i].isalpha(): # only process characters, skip digits # we will take all existing permutations and change the letter case appropriately n = len(permutations) for j in range(n): chs = list(permutations[j]) # if the current char is in upper case, change it to lower case or vice versa chs[i] = chs[i].swapcase() permutations.append(&#x27;&#x27;.join(chs)) # 原来打算这么写，但是python中不允许str[i] = char这样修改,TypeError: &#x27;str&#x27; object does not support item assignment # python没有字符的概念print(type(&#x27;1&#x27;)) =&gt; &lt;class &#x27;str&#x27;&gt; # new_string = permutations[j] # new_string[i] = new_string[i].swapcase() # permutations.append(new_string) return permutationsdef main(): sol = Solution() print(&quot;String permutations are: &quot; + str(sol.findLetterCaseStringPermutations(&quot;ad52&quot;))) print(&quot;String permutations are: &quot; + str(sol.findLetterCaseStringPermutations(&quot;ab7c&quot;)))main() Time complexitySince we can have 2^N permutations at the most and while processing each permutation we convert it into a character array, the overall time complexity of the algorithm will be O(N\\2^N)*. Space complexityAll the additional space used by our algorithm is for the output list. Since we can have a total of O(2^N) permutations, the space complexity of our algorithm is O(N\\2^N)*. *Balanced Parentheses (hard)Top Interview 150 | 22. Generate Parentheses Design Gurus Educative.io Problem StatementFor a given number ‘N’, write a function to generate all combination of ‘N’ pairs of balanced parentheses. Example 1: 12Input: N=2Output: (()), ()() Example 2: 12Input: N=3Output: ((())), (()()), (())(), ()(()), ()()() Constraints: 1 &lt;= n &lt;= 8 SolutionThis problem follows the Subsets pattern and can be mapped to Permutations. We can follow a similar BFS approach. Let’s take Example-2 mentioned above to generate all the combinations of balanced parentheses. Following a BFS approach, we will keep adding open parentheses ( or close parentheses ). At each step we need to keep two things in mind: We can’t add more than ‘N’ open parenthesis. To keep the parentheses balanced, we can add a close parenthesis ) only when we have already added enough open parenthesis (. For this, we can keep a count of open and close parenthesis with every combination. Following this guideline, let’s generate parentheses for N=3: Start with an empty combination: “” At every step, let’s take all combinations of the previous step and add ( or ) keeping the above-mentioned two rules in mind. For the empty combination, we can add ( since the count of open parenthesis will be less than ‘N’. We can’t add ) as we don’t have an equivalent open parenthesis, so our list of combinations will now be: “(” For the next iteration, let’s take all combinations of the previous set. For “(” we can add another ( to it since the count of open parenthesis will be less than ‘N’. We can also add ) as we do have an equivalent open parenthesis, so our list of combinations will be: “((”, “()” In the next iteration, for the first combination “((”, we can add another ( to it as the count of open parenthesis will be less than ‘N’, we can also add ) as we do have an equivalent open parenthesis. This gives us two new combinations: “(((” and “(()”. For the second combination “()”, we can add another ( to it since the count of open parenthesis will be less than ‘N’. We can’t add ) as we don’t have an equivalent open parenthesis, so our list of combinations will be: “(((”, “(()”, ()(“ Following the same approach, next we will get the following list of combinations: “((()”, “(()(”, “(())”, “()((”, “()()” Next we will get: “((())”, “(()()”, “(())(”, “()(()”, “()()(” Finally, we will have the following combinations of balanced parentheses: “((()))”, “(()())”, “(())()”, “()(())”, “()()()” We can’t add more parentheses to any of the combinations, so we stop here. Here is the visual representation of this algorithm: CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233343536373839404142from collections import dequeclass ParenthesesString: def __init__(self, str, openCount, closeCount): self.str = str self.openCount = openCount self.closeCount = closeCountclass Solution: def generateValidParentheses(self, num): result = [] queue = deque() queue.append(ParenthesesString(&quot;&quot;, 0, 0)) while queue: ps = queue.popleft() # if we&#x27;ve reached the maximum number of open and close parentheses, add to result if ps.openCount == num and ps.closeCount == num: result.append(ps.str) else: if ps.openCount &lt; num: # if we can add an open parentheses, add it queue.append(ParenthesesString( ps.str + &quot;(&quot;, ps.openCount + 1, ps.closeCount)) if ps.openCount &gt; ps.closeCount: # if we can add a close parentheses, add it queue.append(ParenthesesString(ps.str + &quot;)&quot;, ps.openCount, ps.closeCount + 1)) return resultdef main(): sol = Solution() print(&quot;All combinations of balanced parentheses are: &quot; + str(sol.generateValidParentheses(2))) print(&quot;All combinations of balanced parentheses are: &quot; + str(sol.generateValidParentheses(3)))main() Time complexityLet’s try to estimate how many combinations we can have for ‘N’ pairs of balanced parentheses. If we don’t care for the ordering - that ) can only come after ( - then we have two options for every position, i.e., either put open parentheses or close parentheses. This means we can have a maximum of 2^N combinations. Because of the ordering, the actual number will be less than 2^N. If you see the visual representation of Example-2 closely you will realize that, in the worst case, it is equivalent to a binary tree, where each node will have two children. This means that we will have 2^N leaf nodes and 2^N-1 intermediate nodes. So the total number of elements pushed to the queue will be 2^N + 2^N-1, which is asymptotically equivalent to O(2^N). While processing each element, we do need to concatenate the current string with ( or ). This operation will take O(N), so the overall time complexity of our algorithm will be O(N2^N)*. This is not completely accurate but reasonable enough to be presented in the interview. The actual time complexity O(4n/√n)* is bounded by the Catalan number and is beyond the scope of a coding interview. See more details here. Space complexityAll the additional space used by our algorithm is for the output list. Since we can’t have more than O(2^N) combinations, the space complexity of our algorithm is O(N \\2^N)*. Recursive SolutionHere is the recursive algorithm following a similar approach: 1234567891011121314151617181920212223242526272829303132333435class Solution: def generateValidParenthese(self, num): result = [] parenthesesString = [0 for x in range(2 * num)] self.generate_valid_parentheses_rec(num, 0, 0, parenthesesString, 0, result) return result def generate_valid_parentheses_rec(self, num, openCount, closeCount, parenthesesString, index, result): # if we&#x27;ve reached the maximum number of open and close parentheses, add to the result if openCount == num and closeCount == num: result.append(&#x27;&#x27;.join(parenthesesString)) else: if openCount &lt; num: # if we can add an open parentheses, add it parenthesesString[index] = &#x27;(&#x27; self.generate_valid_parentheses_rec( num, openCount + 1, closeCount, parenthesesString, index + 1, result) if openCount &gt; closeCount: # if we can add a close parentheses, add it parenthesesString[index] = &#x27;)&#x27; self.generate_valid_parentheses_rec( num, openCount, closeCount + 1, parenthesesString, index + 1, result)def main(): sol = Solution() print(&quot;All combinations of balanced parentheses are: &quot; + str(sol.generateValidParenthese(2))) print(&quot;All combinations of balanced parentheses are: &quot; + str(sol.generateValidParenthese(3)))main() #Unique Generalized Abbreviations (hard)Leetcode 320 Design Gurus Educative.io Problem StatementGiven a word, write a function to generate all of its unique generalized abbreviations. A generalized abbreviation of a word can be generated by replacing each substring of the word with the count of characters in the substring. Take the example of “ab” which has four substrings: “”, “a”, “b”, and “ab”. After replacing these substrings in the actual word by the count of characters, we get all the generalized abbreviations: “ab”, “1b”, “a1”, and “2”. Note: All contiguous characters should be considered one substring, e.g., we can’t take “a” and “b” as substrings to get “11”; since “a” and “b” are contiguous, we should consider them together as one substring to get an abbreviation “2”. Example 1: 12Input: &quot;BAT&quot;Output: &quot;BAT&quot;, &quot;BA1&quot;, &quot;B1T&quot;, &quot;B2&quot;, &quot;1AT&quot;, &quot;1A1&quot;, &quot;2T&quot;, &quot;3&quot; Example 2: 123Input: &quot;code&quot;Output: &quot;code&quot;, &quot;cod1&quot;, &quot;co1e&quot;, &quot;co2&quot;, &quot;c1de&quot;, &quot;c1d1&quot;, &quot;c2e&quot;, &quot;c3&quot;, &quot;1ode&quot;, &quot;1od1&quot;, &quot;1o1e&quot;, &quot;1o2&quot;, &quot;2de&quot;, &quot;2d1&quot;, &quot;3e&quot;, &quot;4&quot; Constraints: 1 &lt;= word.length &lt;= 15 word consists of only lowercase English letters. SolutionThis problem follows the Subsets pattern and can be mapped to Balanced Parentheses. We can follow a similar BFS approach. Let’s take Example-1 mentioned above to generate all unique generalized abbreviations. Following a BFS approach, we will abbreviate one character at a time. At each step we have two options: Abbreviate the current character, or Add the current character to the output and skip abbreviation. Following these two rules, let’s abbreviate BAT: Start with an empty word: “” At every step, we will take all the combinations from the previous step and apply the two abbreviation rules to the next character. Take the empty word from the previous step and add the first character to it. We can either abbreviate the character or add it (by skipping abbreviation). This gives us two new words: _, B. In the next iteration, let’s add the second character. Applying the two rules on _ will give us _ _ and 1A. Applying the above rules to the other combination B gives us B_ and BA. The next iteration will give us: _ _ _, 2T, 1A_, 1AT, B _ _, B1T, BA_, BAT The final iteration will give us:3, 2T, 1A1, 1AT, B2, B1T, BA1, BAT Here is the visual representation of this algorithm: CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from collections import dequeclass AbbreviatedWord: def __init__(self, str, start, count): self.str = str self.start = start # 表示遍历到单词的index self.count = count # 表示到目前为止有几个单词被压缩了并且还没有被处理为数字的class Solution: def generateGeneralizedAbbreviation(self, word): wordLen = len(word) result = [] queue = deque() queue.append(AbbreviatedWord(list(), 0, 0)) # 这里因为对于queue中的每一个元素都要根据自己的元素属性（被压缩的字符个数），所以使用while queue作为条件 # 而没有像之前一样使用for i in range()来循环 while queue: abWord = queue.popleft() if abWord.start == wordLen: if abWord.count != 0: abWord.str.append(str(abWord.count)) result.append(&#x27;&#x27;.join(abWord.str)) else: # continue abbreviating by incrementing the current abbreviation count queue.append(AbbreviatedWord(list(abWord.str), abWord.start + 1, abWord.count + 1)) # restart abbreviating, append the count and the current character to the string if abWord.count != 0: abWord.str.append(str(abWord.count)) newWord = list(abWord.str) newWord.append(word[abWord.start]) queue.append(AbbreviatedWord(newWord, abWord.start + 1, 0)) return resultdef main(): sol = Solution() print(&quot;Generalized abbreviation are: &quot; + str(sol.generateGeneralizedAbbreviation(&quot;BAT&quot;))) print(&quot;Generalized abbreviation are: &quot; + str(sol.generateGeneralizedAbbreviation(&quot;code&quot;)))main() Time complexitySince we had two options for each character, we will have a maximum of 2^N combinations. If you see the visual representation of Example-1 closely you will realize that it is equivalent to a binary tree, where each node has two children. This means that we will have 2^N leaf nodes and 2^N-1 intermediate nodes, so the total number of elements pushed to the queue will be 2^N + 2^N-1, which is asymptotically equivalent to O(2^N). While processing each element, we do need to concatenate the current string with a character. This operation will take O(N), so the overall time complexity of our algorithm will be O(N\\2^N)*. Space complexityAll the additional space used by our algorithm is for the output list. Since we can’t have more than O(2^N) combinations, the space complexity of our algorithm is O(N2^N)*. Recursive SolutionHere is the recursive algorithm following a similar approach: 1234567891011121314151617181920212223242526272829303132333435class Solution: def generateGeneralizedAbbreviation(self, word): result = [] self.generate_abbreviation_recursive(word, list(), 0, 0, result) return result def generate_abbreviation_recursive(self, word, abWord, start, count, result): if start == len(word): if count != 0: abWord.append(str(count)) result.append(&#x27;&#x27;.join(abWord)) else: # continue abbreviating by incrementing the current abbreviation count self.generate_abbreviation_recursive( word, list(abWord), start + 1, count + 1, result) # restart abbreviating, append the count and the current character to the string if count != 0: abWord.append(str(count)) newWord = list(abWord) newWord.append(word[start]) self.generate_abbreviation_recursive(word, newWord, start + 1, 0, result)def main(): sol = Solution() print(&quot;Generalized abbreviation are: &quot; + str(sol.generateGeneralizedAbbreviation(&quot;BAT&quot;))) print(&quot;Generalized abbreviation are: &quot; + str(sol.generateGeneralizedAbbreviation(&quot;code&quot;)))main() *Problem Challenge 1241. Different Ways to Add Parentheses Design Gurus Educative.io Evaluate Expression (hard)Given an expression containing digits and operations (+, -, *), find all possible ways in which the expression can be evaluated by grouping the numbers and operators using parentheses. Example 1: 12345Input: &quot;1+2*3&quot;Output: 7, 9Explanation: 1+(2*3) =&gt; 7 (1+2)*3 =&gt; 9 Example 2: 12345678Input: &quot;2*3-4-5&quot;Output: 8, -12, 7, -7, -3 Explanation: 2*(3-(4-5)) =&gt; 8 2*(3-4-5) =&gt; -12 2*3-(4-5) =&gt; 7 2*(3-4)-5 =&gt; -7 (2*3)-4-5 =&gt; -3 SolutionThis problem follows the Subsets pattern and can be mapped to Balanced Parentheses. We can follow a similar BFS approach. Let’s take Example-1 mentioned above to generate different ways to evaluate the expression. We can iterate through the expression character-by-character. we can break the expression into two halves whenever we get an operator (+, -, *). The two parts can be calculated by recursively calling the function. Once we have the evaluation results from the left and right halves, we can combine them to produce all results. CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233343536class Solution: def diffWaysToEvaluateExpression(self, input): result = [] # base case: if the input string is a number, parse and add it to output. if &#x27;+&#x27; not in input and &#x27;-&#x27; not in input and &#x27;*&#x27; not in input: result.append(int(input)) else: for i in range(0, len(input)): char = input[i] if not char.isdigit(): # break the equation here into two parts and make recursively calls leftParts = self.diffWaysToEvaluateExpression(input[0:i]) rightParts = self.diffWaysToEvaluateExpression(input[i + 1:]) for part1 in leftParts: for part2 in rightParts: if char == &#x27;+&#x27;: result.append(part1 + part2) elif char == &#x27;-&#x27;: result.append(part1 - part2) elif char == &#x27;*&#x27;: result.append(part1 * part2) return resultdef main(): sol = Solution() print(&quot;Expression evaluations: &quot; + str(sol.diffWaysToEvaluateExpression(&quot;1+2*3&quot;))) print(&quot;Expression evaluations: &quot; + str(sol.diffWaysToEvaluateExpression(&quot;2*3-4-5&quot;)))main() Time complexityThe time complexity of this algorithm will be exponential and will be similar to Balanced Parentheses. Estimated time complexity will be O(N\\2^N)* but the actual time complexity O(4n/√n) is bounded by the Catalan number and is beyond the scope of a coding interview. See more details here. Space complexityThe space complexity of this algorithm will also be exponential, estimated at O(2^N) though the actual will be O(4n/√n). Memoized versionThe problem has overlapping subproblems, as our recursive calls can be evaluating the same sub-expression multiple times. To resolve this, we can use memoization and store the intermediate results in a HashMap. In each function call, we can check our map to see if we have already evaluated this sub-expression before. Here is the memoized version of our algorithm; please see highlighted changes: 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution: def diffWaysToEvaluateExpression(self, input): return self.diff_ways_to_evaluate_expression_rec(&#123;&#125;, input) def diff_ways_to_evaluate_expression_rec(self, map, input): if input in map: return map[input] result = [] # base case: if the input string is a number, parse and return it. if &#x27;+&#x27; not in input and &#x27;-&#x27; not in input and &#x27;*&#x27; not in input: result.append(int(input)) else: for i in range(0, len(input)): char = input[i] if not char.isdigit(): # break the equation here into two parts and make recursively calls leftParts = self.diff_ways_to_evaluate_expression_rec( map, input[0:i]) rightParts = self.diff_ways_to_evaluate_expression_rec( map, input[i + 1:]) for part1 in leftParts: for part2 in rightParts: if char == &#x27;+&#x27;: result.append(part1 + part2) elif char == &#x27;-&#x27;: result.append(part1 - part2) elif char == &#x27;*&#x27;: result.append(part1 * part2) map[input] = result return resultdef main(): sol = Solution() print(&quot;Expression evaluations: &quot; + str(sol.diffWaysToEvaluateExpression(&quot;1+2*3&quot;))) print(&quot;Expression evaluations: &quot; + str(sol.diffWaysToEvaluateExpression(&quot;2*3-4-5&quot;)))main() Problem Challenge 295. Unique Binary Search Trees II Design Gurus Educative.io Structurally Unique Binary Search Trees (hard)Given a number ‘n’, write a function to return all structurally unique Binary Search Trees (BST) that can store values 1 to ‘n’? Example 1: 123Input: 2Output: 2Explanation: Here are all the structurally unique BSTs storing all numbers from 1 to 2: Example 2: 123Input: 3Output: 5Explanation: Here are all the structurally unique BSTs storing all numbers from 1 to 3: Constraints: 1 &lt;= n &lt;= 19 SolutionThis problem follows the Subsets pattern and is quite similar to Evaluate Expression. Following a similar approach, we can iterate from 1 to ‘n’ and consider each number as the root of a tree. All smaller numbers will make up the left sub-tree and bigger numbers will make up the right sub-tree. We will make recursive calls for the left and right sub-trees CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233343536373839404142434445# class TreeNode:# def __init__(self, val):# self.val = val# self.left = None# self.right = Noneclass Solution: def findUniqueTrees(self, n): if n &lt;= 0: return [] return self.findUnique_trees_recursive(1, n) def findUnique_trees_recursive(self, start, end): result = [] # base condition, return &#x27;None&#x27; for an empty sub-tree # consider n = 1, in this case we will have start = end = 1, this means we should have # only one tree we will have two recursive calls, findUniqueTreesRecursive(1, 0) &amp; # (2, 1) both of these should return &#x27;None&#x27; for the left and the right child if start &gt; end: result.append(None) return result for i in range(start, end + 1): # making &#x27;i&#x27; the root of the tree leftSubtrees = self.findUnique_trees_recursive(start, i - 1) rightSubtrees = self.findUnique_trees_recursive(i + 1, end) for leftTree in leftSubtrees: for rightTree in rightSubtrees: root = TreeNode(i) root.left = leftTree root.right = rightTree result.append(root) return resultdef main(): sol = Solution() print(&quot;Total trees: &quot; + str(len(sol.findUniqueTrees(2)))) print(&quot;Total trees: &quot; + str(len(sol.findUniqueTrees(3))))main() Time complexityThe time complexity of this algorithm will be exponential and will be similar to Balanced Parentheses. Estimated time complexity will be O(n\\2^n)* but the actual time complexity O(4n/√n) is bounded by the Catalan number and is beyond the scope of a coding interview. See more details here. Space complexityThe space complexity of this algorithm will be exponential too, estimated at O(2^n), but the actual will be O(4n/√n). Memoized versionSince our algorithm has overlapping subproblems, can we use memoization to improve it? We could, but every time we return the result of a subproblem from the cache, we have to clone the result list because these trees will be used as the left or right child of a tree. This cloning is equivalent to reconstructing the trees, therefore, the overall time complexity of the memoized algorithm will also be the same. Problem Challenge 396. Unique Binary Search Trees Design Gurus Educative.io Count of Structurally Unique Binary Search Trees (hard)Given a number ‘n’, write a function to return the count of structurally unique Binary Search Trees (BST) that can store values 1 to ‘n’. Example 1: 123Input: 2Output: 2Explanation: As we saw in the previous problem, there are 2 unique BSTs storing numbers from 1-2. Example 2: 123Input: 3Output: 5Explanation: There will be 5 unique BSTs that can store numbers from 1 to 5. Constraints: 1 &lt;= n &lt;= 8 SolutionThis problem is similar to Structurally Unique Binary Search Trees. Following a similar approach, we can iterate from 1 to ‘n’ and consider each number as the root of a tree and make two recursive calls to count the number of left and right sub-trees. CodeHere is what our algorithm will look like: 1234567891011121314151617181920212223242526272829303132333435# 这道题和上道题有一点区别，这道题只是要求返回个数就可以。# 上一道题还要求返回对应的结构# 这道题用上面一道题目的代码也是完全可以的,但是会空间超限# 最后返回的数组的大小就是答案# class TreeNode:# def __init__(self, val):# self.val = val# self.left = None# self.right = Noneclass Solution: def countTrees(self, n): if n &lt;= 1: return 1 count = 0 for i in range(1, n + 1): # making &#x27;i&#x27; root of the tree countOfLeftSubtrees = self.countTrees(i - 1) countOfRightSubtrees = self.countTrees(n - i) count += (countOfLeftSubtrees * countOfRightSubtrees) return countdef main(): sol = Solution() print(&quot;Total trees: &quot; + str(sol.countTrees(2))) print(&quot;Total trees: &quot; + str(sol.countTrees(3)))main() Time complexityThe time complexity of this algorithm will be exponential and will be similar to Balanced Parentheses. Estimated time complexity will be O(n2^n)O(n∗2n) but the actual time complexity O(4n/√n)* is bounded by the Catalan number and is beyond the scope of a coding interview. See more details here. Space complexityThe space complexity of this algorithm will be exponential too, estimated O(2^n) but the actual will be O(4n/√n). Memoized versionOur algorithm has overlapping subproblems as our recursive call will be evaluating the same sub-expression multiple times. To resolve this, we can use memoization and store the intermediate results in a HashMap. In each function call, we can check our map to see if we have already evaluated this sub-expression before. Here is the memoized version of our algorithm, please see highlighted changes: 123456789101112131415161718192021222324252627282930313233343536# class TreeNode:# def __init__(self, val):# self.val = val# self.left = None# self.right = Noneclass Solution: def countTrees(self, n): return self.count_trees_rec(&#123;&#125;, n) def count_trees_rec(self, map, n): if n in map: return map[n] if n &lt;= 1: return 1 count = 0 for i in range(1, n + 1): # making &#x27;i&#x27; the root of the tree countOfLeftSubtrees = self.count_trees_rec(map, i - 1) countOfRightSubtrees = self.count_trees_rec(map, n - i) count += (countOfLeftSubtrees * countOfRightSubtrees) map[n] = count return countdef main(): sol = Solution() print(&quot;Total trees: &quot; + str(sol.countTrees(2))) print(&quot;Total trees: &quot; + str(sol.countTrees(3)))main()","categories":[{"name":"Grokking Interview Pattern","slug":"Grokking-Interview-Pattern","permalink":"https://hasuer.github.io/categories/Grokking-Interview-Pattern/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hasuer.github.io/tags/Interview/"}]},{"title":"14. Pattern Two Heaps","slug":"14. Pattern Two Heaps","date":"2024-05-14T01:44:26.000Z","updated":"2024-05-28T03:29:05.289Z","comments":true,"path":"14-pattern-two-heaps/index.html","link":"","permalink":"https://hasuer.github.io/14-pattern-two-heaps/index.html","excerpt":"","text":"IntroductionIn many problems, where we are given a set of elements such that we can divide them into two parts. To solve the problem, we are interested in knowing the smallest element in one part and the biggest element in the other part. This pattern is an efficient approach to solve such problems. This pattern uses two Heaps to solve these problems; A Min Heap to find the smallest element and a Max Heap to find the biggest element. Let’s jump onto our first problem to see this pattern in action. Find the Median of a Number Stream (medium)Top Interview 150 | 295. Find Median from Data Stream Design Gurus Educative.io IntroductionProblem StatementDesign a class to calculate the median of a number stream. The class should have the following two methods: insertNum(int num): stores the number in the class findMedian(): returns the median of all numbers inserted in the class If the count of numbers inserted in the class is even, the median will be the average of the middle two numbers. Example 1: 12345671. insertNum(3)2. insertNum(1)3. findMedian() -&gt; output: 24. insertNum(5)5. findMedian() -&gt; output: 36. insertNum(4)7. findMedian() -&gt; output: 3.5 Constraints: -10^5 &lt;= num &lt;= 10^5 There will be at least one element in the data structure before calling findMedian. At most 5 * 10^4 calls will be made to insertNum and findMedian. SolutionAs we know, the median is the middle value in an ordered integer list. So a brute force solution could be to maintain a sorted list of all numbers inserted in the class so that we can efficiently return the median whenever required. Inserting a number in a sorted list will take O(N) time if there are ‘N’ numbers in the list. This insertion will be similar to the Insertion sort. Can we do better than this? Can we utilize the fact that we don’t need the fully sorted list - we are only interested in finding the middle element? Assume ‘x’ is the median of a list. This means that half of the numbers in the list will be smaller than (or equal to) ‘x’ and half will be greater than (or equal to) ‘x’. This leads us to an approach where we can divide the list into two halves: one half to store all the smaller numbers (let’s call it smallNumList) and one half to store the larger numbers (let’s call it largNumList). The median of all the numbers will either be the largest number in the smallNumList or the smallest number in the largNumList. If the total number of elements is even, the median will be the average of these two numbers. The best data structure that comes to mind to find the smallest or largest number among a list of numbers is a Heap). Let’s see how we can use a heap to find a better algorithm. We can store the first half of numbers (i.e., smallNumList) in a Max Heap. We should use a Max Heap as we are interested in knowing the largest number in the first half. We can store the second half of numbers (i.e., largeNumList) in a Min Heap, as we are interested in knowing the smallest number in the second half. Inserting a number in a heap will take O(logN), which is better than the brute force approach. At any time, the median of the current list of numbers can be calculated from the top element of the two heaps. Let’s take the Example-1 mentioned above to go through each step of our algorithm: insertNum(3): We can insert a number in the Max Heap (i.e. first half) if the number is smaller than the top (largest) number of the heap. After every insertion, we will balance the number of elements in both heaps, so that they have an equal number of elements. If the count of numbers is odd, let’s decide to have more numbers in max-heap than the Min Heap. insertNum(1): As ‘1’ is smaller than ‘3’, let’s insert it into the Max Heap. Now, we have two elements in the Max Heap and no elements in Min Heap. Let’s take the largest element from the Max Heap and insert it into the Min Heap, to balance the number of elements in both heaps. findMedian(): As we have an even number of elements, the median will be the average of the top element of both the heaps -&gt; (1+3)/2 = 2.0(1+3)/2=2.0 insertNum(5): As ‘5’ is greater than the top element of the Max Heap, we can insert it into the Min Heap. After the insertion, the total count of elements will be odd. As we had decided to have more numbers in the Max Heap than the Min Heap, we can take the top (smallest) number from the Min Heap and insert it into the Max Heap. findMedian(): Since we have an odd number of elements, the median will be the top element of Max Heap -&gt; 3. An odd number of elements also means that the Max Heap will have one extra element than the Min Heap. insertNum(4): Insert ‘4’ into Min Heap. findMedian(): As we have an even number of elements, the median will be the average of the top element of both the heaps -&gt; (3+4)/2 = 3.5(3+4)/2=3.5 CodeHere is what our algorithm will look like: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from heapq import *class Solution: def __init__(self): self.maxHeap = [] # containing first half of numbers，# 存储小的一半的数字 self.minHeap = [] # containing second half of numbers # 存储大的一半的数字 def insertNum(self, num): if not self.maxHeap or -self.maxHeap[0] &gt;= num: # heapq默认是小顶堆，所以要实现大顶堆的时候，就要取反 heappush(self.maxHeap, -num) else: heappush(self.minHeap, num) # either both the heaps will have equal number of elements or max-heap will have one # more element than the min-heap if len(self.maxHeap) &gt; len(self.minHeap) + 1: heappush(self.minHeap, -heappop(self.maxHeap)) elif len(self.maxHeap) &lt; len(self.minHeap): heappush(self.maxHeap, -heappop(self.minHeap)) def findMedian(self): if len(self.maxHeap) == len(self.minHeap): # we have even number of elements, take the average of middle two elements return -self.maxHeap[0] / 2.0 + self.minHeap[0] / 2.0 # because max-heap will have one more element than the min-heap return -self.maxHeap[0] / 1.0def main(): sol = Solution() sol.insertNum(3) sol.insertNum(1) print(&quot;The median is: &quot; + str(sol.findMedian())) sol.insertNum(5) print(&quot;The median is: &quot; + str(sol.findMedian())) sol.insertNum(4) print(&quot;The median is: &quot; + str(sol.findMedian()))main() Time complexityThe time complexity of the insertNum() will be O(logN) due to the insertion in the heap. The time complexity of the findMedian() will be O(1) as we can find the median from the top elements of the heaps. Space complexityThe space complexity will be O(N) because, as at any time, we will be storing all the numbers. *Sliding Window Median (hard) 480. Sliding Window Median Design Gurus Educative.io Problem StatementGiven an array of numbers and a number ‘k’, find the median of all the ‘k’ sized sub-arrays (or windows) of the array. Example 1: Input: nums=[1, 2, -1, 3, 5], k = 2Output: [1.5, 0.5, 1.0, 4.0]Explanation: Lets consider all windows of size ‘2’: [1, 2, -1, 3, 5] -&gt; median is 1.5 [1, 2, -1, 3, 5] -&gt; median is 0.5 [1, 2, -1, 3, 5] -&gt; median is 1.0 [1, 2, -1, 3, 5] -&gt; median is 4.0 Example 2: Input: nums=[1, 2, -1, 3, 5], k = 3Output: [1.0, 2.0, 3.0]Explanation: Lets consider all windows of size ‘3’: [1, 2, -1, 3, 5] -&gt; median is 1.0 [1, 2, -1, 3, 5] -&gt; median is 2.0 [1, 2, -1, 3, 5] -&gt; median is 3.0 Constraints: 1 &lt;= k &lt;= nums.length &lt;= 10^5 -2^31 &lt;= nums[i] &lt;= 2^31 - 1 SolutionThis problem follows the Two Heaps pattern and share similarities with Find the Median of a Number Stream. We can follow a similar approach of maintaining a max-heap and a min-heap for the list of numbers to find their median. The only difference is that we need to keep track of a sliding window of ‘k’ numbers. This means, in each iteration, when we insert a new number in the heaps, we need to remove one number from the heaps which is going out of the sliding window. After the removal, we need to rebalance the heaps in the same way that we did while inserting. Here is the visual representation of the algorithm: CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475from heapq import *import heapqclass Solution: def __init__(self): self.maxHeap, self.minHeap = [], [] def findSlidingWindowMedian(self, nums, k): result = [0.0 for x in range(len(nums) - k + 1)] for i in range(0, len(nums)): if not self.maxHeap or nums[i] &lt;= -self.maxHeap[0]: heappush(self.maxHeap, -nums[i]) else: heappush(self.minHeap, nums[i]) self.rebalance_heaps() if i - k + 1 &gt;= 0: # if we have at least &#x27;k&#x27; elements in the sliding window # add the median to the the result array if len(self.maxHeap) == len(self.minHeap): # we have even number of elements, take the average of middle two elements result[i - k + 1] = -self.maxHeap[0] / \\ 2.0 + self.minHeap[0] / 2.0 else: # because max-heap will have one more element than the min-heap result[i - k + 1] = -self.maxHeap[0] / 1.0 # remove the element going out of the sliding window elementToBeRemoved = nums[i - k + 1] if elementToBeRemoved &lt;= -self.maxHeap[0]: self.remove(self.maxHeap, -elementToBeRemoved) else: self.remove(self.minHeap, elementToBeRemoved) self.rebalance_heaps() return result # removes an element from the heap keeping the heap property def remove(self, heap, element): ind = heap.index(element) # find the element # copy the last element of the heap to this index and decrement the heap size heap[ind] = heap[-1] del heap[-1] # adjust the position of the element while maintaining the heap property. # we can use heapify to readjust the elements but that would be O(N), # instead, we will adjust only one element which will O(logN) if ind &lt; len(heap): heapq._siftup(heap, ind) heapq._siftdown(heap, 0, ind) def rebalance_heaps(self): # either both the heaps will have equal number of elements or max-heap will have # one more element than the min-heap if len(self.maxHeap) &gt; len(self.minHeap) + 1: heappush(self.minHeap, -heappop(self.maxHeap)) elif len(self.maxHeap) &lt; len(self.minHeap): heappush(self.maxHeap, -heappop(self.minHeap))def main(): sol = Solution() result = sol.findSlidingWindowMedian( [1, 2, -1, 3, 5], 2) print(&quot;Sliding window medians are: &quot; + str(result)) sol = Solution() result = sol.findSlidingWindowMedian( [1, 2, -1, 3, 5], 3) print(&quot;Sliding window medians are: &quot; + str(result))main() Time complexityThe time complexity of our algorithm is O(N\\K)* where ‘N’ is the total number of elements in the input array and ‘K’ is the size of the sliding window. This is due to the fact that we are going through all the ‘N’ numbers and, while doing so, we are doing two things: Inserting/removing numbers from heaps of size ‘K’. This will take O(logK) Removing the element going out of the sliding window. This will take O(K) as we will be searching this element in an array of size ‘K’ (i.e., a heap). Space complexityIgnoring the space needed for the output array, the space complexity will be O(K) because, at any time, we will be storing all the numbers within the sliding window. Maximize Capital (hard)Top Interview 150 | 502. IPO) Design Gurus Educative.io Given a set of investment projects with their respective profits, we need to find the most profitable projects. We are given an initial capital and are allowed to invest only in a fixed number of projects. Our goal is to choose projects that give us the maximum profit. Write a function that returns the maximum total capital after selecting the most profitable projects. We can start an investment project only when we have the required capital. After selecting a project, we can assume that its profit has become our capital, and that we have also received our capital back. Example 1: 123456789Input: Project Capitals=[0,1,2], Project Profits=[1,2,3], Initial Capital=1, Number of Projects=2Output: 6Explanation:1. With initial capital of ‘1’, we will start the second project which will give us profit of ‘2’. Once we selected our first project, our total capital will become 3 (profit + initial capital).2. With ‘3’ capital, we will select the third project, which will give us ‘3’ profit.After the completion of the two projects, our total capital will be 6 (1+2+3). Example 2: 1234567891011Input: Project Capitals=[0,1,2,3], Project Profits=[1,2,3,5], Initial Capital=0, Number of Projects=3Output: 8Explanation:1. With ‘0’ capital, we can only select the first project, bringing out capital to 1.2. Next, we will select the second project, which will bring our capital to 3.3. Next, we will select the fourth project, giving us a profit of 5.After selecting the three projects, our total capital will be 8 (1+2+5). Constraints: 1 &lt;= numberOfprojects &lt;= 10^5 0 &lt;= initialCapital &lt;= 10^9 n == profits.length n == capital.length 1 &lt;= n &lt;= 10^5 0 &lt;= profits[i] &lt;= 10^4 0 &lt;= capital[i] &lt;= 10^9 SolutionWhile selecting projects we have two constraints: We can select a project only when we have the required capital. There is a maximum limit on how many projects we can select. Since we don’t have any constraint on time, we should choose a project, among the projects for which we have enough capital, which gives us a maximum profit. Following this greedy approach will give us the best solution. While selecting a project, we will do two things: Find all the projects that we can choose with the available capital. From the list of projects in the 1st step, choose the project that gives us a maximum profit. We can follow the Two Heaps approach similar to Find the Median of a Number Stream. Here are the steps of our algorithm: Add all project capitals to a min-heap, so that we can select a project with the smallest capital requirement. Go through the top projects of the min-heap and filter the projects that can be completed within our available capital. Insert the profits of all these projects into a max-heap, so that we can choose a project with the maximum profit. Finally, select the top project of the max-heap for investment. Repeat the 2nd and 3rd steps for the required number of projects. CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233343536373839404142434445from heapq import *class Solution: def findMaximumCapital(self, capital, profits, numberOfProjects, initialCapital): minCapitalHeap = [] maxProfitHeap = [] # insert all project capitals to a min-heap for i in range(0, len(profits)): heappush(minCapitalHeap, (capital[i], i)) # let&#x27;s try to find a total of &#x27;numberOfProjects&#x27; best projects availableCapital = initialCapital for _ in range(numberOfProjects): # find all projects that can be selected within the available capital and insert # them in a max-heap while minCapitalHeap and minCapitalHeap[0][0] &lt;= availableCapital: capital, i = heappop(minCapitalHeap) # push相反数来实现大顶堆 heappush(maxProfitHeap, (-profits[i], i)) # terminate if we are not able to find any project that can be completed within the # available capital # 如果没有可以负担得起的项目，那就break，不然下面的会报错 if not maxProfitHeap: break # select the project with the maximum profit availableCapital += -heappop(maxProfitHeap)[0] return availableCapitaldef main(): sol = Solution() print(&quot;Maximum capital: &quot; + str(sol.findMaximumCapital([0, 1, 2], [1, 2, 3], 2, 1))) print(&quot;Maximum capital: &quot; + str(sol.findMaximumCapital([0, 1, 2, 3], [1, 2, 3, 5], 3, 0)))main() Time complexitySince, at the most, all the projects will be pushed to both the heaps once, the time complexity of our algorithm is O(NlogN + KlogN), where ‘N’ is the total number of projects and ‘K’ is the number of projects we are selecting. Space complexityThe space complexity will be O(N) because we will be storing all the projects in the heaps. Problem Challenge 1 436. Find Right Interval Design Gurus Educative.io Next Interval (hard)Given an array of intervals, find the next interval of each interval. In a list of intervals, for an interval ‘i’ its next interval ‘j’ will have the smallest ‘start’ greater than or equal to the ‘end’ of ‘i’. Write a function to return an array containing indices of the next interval of each input interval. If there is no next interval of a given interval, return -1. It is given that none of the intervals have the same start point. Example 1: Input: Intervals [[2,3], [3,4], [5,6]]Output: [1, 2, -1]Explanation: The next interval of [2,3] is [3,4] having index ‘1’. Similarly, the next interval of [3,4] is [5,6] having index ‘2’. There is no next interval for [5,6] hence we have ‘-1’. Example 2: Input: Intervals [[3,4], [1,5], [4,6]]Output: [2, -1, -1]Explanation: The next interval of [3,4] is [4,6] which has index ‘2’. There is no next interval for [1,5] and [4,6]. Constraints: 1 &lt;= intervals.length &lt;= 2 * 10^4 intervals[i].length == 2 -10^6 &lt;= starti &lt;= endi &lt;= 10^6 The start point of each interval is unique. SolutionA brute force solution could be to take one interval at a time and go through all the other intervals to find the next interval. This algorithm will take O(N^2) where ‘N’ is the total number of intervals. Can we do better than that? We can utilize the Two Heaps approach. We can push all intervals into two heaps: one heap to sort the intervals on maximum start time (let’s call it maxStartHeap) and the other on maximum end time (let’s call it maxEndHeap). We can then iterate through all intervals of the `maxEndHeap’ to find their next interval. Our algorithm will have the following steps: Take out the top (having highest end) interval from the maxEndHeap to find its next interval. Let’s call this interval topEnd. Find an interval in the maxStartHeap with the closest start greater than or equal to the start of topEnd. Since maxStartHeap is sorted by ‘start’ of intervals, it is easy to find the interval with the highest ‘start’. Let’s call this interval topStart. Add the index of topStart in the result array as the next interval of topEnd. If we can’t find the next interval, add ‘-1’ in the result array. Put the topStart back in the maxStartHeap, as it could be the next interval of other intervals. Repeat the steps 1-4 until we have no intervals left in maxEndHeap. CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from heapq import *# class Interval:# def __init__(self, start, end):# self.start = start# self.end = endclass Solution: def findNextInterval(self, intervals): n = len(intervals) # heaps for finding the maximum start and end maxStartHeap, maxEndHeap = [], [] result = [0 for x in range(n)] for endIndex in range(n): heappush(maxStartHeap, (-intervals[endIndex].start, endIndex)) heappush(maxEndHeap, (-intervals[endIndex].end, endIndex)) # go through all the intervals to find each interval&#x27;s next interval for _ in range(n): # let&#x27;s find the next interval of the interval which has the highest &#x27;end&#x27; topEnd, endIndex = heappop(maxEndHeap) result[endIndex] = -1 # defaults to - 1 if -maxStartHeap[0][0] &gt;= -topEnd: topStart, startIndex = heappop(maxStartHeap) # find the the interval that has the closest &#x27;start&#x27; while maxStartHeap and -maxStartHeap[0][0] &gt;= -topEnd: topStart, startIndex = heappop(maxStartHeap) result[endIndex] = startIndex # put the interval back as it could be the next interval of other intervals heappush(maxStartHeap, (topStart, startIndex)) return resultdef main(): sol = Solution() result = sol.findNextInterval( [Interval(2, 3), Interval(3, 4), Interval(5, 6)]) print(&quot;Next interval indices are: &quot; + str(result)) result = sol.findNextInterval( [Interval(3, 4), Interval(1, 5), Interval(4, 6)]) print(&quot;Next interval indices are: &quot; + str(result))main() Time complexityThe time complexity of our algorithm will be O(NlogN), where ‘N’ is the total number of intervals. Space complexityThe space complexity will be O(N) because we will be storing all the intervals in the heaps.","categories":[{"name":"Grokking Interview Pattern","slug":"Grokking-Interview-Pattern","permalink":"https://hasuer.github.io/categories/Grokking-Interview-Pattern/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hasuer.github.io/tags/Interview/"}]},{"title":"13. Pattern Island (Matrix traversal)","slug":"13. Pattern Island (Matrix traversal)","date":"2024-05-13T01:43:32.000Z","updated":"2024-05-28T03:28:55.480Z","comments":true,"path":"13-pattern-island-matrix-traversal/index.html","link":"","permalink":"https://hasuer.github.io/13-pattern-island-matrix-traversal/index.html","excerpt":"","text":"Introduction to Island PatternMany coding interview problems involve traversing 2D arrays (aka matrix or grid). The Island pattern describes all the efficient ways to traverse a matrix. This pattern will go through many problems to explain matrix traversal using Depth First Search (DFS) and Breadth First Search (BFS) approaches and their variants. Let’s jump onto our first problem to develop an understanding of this pattern. Number of IslandsTop Interview 150 | 200. Number of Islands Design Gurus Problem StatementGiven a 2D array (i.e., a matrix) containing only 1s (land) and 0s (water), count the number of islands in it. An island is a connected set of 1s (land) and is surrounded by either an edge or 0s (water). Each cell is considered connected to other cells horizontally or vertically (not diagonally). Example 1 Input: matrix = Output: 1Explanation: The matrix has only one island. See the highlighted cells below. Example 2 Input: matrix = Output: 3Explanation: The matrix has three islands. See the highlighted cells below. Constraints: m == matrix.length n == matrix[i].length 1 &lt;= m, n &lt;= 300 matrix[i][j] is &#39;0&#39; or &#39;1&#39;. SolutionWe can traverse the matrix linearly to find islands. Whenever we find a cell with the value ‘1’ (i.e., land), we have found an island. Using that cell as the root node, we will perform a Depth First Search (DFS) or Breadth First Search (BFS) to find all of its connected land cells. During our DFS or BFS traversal, we will find and mark all the horizontally and vertically connected land cells. We need to have a mechanism to mark each land cell to ensure that each land cell is visited only once. To mark a cell visited, we have two options: We can update the given input matrix. Whenever we see a ‘1’, we will make it ‘0’. A separate boolean matrix can be used to record whether or not each cell has been visited. Following is the DFS or BFS traversal of the example-2 mentioned above: By following the above algorithm, every time DFS or BFS is triggered, we are sure that we have found an island. We will keep a running count to calculate the total number of islands. Below, we will see three solutions based on: DFS BFS BFS with visited matrix Code (DFS)Here is what our DFS algorithm will look like. We will update the input matrix to mark cells visited. 1234567891011121314151617181920212223242526272829303132333435363738394041# dfs一般使用stack或者递归class Solution: def countIslands(self, matrix): rows = len(matrix) cols = len(matrix[0]) totalIslands = 0 for i in range(rows): for j in range(cols): if (matrix[i][j] == 1): # only if the cell is a land # we have found an island totalIslands += 1 self.visit_is_land_DFS(matrix, i, j) return totalIslands def visit_is_land_DFS(self, matrix, x, y): if (x &lt; 0 or x &gt;= len(matrix) or y &lt; 0 or y &gt;= len(matrix[0])): return # return, if it is not a valid cell if (matrix[x][y] == 0): return # return, if it is a water cell matrix[x][y] = 0 # mark the cell visited by making it a water cell # recursively visit all neighboring cells (horizontally &amp; vertically) self.visit_is_land_DFS(matrix, x + 1, y) # lower cell self.visit_is_land_DFS(matrix, x - 1, y) # upper cell self.visit_is_land_DFS(matrix, x, y + 1) # right cell self.visit_is_land_DFS(matrix, x, y - 1) # left celldef main(): sol = Solution() print(sol.countIslands([[0, 1, 1, 1, 0], [0, 0, 0, 1, 1], [ 0, 1, 1, 1, 0], [0, 1, 1, 0, 0], [0, 0, 0, 0, 0]])) print(sol.countIslands([[1, 1, 1, 0, 0], [0, 1, 0, 0, 1], [ 0, 0, 1, 1, 0], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0]]))main() Time ComplexityTime complexity of the above algorithm will be O(M \\ N)*, where ‘M’ is the number of rows and ‘N’ is the number of columns of the input matrix. This is due to the fact that we have to traverse the whole matrix to find the islands. Space ComplexityDFS recursion stack can go O(M \\ N)* deep when the whole matrix is filled with ‘1’s. Hence, the space complexity will be O(M \\ N)* , where ‘M’ is the number of rows and ‘N’ is the number of columns of the input matrix. Code (DFS) (DFS with visited matrix)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 过leetcodefrom collections import dequeclass Solution: def countIslands(self, matrix): rows = len(matrix) cols = len(matrix[0]) totalIslands = 0 visited = [[False for i in range(cols)] for j in range(rows)] for i in range(rows): for j in range(cols): if (matrix[i][j] == 1 and not visited[i][j]): # only if the cell is a land # we have found an island totalIslands += 1 self.visit_is_land_DFS(matrix, visited, i, j) return totalIslands def visit_is_land_DFS(self, matrix, visited, x, y): stack = deque() stack.append((x, y)) # stack = deque([(x, y)]) # 这一行可以代替上面两行 while stack: x, y = stack.pop() if (x &lt; 0 or x &gt;= len(matrix) or y &lt; 0 or y &gt;= len(matrix[0])): continue # continue, if it is not a valid cell if (visited[x][y] or matrix[x][y] == 0): continue # continue if the cell is water or visited visited[x][y] = True # mark the cell visited by making it a water cell # recursively visit all neighboring cells (horizontally &amp; vertically) stack.append((x + 1, y)) # lower cell stack.append((x - 1, y)) # upper cell stack.append((x, y + 1)) # right cell stack.append((x, y - 1)) # left celldef main(): sol = Solution() print(sol.countIslands([[0, 1, 1, 1, 0], [0, 0, 0, 1, 1], [ 0, 1, 1, 1, 0], [0, 1, 1, 0, 0], [0, 0, 0, 0, 0]])) print(sol.countIslands([[1, 1, 1, 0, 0], [0, 1, 0, 0, 1], [ 0, 0, 1, 1, 0], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0]]))main() Code (BFS)Here is what our BFS algorithm will look like. We will update the input matrix to mark cells visited. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# BFS一般使用queue,很少见递归from collections import dequeclass Solution: def count_is_lands_BFS(self, matrix): rows = len(matrix) cols = len(matrix[0]) totalIslands = 0 for i in range(rows): for j in range(cols): if (matrix[i][j] == 1): # only if the cell is a land # we have found an island totalIslands += 1 self.visit_is_land_BFS(matrix, i, j) return totalIslands def visit_is_land_BFS(self, matrix, x, y): neighbors = deque([(x, y)]) while neighbors: row, col = neighbors.popleft() if row &lt; 0 or row &gt;= len(matrix) or col &lt; 0 or col &gt;= len(matrix[0]): continue # continue, if it is not a valid cell if matrix[row][col] == 0: continue # continue if it is a water cell matrix[row][col] = 0 # mark the cell visited by making it a water cell # insert all neighboring cells to the queue for BFS # append元素，entend列表 neighbors.extend([(row + 1, col)]) # lower cell neighbors.extend([(row - 1, col)]) # upper cell neighbors.extend([(row, col + 1)]) # right cell neighbors.extend([(row, col - 1)]) # left celldef main(): sol = Solution() print(sol.count_is_lands_BFS([[0, 1, 1, 1, 0], [0, 0, 0, 1, 1], [ 0, 1, 1, 1, 0], [0, 1, 1, 0, 0], [0, 0, 0, 0, 0]])) print(sol.count_is_lands_BFS([[1, 1, 1, 0, 0], [0, 1, 0, 0, 1], [ 0, 0, 1, 1, 0], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0]]))main() Time ComplexityTime complexity of the above algorithm will be O(M * N), where ‘M’ is the number of rows and ‘N’ is the number of columns. Space ComplexitySpace complexity of the above algorithm will be *O(min(M, N)). In the worst case, when the matrix is completely filled with land cells, the size of the queue can grow up to min(M, N). Code (BFS with visited matrix)Here is what our BFS algorithm will look like. We will keep a separate boolean matrix to record whether or not each cell has been visited. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from collections import dequeclass Solution: def count_is_lands_BFS(self, matrix): rows = len(matrix) cols = len(matrix[0]) totalIslands = 0 visited = [[False for i in range(cols)] for j in range(rows)] for i in range(rows): for j in range(cols): # if the cell has not been visited before and is a land if (matrix[i][j] == 1 and not visited[i][j]): # we have found an island totalIslands += 1 self.visit_is_land_BFS(matrix, visited, i, j) return totalIslands def visit_is_land_BFS(self, matrix, visited, x, y): neighbors = deque([(x, y)]) while neighbors: row, col = neighbors.popleft() if row &lt; 0 or row &gt;= len(matrix) or col &lt; 0 or col &gt;= len(matrix[0]): continue # continue, if it is not a valid cell if matrix[row][col] == 0 or visited[row][col]: continue # continue if the cell is water or visited visited[row][col] = True # mark the visited array # insert all neighboring cells to the queue for BFS # append元素，entend列表 neighbors.extend([(row + 1, col)]) # lower cell neighbors.extend([(row - 1, col)]) # upper cell neighbors.extend([(row, col + 1)]) # right cell neighbors.extend([(row, col - 1)]) # left celldef main(): sol = Solution() print(sol.count_is_lands_BFS([[0, 1, 1, 1, 0], [0, 0, 0, 1, 1], [ 0, 1, 1, 1, 0], [0, 1, 1, 0, 0], [0, 0, 0, 0, 0]])) print(sol.count_is_lands_BFS([[1, 1, 1, 0, 0], [0, 1, 0, 0, 1], [ 0, 0, 1, 1, 0], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0]]))main() Time ComplexityTime complexity of the above algorithm will be O(M \\ N)*, where ‘M’ is the number of rows and ‘N’ is the number of columns. Space ComplexityBecause of the visited array and max size of the queue, the space complexity will be O(M \\ N)*, where ‘M’ is the number of rows and ‘N’ is the number of columns of the input matrix. Biggest Island695. Max Area of Island Design Gurus Problem StatementGiven a 2D array (i.e., a matrix) containing only 1s (land) and 0s (water), find the biggest island in it. Write a function to return the area of the biggest island. An island is a connected set of 1s (land) and is surrounded by either an edge or 0s (water). Each cell is considered connected to other cells horizontally or vertically (not diagonally). Example 1 Input: matrix = Output: 5Explanation: The matrix has three islands. The biggest island has 5 cells . Constraints: m == matrix.length n == matrix[i].length 1 &lt;= m, n &lt;= 50 matrix[i][j] is &#39;0&#39; or &#39;1&#39;. SolutionThe question follows the Island pattern and is quite similar to Number of Islands problem. We will traverse the matrix linearly to find islands. Whenever we find a cell with the value ‘1’ (i.e., land), we have found an island. Using that cell as the root node, we will perform a Depth First Search (DFS) or Breadth First Search (BFS) to find all of its connected land cells. During our DFS or BFS traversal, we will find and mark all the horizontally and vertically connected land cells. We will keep a variable to remember the max area of any island. Algorithm Walkthrough Here is the detailed walkthrough of the DFS algorithm: We first initialize biggestIslandArea to 0. This variable will keep track of the largest island’s area we have encountered so far. Then, we traverse each cell in the matrix. If the cell’s value is 1 (land), we begin a DFS search from this cell using the visitIslandDFS function. This function will visit the cell and all its neighboring cells that are part of the same island. In the visitIslandDFS function, we first check if the current cell (x, y) is within the boundaries of the matrix and if it’s a land cell. If it’s not, we return 0. We then mark the current cell as visited by setting its value to 0 (water). This helps avoid visiting the same cell again and ending up in an infinite loop. We initialize the area of the current island to 1 (counting the current cell), and then add to it the areas returned by the recursive DFS calls for the neighboring cells (top, bottom, left, and right). After we finish the DFS for a cell (meaning we have visited all cells in the island that the cell is a part of), we update biggestIslandArea with the maximum of its current value and the area of the island we just finished exploring. Finally, after traversing all cells in the matrix, we return biggestIslandArea, which now holds the area of the largest island. Here is the visual representation of the algorithm: Code (DFS)Here is what our DFS algorithm will look like. We will update the input matrix to mark nodes visited. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889# 官方使用的是DFS的递归，但是我比较习惯使用whileclass Solution: def maxAreaOfIsland(self, matrix): rows = len(matrix) cols = len(matrix[0]) biggestIslandArea = 0 for i in range(rows): for j in range(cols): if (matrix[i][j] == 1): # only if the cell is a land # we have found an island biggestIslandArea = max( biggestIslandArea, self.visit_is_land_DFS(matrix, i, j)) return biggestIslandArea def visit_is_land_DFS(self, matrix, x, y): if (x &lt; 0 or x &gt;= len(matrix) or y &lt; 0 or y &gt;= len(matrix[0])): return 0 # return, if it is not a valid cell if (matrix[x][y] == 0): return 0 # return, if it is a water cell matrix[x][y] = 0 # mark the cell visited by making it a water cell area = 1 # counting the current cell # recursively visit all neighboring cells (horizontally &amp; vertically) area += self.visit_is_land_DFS(matrix, x + 1, y) # lower cell area += self.visit_is_land_DFS(matrix, x - 1, y) # upper cell area += self.visit_is_land_DFS(matrix, x, y + 1) # right cell area += self.visit_is_land_DFS(matrix, x, y - 1) # left cell return areadef main(): sol = Solution() print(sol.maxAreaOfIsland([[1, 1, 1, 0, 0], [0, 1, 0, 0, 1], [ 0, 0, 1, 1, 0], [0, 1, 1, 0, 0], [0, 0, 1, 0, 0]]))main()# 自己实现的DFS的while版本, 过了leetcodefrom collections import dequeclass Solution: def maxAreaOfIsland(self, matrix): rows = len(matrix) cols = len(matrix[0]) biggestIslandArea = 0 visited = [[False for i in range(cols)] for j in range(rows)] for i in range(rows): for j in range(cols): if (matrix[i][j] == 1): # only if the cell is a land # we have found an island biggestIslandArea = max( biggestIslandArea, self.visit_is_land_DFS(matrix, visited, i, j)) return biggestIslandArea def visit_is_land_DFS(self, matrix, visited, x, y): stack = deque([(x, y)]) area = 0 while stack: x, y = stack.pop() if x &lt; 0 or x &gt;= len(matrix) or y &lt; 0 or y &gt;= len(matrix[0]): continue # return, if it is not a valid cell if matrix[x][y] == 0 or visited[x][y]: continue # return, if it is a water cell area += 1 visited[x][y] = True # mark the cell visited by making it a water cell # recursively visit all neighboring cells (horizontally &amp; vertically) stack.append((x + 1, y)) # lower cell stack.append((x - 1, y)) # upper cell stack.append((x, y + 1)) # right cell stack.append((x, y - 1)) # left cell return areadef main(): sol = Solution() print(sol.maxAreaOfIsland([[1, 1, 1, 0, 0], [0, 1, 0, 0, 1], [ 0, 0, 1, 1, 0], [0, 1, 1, 0, 0], [0, 0, 1, 0, 0]]))main() Complexity AnalysisTime ComplexityTime complexity of the above algorithm will be O(M * N), where ‘M’ is the number of rows and ‘N’ is the number of columns of the input matrix. This is due to the fact that we have to traverse the whole matrix to find islands. Space ComplexityDFS recursion stack can go O(M * N) deep when the whole matrix is filled with ‘1’s. Hence, the space complexity will be O(M * N), where ‘M’ is the number of rows and ‘N’ is the number of columns of the input matrix. Flood Fill733. Flood Fill Design Gurus Problem StatementAny image can be represented by a 2D integer array (i.e., a matrix) where each cell represents the pixel value of the image. Flood fill algorithm takes a starting cell (i.e., a pixel) and a color. The given color is applied to all horizontally and vertically connected cells with the same color as that of the starting cell. Recursively, the algorithm fills cells with the new color until it encounters a cell with a different color than the starting cell. Given a matrix, a starting cell, and a color, flood fill the matrix. Example 1: Input: matrix = starting cell = (1, 3)new color = 2 Output: Example 2: Input: matrix = starting cell = (3, 2) new color = 5 Output: Constraints: m == matrix.length n == - m == matrix[i].length 1 &lt;= m, n &lt;= 50 0 &lt;= - m == matrix[i][j], color &lt; 216 0 &lt;= x &lt; m 0 &lt;= y &lt; n SolutionThe question follows the Island pattern and is quite similar to Number of Islands problem. From the given starting cell, we can perform a Depth First Search (DFS) or Breadth First Search (BFS) to find all of its connected cells with the same color. During our DFS or BFS traversal, we will update the cells with the new color. Following is the DFS or BFS traversal of the example-2 mentioned above: Code (DFS)Here is what our DFS algorithm will look like: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071# 官方使用的是DFS的递归，但是我比较习惯使用whileclass Solution: def floodFill(self, matrix, x, y, newColor): if matrix[x][y] != newColor: self.fill_DFS(matrix, x, y, matrix[x][y], newColor) return matrix def fill_DFS(self, matrix, x, y, oldColor, newColor): if x &lt; 0 or x &gt;= len(matrix) or y &lt; 0 or y &gt;= len(matrix[0]): return # return, if it is not a valid cell if matrix[x][y] != oldColor: return # return, if it is not the required color matrix[x][y] = newColor # // update the cell to the new color # recursively visit all neighboring cells (horizontally &amp; vertically) self.fill_DFS(matrix, x + 1, y, oldColor, newColor) # lower cell self.fill_DFS(matrix, x - 1, y, oldColor, newColor) # upper cell self.fill_DFS(matrix, x, y + 1, oldColor, newColor) # right cell self.fill_DFS(matrix, x, y - 1, oldColor, newColor) # left celldef main(): sol = Solution() print(sol.floodFill([[0, 1, 1, 1, 0], [0, 0, 0, 1, 1], [ 0, 1, 1, 1, 0], [0, 1, 1, 0, 0], [0, 0, 0, 0, 0]], 1, 3, 2)) print(sol.floodFill([[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [ 0, 0, 1, 1, 0], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0]], 3, 2, 5))main()# 自己实现的DFS while, 过了leetcodefrom collections import dequeclass Solution: def floodFill(self, matrix, x, y, newColor): if matrix[x][y] != newColor: self.fill_DFS(matrix, x, y, matrix[x][y], newColor) return matrix def fill_DFS(self, matrix, x, y, oldColor, newColor): stack = deque([(x, y)]) while stack: x, y = stack.pop() if x &lt; 0 or x &gt;= len(matrix) or y &lt; 0 or y &gt;= len(matrix[0]): continue # continue, if it is not a valid cell if matrix[x][y] != oldColor: continue # continue, if it is not the required color matrix[x][y] = newColor # // update the cell to the new color # recursively visit all neighboring cells (horizontally &amp; vertically) stack.append((x + 1, y)) # lower cell stack.append((x - 1, y)) # upper cell stack.append((x, y + 1)) # right cell stack.append((x, y - 1)) # left celldef main(): sol = Solution() print(sol.floodFill([[0, 1, 1, 1, 0], [0, 0, 0, 1, 1], [ 0, 1, 1, 1, 0], [0, 1, 1, 0, 0], [0, 0, 0, 0, 0]], 1, 3, 2)) print(sol.floodFill([[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [ 0, 0, 1, 1, 0], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0]], 3, 2, 5))main() Time ComplexityTime complexity the above algorithm will be O(M * N), where ‘M’ is the number of rows and ‘N’ is the number of columns of the input matrix. This is due to the fact that, in the worst case, we might have to fill the whole matrix. Space ComplexityDFS recursion stack can go O(M * N) deep when we have to fill the whole matrix. Hence, the space complexity will be O(M * N) , where ‘M’ is the number of rows and ‘N’ is the number of columns of the input matrix. Number of Closed IslandsSimilar | 1254. Number of Closed Islands Design Gurus Leetcode 中 ‘0’ and ‘1’的含义反过来了，所以只要改一下这个就过了 Problem StatementYou are given a 2D matrix containing only 1s (land) and 0s (water). An island is a connected set of 1s (land) and is surrounded by either an edge or 0s (water). Each cell is considered connected to other cells horizontally or vertically (not diagonally). A closed island is an island that is totally surrounded by 0s (i.e., water). This means all horizontally and vertically connected cells of a closed island are water. This also means that, by definition, a closed island can’t touch an edge (as then the edge cells are not connected to any water cell). Write a function to find the number of closed islands in the given matrix. Example 1 Input: matrix = Output: 1 Explanation: The given matrix has two islands, but only the highlighted island is a closed island. The other island is touching the boundary that’s why is is not considered a closed island. Example 2 Input: matrix = Output: 2 Explanation: The given matrix has two islands and both of them are closed islands. Constraints: 1 &lt;= grid.length, grid[0].length &lt;= 100 0 &lt;= grid[i][j] &lt;=1 SolutionThe question follows the Island pattern and is quite similar to Number of Islands problem. We will traverse the matrix linearly to find islands. We can use the Depth First Search (DFS) or Breadth First Search (BFS) to traverse an island i.e., to find all of its connected land cells. How do we decide if an island is a closed island? To find that out, while traversing an island we need to ensure two things: The island does not touch an edge. Outside boundary of the island are water cells. For the first condition, whenever we go outside the boundary of the matrix during DFS or BFS, it means that one of the cells of the island is touching an edge; so, the island is not closed. Following code will cover this condition: 12if (x &lt; 0 || x &gt;= matrix.length || y &lt; 0 || y &gt;= matrix[0].length) return false; // returning false since the island is touching an edge For the second condition, we need to ensure that all the boundary cells of the island are water. Following code will take care of that: 12if (matrix[x][y] == 0 || visited[x][y]) return true; // returning true as the island is surrounded by water Here is the visual representation of the algorithm: Code (DFS)Here is what our DFS algorithm will look like. We will use a separate array to mark nodes visited. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100# 官方使用的是DFS的递归，但是我比较习惯使用whileclass Solution: def countClosedIslands(self, matrix): rows = len(matrix) cols = len(matrix[0]) visited = [[False for i in range(cols)] for j in range(rows)] countClosedIslands = 0 for i in range(rows): for j in range(cols): # only if the cell is a land and not visited if (matrix[i][j] == 1 and not visited[i][j]): if self.is_closed_is_land_DFS(matrix, visited, i, j): countClosedIslands += 1 return countClosedIslands def is_closed_is_land_DFS(self, matrix, visited, x, y): if (x &lt; 0 or x &gt;= len(matrix) or y &lt; 0 or y &gt;= len(matrix[0])): return False # returning false since the island is touching an edge if (matrix[x][y] == 0 or visited[x][y]): return True # returning true as the island is surrounded by water visited[x][y] = True # mark the cell visited isClosed = True # recursively visit all neighboring cells (horizontally &amp; vertically) isClosed &amp;= self.is_closed_is_land_DFS(matrix, visited, x + 1, y) # lower cell isClosed &amp;= self.is_closed_is_land_DFS(matrix, visited, x - 1, y) # upper cell isClosed &amp;= self.is_closed_is_land_DFS(matrix, visited, x, y + 1) # right cell isClosed &amp;= self.is_closed_is_land_DFS(matrix, visited, x, y - 1) # left cell return isCloseddef main(): sol = Solution() print(sol.countClosedIslands([[1, 1, 0, 0, 0], [0, 1, 0, 0, 0], [ 0, 0, 1, 1, 0], [0, 1, 1, 0, 0], [0, 0, 0, 0, 0]])) print(sol.countClosedIslands([[0, 0, 0, 0], [0, 1, 0, 0], [ 0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 0]]))main()# 自己实现的DFS while，可以过leetcodefrom collections import dequeclass Solution: def countClosedIslands(self, matrix): rows = len(matrix) cols = len(matrix[0]) visited = [[False for i in range(cols)] for j in range(rows)] countClosedIslands = 0 for i in range(rows): for j in range(cols): # only if the cell is a land and not visited if (matrix[i][j] == 1 and not visited[i][j]): if self.is_closed_is_land_DFS(matrix, visited, i, j): countClosedIslands += 1 return countClosedIslands def is_closed_is_land_DFS(self, matrix, visited, x, y): is_closed = True stack = deque([(x, y)]) while stack: x, y = stack.pop() if x &lt; 0 or x &gt;= len(matrix) or y &lt; 0 or y &gt;= len(matrix[0]): continue # returning false since the island is touching an edge if matrix[x][y] == 1 and (x == 0 or x == len(matrix) - 1 or y == 0 or y == len(matrix[0]) - 1): is_closed = False if matrix[x][y] == 0 or visited[x][y]: continue # returning true as the island is surrounded by water visited[x][y] = True # mark the cell visited # recursively visit all neighboring cells (horizontally &amp; vertically) stack.append((x + 1, y)) # lower cell stack.append((x - 1, y)) # upper cell stack.append((x, y + 1)) # right cell stack.append((x, y - 1)) # left cell return is_closeddef main(): sol = Solution() print(sol.countClosedIslands([[1, 1, 0, 0, 0], [0, 1, 0, 0, 0], [ 0, 0, 1, 1, 0], [0, 1, 1, 0, 0], [0, 0, 0, 0, 0]])) print(sol.countClosedIslands([[0, 0, 0, 0], [0, 1, 0, 0], [ 0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 0]]))main() Time ComplexityTime complexity of the above algorithm will be O(M * N), where ‘M’ is the number of rows and ‘N’ is the number of columns of the input matrix. This is due to the fact that we have to traverse the whole matrix to find islands. Space ComplexityDFS recursion stack can go MN deep when the whole matrix is filled with ‘1’s. Hence, the space complexity will be **O(M \\ N)**, where ‘M’ is the number of rows and ‘N’ is the number of columns of the input matrix. Problem Challenge 1463. Island Perimeter Design Gurus Problem StatementYou are given a 2D matrix containing only 1s (land) and 0s (water). An island is a connected set of 1s (land) and is surrounded by either an edge or 0s (water). Each cell is considered connected to other cells horizontally or vertically (not diagonally). There are no lakes on the island, so the water inside the island is not connected to the water around it. A cell is a square with a side length of 1.. The given matrix has only one island, write a function to find the perimeter of that island. Example 1 Input: matrix = Output: 14 Explanation: The boundary of the island constitutes 14 sides. Example 2 Input: matrix = Output: 12 Explanation: The boundary of the island constitute 12 sides. SolutionThe question follows the Island pattern and is quite similar to Number of Islands problem. We will traverse the matrix linearly to find the island. We can use the Depth First Search (DFS) or Breadth First Search (BFS) to traverse the island i.e., to find all of its connected land cells. How do we calculate the boundary if the island? Each cell has four sides. Each side of an island cell can be shared with another cell; we can include the side in the island perimeter only if the other cell is a water. If a cell side is on boundary, we should include that side in the perimeter. Following piece of code will cover these two conditions: 1234if (x &lt; 0 || x &gt;= matrix.length || y &lt; 0 || y &gt;= matrix[0].length) return 1; // returning 1, since this a boundary cell initiated this DFS call if (matrix[x][y] == 0) return 1; // returning 1, because of the shared side b/w a water and a land cell Code (DFS)Here is what our DFS algorithm will look like. We will use a separate matrix to mark nodes visited. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117# 官方使用的是DFS的递归，但是我比较习惯使用whileclass Solution: def findIslandPerimeter(self, matrix): rows = len(matrix) cols = len(matrix[0]) visited = [[False for i in range(cols)] for j in range(rows)] for i in range(rows): for j in range(cols): # only if the cell is a land and not visited if matrix[i][j] == 1 and not visited[i][j]: return self.is_land_perimeter_DFS(matrix, visited, i, j) return 0 def is_land_perimeter_DFS(self, matrix, visited, x, y): if x &lt; 0 or x &gt;= len(matrix) or y &lt; 0 or y &gt;= len(matrix[0]): return 1 # returning 1, since this a boundary cell initiated this DFS call if matrix[x][y] == 0: return 1 # returning 1, because of the shared side b/w a water and a land cell if visited[x][y]: # 到这一步的时候，matrix[x][y]已经是1了 return 0 # we have already taken care of this cell visited[x][y] = True # mark the cell visited edgeCount = 0 # recursively visit all neighboring cells (horizontally &amp; vertically) edgeCount += self.is_land_perimeter_DFS(matrix, visited, x + 1, y) # lower cell edgeCount += self.is_land_perimeter_DFS(matrix, visited, x - 1, y) # upper cell edgeCount += self.is_land_perimeter_DFS(matrix, visited, x, y + 1) # right cell edgeCount += self.is_land_perimeter_DFS(matrix, visited, x, y - 1) # left cell return edgeCountdef main(): sol = Solution() print(sol.findIslandPerimeter([[1, 1, 0, 0, 0], [0, 1, 0, 0, 0], [0, 1, 0, 0, 0], [0, 1, 1, 0, 0], [0, 0, 0, 0, 0]])) print(sol.findIslandPerimeter([[0, 0, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0], [0, 1, 1, 0], [0, 1, 0, 0]]))main()# 自己实现的DFS while，可以过leetcodefrom collections import dequeclass Solution: def findIslandPerimeter(self, matrix): rows = len(matrix) cols = len(matrix[0]) visited = [[False for i in range(cols)] for j in range(rows)] for i in range(rows): for j in range(cols): # only if the cell is a land and not visited if matrix[i][j] == 1 and not visited[i][j]: return self.is_land_perimeter_DFS(matrix, visited, i, j) return 0 def is_land_perimeter_DFS(self, matrix, visited, x, y): stack = deque([(x, y)]) edge_count = 0 while stack: x, y = stack.pop() if x &lt; 0 or x &gt;= len(matrix) or y &lt; 0 or y &gt;= len(matrix[0]): edge_count += 1 # returning 1, since this a boundary cell initiated this DFS call continue if matrix[x][y] == 0: edge_count += 1 # returning 1, because of the shared side b/w a water and a land cell continue if visited[x][y]: # 到这一步的时候，matrix[x][y]已经是1了 continue # we have already taken care of this cell visited[x][y] = True # mark the cell visited # recursively visit all neighboring cells (horizontally &amp; vertically) stack.append((x + 1, y)) # lower cell stack.append((x - 1, y)) # upper cell stack.append((x, y + 1)) # right cell stack.append((x, y - 1)) # left cell return edge_countdef main(): sol = Solution() print(sol.findIslandPerimeter([[1, 1, 0, 0, 0], [0, 1, 0, 0, 0], [0, 1, 0, 0, 0], [0, 1, 1, 0, 0], [0, 0, 0, 0, 0]])) print(sol.findIslandPerimeter([[0, 0, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0], [0, 1, 1, 0], [0, 1, 0, 0]]))main() Time ComplexityTime complexity of the above algorithm will be O(M * N), where ‘M’ is the number of rows and ‘N’ is the number of columns of the input matrix. This is due to the fact that we have to traverse the whole matrix to find the island. Space ComplexityDFS recursion stack can go O(M * N) deep when the whole matrix is filled with ‘1’s. Hence, the space complexity will be O(M * N), where ‘M’ is the number of rows and ‘N’ is the number of columns of the input matrix. Problem Challenge 2Leetcode 会员 Design Gurus Problem StatementYou are given a 2D matrix containing only 1s (land) and 0s (water). An island is a connected set of 1s (land) and is surrounded by either an edge or 0s (water). Each cell is considered connected to other cells horizontally or vertically (not diagonally). Two islands are considered the same if and only if they can be translated (not rotated or reflected) to equal each other. Write a function to find the number of distinct islands in the given matrix. Example 1 Input: matrix = Output: 2 Explanation: There are four islands in the given matrix, but three of them are the same; hence, there are only two distinct islands. Example 2 Input: matrix = Output: 2 Explanation: There are three islands in the given matrix, but two of them are the same; hence, there are only two distinct islands. SolutionThe question follows the Island pattern and is quite similar to Number of Islands problem. We will traverse the matrix linearly to find islands. We can use the Depth First Search (DFS) or Breadth First Search (BFS) to traverse an island i.e., to find all of its connected land cells. How do we decide if two islands are same? If two islands are same, their traversal path should be same too. This means, if we perform a DFS or BFS on two equal islands starting from their top-left cell, the traversal pattern should be exactly same for both the islands. For example, here is the DFS traversal of the example-2 mentioned above: We can clearly see that the two equal islands have same traversal pattern. We can utilize this fact to develop an algorithm. While traversing an island, we can construct a string that maps the traversal path of the island. For example, here is the DFS traversal of the two same islands mentioned in Example-2 ( ‘R’ for right move, ‘D’ for down move, ‘O’ for origin denoting the start): ORDR We can start inserting these traversal strings of each island in a HashSet. This will ensure that we will not have any duplicate traversal string in the HashSet, thus giving us distinct islands. When we finish traversing the matrix, the HashSet will contain the distinct traversal path of all islands. Hence, the total number of elements in the HashSet will be equal to distinct number of islands. CodeHere is the code for this algorithm: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116# 官方使用的是DFS的递归，但是我比较习惯使用whileclass Solution: def findDistinctIslandsDFS(self, matrix): rows = len(matrix) cols = len(matrix[0]) visited = [[False for i in range(cols)] for j in range(rows)] islandsSet = set() for i in range(rows): for j in range(cols): # only if the cell is a land and not visited if (matrix[i][j] == 1 and not visited[i][j]): traversal = self.traverse_is_land_DFS(matrix, visited, i, j, &quot;O&quot;); # origin islandsSet.add(traversal) return len(islandsSet) def traverse_is_land_DFS(self, matrix, visited, x, y, direction): if x &lt; 0 or x &gt;= len(matrix) or y &lt; 0 or y &gt;= len(matrix[0]): return &quot;&quot; # return if it is not a valid cell if matrix[x][y] == 0 or visited[x][y]: return &quot;&quot; # return if it is a water cell or is visited visited[x][y] = True # mark the cell visited islandTraversal = direction # recursively visit all neighboring cells (horizontally &amp; vertically) islandTraversal += self.traverse_is_land_DFS(matrix, visited, x + 1, y, &quot;D&quot;) # down islandTraversal += self.traverse_is_land_DFS(matrix, visited, x - 1, y, &quot;U&quot;) # up islandTraversal += self.traverse_is_land_DFS(matrix, visited, x, y + 1, &quot;R&quot;) # right islandTraversal += self.traverse_is_land_DFS(matrix, visited, x, y - 1, &quot;L&quot;) # left islandTraversal += &quot;B&quot; # back return islandTraversaldef main(): sol = Solution() print(sol.findDistinctIslandsDFS([[1, 1, 0, 1, 1], [1, 1, 0, 1, 1], [0, 0, 0, 0, 0], [0, 1, 1, 0, 1], [0, 1, 1, 0, 1]])) print(sol.findDistinctIslandsDFS([[1, 1, 0, 1], [0, 1, 1, 0], [0, 0, 0, 0], [1, 1, 0, 0], [0, 1, 1, 0]]))main()# 自己实现的DFS while，可以过leetcodefrom collections import dequeclass Solution: def findDistinctIslandsDFS(self, matrix): rows = len(matrix) cols = len(matrix[0]) visited = [[False for i in range(cols)] for j in range(rows)] islandsSet = set() for i in range(rows): for j in range(cols): # only if the cell is a land and not visited if (matrix[i][j] == 1 and not visited[i][j]): traversal = self.traverse_is_land_DFS(matrix, visited, i, j, &quot;O&quot;); # origin islandsSet.add(traversal) return len(islandsSet) def traverse_is_land_DFS(self, matrix, visited, x, y, direction): stack = deque([(x, y, direction)]) islandTraversal = &#x27;&#x27; while stack: x, y, direction = stack.pop() if x &lt; 0 or x &gt;= len(matrix) or y &lt; 0 or y &gt;= len(matrix[0]): continue # return if it is not a valid cell if matrix[x][y] == 0 or visited[x][y]: continue # return if it is a water cell or is visited visited[x][y] = True # mark the cell visited islandTraversal += direction # recursively visit all neighboring cells (horizontally &amp; vertically) stack.append((x + 1, y, &quot;D&quot;)) # down stack.append((x - 1, y, &quot;U&quot;)) # up stack.append((x, y + 1, &quot;R&quot;)) # right stack.append((x, y - 1, &quot;L&quot;)) # left return islandTraversaldef main(): sol = Solution() print(sol.findDistinctIslandsDFS([[1, 1, 0, 1, 1], [1, 1, 0, 1, 1], [0, 0, 0, 0, 0], [0, 1, 1, 0, 1], [0, 1, 1, 0, 1]])) print(sol.findDistinctIslandsDFS([[1, 1, 0, 1], [0, 1, 1, 0], [0, 0, 0, 0], [1, 1, 0, 0], [0, 1, 1, 0]]))main() Time ComplexityTime complexity of the above algorithm will be O(M * N), where ‘M’ is the number of rows and ‘N’ is the number of columns of the input matrix. This is due to the fact that we have to traverse the whole matrix to find islands. Space ComplexityDFS recursion stack can go MN deep when the whole matrix is filled with ‘1’s. Hence, the space complexity will be **O(M \\ N)**, where ‘M’ is the number of rows and ‘N’ is the number of columns of the input matrix. Problem Challenge 31559. Detect Cycles in 2D Grid Design Gurus Problem StatementYou are given a 2D matrix containing different characters, you need to find if there exists any cycle consisting of the same character in the matrix. A cycle is a path in the matrix that starts and ends at the same cell and has four or more cells. From a given cell, you can move to one of the cells adjacent to it - in one of the four directions (up, down, left, or right), if it has the same character value of the current cell. Write a function to find if the matrix has a cycle. Example 1 Input: matrix = Output: true Explanation: The given matrix has a cycle as shown below: Example 2 Input: matrix = Output: true Explanation: The given matrix has one cycle as shown below: Example 3 Input: matrix = Output: false Explanation: The given matrix has no cycle. Constraints: m == matrix.length n == matrix[i].length 1 &lt;= m, n &lt;= 500 matrix[i][j] is ‘0’ or ‘1’. SolutionThe question follows the Island pattern and is quite similar to Number of Islands problem. We will traverse the matrix linearly to find any cycle. Each cycle is like an island having cells containing same values. Hence, we can use the Depth First Search (DFS) or Breadth First Search (BFS) to traverse a cycle i.e., to find all of its connected cells with the same value. Our approach for traversing the matrix will be similar to the one we used when searching for islands. We will keep another matrix to remember the cells that we have visited. From any given cell, we can perform DFS to traverse all the neighboring cells having the same character value. Whenever we reach a cell that have already been visited, we can conclude that we have found a cycle. This also means that we need to be careful to not start traversing the parent cell and wrongly finding a cycle. That is, while traversing, when initiating DFS recursive calls to all the neighboring cell, we should not start a DFS call to the pervious cell, Here is the visual representation of the algorithm: CodeHere is the code for this algorithm: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125# 官方使用的是DFS的递归，但是我比较习惯使用whileclass Solution: def hasCycle(self, matrix): rows = len(matrix) cols = len(matrix[0]) visited = [[False for i in range(cols)] for j in range(rows)] for i in range(rows): for j in range(cols): if (not visited[i][j]): # only if the cell is not visited if (self.contains_cycle_DFS(matrix, visited, matrix[i][j], i, j, -1, -1)): return True return False def contains_cycle_DFS(self, matrix, visited, startChar, x, y, prevX, prevY): if (x &lt; 0 or x &gt;= len(matrix) or y &lt; 0 or y &gt;= len(matrix[0])): return False # not a valid cell if (matrix[x][y] != startChar): return False # different character which means a different island if (visited[x][y]): return True # found a cycle, as we are visiting an already visited valid cell visited[x][y] = True # mark the cell visited # recursively visit all neighboring cells (horizontally &amp; vertically) if (x + 1 != prevX and self.contains_cycle_DFS(matrix, visited, startChar, x + 1, y, x, y)): # down return True if (x - 1 != prevX and self.contains_cycle_DFS(matrix, visited, startChar, x - 1, y, x, y)): # up return True if (y + 1 != prevY and self.contains_cycle_DFS(matrix, visited, startChar, x, y + 1, x, y)): # right return True if (y - 1 != prevY and self.contains_cycle_DFS(matrix, visited, startChar, x, y - 1, x, y)): # left return True return Falsedef main(): sol = Solution() print(sol.hasCycle([[&#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;], [&#x27;b&#x27;, &#x27;a&#x27;, &#x27;c&#x27;, &#x27;a&#x27;], [&#x27;b&#x27;, &#x27;a&#x27;, &#x27;c&#x27;, &#x27;a&#x27;], [&#x27;b&#x27;, &#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;]])) print(sol.hasCycle([[&#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;], [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;b&#x27;, &#x27;a&#x27;], [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, &#x27;a&#x27;], [&#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;, &#x27;c&#x27;]])) print(sol.hasCycle([[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;e&#x27;, &#x27;b&#x27;], [&#x27;b&#x27;, &#x27;b&#x27;, &#x27;b&#x27;, &#x27;b&#x27;], [&#x27;b&#x27;, &#x27;c&#x27;, &#x27;c&#x27;, &#x27;d&#x27;], [&#x27;c&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;d&#x27;]]))main()# 自己实现的DFS while，可以过leetcodefrom collections import dequeclass Solution: def hasCycle(self, matrix): rows = len(matrix) cols = len(matrix[0]) visited = [[False for i in range(cols)] for j in range(rows)] for i in range(rows): for j in range(cols): if not visited[i][j]: # only if the cell is not visited if self.contains_cycle_DFS(matrix, visited, matrix[i][j], i, j, -1, -1): return True return False def contains_cycle_DFS(self, matrix, visited, startChar, x, y, prevX, prevY): stack = deque([(x, y, prevX, prevY)]) while stack: x, y, prevX, prevY = stack.pop() if x &lt; 0 or x &gt;= len(matrix) or y &lt; 0 or y &gt;= len(matrix[0]): continue # not a valid cell if matrix[x][y] != startChar: continue # different character which means a different island if visited[x][y]: return True # found a cycle, as we are visiting an already visited valid cell visited[x][y] = True # mark the cell visited # recursively visit all neighboring cells (horizontally &amp; vertically) if x + 1 != prevX: stack.append((x + 1, y, x, y)) # down if x - 1 != prevX: stack.append((x - 1, y, x, y)) # up if y + 1 != prevY: stack.append((x, y + 1, x, y)) # right if y - 1 != prevY: stack.append((x, y - 1, x, y)) # left return Falsedef main(): sol = Solution() print(sol.hasCycle([[&#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;], [&#x27;b&#x27;, &#x27;a&#x27;, &#x27;c&#x27;, &#x27;a&#x27;], [&#x27;b&#x27;, &#x27;a&#x27;, &#x27;c&#x27;, &#x27;a&#x27;], [&#x27;b&#x27;, &#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;]])) print(sol.hasCycle([[&#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;], [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;b&#x27;, &#x27;a&#x27;], [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, &#x27;a&#x27;], [&#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;, &#x27;c&#x27;]])) print(sol.hasCycle([[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;e&#x27;, &#x27;b&#x27;], [&#x27;b&#x27;, &#x27;b&#x27;, &#x27;b&#x27;, &#x27;b&#x27;], [&#x27;b&#x27;, &#x27;c&#x27;, &#x27;c&#x27;, &#x27;d&#x27;], [&#x27;c&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;d&#x27;]]))main() Time ComplexityTime complexity of the above algorithm will be O(M * N), where ‘M’ is the number of rows and ‘N’ is the number of columns of the input matrix. This is due to the fact that we have to traverse the whole matrix to find cycles. Space ComplexityDFS recursion stack can go MN deep when the whole matrix is filled with the same character. Hence, the space complexity will be **O(M \\ N)**, where ‘M’ is the number of rows and ‘N’ is the number of columns of the input matrix.","categories":[{"name":"Grokking Interview Pattern","slug":"Grokking-Interview-Pattern","permalink":"https://hasuer.github.io/categories/Grokking-Interview-Pattern/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hasuer.github.io/tags/Interview/"}]},{"title":"12. Pattern Graphs","slug":"12. Pattern Graphs","date":"2024-05-12T01:42:19.000Z","updated":"2024-05-28T03:28:42.477Z","comments":true,"path":"12-pattern-graphs/index.html","link":"","permalink":"https://hasuer.github.io/12-pattern-graphs/index.html","excerpt":"","text":"Introduction to GraphA graph is a data structure that consists of a set of vertices (nodes) and a bunch of edges connecting these vertices. Graphs are widely used to model real-world scenarios where relationships and connections between entities must be represented. A Graph G (V, E) with five vertices (A, B, C, D, E) and six edges ((A, B), (B, C), (C, E), (E, D), (D, B), (D, A)) are shown in the following figure. Graphs can become more complex as they grow and have many interconnected nodes and edges. Graphs are a fundamental and versatile data structure used in various computer science applications to model and solve complex problems involving relationships and connections. Application of GraphsGraphs are versatile data structures that find applications in various fields. Here are five graph applications with facts and figures: 1. Social Network Analysis: Graphs are widely used for analyzing social networks to understand connections between individuals or entities. One of the most popular social networks is Facebook. 2. Transportation Network Optimization: Graphs are crucial in optimizing transportation networks like road or flight routes. For example, the road network of the United States spans over 4 million miles. Using graph algorithms like Dijkstra’s algorithm, authorities can efficiently find the shortest path between two locations, minimizing travel time and fuel consumption. 3. Internet and Webpage Ranking: Search engines like Google use graphs to rank webpages and determine their relevance to a search query. Google’s PageRank algorithm, which Larry Page and Sergey Brin introduced, utilizes a graph representation of the web. 4. Recommendation Systems: Graphs are employed in recommendation systems to provide personalized suggestions to users based on their preferences and behaviors. A popular streaming platform, Netflix uses a graph-based collaborative filtering approach to recommend movies and TV shows to its subscribers. 5. Bioinformatics and Protein Interactions: In bioinformatics, graphs model complex biological interactions, such as protein-protein interactions, gene regulatory networks, and metabolic pathways. The Human Protein Reference Database (HPRD), which stores protein-protein interaction data, contains information about more than 39,000 interactions among over 9,000 proteins. These examples demonstrate the wide-ranging applications of graphs in different domains, each significantly impacting the respective industries. Common Graph TerminologiesUnderstanding baseline graph terminologies is essential for understanding complex graph concepts. Like the other concepts, graph theory has some baseline terminologies. These terminologies are the most commonly used jargon in graphs. Understanding these jargons empower you better understand and communicate the graph concept. Here are some of the most commonly used graph terminologies: 1. Digraph: A digraph, short for directed graph, is a type of graph in which edges have a direction or are represented by arrows. Each edge connects two vertices (nodes), but the direction of the edge indicates a one-way relationship between the nodes. In other words, if there is an edge from vertex A to vertex B, you can only travel from A to B along that edge. 3. Loop in Graph: A “loop” in a graph refers to an edge that connects a vertex to itself. In other words, it is an edge that starts and ends at the same vertex. Loops can exist in both directed and undirected graphs. In an undirected graph, a loop is simply an edge that connects a vertex to itself. It forms a cycle of length 1. For example, if you have a graph with a single vertex v, and there is an edge from v to itself, then it forms a loop. In a directed graph, a loop is an arc (directed edge) that starts and ends at the same vertex. It forms a directed cycle of length 1. For example, if you have a graph with a single vertex v, and there is a directed edge from v to itself, then it forms a loop. 4. Node in Graph: A “node” (also known as a “vertex”) is a fundamental building block of a graph. A graph is a mathematical representation of a set of vertices (nodes) and the connections (edges) between those objects. The links between nodes can be either directed or undirected, depending on whether the relationship has a specific direction. In the following figure, A, B, C, D, and E are the nodes in the graph, also known as vertices. 5. Adjacent Nodes: Two nodes are said to be adjacent if an edge is connected directly. The set of nodes adjacent to a particular node is known as its neighborhood. As in the above figure, the nodes A and B are adjacent. 6. Degree of a Node: The degree of a node is the number of edges connected to it. In an undirected graph, it represents the number of neighbors a node has. As in the above figure, the degree of Node A is two because it has two neighbors. In a directed graph, there are two degrees: The in-degree (number of incoming edges) The out-degree (number of outgoing edges). In the above graph, the degree of node A is two because two edges are outgoing, and the degree of node C is 1. 7. Path: A sequence of vertices in which each consecutive pair of vertices is connected by an edge. For example in the above figure, there is a path from vertex A to B. 8. Cycle: A path in which the first and last vertices are the same, forming a closed loop. The following figure shows a route from A to B, B to D, D to C, and C to A. So here, the cycle completes because we start from vertex A and end again at A vertex. Graph TypesThere are several types of graphs, each with its specific characteristics. Here are some common types of graphs, along with examples: 1. Undirected Graph: In an undirected graph, edges have no direction, representing a bidirectional connection between two vertices. If an edge exists between vertex A and vertex B, you can traverse from A to B and vice versa. Example: Friends Network 2. Directed Graph: In a directed graph, edges have a direction, indicating a one-way connection between vertices. If there is an edge from vertex A to vertex B, you can only traverse from A to B, not vice versa. Example: Webpage Links 3. Weighted Graph: Each edge is associated with a numerical value called a weight in a weighted graph. The weight can represent distances, costs, or any other relevant metric between the connected vertices. Example: Transportation Network 4. Unweighted Graph: All edges have the same default weight of 1 in an unweighted graph. There are no additional numerical values associated with the edges. In an unweighted graph, the absence of edge weights implies that all edges are considered to have equal importance or distance between the connected nodes. Example: Family Tree (Connection exists or doesn’t) 5. Cyclic Graph: A cyclic graph is a graph that contains at least one cycle, which is a closed path (sequence of vertices) that starts and ends at the same vertex. 6. Acyclic Graph: An acyclic graph is a directed graph that has no cycles. A cycle occurs when the following edges from a node lead back to the same node. Some key properties of acyclic graphs: They have at least one node with no incoming edges (called a source node). They have at least one node with no outgoing edges (called a sink node). In this graph, node A is the root node. It has no incoming edges. Nodes D, E, F, G are leaf nodes - they have no outgoing edges. There are no cycles in this graph. A valid topological ordering of the nodes could be: A, B, C, D, E, F, G. So this graph structure forms an acyclic-directed graph. Trees and DAGs (Directed Acyclic Graphs) are common examples of acyclic graph structures 7. Connected Graph: A connected graph is one in which there is a path between every pair of vertices. In other words, every vertex is reachable from any other vertex in the graph. 8. Disconnected Graph: A disconnected graph has two or more connected components (subgraphs) with no direct connection between these components. The figure below is one separate graph. The first component contains A, B, C, and D vertices, and the other part contains E, F, G, and H, with at least two vertices not connected by a path. 9. Strongly Connected Graphs: A strongly connected graph is a type of directed graph in which there is a directed path from every vertex to every other vertex. In other words, for any two vertices, A and B, in a strongly connected graph, there is a directed path from A to B and B to A. These are some of the common types of graphs in data structures. Each type has its significance and use cases depending on the problem you’re trying to solve. Understanding different types of graphs is crucial for effectively applying graph algorithms and solving graph-related problems. Graph RepresentationsWe primarily represent graphs using two ways: Adjacency matrix Adjacency list Let’s explore what they are. Adjacency MatrixAn adjacency matrix is a common way to represent a graph as a matrix. It is a square matrix where the rows and columns represent the vertices of the graph, and the entries (elements) of the matrix indicate whether there is an edge between the corresponding vertices. In an undirected graph, the edges have no direction, meaning they can be traversed in both directions between two vertices. On the other hand, in a directed graph, the edges have a direction, indicating a one-way relationship between two vertices. As there are two major types of graphs directed graph and undirected graph. Let’s see how the adjacency matrix works for both types of graphs: Adjacency matrix for undirected graphsIn an undirected graph with N vertices, the adjacency matrix A will be an N x N matrix. For an undirected edge between vertices i and j, the corresponding entries in the matrix (A[i][j] and A[j][i]) will have a value of 1, indicating the presence of an edge. If there is no edge between vertices i and j, the matrix entries will have the value of 0. Example of an undirected graph with 4 vertices (A, B, C, D) and 4 edges (A-B, B-C, C-D, D-A): Adjacency matrix for directed graphsIn a directed graph with N vertices, the adjacency matrix A will also be an N x N matrix. For a directed edge from vertex i to vertex j, the corresponding entry in the matrix () will have the value of 1, indicating the presence of an edge from i to j. If there is no edge from vertex i to vertex j, the matrix entry will have the value of 0. Example of a directed graph with 4 vertices (A, B, C, D) and 5 directed edges (A-&gt;B, A-&gt;C, C-&gt;D, D-&gt;B, D-&gt;C): The above figure explains the adjacency matrix of the directed graph in such a way that there is an edge between vertices A-C and A-B so 1 is placed there. Adjacency ListIn linked list representation, an adjacency list is used to store the graph. An adjacency list is a common way to represent the connections between vertices in a graph. It is used in both directed and undirected graphs, but the way edges are stored and described differs slightly between the two types. In an adjacency list, each vertex is associated with a list of its neighboring vertices directly connected to it. Representing undirected graph using adjacency listIn an undirected graph, the edges between vertices have no direction. If vertex A is connected to vertex B, then vertex B is also connected to vertex A. As a result, the adjacency list for an undirected graph is symmetric. Here is an example of a undirected graph with four vertices (A, B, C, D) and four edges. Here is the adjacency list for the above-undirected graph. From vertex A there is an edge to vertex B and C in the graph. So in the adjacency list, there are two nodes from node A. Representing directed graphs using adjacency listIn a directed graph, the edges between vertices have a direction. If vertex X is connected to vertex Y, it does not necessarily mean that vertex Y is connected to vertex X. As a result, the adjacency list for a directed graph is not symmetric. Example of a directed graph with 4 vertices (A, B, C, D) and 4 directed edges (A-&gt;B, A-&gt;C, C-&gt;D, D-&gt;B): Here is the adjacency list for the above directed graph. From vertex A there is an edge to vertex B and C in the graph. So in the adjacency list, there are two nodes from node A. From vertex B there is no edge coming out so the adjacency list contains no further node from node B. Graph as an Abstract Data Type (ADT)As discussed earlier in the course, an abstract data type (ADT) is a theoretical concept that defines a set of operations and their behavior without specifying the internal representation of the data or the algorithms used to implement those operations. It provides a high-level description of the data and the functions that can be performed on it. Here are some of the operations can be performed on graphs: Adding a new vertex Removing a vertex Adding an edge between two vertices Removing an edge between two vertices Getting a list of all the vertices Checking if two graph nodes are adjacent to each other or not Getting count of the total vertices in the graph Getting count of the total edges in the graph Getting a list of the graph edges Getting neighbors of a graph vertex There are a few other ADT operations involving graph searching and traversal. Searching and traversal operations require detailed illustrations. Thereby, we will discuss those in the Graph Traversals section. 123456789101112131415161718192021222324252627282930313233343536from collections import defaultdictclass Graph: def __init__(self): self.adjacencyList = &#123;&#125; def add_vertex(self, vertex): pass # Add a new vertex to the graph. def remove_vertex(self, vertex): pass # Remove a vertex from the graph. def add_edge(self, vertex1, vertex2): pass # Add an edge between two vertices. def remove_edge(self, vertex1, vertex2): pass # Remove an edge between two vertices. def get_vertices(self): return [] # Get a list of all vertices. def is_adjacent(self, vertex1, vertex2): return False # Check if two vertices are adjacent. def get_vertex_count(self): return 0 # Get the total number of vertices. def get_edge_count(self): return 0 # Get the total number of edges. def get_edges(self): return [] # Get a list of all edges. def get_neighbors(self, vertex): return [] # Get a list of neighbors of a given vertex. Implementing the ADT operationsIn the beginning of this section, we mentioned ten major and the most common ADT operations associated with the graphs. Let’s discuss each operation individually - understanding how is it implemented. 1. add_vertex(vertex)The function add_vertex(vertex) is a common operation in graph theory, where it adds a new vertex (also called a node or point) to a graph data structure. The vertex is a fundamental unit of a graph and represents an entity or an element. Adding a vertex expands the graph and creates potential connections (edges) between this new vertex and existing vertices. In an adjacency list, each vertex is associated with a list of its adjacent vertices. We are using a dictionary or map for implementing the adjacency list. Thereby, we are able to store node key and value (s) associated with it. For this course, we assume that graphs don’t have any extra satellite data or values associated with it. Therefore, we will add an empty vector or list as a value attribute for the new graph node or vertex. You can add a new vertex following the two main steps: Check if vertex already exists Use predefined map or dictionary search methods If not, add it by inserting new key-value pair Keep value of the new inserted vertex as empty list Here is a generalized pseudocode: 12345678910111213141516Graph is represented as:adjacencyList (map/dictionary): key: vertex value: list of adjacent verticesFunction addVertex(vertex) if vertex does not exist in adjacencyList add new key-value pair: key: vertex value: empty list end if end Function Let’s now see the actual implementation of the add_vertex() method. 123def add_vertex(self, vertex): if vertex not in self.adjacency_list: self.adjacency_list[vertex] = [] 2. add_edge(vertex1, vertex2)Pseudocode 123456Function addEdge(vertex1, vertex2): insert vertex2 into adjacencyList[vertex1] insert vertex1 into adjacencyList[vertex2] end Function To implement the add_edge() function, we need to add an edge between vertex1 and vertex2 in the graph. We are using the insert method provided by the std::unordered_map. This method allows us to insert elements into the vector of neighbors directly using an iterator. Here is the implementation: 123def add_edge(self, vertex1, vertex2): self.adjacency_list[vertex1].append(vertex2) self.adjacency_list[vertex2].append(vertex1) A complete executable example12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273from collections import defaultdictclass Graph: def __init__(self): self.adjacency_list = defaultdict(list) def add_vertex(self, vertex): if vertex not in self.adjacency_list: self.adjacency_list[vertex] = [] def remove_vertex(self, vertex): if vertex not in self.adjacency_list: return self.adjacency_list.pop(vertex) for neighbors in self.adjacency_list.values(): if vertex in neighbors: neighbors.remove(vertex) def add_edge(self, vertex1, vertex2): self.adjacency_list[vertex1].append(vertex2) self.adjacency_list[vertex2].append(vertex1) def remove_edge(self, vertex1, vertex2): self.adjacency_list[vertex1].remove(vertex2) self.adjacency_list[vertex2].remove(vertex1) def get_vertices(self): return list(self.adjacency_list.keys()) def get_edges(self): edges = [] for vertex, neighbors in self.adjacency_list.items(): for neighbor in neighbors: if vertex &lt; neighbor: edges.append((vertex, neighbor)) return edges def get_neighbors(self, vertex): return self.adjacency_list[vertex] def is_adjacent(self, vertex1, vertex2): return vertex2 in self.adjacency_list[vertex1] def get_vertex_count(self): return len(self.adjacency_list) def get_edge_count(self): count = sum(len(neighbors) for neighbors in self.adjacency_list.values()) return count // 2 if __name__ == &quot;__main__&quot;: graph = Graph() vertices = [1, 2, 3, 4, 5, 6] edges = [(1, 2), (1, 3), (2, 3), (3, 4), (4, 5), (5, 6)] for v in vertices: graph.add_vertex(v) for edge in edges: graph.add_edge(*edge) print(f&quot;Vertices: &#123;graph.get_vertices()&#125;&quot;) print(f&quot;Edges: &#123;graph.get_edges()&#125;&quot;) print(f&quot;Neighbors of 1: &#123;graph.get_neighbors(1)&#125;&quot;) print(f&quot;Is 1 adjacent to 2? &#123;graph.is_adjacent(1, 2)&#125;&quot;) graph.remove_edge(1, 2) graph.remove_vertex(3) print(&quot;After removing an edge and vertex:&quot;) print(f&quot;Vertices: &#123;graph.get_vertices()&#125;&quot;) print(f&quot;Edges: &#123;graph.get_edges()&#125;&quot;) Graph TraversalA graph consists of vertices (nodes) connected by edges (lines). Graph traversal involves visiting all the graph nodes following a specific strategy or order. During traversal, each node is typically marked as visited to avoid revisiting the same node multiple times and to prevent infinite loops in cyclic graphs. There are two common graph traversal algorithms: Depth-First Search (DFS) and Breadth-First Search (BFS). Let’s briefly discuss each of them: Depth First Search(DFS)Depth-First Search (DFS) is a graph traversal algorithm that explores all the nodes in a graph by systematically visiting as far as possible along each branch before backtracking. It operates on both directed and undirected graphs and can be implemented using recursion or an explicit stack data structure. DFS starts from a selected source node (or a starting point) and explores as deeply as possible along each branch before backtracking. The algorithm visits nodes in a depth ward motion until it reaches a leaf node with no unexplored neighbors. At that point, it backtracks and explores other unexplored branches. Here’s a step-by-step explanation of the DFS algorithm: 1. Initialization: Choose a starting node as the source node. Create a data structure to keep track of visited nodes (e.g., an array or a hash set) and mark the source node as visited. 2. Visit the Current Node: Process the current node (e.g., print its value or perform any other operation you need to do). 3. Recursive Approach (Using Recursion): For each unvisited neighbor of the current node: Recursively call the DFS function with the neighbor as the new current node. Mark the neighbor as visited. 4. Stack-Based Approach (Using an Explicit Stack): Push the starting node onto the stack. While the stack is not empty: Pop a node from the stack (current node). Process the current node (e.g., print its value or perform any other operation you need to do). For each unvisited neighbor of the current node: Push the unvisited neighbor onto the stack. Mark the neighbor as visited. 5. Backtracking: If there are no more unvisited neighbors for the current node, backtrack by returning from the recursive function (if recursion) or popping nodes from the stack until a node with unvisited neighbors is found (if using an explicit stack). 6. Termination: The DFS algorithm terminates when all nodes reachable from the source node have been visited. This means that all connected components of the graph have been explored. Step-by-step Illustration of DFSLet’s illustrate Depth-First Search (DFS) on a simple graph with its step-by-step traversal process. Consider the following graph: Depth-First Search (DFS) algorithm on an undirected graph with 5 vertices We are starting from vertex 0, the DFS algorithm starts by putting it in the visited list and putting all its adjacent vertices in the stack. Next, we visit the element at the top of stack i.e. 1 and go to its adjacent nodes. Since 0 has already been visited, we visit 2 instead Vertex 2 has an unvisited adjacent vertex in 4, so we add that to the top of the stack and visit it. Next, we will visit 3. After we visit the last element 3, it doesn’t have any unvisited adjacent nodes, so we have completed the Depth First Traversal of the graph. Now, consider this example: Starting from node A, let’s perform DFS on this graph: Start at node A (the source node). Mark node A as visited and process it: A (visited). Explore an unvisited neighbor of A. Let’s say we choose B. Mark node B as visited and process it: A -&gt; B (visited). From node B, explore an unvisited neighbor. We choose D. Mark node D as visited and process it: A -&gt; B -&gt; D (visited). Node D has no unvisited neighbors, so we backtrack to node B. Node B has another unvisited neighbor, E. We explore E. Mark node E as visited and process it: A -&gt; B -&gt; D -&gt; E (visited). From node E, explore an unvisited neighbor. We choose F. Mark node F as visited and process it: A -&gt; B -&gt; D -&gt; E -&gt; F (visited). Node F has no unvisited neighbors, so we backtrack to node E. Node E has no more unvisited neighbors, so we backtrack to node B. Node B has no more unvisited neighbors, so we backtrack to node A. Node A has one more unvisited neighbor, C. We explore C. Mark node C as visited and process it: A -&gt; B -&gt; D -&gt; E -&gt; F -&gt; C (visited). Node C has no unvisited neighbors, so we backtrack to node A. Node A has no more unvisited neighbors, and we have visited all reachable nodes. The DFS traversal order for this graph starting from node A is: A -&gt; B -&gt; D -&gt; E -&gt; F -&gt; C. Note that the choice of the starting node can affect the order of traversal for the graph. Also, in a disconnected graph, you would need to start DFS from each unvisited node to traverse all components. Implementation of Depth First SearchBelow is an implementation of Depth-First Search (DFS) in C++, Python, Java, and JavaScript. DFS is a graph traversal algorithm that explores as far as possible along each branch before backtracking. In this example implementation, we assume that the graph is represented as an adjacency list. 123456789101112131415161718192021222324252627282930313233343536class Graph: def __init__(self, V): self.vertices = V self.adjList = [[] for _ in range(V)] def addEdge(self, u, v): self.adjList[u].append(v) self.adjList[v].append(u) # For an undirected graph def DFS(self, start): visited = [False] * self.vertices stack = [] stack.append(start) visited[start] = True while stack: curr = stack.pop() print(curr) for neighbor in self.adjList[curr]: if not visited[neighbor]: stack.append(neighbor) visited[neighbor] = Trueg = Graph(7)g.addEdge(0, 1)g.addEdge(0, 2)g.addEdge(1, 3)g.addEdge(1, 4)g.addEdge(2, 5)g.addEdge(2, 6)print(&quot;DFS Traversal starting from vertex 0:&quot;)g.DFS(0) Complexity analysisThe time and space complexity of Depth-First Search (DFS) depend on the size and structure of the graph being traversed. Let’s analyze the complexity of DFS: 1. Time Complexity: In the worst case, DFS once visits all nodes and edges in the graph. For a graph with V vertices (nodes) and E edges, the time complexity of DFS is O(V + E) The time complexity can be further broken down as follows: Visiting a node (marking it as visited and processing it) takes O(1) time. Exploring all neighbors of a node takes O(d) time, where ‘d’ is the average degree of nodes in the graph. In the worst case, ‘d’ can be as high as V - 1 (complete graph). So, the time complexity can be approximated as O(V) for exploring all neighbors of one node. In summary, the overall time complexity of DFS is: O(V + E) 2. Space Complexity: The space complexity of DFS is determined by the space needed to store information about the nodes during the traversal. The primary sources of space usage are the recursion stack (if using recursion) or the explicit stack data structure (if using an iterative approach). In the worst case, the maximum depth of the recursion stack (or the maximum number of nodes stored in the stack) is the height of the deepest branch of the graph. For a graph with a single connected component, this height can be O(V - 1) (when all nodes are connected in a straight line). The space complexity of the recursion stack in the worst case is O(V). Additionally, if an explicit stack is used, its space complexity would also be O(V) in the worst case. In summary, the overall space complexity of DFS is O(V) due to the recursion stack or the explicit stack. DFS can be used for various applications, such as finding connected components, detecting cycles in the graph, topological sorting, and solving problems like maze exploration or finding paths between nodes. It’s essential to be cautious about infinite loops when traversing graphs that may have cycles. To avoid this, the algorithm must keep track of visited nodes and avoid revisiting nodes that have already been explored. Overall, DFS is a powerful graph traversal algorithm that can efficiently explore the entire graph and is widely used in many graph-related problems. Breadth First Search (BFS)Breadth-First Search (BFS) is a graph traversal algorithm that explores a graph’s vertices (nodes) level by level. It starts from a selected source node and moves outward to visit all the nodes at the same distance from the source before moving on to nodes at the following distance level. BFS is particularly useful for finding the shortest path in unweighted graphs and for systematically exploring graphs. Here is a complete description of the Breadth-First Search algorithm: 1. Use a Queue BFS uses a queue to keep track of the nodes to be visited. The queue follows the First-In-First-Out (FIFO) principle, where the first node inserted in the queue will be the first one to be removed (dequeue). 2. Initialization: Start by selecting a source node to begin the traversal. Create an empty queue to hold the nodes to be visited. Mark the source node as visited and enqueue it into the queue. 3. Traversal: While the queue is not empty, continue the following steps: Dequeue a node from the front of the queue (let’s call it the “current node”). Process the current node (print it, perform some operation, etc.). Enqueue all the unvisited neighbors of the current node into the queue. Mark each enqueued neighbor as visited. 4. Termination: The BFS algorithm continues until the queue becomes empty, meaning all reachable nodes from the source node have been visited. Step-by-Step Illustration of BFSLet’s see how the Breadth First Search algorithm works with an example. We use an undirected graph with 5 vertices. We start from vertex 0, the BFS algorithm starts by putting it in the Visited list and putting all its adjacent vertices in the queue. Next, we visit the element at the front of queue i.e. 1 and go to its adjacent nodes. Since 0 has already been visited, we visit 2 instead. Vertex 2 has an unvisited adjacent vertex in 4, so we add that to the back of the queue and visit 3, which is at the front of the queue. Only 4 remains in the queue since the only adjacent node of 3 i.e. 0 is already visited. We visit it. Now, consider this example: Starting from the source node A, the BFS traversal would be as follows: Start with A (the source node) and enqueue it. Queue: [A] Dequeue A and process it. Enqueue its neighbors B and C. Queue: [B, C] Dequeue B and process it. Enqueue its neighbors D and E. Queue: [C, D, E] Dequeue C and process it. Enqueue its neighbor F. Queue: [D, E, F] Dequeue D and process it. No unvisited neighbors to enqueue. Queue: [E, F] Dequeue E and process it. Enqueue its neighbor F. Queue: [F] Dequeue F and process it. No unvisited neighbors to enqueue. Queue: [] The BFS traversal order is: A -&gt; B -&gt; C -&gt; D -&gt; E -&gt; F. BFS guarantees that it visits nodes in the order of their distance from the source node. It is an efficient algorithm to find the shortest path in unweighted graphs. Additionally, BFS can be used to find connected components, detect cycles, and solve various graph-related problems. However, it may consume more memory compared to DFS, especially in graphs with a large branching factor or infinite graphs. Implementation of Breadth First SearchBelow is an implementation of Breadth-First Search (DFS) in C++, Python, Java, and JavaScript. BFS is an algorithm used for traversing or searching a graph or tree in a level-by-level manner. 1234567891011121314151617181920212223242526272829303132333435363738394041from collections import defaultdict, dequeclass Graph: def __init__(self, vertices): self.V = vertices self.adjList = defaultdict(list) def addEdge(self, u, v): self.adjList[u].append(v) self.adjList[v].append(u) # For undirected graph def BFS(self, startVertex): visited = [False] * self.V # To keep track of visited vertices q = deque() visited[startVertex] = True q.append(startVertex) while q: currentVertex = q.popleft() print(currentVertex, end=&quot; &quot;) # Explore adjacent vertices for neighbor in self.adjList[currentVertex]: if not visited[neighbor]: visited[neighbor] = True q.append(neighbor)if __name__ == &quot;__main__&quot;: graph = Graph(6) # Create a graph with 6 vertices graph.addEdge(0, 1) graph.addEdge(0, 2) graph.addEdge(1, 3) graph.addEdge(2, 4) graph.addEdge(3, 4) graph.addEdge(3, 5) print(&quot;Breadth-First Traversal starting from vertex 0:&quot;) graph.BFS(0) Complexity analysisThe time and space complexity of Breadth-First Search (BFS) depends on the size of the graph and the way it is represented. Let’s analyze the complexities: 1. Time Complexity: Visiting a vertex takes O(1) time as we dequeue it from the queue in constant time. Exploring the neighbors of a vertex takes O(1) time per neighbor, as we have to traverse its adjacency list once. In the worst case, we visit all the vertices at least once, which takes O(V) time. Additionally, for each vertex, we explore all its neighbors once, which takes O(E) time in total (sum of the sizes of all adjacency lists). Hence, the overall time complexity of BFS is: O(V + E) 2. Space Complexity: The space required to store the graph using an adjacency list representation is O(V + E), as we need to store each vertex and its corresponding edges. The space required for the queue in BFS is O(V) in the worst case, as all the vertices can be in the queue at once. Since the space occupied by the queue is dominant in the overall space complexity, the space complexity of BFS is: O(V) BFS is generally efficient for searching and traversal when the graph is not too dense. For sparse graphs, where E is much smaller than V^2, the time complexity becomes almost linear, making BFS a reasonable choice for many practical applications. BFS guarantees it visits nodes according to their distance from the source node. It is an efficient algorithm to find the shortest path in unweighted graphs. Additionally, BFS can find connected components, detect cycles, and solve graph-related problems. However, it may consume more memory than DFS, especially in graphs with a significant or infinite branching factor. Find if Path Exists in Graph(easy)1971. Find if Path Exists in Graph Design Gurus Problem StatementGiven an undirected graph, represented as a list of edges. Each edge is illustrated as a pair of integers [u, v], signifying that there’s a mutual connection between node u and node v. Given this graph, a starting node start, and a destination node end, your task is to ascertain if a path exists between the starting node and the destination node. Examples Example 1: Input: 4, [[0,1],[1,2],[2,3]], 0, 3 Expected Output: true Justification: There’s a path from node 0 -&gt; 1 -&gt; 2 -&gt; 3. Example 2: Input: 4, [[0,1],[2,3]], 0, 3 Expected Output: false Justification: Nodes 0 and 3 are not connected, so no path exists between them. Example 3: Input: 5, [[0,1],[3,4]], 0, 4 Expected Output: false Justification: Nodes 0 and 4 are not connected in any manner. Constraints: 1 &lt;= n &lt;= 2 * 10^5 0 &lt;= edges.length &lt;= 2 * 10^5 edges[i].length == 2 0 &lt;= ui, vi &lt;= n - 1 ui != vi 0 &lt;= source, destination &lt;= n - 1 There are no duplicate edges. There are no self edges. SolutionThe task at hand is to determine if there’s a path from a starting node to an ending node in a given undirected graph. Our approach uses Depth First Search (DFS) to explore the graph recursively. Starting at the initial node, we’ll dive as deep as possible into its neighboring nodes. If we reach the target node at any point during the traversal, we know a path exists. If we exhaust all possible routes and haven’t found the target, then no path exists. Graph Representation: We’ll begin by converting the provided edge list into an adjacency list to represent our graph. The adjacency list is essentially an array (or list) of lists, where each index corresponds to a node, and its content is a list of neighbors for that node. Since our graph is undirected, if there’s an edge between nodes A and B, both A will be in B’s list and B in A’s list. Depth First Search (DFS): With our graph ready, we then use a recursive DFS function to traverse the graph. This function starts at the given node, and if it’s the target node, we return true. Otherwise, we mark this node as visited and call the DFS function on all its unvisited neighbors. This dives deeper into the graph. If any of these recursive calls return true (meaning they found the target), our current DFS call also returns true. Handling Cycles: To avoid getting stuck in a loop, especially in cyclic graphs, we keep track of which nodes we’ve visited. Before exploring a node, we’ll check if it’s been visited; if it has, we’ll skip it. Result: If our DFS exploration reaches the target node, we return true, signifying that a path exists. Otherwise, after checking all paths from the starting node and not finding the target, we’ll conclude and return false. Algorithm Walkthrough: Using the input from Example 1: Nodes = 4, Edges = [[0,1],[1,2],[2,3]], Start = 0, End = 3 Create the graph from the edges. Begin DFS at node 0. Mark node 0 as visited. Explore neighbors of node 0. Discover node 1. Delve into DFS for node 1. Mark node 1 as visited. Explore neighbors of node 1. Discover node 2. Delve into DFS for node 2. Mark node 2 as visited. Explore neighbors of node 2. Discover node 3. Since node 3 is the target end node, return true. CodeHere is the code for this algorithm: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869# 官方使用递归如下，但是我更习惯我写的，使用whilefrom collections import defaultdictclass Solution: def validPath(self, n: int, edges: [[int]], start: int, end: int) -&gt; bool: graph = defaultdict(list) # Create graph from edges for u, v in edges: graph[u].append(v) graph[v].append(u) # Undirected graph visited = set() def dfs(node): if node == end: # Found the path return True visited.add(node) # Traverse neighbors for neighbor in graph[node]: if neighbor not in visited and dfs(neighbor): return True return False # Path not found return dfs(start)# Testsol = Solution()print(sol.validPath(4, [[0,1],[1,2],[2,3]], 0, 3)) # trueprint(sol.validPath(4, [[0,1],[2,3]], 0, 3)) # falseprint(sol.validPath(5, [[0,1],[3,4]], 0, 4)) # false# 自己写的，可以过leetcodefrom collections import defaultdict, dequeclass Solution: def validPath(self, n: int, edges: [[int]], start: int, end: int) -&gt; bool: graph = &#123;i: [] for i in range(n)&#125; # Create graph from edges for u, v in edges: graph[u].append(v) graph[v].append(u) # Undirected graph visited = [False for i in range(n)] stack = deque() stack.append(start) visited[start] = True while stack: element = stack.pop() for child in graph[element]: if not visited[child]: stack.append(child) visited[child] = True if child == end: return True return False# Testsol = Solution()print(sol.validPath(4, [[0, 1], [1, 2], [2, 3]], 0, 3)) # trueprint(sol.validPath(4, [[0, 1], [2, 3]], 0, 3)) # falseprint(sol.validPath(5, [[0, 1], [3, 4]], 0, 4)) # false Time Complexity Graph Construction: Constructing the adjacency list from the given edge list takes (O(E)), where (E) is the number of edges. Each edge is processed once. DFS Traversal: In the worst-case scenario, the Depth-First Search (DFS) can traverse all nodes and all edges once. This traversal has a time complexity of (O(V + E)), where (V) is the number of vertices or nodes, and (E) is the number of edges. Combining the above, our time complexity is dominated by the DFS traversal, making it (O(V + E)). Space Complexity Graph Representation: The adjacency list requires (O(V + E)) space. Visited Set/Array: The visited set (or array) will take (O(V)) space, as it needs to track each node in the graph. Recursive Call Stack: The DFS function is recursive, and in the worst case (for a connected graph), it can have (V) nested calls. This would result in a call stack depth of (V), adding (O(V)) space complexity. The dominant factor here is the graph representation and the call stack, so the total space complexity is (O(V + E)). Summary: Time Complexity: (O(V + E)) Space Complexity: (O(V + E)) This makes our algorithm efficient, especially for sparse graphs (i.e., graphs with relatively fewer edges compared to nodes). The worst-case scenario is when the graph is fully connected, but even then, our algorithm is designed to handle it within reasonable limits. Number of Provinces (medium)547. Number of Provinces Design Gurus 也可以使用并查集，在Pattern Union Find中 Problem StatementImagine a country with several cities. Some cities have direct roads connecting them, while others might be connected through a sequence of intermediary cities. Using a matrix representation, if matrix[i][j] holds the value 1, it indicates that city i is directly linked to city j and vice versa. If it holds 0, then there’s no direct link between them. Determine the number of separate city clusters (or provinces). A province is defined as a collection of cities that can be reached from each other either directly or through other cities in the same province. Examples Input: 1[[1,1,0],[1,1,0],[0,0,1]] Expected Output:2 Justification:There are two provinces: cities 0 and 1 form one province, and city 2 forms its own province. Input: 1[[1,0,0,1],[0,1,1,0],[0,1,1,0],[1,0,0,1]] Expected Output:2 Justification:There are two provinces: cities 0 and 3 are interconnected forming one province, and cities 1 and 2 form another. Input: 1[[1,0,0],[0,1,0],[0,0,1]] Expected Output:3 Justification:Each city stands alone and is not connected to any other city. Thus, we have three provinces. Constraints: 1 &lt;= n &lt;= 200 n == isConnected.length n == isConnected[i].length isConnected[i][j] is 1 or 0. isConnected[i][i] == 1 isConnected[i][j] == isConnected[j][i] SolutionAt a high level, the problem of identifying provinces in the given matrix can be visualized as detecting connected components in an undirected graph. Every city represents a node, and a direct connection between two cities is an edge. The number of separate, interconnected clusters in this graph is essentially the number of provinces. To navigate this graph and identify these clusters, we employ the Depth First Search (DFS) technique, marking visited nodes (cities) along the way. Initialization: Start with a visited array, initialized with all values set to false. This will help in keeping track of cities that have been processed. DFS Function: This recursive function allows us to traverse the matrix. When an unvisited city is found, we recursively visit all other cities accessible from it, marking them as visited. All cities traversed in a single DFS invocation belong to the same province. Counting Provinces: Every unique invocation of the DFS function on an unvisited city, from the main function, signifies the discovery of a new province. Therefore, for each such invocation, we increment our province count. Completion: After every city has been visited, our province counter will hold the total number of provinces in the country. Algorithm Walkthrough: Using the input [[1,1,0],[1,1,0],[0,0,1]]: Begin with an unvisited visited array: [false, false, false]. Start from city 0: Visit city 0 and city 1 since they are connected. Update visited to [true, true, false]. City 2 remains unvisited, but it isn’t connected to any other unvisited city. So, it forms its own province. We initiated the DFS twice: once for the province comprising cities {0,1} and once for the solitary city 2. Our answer becomes 2. CodeHere is the code for this algorithm: 1234567891011121314151617181920212223242526# 官方使用的是递归class Solution: def findCircleNum(self, isConnected) -&gt; int: def dfs(city): # For each city, mark it as visited and explore its connections for i in range(len(isConnected)): if isConnected[city][i] == 1 and not visited[i]: visited[i] = True dfs(i) visited = [False] * len(isConnected) provinces = 0 for city in range(len(isConnected)): if not visited[city]: dfs(city) provinces += 1 return provinces# Test the Solution classsolution = Solution()print(solution.findCircleNum([[1,1,0], [1,1,0], [0,0,1]])) # Expected output: 2print(solution.findCircleNum([[1,0,0,1], [0,1,1,0], [0,1,1,0], [1,0,0,1]])) # Expected output: 2print(solution.findCircleNum([[1,0,0], [0,1,0], [0,0,1]])) # Expected output: 3 Time Complexity Depth First Search (DFS): For a given node, the DFS will explore all of its neighbors. In the worst case, we may end up visiting all nodes in the graph starting from a single node. Hence, the DFS complexity is (O(n)), where (n) is the number of nodes. Overall Time Complexity: For each node, we might call DFS once (if that node is not visited before). Thus, the overall time complexity is (O(n^2)), with the DFS call being nested inside a loop that iterates over all nodes. In dense graphs where each node is connected to every other node, we will reach this upper bound. Space Complexity Visited Array: This is an array of size (n) (the number of nodes), so its space requirement is (O(n)). Recursive Call Stack: In the worst case, if all cities are connected in a linear manner (like a linked list), the maximum depth of recursive DFS calls will be (n). Hence, the call stack will take (O(n)) space. Overall Space Complexity: The dominant space-consuming factors are the visited array and the recursive call stack. Hence, the space complexity is (O(n)). In summary: Time Complexity: (O(n^2)) Space Complexity: (O(n)) This algorithm is efficient because once a city is visited, it won’t be visited again, ensuring we don’t do redundant work. Moreover, using DFS allows us to deeply traverse through connected cities, marking entire provinces in one go. This approach optimizes our search and helps in reducing the number of unnecessary computations. Minimum Number of Vertices to Reach All Nodes(medium)1557. Minimum Number of Vertices to Reach All Nodes Design Gurus 这道题适合在拓扑排序中 Problem StatementGiven a directed acyclic graph with n nodes labeled from 0 to n-1, determine the smallest number of initial nodes such that you can access all the nodes by traversing edges. Return these nodes. Examples Input: n = 6 edges = [[0,1],[0,2],[2,5],[3,4],[4,2]] Expected Output: [0,3] Justification: Starting from nodes 0 and 3, you can reach all other nodes in the graph. Starting from node 0, you can reach nodes 1, 2, and 5. Starting from node 3, you can reach nodes 4 and 2 (and by extension 5). Input: n = 3 edges = [[0,1],[2,1]] Expected Output: [0,2] Justification: Nodes 0 and 2 are the only nodes that don’t have incoming edges. Hence, you need to start from these nodes to reach node 1. Input: n = 5 edges = [[0,1],[2,1],[3,4]] Expected Output: [0,2,3] Justification: Node 1 can be reached from both nodes 0 and 2, but to cover all nodes, you also need to start from node 3. Constraints: 2 &lt;= n &lt;= 10^5 1 &lt;= edges.length &lt;= min(10^5, n * (n - 1) / 2) edges[i].length == 2 0 &lt;= fromi, toi &lt; n All pairs (fromi, toi) are distinct. SolutionTo solve the problem of determining the minimum number of vertices needed to reach all nodes in a directed graph, we focus on the concept of “in-degree” which represents the number of incoming edges to a node. In a directed graph, if a node doesn’t have any incoming edges (in-degree of 0), then it means that the node cannot be reached from any other node. Hence, such nodes are mandatory starting points to ensure that every node in the graph can be reached. Our algorithm thus identifies all nodes with an in-degree of 0 as they are potential starting points to traverse the entire graph. Steps: Graph Representation: Begin by representing the graph using an adjacency list or a similar data structure. In-Degree Calculation: Compute the in-degree for all the nodes. The in-degree of a node is the number of edges coming into it. This can be done by initializing an array to keep track of in-degrees for each node and iterating over the edges to update the in-degree counts. Result Gathering: Iterate over the computed in-degrees. Nodes with an in-degree of 0 don’t have any incoming edges and thus are part of our result set as they serve as starting points. Algorithm Walkthrough:Let’s walk through the solution using the example n = 6 and edges = [[0,1],[0,2],[2,5],[3,4],[4,2]]: Step 1: Start with an in-degree array initialized to zeros for all nodes: [0, 0, 0, 0, 0, 0]. Step 2: Iterate over the edges. For each edge (source, destination), increment the in-degree of the destination node by 1. After processing all edges, the in-degree array becomes: [0,1,2,0,1,1]. Step 3: Finally, by examining the in-degree array, nodes 0 and 3 are identified as having an in-degree of 0. This means they don’t receive any incoming edges, and thus, they become our result set: [0,3]. Starting from these nodes, we can reach all other nodes in the graph. CodeHere is the code for this algorithm: 123456789101112131415161718192021222324252627from typing import Listclass Solution: def findSmallestSetOfVertices(self, n: int, edges: List[List[int]]) -&gt; List[int]: # Create a set to store nodes with incoming edges nodes_with_incoming = set() # Populate the set for _, to_node in edges: nodes_with_incoming.add(to_node) # Return nodes without incoming edges return [i for i in range(n) if i not in nodes_with_incoming]if __name__ == &quot;__main__&quot;: solution = Solution() # Test cases edges1 = [[0,1], [0,2], [2,5], [3,4], [4,2]] print(solution.findSmallestSetOfVertices(6, edges1)) # Expected: [0, 3] edges2 = [[0,1], [3,1], [1,2]] print(solution.findSmallestSetOfVertices(4, edges2)) # Expected: [0, 3] edges3 = [[2,0], [3,2]] print(solution.findSmallestSetOfVertices(4, edges3)) # Expected: [1, 3] Time Complexity: Initialization: Initializing the set for all nodes in the graph takes (O(n)), where (n) is the number of nodes. Processing Edges: For every edge ([u, v]), we are simply checking and potentially removing the node (v) from our set. Since we do a constant amount of work for each edge, this step takes (O(e)) time, where (e) is the number of edges. Thus, the overall time complexity is the sum of the above two steps, i.e., (O(n + e)). In the worst case (a complete graph), every node is connected to every other node, making (e = n^2), leading to a worst-case time complexity of (O(n^2)). However, this is not a typical scenario, and in most real-world graphs, (e) is often linear or close to linear with respect to (n). Therefore, (O(n + e)) is a more informative measure. Space Complexity: Set for Nodes: The set that we’re using to keep track of nodes which do not have any incoming edges will, at most, contain all nodes. This gives us a space complexity of (O(n)). Graph Representation: Though we are given the edges as an input, if we consider the space used by this representation, it will be (O(e)) for the edges. However, note that since we are not using any additional data structures that scale with the size of the graph other than the set for nodes, our primary concern is the set’s space. Thus, the dominant term here is (O(n)). So, the overall space complexity is (O(n)). In summary: Time Complexity: (O(n + e)) Space Complexity: (O(n))","categories":[{"name":"Grokking Interview Pattern","slug":"Grokking-Interview-Pattern","permalink":"https://hasuer.github.io/categories/Grokking-Interview-Pattern/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hasuer.github.io/tags/Interview/"}]},{"title":"11. Pattern Tree Depth First Search","slug":"11. Pattern Tree Depth First Search","date":"2024-05-11T00:50:28.000Z","updated":"2024-05-28T03:28:30.718Z","comments":true,"path":"11-pattern-tree-depth-first-search/index.html","link":"","permalink":"https://hasuer.github.io/11-pattern-tree-depth-first-search/index.html","excerpt":"","text":"IntroductionThis pattern is based on the Depth First Search (DFS) technique to traverse a tree. We will be using recursion (or we can also use a stack for the iterative approach) to keep track of all the previous (parent) nodes while traversing. This also means that the space complexity of the algorithm will be O(H), where ‘H’ is the maximum height of the tree. Let’s jump onto our first problem to understand this pattern. *Binary Tree Path Sum (easy)Top Interview 150 | 112. Path Sum Design Gurus Educative.io Problem StatementGiven a binary tree and a number ‘S’, find if the tree has a path from root-to-leaf such that the sum of all the node values of that path equals ‘S’. Constraints: The number of nodes in the tree is in the range [0, 5000]. -1000 &lt;= Node.val &lt;= 1000 -1000 &lt;= targetSum &lt;= 1000 SolutionAs we are trying to search for a root-to-leaf path, we can use the Depth First Search (DFS) technique to solve this problem. To recursively traverse a binary tree in a DFS fashion, we can start from the root and at every step, make two recursive calls one for the left and one for the right child. Here are the steps for our Binary Tree Path Sum problem: Start DFS with the root of the tree. If the current node is not a leaf node, do two things: Subtract the value of the current node from the given number to get a new sum =&gt; S = S - node.value Make two recursive calls for both the children of the current node with the new number calculated in the previous step. At every step, see if the current node being visited is a leaf node and if its value is equal to the given number ‘S’. If both these conditions are true, we have found the required root-to-leaf path, therefore return true. If the current node is a leaf but its value is not equal to the given number ‘S’, return false. Let’s take the example-2 mentioned above to visually see our algorithm: CodeHere is what our algorithm will look like: 1234567891011121314151617181920212223242526272829303132333435# class TreeNode:# def __init__(self, val, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def hasPath(self, root, sum): if root is None: return False # if the current node is a leaf and its value is equal to the sum, we&#x27;ve found a path if root.val == sum and root.left is None and root.right is None: return True # recursively call to traverse the left and right sub-tree # return true if any of the two recursive call return true return self.hasPath(root.left, sum - root.val) or self.hasPath(root.right, sum - root.val)def main(): sol = Solution() root = TreeNode(12) root.left = TreeNode(7) root.right = TreeNode(1) root.left.left = TreeNode(9) root.right.left = TreeNode(10) root.right.right = TreeNode(5) print(&quot;Tree has path: &quot; + str(sol.hasPath(root, 23))) print(&quot;Tree has path: &quot; + str(sol.hasPath(root, 16)))main() Time complexityThe time complexity of the above algorithm is O(N), where ‘N’ is the total number of nodes in the tree. This is due to the fact that we traverse each node once. Space complexityThe space complexity of the above algorithm will be O(N) in the worst case. This space will be used to store the recursion stack. The worst case will happen when the given tree is a linked list (i.e., every node has only one child). *All Paths for a Sum (medium) 113. Path Sum II Design Gurus Educative.io Problem StatementGiven a binary tree and a number ‘S’, find all paths from root-to-leaf such that the sum of all the node values of each path equals ‘S’. Constraints: The number of nodes in the tree is in the range [0, 5000]. -1000 &lt;= Node.val &lt;= 1000 -1000 &lt;= targetSum &lt;= 1000 SolutionThis problem follows the Binary Tree Path Sum pattern. We can follow the same DFS approach. There will be two differences: Every time we find a root-to-leaf path, we will store it in a list. We will traverse all paths and will not stop processing after finding the first path. Here is the visual representation of the algorithm: CodeHere is what our algorithm will look like: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# class TreeNode:# def __init__(self, val, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def findPaths(self, root, required_sum): allPaths = [] self.findPaths_recursive(root, required_sum, [], allPaths) return allPaths def findPaths_recursive(self, currentNode, required_sum, currentPath, allPaths): if currentNode is None: return # 原来以为这个if加了可以剪枝，还想着solution里怎么没有加，然后在leetcode提提交了之后出错了“[-2,null,-3]”。因为节点的值可能是负数。 # if sum &lt; root.val: # return # add the current node to the path currentPath.append(currentNode.val) # if the current node is a leaf and its value is equal to required_sum, save the # current path if currentNode.val == required_sum and currentNode.left is None \\ and currentNode.right is None: allPaths.append(list(currentPath)) else: # traverse the left sub-tree self.findPaths_recursive(currentNode.left, required_sum - currentNode.val, currentPath, allPaths) # traverse the right sub-tree self.findPaths_recursive(currentNode.right, required_sum - currentNode.val, currentPath, allPaths) # remove the current node from the path to backtrack, # we need to remove the current node while we are going up the recursive call stack. del currentPath[-1]def main(): sol = Solution() root = TreeNode(12) root.left = TreeNode(7) root.right = TreeNode(1) root.left.left = TreeNode(4) root.right.left = TreeNode(10) root.right.right = TreeNode(5) required_sum = 23 print(&quot;Tree paths with required_sum &quot; + str(required_sum) + &quot;: &quot; + str(sol.findPaths(root, required_sum)))main() Time complexityThe time complexity of the above algorithm is O(N^2), where ‘N’ is the total number of nodes in the tree. This is due to the fact that we traverse each node once (which will take O(N)), and for every leaf node we might have to store its path which will take O(N). We can calculate a tighter time complexity of O(NlogN) from the space complexity discussion below. Space complexityIf we ignore the space required for the allPaths list, the space complexity of the above algorithm will be O(N) in the worst case. This space will be used to store the recursion stack. The worst case will happen when the given tree is a linked list (i.e., every node has only one child). How can we estimate the space used for the allPaths array? Take the example of the following balanced tree: Here we have seven nodes (i.e., N = 7). Since, for binary trees, there exists only one path to reach any leaf node, we can easily say that total root-to-leaf paths in a binary tree can’t be more than the number of leaves. As we know that there can’t be more than N/2 leaves in a binary tree, therefore the maximum number of elements in allPaths will be O(N/2) = O(N). Now, each of these paths can have many nodes in them. For a balanced binary tree (like above), each leaf node will be at maximum depth. As we know that the depth (or height) of a balanced binary tree is O(logN) we can say that, at the most, each path can have logN nodes in it. This means that the total size of the allPaths list will be O(N\\logN)*. If the tree is not balanced, we will still have the same worst-case space complexity. From the above discussion, we can conclude that the overall space complexity of our algorithm is O(NlogN)*. Also from the above discussion, since for each leaf node, in the worst case, we have to copy log(N) nodes to store its path, therefore the time complexity of our algorithm will also be O(N\\logN)*. Similar ProblemsProblem 1: Given a binary tree, return all root-to-leaf paths. Solution: We can follow a similar approach. We just need to remove the “check for the path sum.” Problem 2: Given a binary tree, find the root-to-leaf path with the maximum sum. Solution: We need to find the path with the maximum sum. As we traverse all paths, we can keep track of the path with the maximum sum. Sum of Path Numbers (medium) Top Interview 150 | 129. Sum Root to Leaf Numbers Design Gurus Educative.io Problem StatementGiven a binary tree where each node can only have a digit (0-9) value, each root-to-leaf path will represent a number. Find the total sum of all the numbers represented by all paths. Constraints: The number of nodes in the tree is in the range [1, 1000]. 0 &lt;= Node.val &lt;= 9 The depth of the tree will not exceed 10. SolutionThis problem follows the Binary Tree Path Sum pattern. We can follow the same DFS approach. The additional thing we need to do is to keep track of the number representing the current path. How do we calculate the path number for a node? Taking the first example mentioned above, say we are at node ‘7’. As we know, the path number for this node is ‘17’, which was calculated by: 1 * 10 + 7 =&gt; 17. We will follow the same approach to calculate the path number of each node. Here is the visual representation of the algorithm: CodeHere is what our algorithm will look like: 1234567891011121314151617181920212223242526272829303132333435363738394041# class TreeNode:# def __init__(self, val, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def findSumOfPathNumbers(self, root): return self.find_root_to_leaf_path_numbers(root, 0) def find_root_to_leaf_path_numbers(self, currentNode, pathSum): if currentNode is None: return 0 # calculate the path number of the current node pathSum = 10 * pathSum + currentNode.val # if the current node is a leaf, return the current path sum if currentNode.left is None and currentNode.right is None: return pathSum # traverse the left and the right sub-tree return self.find_root_to_leaf_path_numbers(currentNode.left, pathSum) + \\ self.find_root_to_leaf_path_numbers(currentNode.right, pathSum)def main(): sol = Solution() root = TreeNode(1) root.left = TreeNode(0) root.right = TreeNode(1) root.left.left = TreeNode(1) root.right.left = TreeNode(6) root.right.right = TreeNode(5) print(&quot;Total Sum of Path Numbers: &quot; + str(sol.findSumOfPathNumbers(root)))main() Time complexityThe time complexity of the above algorithm is O(N), where ‘N’ is the total number of nodes in the tree. This is due to the fact that we traverse each node once. Space complexityThe space complexity of the above algorithm will be O(N) in the worst case. This space will be used to store the recursion stack. The worst case will happen when the given tree is a linked list (i.e., every node has only one child). *Path With Given Sequence (medium)Design Gurus Educative.io Problem StatementGiven a binary tree and a number sequence, find if the sequence is present as a root-to-leaf path in the given tree. Constraints: 1 &lt;= arr.length &lt;= 5000 0 &lt;= arr[i] &lt;= 9 Each node’s value is between [0 - 9]. SolutionThis problem follows the Binary Tree Path Sum pattern. We can follow the same DFS approach and additionally, track the element of the given sequence that we should match with the current node. Also, we can return false as soon as we find a mismatch between the sequence and the node value. Here is the visual representation of the algorithm: CodeHere is what our algorithm will look like: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# class TreeNode:# def __init__(self, val, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def findPath(self, root, sequence): if not root: return len(sequence) == 0 return self.find_path_recursive(root, sequence, 0) def find_path_recursive(self, currentNode, sequence, sequenceIndex): if currentNode is None: return False seqLen = len(sequence) if sequenceIndex &gt;= seqLen or currentNode.val != sequence[sequenceIndex]: return False # if the current node is a leaf, add it is the end of the sequence, we have found # a path! if currentNode.left is None and currentNode.right is None \\ and sequenceIndex == seqLen - 1: return True # recursively call to traverse the left and right sub-tree # return true if any of the two recursive call return true return self.find_path_recursive(currentNode.left, sequence, sequenceIndex + 1) or \\ self.find_path_recursive(currentNode.right, sequence, sequenceIndex + 1)def main(): sol = Solution() root = TreeNode(1) root.left = TreeNode(0) root.right = TreeNode(1) root.left.left = TreeNode(1) root.right.left = TreeNode(6) root.right.right = TreeNode(5) print(&quot;Tree has path sequence: &quot; + str(sol.findPath(root, [1, 0, 7]))) print(&quot;Tree has path sequence: &quot; + str(sol.findPath(root, [1, 1, 6])))main() Time complexityThe time complexity of the above algorithm is O(N), where ‘N’ is the total number of nodes in the tree. This is due to the fact that we traverse each node once. Space complexityThe space complexity of the above algorithm will be O(N) in the worst case. This space will be used to store the recursion stack. The worst case will happen when the given tree is a linked list (i.e., every node has only one child). *Count Paths for a Sum (medium) 437. Path Sum III Design Gurus Educative.io Problem StatementGiven a binary tree and a number ‘S’, find all paths in the tree such that the sum of all the node values of each path equals ‘S’. Please note that the paths can start or end at any node but all paths must follow direction from parent to child (top to bottom). Constraints: The number of nodes in the tree is in the range [0, 1000]. -10^9 &lt;= Node.val &lt;= 10^9 -1000 &lt;= targetSum &lt;= 1000 SolutionThis problem follows the Binary Tree Path Sum pattern. We can follow the same DFS approach. But there will be four differences: We will keep track of the current path in a list which will be passed to every recursive call. Whenever we traverse a node we will do two things: Add the current node to the current path. As we added a new node to the current path, we should find the sums of all sub-paths ending at the current node. If the sum of any sub-path is equal to ‘S’ we will increment our path count. We will traverse all paths and will not stop processing after finding the first path. Remove the current node from the current path before returning from the function. This is needed to Backtrack while we are going up the recursive call stack to process other paths. Here is the visual representation of the algorithm: CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# 也可以暴力解法：对于每一个节点都使用递归计算，可能也会TLE，具体详见下一题“problem challenge 1&quot;# class TreeNode:# def __init__(self, val, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def countPaths(self, root, S): return self.count_paths_recursive(root, S, []) def count_paths_recursive(self, currentNode, S, currentPath): if currentNode is None: return 0 # add the current node to the path currentPath.append(currentNode.val) pathCount, pathSum = 0, 0 # find the sums of all sub-paths in the current path list for i in range(len(currentPath) - 1, -1, -1): pathSum += currentPath[i] # if the sum of any sub-path is equal to &#x27;S&#x27; we increment our path count. if pathSum == S: pathCount += 1 # traverse the left sub-tree pathCount += self.count_paths_recursive(currentNode.left, S, currentPath) # traverse the right sub-tree pathCount += self.count_paths_recursive(currentNode.right, S, currentPath) # remove the current node from the path to backtrack # we need to remove the current node while we are going up the recursive call stack del currentPath[-1] return pathCountdef main(): sol = Solution() root = TreeNode(12) root.left = TreeNode(7) root.right = TreeNode(1) root.left.left = TreeNode(4) root.right.left = TreeNode(10) root.right.right = TreeNode(5) print(&quot;Tree has paths: &quot; + str(sol.countPaths(root, 11)))main() Time complexityThe time complexity of the above algorithm is O(N^2) in the worst case, where ‘N’ is the total number of nodes in the tree. This is due to the fact that we traverse each node once, but for every node, we iterate the current path. The current path, in the worst case, can be O(N) (in the case of a skewed tree). But, if the tree is balanced, then the current path will be equal to the height of the tree, i.e., O(logN). So the best case of our algorithm will be O(NlogN). Space complexityThe space complexity of the above algorithm will be O(N). This space will be used to store the recursion stack. The worst case will happen when the given tree is a linked list (i.e., every node has only one child). We also need O(N) space for storing the currentPath in the worst case. Overall space complexity of our algorithm is O(N). A more efficient solutionCan we further improve the solution? One thing we are repeating for each node is traversing the current path and seeing if any sub-path that ends at the current node gives us the required sum. Let’s see if we can improve this part. We can use the Prefix Sum technique to efficiently manage the path sums. Prefix Sum详见Pattern Prefix sum Let’s first understand what Prefix Sum is. For a given array, its Prefix Sum is another array where each element is the commutative sum of the corresponding element in the given array and all its previous elements. Here is an example: Now, let’s say we want to find all subarrays of a given array with a target sum. Let’s say our target sum is 7, and we want to find all the subarrays of the array mentioned above. We can clearly see that there are two such subarrays: 1) [1, 6], and 2) [2, 5]. How can we utilize the Prefix Sum array to find these two subarrays efficiently? There are two ways Prefix Sum can help us: a) Since each element of the prefix sum array contains the cumulative sum of current and previous elements, therefore, whenever we see our target sum, we have found our targeted subarray. For example, since the second element of the prefix sum array is 7; therefore, our target subarray will be from the start of the array till the second element, i.e., [1, 6] (b) Secondly, the prefix sum array can also help us find our target subarray that is not starting from the first index. If we subtract the target sum from any element of the prefix sum array, the result will also give us our target subarray (if that result is present in the prefix sum array). For example, take the 4th element of the prefix sum array and subtract the target sum from it: 14 – 7 =&gt; 7 Is this result (7) present in the prefix sum array? Yes, it is the second element. This means the sum from the 3rd element to the current element (i.e., the 4th) is also 7. Hence, our target subarray will be from the 3rd element to the current element, i.e., [2, 5]. Now, let’s see how we can use prefix sum for binary trees. Take the following example: We can consider each path as an array and calculate its prefix sums to find any required sub-paths. In the above tree, the highlighted sub-paths are exactly the same as our previous array example. Here is what our new algorithm will look like: CodeHere is the code for this algorithm: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class TreeNode: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = rightclass Solution: def count_paths(self, root, target_sum): # A map that stores the number of times a prefix sum has occurred so far. map = &#123;&#125; return self.count_paths_prefix_sum(root, target_sum, map, 0) def count_paths_prefix_sum(self, current_node, target_sum, map, current_path_sum): if current_node is None: return 0 # The number of paths that have the required sum. path_count = 0 # &#x27;current_path_sum&#x27; is the prefix sum, i.e., sum of all node values from the root # to the current node. current_path_sum += current_node.val # This is the base case. If the current sum is equal to the target sum, we have found # a path from root to the current node having the required sum. Hence, we increment # the path count by 1. if target_sum == current_path_sum: path_count += 1 # &#x27;current_path_sum&#x27; is the path sum from root to the current node. If within this path, # there is a valid solution, then there must be an &#x27;old_path_sum&#x27; such that: # =&gt; current_path_sum - old_path_sum = target_sum # =&gt; current_path_sum - target_sum = old_path_sum # Hence, we can search such an &#x27;old_path_sum&#x27; in the map from the key # &#x27;current_path_sum - target_sum&#x27;. path_count += map.get(current_path_sum - target_sum, 0) # This is the key step in the algorithm. We are storing the number of times the prefix sum # `current_path_sum` has occurred so far. map[current_path_sum] = map.get(current_path_sum, 0) + 1 # Counting the number of paths from the left and right subtrees. path_count += self.count_paths_prefix_sum(current_node.left, target_sum, map, current_path_sum) path_count += self.count_paths_prefix_sum(current_node.right, target_sum, map, current_path_sum) # Removing the current path sum from the map for backtracking. # &#x27;current_path_sum&#x27; is the prefix sum up to the current node. When we go # back (i.e., backtrack), then the current node is no more a part of the path, hence, we # should remove its prefix sum from the map. map[current_path_sum] = map.get(current_path_sum, 1) - 1 return path_countdef main(): sol = Solution() root = TreeNode(12) root.left = TreeNode(7) root.right = TreeNode(1) root.left.left = TreeNode(4) root.right.left = TreeNode(10) root.right.right = TreeNode(5) print(&quot;Tree has paths: &quot; + str(sol.count_paths(root, 11)))main() Time ComplexityAs we are not traversing the current path for each node, the time complexity of the above algorithm will be O(N) in the worst case, where ‘N’ is the total number of nodes in the tree. Space ComplexityThe space complexity of the above algorithm will be O(N). This space will be used to store the recursion stack, as well as for the prefix sum. *Problem Challenge 1 543. Diameter of Binary Tree Design Gurus Educative.io Tree Diameter (medium)Given a binary tree, find the length of its diameter. The diameter of a tree is the number of nodes on the longest path between any two leaf nodes. The diameter of a tree may or may not pass through the root. Note: You can always assume that there are at least two leaf nodes in the given tree. Constraints: n == edges.length + 1 1 &lt;= n &lt;= 10^4 0 &lt;= a_i, b_i &lt; n a_i != b_i SolutionThis problem follows the Binary Tree Path Sum pattern. We can follow the same DFS approach. There will be a few differences: At every step, we need to find the height of both children of the current node. For this, we will make two recursive calls similar to DFS. The height of the current node will be equal to the maximum of the heights of its left or right children, plus ‘1’ for the current node. The tree diameter at the current node will be equal to the height of the left child plus the height of the right child plus ‘1’ for the current node: diameter = leftTreeHeight + rightTreeHeight + 1. To find the overall tree diameter, we will use a class level variable. This variable will store the maximum diameter of all the nodes visited so far, hence, eventually, it will have the final tree diameter. Here is the visual representation of the algorithm: CodeHere is what our algorithm will look like: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# class TreeNode:# def __init__(self, val, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def findDiameter(self, root): self.treeDiameter = 0 self.calculate_height(root) return self.treeDiameter def calculate_height(self, currentNode): if currentNode is None: return 0 leftTreeHeight = self.calculate_height(currentNode.left) rightTreeHeight = self.calculate_height(currentNode.right) # if the current node doesn&#x27;t have a left or right subtree, we can&#x27;t have # a path passing through it, since we need a leaf node on each side if leftTreeHeight != 0 and rightTreeHeight != 0: # diameter at the current node will be equal to the height of left subtree + # the height of right sub-trees + &#x27;1&#x27; for the current node diameter = leftTreeHeight + rightTreeHeight + 1 # update the global tree diameter self.treeDiameter = max(self.treeDiameter, diameter) # height of the current node will be equal to the maximum of the heights of # left or right subtrees plus &#x27;1&#x27; for the current node return max(leftTreeHeight, rightTreeHeight) + 1def main(): sol = Solution() root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.right.left = TreeNode(5) root.right.right = TreeNode(6) print(&quot;Tree Diameter: &quot; + str(sol.findDiameter(root))) root.left.left = None root.right.left.left = TreeNode(7) root.right.left.right = TreeNode(8) root.right.right.left = TreeNode(9) root.right.left.right.left = TreeNode(10) root.right.right.left.left = TreeNode(11) print(&quot;Tree Diameter: &quot; + str(sol.findDiameter(root)))main() Time complexityThe time complexity of the above algorithm is O(N), where ‘N’ is the total number of nodes in the tree. This is due to the fact that we traverse each node once. Space complexityThe space complexity of the above algorithm will be O(N) in the worst case. This space will be used to store the recursion stack. The worst case will happen when the given tree is a linked list (i.e., every node has only one child). *Problem Challenge 2Top Interview 150 | 124. Binary Tree Maximum Path Sum Design Gurus Educative.io Path with Maximum Sum (hard)Find the path with the maximum sum in a given binary tree. Write a function that returns the maximum sum. A path can be defined as a sequence of nodes between any two nodes and doesn’t necessarily pass through the root. Constraints: The number of nodes in the tree is in the range [1, 3 * 10^4]. -1000 &lt;= Node.val &lt;= 1000 SolutionThis problem follows the Binary Tree Path Sum pattern and shares the algorithmic logic with Tree Diameter. We can follow the same DFS approach. The only difference will be to ignore the paths with negative sums. Since we need to find the overall maximum sum, we should ignore any path which has an overall negative sum. Here is the visual representation of the algorithm: CodeHere is what our algorithm will look like, the most important changes are in the highlighted lines: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import math# class TreeNode:# def __init__(self, val, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def findMaximumPathSum(self, root): self.globalMaximumSum = -math.inf self.find_maximum_path_sum_recursive(root) return self.globalMaximumSum def find_maximum_path_sum_recursive(self, currentNode): if currentNode is None: return 0 maxPathSumFromLeft = self.find_maximum_path_sum_recursive( currentNode.left) maxPathSumFromRight = self.find_maximum_path_sum_recursive( currentNode.right) # ignore paths with negative sums, since we need to find the maximum sum we should # ignore any path which has an overall negative sum. maxPathSumFromLeft = max(maxPathSumFromLeft, 0) maxPathSumFromRight = max(maxPathSumFromRight, 0) # maximum path sum at the current node will be equal to the sum from the left # subtree + the sum from right subtree + val of current node localMaximumSum = maxPathSumFromLeft + maxPathSumFromRight + currentNode.val # update the global maximum sum self.globalMaximumSum = max(self.globalMaximumSum, localMaximumSum) # maximum sum of any path from the current node will be equal to the maximum of # the sums from left or right subtrees plus the value of the current node return max(maxPathSumFromLeft, maxPathSumFromRight) + currentNode.valdef main(): sol = Solution() root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) print(&quot;Maximum Path Sum: &quot; + str(sol.findMaximumPathSum(root))) root.left.left = TreeNode(1) root.left.right = TreeNode(3) root.right.left = TreeNode(5) root.right.right = TreeNode(6) root.right.left.left = TreeNode(7) root.right.left.right = TreeNode(8) root.right.right.left = TreeNode(9) print(&quot;Maximum Path Sum: &quot; + str(sol.findMaximumPathSum(root))) root = TreeNode(-1) root.left = TreeNode(-3) print(&quot;Maximum Path Sum: &quot; + str(sol.findMaximumPathSum(root)))main() Time complexityThe time complexity of the above algorithm is O(N), where ‘N’ is the total number of nodes in the tree. This is due to the fact that we traverse each node once. Space complexityThe space complexity of the above algorithm will be O(N) in the worst case. This space will be used to store the recursion stack. The worst case will happen when the given tree is a linked list (i.e., every node has only one child).","categories":[{"name":"Grokking Interview Pattern","slug":"Grokking-Interview-Pattern","permalink":"https://hasuer.github.io/categories/Grokking-Interview-Pattern/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hasuer.github.io/tags/Interview/"}]},{"title":"10. Pattern Tree Breadth First Search","slug":"10. Pattern Tree Breadth First Search","date":"2024-05-10T09:24:15.000Z","updated":"2024-05-28T03:28:19.463Z","comments":true,"path":"10-pattern-tree-breadth-first-search/index.html","link":"","permalink":"https://hasuer.github.io/10-pattern-tree-breadth-first-search/index.html","excerpt":"","text":"IntroductionThis pattern is based on the Breadth First Search (BFS) technique to traverse a tree. Any problem involving the traversal of a tree in a level-by-level order can be efficiently solved using this approach. We will use a Queue to keep track of all the nodes of a level before we jump onto the next level. This also means that the space complexity of the algorithm will be O(W), where ‘W’ is the maximum number of nodes on any level. Let’s jump onto our first problem to understand this pattern. Binary Tree Level Order Traversal (easy)Top Interview 150 | 102. Binary Tree Level Order Traversal Design Gurus Educative.io Problem StatementGiven a binary tree, populate an array to represent its level-by-level traversal. You should populate the values of all nodes of each level from left to right in separate sub-arrays. Example 1: Example 2: Constraints: The number of nodes in the tree is in the range [0, 2000]. -1000 &lt;= Node.val &lt;= 1000 SolutionSince we need to traverse all nodes of each level before moving onto the next level, we can use the Breadth First Search (BFS) technique to solve this problem. We can use a Queue to efficiently traverse in BFS fashion. Here are the steps of our algorithm: Start by pushing the root node to the queue. Keep iterating until the queue is empty. In each iteration, first count the elements in the queue (let’s call it levelSize). We will have these many nodes in the current level. Next, remove levelSize nodes from the queue and push their value in an array to represent the current level. After removing each node from the queue, insert both of its children into the queue. If the queue is not empty, repeat from step 3 for the next level. Let’s take the example-2 mentioned above to visually represent our algorithm: CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from collections import deque# class TreeNode:# def __init__(self, val):# self.val = val# self.left, self.right = None, Noneclass Solution: def traverse(self, root): result = [] if root is None: return result queue = deque() queue.append(root) while queue: levelSize = len(queue) currentLevel = [] for _ in range(levelSize): currentNode = queue.popleft() # add the node to the current level currentLevel.append(currentNode.val) # insert the children of current node in the queue if currentNode.left: queue.append(currentNode.left) if currentNode.right: queue.append(currentNode.right) result.append(currentLevel) return resultdef main(): sol = Solution() root = TreeNode(12) root.left = TreeNode(7) root.right = TreeNode(1) root.left.left = TreeNode(9) root.right.left = TreeNode(10) root.right.right = TreeNode(5) print(&quot;Level order traversal: &quot; + str(sol.traverse(root)))main() Time complexityThe time complexity of the above algorithm is O(N), where ‘N’ is the total number of nodes in the tree. This is due to the fact that we traverse each node once. Space complexityThe space complexity of the above algorithm will be O(N) as we need to return a list containing the level order traversal. We will also need O(N) space for the queue. Since we can have a maximum of N/2 nodes at any level (this could happen only at the lowest level), therefore we will need O(N) space to store them in the queue. Reverse Level Order Traversal (easy)107. Binary Tree Level Order Traversal II Design Gurus Educative.io Problem StatementGiven a binary tree, populate an array to represent its level-by-level traversal in reverse order, i.e., the lowest level comes first. You should populate the values of all nodes in each level from left to right in separate sub-arrays. Example 1: Example 2: Constraints: The number of nodes in the tree is in the range [0, 2000]. -1000 &lt;= Node.val &lt;= 1000 SolutionThis problem follows the Binary Tree Level Order Traversal pattern. We can follow the same BFS approach. The only difference will be that instead of appending the current level at the end, we will append the current level at the beginning of the result list. Here is the visual representation of the algorithm: CodeHere is what our algorithm will look like; only the highlighted lines have changed. Please note that, for Java, we will use a LinkedList instead of an ArrayList for our result list. As in the case of ArrayList, appending an element at the beginning means shifting all the existing elements. Since we need to append the level array at the beginning of the result list, a LinkedList will be better, as this shifting of elements is not required in a LinkedList. Similarly, we will use a double-ended queue (deque) for Python, C++, and JavaScript. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from collections import deque# class TreeNode:# def __init__(self, val):# self.val = val# self.left, self.right = None, Noneclass Solution: def traverse(self, root): result = deque() if root is None: return result queue = deque() queue.append(root) while queue: levelSize = len(queue) currentLevel = [] for _ in range(levelSize): currentNode = queue.popleft() # add the node to the current level currentLevel.append(currentNode.val) # insert the children of current node in the queue if currentNode.left: queue.append(currentNode.left) if currentNode.right: queue.append(currentNode.right) result.appendleft(currentLevel) result = [list(sublist) for sublist in result] return resultdef main(): sol = Solution() root = TreeNode(12) root.left = TreeNode(7) root.right = TreeNode(1) root.left.left = TreeNode(9) root.right.left = TreeNode(10) root.right.right = TreeNode(5) print(&quot;Reverse level order traversal: &quot; + str(sol.traverse(root)))main() Time complexityThe time complexity of the above algorithm is O(N), where ‘N’ is the total number of nodes in the tree. This is due to the fact that we traverse each node once. Space complexityThe space complexity of the above algorithm will be O(N) as we need to return a list containing the level order traversal. We will also need O(N) space for the queue. Since we can have a maximum of N/2 nodes at any level (this could happen only at the lowest level), therefore we will need O(N) space to store them in the queue. Zigzag Traversal (medium)Top Interview 150 | 103. Binary Tree Zigzag Level Order Traversal Design Gurus Educative.io Problem StatementGiven a binary tree, populate an array to represent its zigzag level order traversal. You should populate the values of all nodes of the first level from left to right, then right to left for the next level and keep alternating in the same manner for the following levels. Example 1: Example 2: Constraints: The number of nodes in the tree is in the range [0, 2000]. -1000 &lt;= Node.val &lt;= 1000 SolutionThis problem follows the Binary Tree Level Order Traversal pattern. We can follow the same BFS approach. The only additional step we have to keep in mind is to alternate the level order traversal, which means that for every other level, we will traverse similar to Reverse Level Order Traversal. Here is the visual representation of the algorithm: CodeHere is what our algorithm will look like, only the highlighted lines have changed: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from collections import deque# class TreeNode:# def __init__(self, val):# self.val = val# self.left, self.right = None, Noneclass Solution: def traverse(self, root): result = [] if root is None: return result queue = deque() queue.append(root) leftToRight = True while queue: levelSize = len(queue) currentLevel = deque() for _ in range(levelSize): currentNode = queue.popleft() # add the node to the current level based on the traverse direction if leftToRight: currentLevel.append(currentNode.val) else: currentLevel.appendleft(currentNode.val) # insert the children of current node in the queue if currentNode.left: queue.append(currentNode.left) if currentNode.right: queue.append(currentNode.right) result.append(list(currentLevel)) # reverse the traversal direction leftToRight = not leftToRight return resultdef main(): sol = Solution() root = TreeNode(12) root.left = TreeNode(7) root.right = TreeNode(1) root.left.left = TreeNode(9) root.right.left = TreeNode(10) root.right.right = TreeNode(5) root.right.left.left = TreeNode(20) root.right.left.right = TreeNode(17) print(&quot;Zigzag traversal: &quot; + str(sol.traverse(root)))main() Time complexityThe time complexity of the above algorithm is O(N), where ‘N’ is the total number of nodes in the tree. This is due to the fact that we traverse each node once. Space complexityThe space complexity of the above algorithm will be O(N) as we need to return a list containing the level order traversal. We will also need O(N) space for the queue. Since we can have a maximum of N/2 nodes at any level (this could happen only at the lowest level), therefore we will need O(N) space to store them in the queue. Level Averages in a Binary Tree (easy)Top Interview 150 | 637. Average of Levels in Binary Tree Design Gurus Educative.io Problem StatementGiven a binary tree, populate an array to represent the averages of all of its levels. Example 1: Example 2: Constraints: The number of nodes in the tree is in the range [1, 10^4]. -2^31 &lt;= Node.val &lt;= 2^31 - 1 SolutionThis problem follows the Binary Tree Level Order Traversal pattern. We can follow the same BFS approach. The only difference will be that instead of keeping track of all nodes of a level, we will only track the running sum of the values of all nodes in each level. In the end, we will append the average of the current level to the result array. Here is the visual representation of the algorithm: CodeHere is what our algorithm will look like; only the highlighted lines have changed:67u 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from collections import deque# class TreeNode:# def __init__(self, val):# self.val = val# self.left, self.right = None, Noneclass Solution: def findLevelAverages(self, root): result = [] if root is None: return result queue = deque() queue.append(root) while queue: levelSize = len(queue) levelSum = 0.0 for _ in range(levelSize): currentNode = queue.popleft() # add the node&#x27;s value to the running sum levelSum += currentNode.val # insert the children of current node to the queue if currentNode.left: queue.append(currentNode.left) if currentNode.right: queue.append(currentNode.right) # append the current level&#x27;s average to the result array result.append(levelSum / levelSize) return resultdef main(): sol = Solution() root = TreeNode(12) root.left = TreeNode(7) root.right = TreeNode(1) root.left.left = TreeNode(9) root.left.right = TreeNode(2) root.right.left = TreeNode(10) root.right.right = TreeNode(5) print(&quot;Level averages are: &quot; + str(sol.findLevelAverages(root)))main() Time complexityThe time complexity of the above algorithm is O(N), where ‘N’ is the total number of nodes in the tree. This is due to the fact that we traverse each node once. Space complexityThe space complexity of the above algorithm will be O(N) which is required for the queue. Since we can have a maximum of N/2 nodes at any level (this could happen only at the lowest level), therefore we will need O(N) space to store them in the queue. Similar ProblemsProblem 1: Find the largest value on each level of a binary tree. Solution: We will follow a similar approach, but instead of having a running sum we will track the maximum value of each level. 1maxValue = max(maxValue, currentNode.val) # Minimum Depth of a Binary Tree (easy)111. Minimum Depth of Binary Tree Design Gurus Educative.io Problem StatementFind the minimum depth of a binary tree. The minimum depth is the number of nodes along the shortest path from the root node to the nearest leaf node. Example 1: Example 2: Constraints: The number of nodes in the tree is in the range [0, 10^5]. -1000 &lt;= Node.val &lt;= 1000 SolutionThis problem follows the Binary Tree Level Order Traversal pattern. We can follow the same BFS approach. The only difference will be, instead of keeping track of all the nodes in a level, we will only track the depth of the tree. As soon as we find our first leaf node, that level will represent the minimum depth of the tree. Here is the visual representation of the algorithm: CodeHere is what our algorithm will look like, only the highlighted lines have changed: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from collections import deque# class TreeNode:# def __init__(self, val):# self.val = val# self.left, self.right = None, Noneclass Solution: def findDepth(self, root): if root is None: return 0 queue = deque() queue.append(root) minimumTreeDepth = 0 while queue: minimumTreeDepth += 1 levelSize = len(queue) for _ in range(levelSize): currentNode = queue.popleft() # check if this is a leaf node if not currentNode.left and not currentNode.right: return minimumTreeDepth # insert the children of current node in the queue if currentNode.left: queue.append(currentNode.left) if currentNode.right: queue.append(currentNode.right)def main(): sol = Solution() root = TreeNode(12) root.left = TreeNode(7) root.right = TreeNode(1) root.right.left = TreeNode(10) root.right.right = TreeNode(5) print(&quot;Tree Minimum Depth: &quot; + str(sol.findDepth(root))) root.left.left = TreeNode(9) root.right.left.left = TreeNode(11) print(&quot;Tree Minimum Depth: &quot; + str(sol.findDepth(root)))main() Time complexityThe time complexity of the above algorithm is O(N), where ‘N’ is the total number of nodes in the tree. This is due to the fact that we traverse each node once. Space complexityThe space complexity of the above algorithm will be O(N) which is required for the queue. Since we can have a maximum of N/2 nodes at any level (this could happen only at the lowest level), therefore we will need O(N) space to store them in the queue. Similar ProblemsTop Interview 150 | 104. Maximum Depth of Binary Tree Design Gurus Educative.io Problem 1: Given a binary tree, find its maximum depth (or height). Solution: We will follow a similar approach. Instead of returning as soon as we find a leaf node, we will keep traversing for all the levels, incrementing maximumDepth each time we complete a level. Here is what the code will look like: Here is the visual representation of the algorithm: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from collections import deque# class TreeNode:# def __init__(self, val):# self.val = val# self.left, self.right = None, Noneclass Solution: def find_maximum_depth(self, root): if root is None: return 0 queue = deque() queue.append(root) maximumTreeDepth = 0 while queue: maximumTreeDepth += 1 levelSize = len(queue) for _ in range(levelSize): currentNode = queue.popleft() # insert the children of current node in the queue if currentNode.left: queue.append(currentNode.left) if currentNode.right: queue.append(currentNode.right) return maximumTreeDepthdef main(): sol = Solution() root = TreeNode(12) root.left = TreeNode(7) root.right = TreeNode(1) root.right.left = TreeNode(10) root.right.right = TreeNode(5) print(&quot;Tree Maximum Depth: &quot; + str(sol.find_maximum_depth(root))) root.left.left = TreeNode(9) root.right.left.left = TreeNode(11) print(&quot;Tree Maximum Depth: &quot; + str(sol.find_maximum_depth(root)))main() Level Order Successor (easy)Design Gurus Educative.io Problem StatementGiven a binary tree and a node, find the level order successor of the given node in the tree. The level order successor is the node that appears right after the given node in the level order traversal. Example 1: Example 2: Example 3: Constraints: The number of nodes in the tree is in the range [0, 10^5]. -1000 &lt;= Node.val &lt;= 1000 SolutionThis problem follows the Binary Tree Level Order Traversal pattern. We can follow the same BFS approach. The only difference will be that we will not keep track of all the levels. Instead we will keep inserting child nodes to the queue. As soon as we find the given node, we will return the next node from the queue as the level order successor. Here is the visual representation of the algorithm: CodeHere is what our algorithm will look like; most of the changes are in the highlighted lines: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# 这是官方solution，但是这个方法有个局限就是所有的值都要唯一from collections import deque# class TreeNode:# def __init__(self, val):# self.val = val# self.left, self.right = None, Noneclass Solutiion: def findSuccessor(self, root, key): if root is None: return None queue = deque() queue.append(root) while queue: currentNode = queue.popleft() # insert the children of current node in the queue if currentNode.left: queue.append(currentNode.left) if currentNode.right: queue.append(currentNode.right) # break if we have found the key if currentNode.val == key: break return queue[0] if queue else Nonedef main(): sol = Solutiion() root = TreeNode(1); root.left = TreeNode(2); root.right = TreeNode(3); root.left.left = TreeNode(4); root.left.right = TreeNode(5); result = sol.findSuccessor(root, 3) if result: print(result.val) root = TreeNode(12) root.left = TreeNode(7) root.right = TreeNode(1) root.left.left = TreeNode(9) root.right.left = TreeNode(10) root.right.right = TreeNode(5) result = sol.findSuccessor(root, 9) if result: print(result.val) result = sol.findSuccessor(root, 12) if result: print(result.val)main() Time complexityThe time complexity of the above algorithm is O(N), where ‘N’ is the total number of nodes in the tree. This is due to the fact that we traverse each node once. Space complexityThe space complexity of the above algorithm will be O(N) which is required for the queue. Since we can have a maximum of N/2 nodes at any level (this could happen only at the lowest level), therefore we will need O(N) space to store them in the queue. 这里在遍历的时候就没有使用LevelSize这个变量,也就没有了While中还嵌套for这个循环，之前的题目中使用这个循环的意义是，由于之前的题目要求广度优先遍历的时候，输出要把一个层次中的放在一起，所以需要知道个数，再使用for循环遍历。如果题目要求没有这个，只要求输出广度优先遍历的结果，只要就不需要使用for循环，只要while(!queue.empty())有就够了。就像这个题目所写的一样。 Connect Level Order Siblings (medium) 116. Populating Next Right Pointers in Each Node Similar | Top Interview 150 |117. Populating Next Right Pointers in Each Node II Design Gurus Educative.io Problem StatementGiven a binary tree, connect each node with its level order successor. The last node of each level should point to a null node. Example 1: Example 2: Constraints: The number of nodes in the tree is in the range [0, 2^12 - 1]. -1000 &lt;= Node.val &lt;= 1000 SolutionThis problem follows the Binary Tree Level Order Traversal pattern. We can follow the same BFS approach. The only difference is that while traversing a level we will remember the previous node to connect it with the current node. Here is the visual representation of the algorithm: CodeHere is the code for this algorithm: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566from collections import deque# class TreeNode:# def __init__(self, val):# self.val = val# self.left, self.right, self.next = None, None, None# level order traversal using &#x27;next&#x27; pointerdef print_level_order(root): nextLevelRoot = root while nextLevelRoot: current = nextLevelRoot nextLevelRoot = None while current: print(str(current.val) + &quot; &quot;, end=&#x27;&#x27;) if not nextLevelRoot: if current.left: nextLevelRoot = current.left elif current.right: nextLevelRoot = current.right current = current.next print()class Solution: def connect(self, root): if root is None: return queue = deque() queue.append(root) while queue: previousNode = None levelSize = len(queue) # connect all nodes of this level for _ in range(levelSize): currentNode = queue.popleft() if previousNode: previousNode.next = currentNode previousNode = currentNode # insert the children of current node in the queue if currentNode.left: queue.append(currentNode.left) if currentNode.right: queue.append(currentNode.right) return rootdef main(): sol = Solution() root = TreeNode(12) root.left = TreeNode(7) root.right = TreeNode(1) root.left.left = TreeNode(9) root.right.left = TreeNode(10) root.right.right = TreeNode(5) root = sol.connect(root) print(&quot;Level order traversal using &#x27;next&#x27; pointer: &quot;) print_level_order(root)main() Time complexityThe time complexity of the above algorithm is O(N), where ‘N’ is the total number of nodes in the tree. This is due to the fact that we traverse each node once. Space complexityThe space complexity of the above algorithm will be O(N), which is required for the queue. Since we can have a maximum of N/2 nodes at any level (this could happen only at the lowest level), therefore we will need O(N) space to store them in the queue. Problem Challenge 1Design Gurus Educative.io Connect All Level Order Siblings (medium)Given a binary tree, connect each node with its level order successor. The last node of each level should point to the first node of the next level. SolutionThis problem follows the Binary Tree Level Order Traversal pattern. We can follow the same BFS approach. The only difference will be that while traversing we will remember (irrespective of the level) the previous node to connect it with the current node. CodeHere is what our algorithm will look like; only the highlighted lines have changed: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# 比较简单的还是，和上一题很类似from collections import deque# class TreeNode:# def __init__(self, val):# self.val = val# self.left, self.right, self.next = None, None, Noneclass Solution: def connect(self, root): if root is None: return root queue = deque() queue.append(root) currentNode, previousNode = None, None while queue: currentNode = queue.popleft() if previousNode: previousNode.next = currentNode previousNode = currentNode # insert the children of current node in the queue if currentNode.left: queue.append(currentNode.left) if currentNode.right: queue.append(currentNode.right) return root# tree traversal using &#x27;next&#x27; pointerdef print_tree(self): print(&quot;Traversal using &#x27;next&#x27; pointer: &quot;, end=&#x27;&#x27;) current = self while current: print(str(current.val) + &quot; &quot;, end=&#x27;&#x27;) current = current.nextdef main(): sol = Solution() root = TreeNode(12) root.left = TreeNode(7) root.right = TreeNode(1) root.left.left = TreeNode(9) root.right.left = TreeNode(10) root.right.right = TreeNode(5) sol.connect(root) print_tree(root)main() Time complexityThe time complexity of the above algorithm is O(N), where ‘N’ is the total number of nodes in the tree. This is due to the fact that we traverse each node once. Space complexityThe space complexity of the above algorithm will be O(N) which is required for the queue. Since we can have a maximum of N/2 nodes at any level (this could happen only at the lowest level), therefore we will need O(N) space to store them in the queue. Problem Challenge 2Top Interview 150 | 199. Binary Tree Right Side View Design Gurus Educative.io Right View of a Binary Tree (easy)Given a binary tree, return an array containing nodes in its right view. The right view of a binary tree is the set of nodes visible when the tree is seen from the right side. Constraints: The number of nodes in the tree is in the range [0, 100]. -100 &lt;= Node.val &lt;= 100 SolutionThis problem follows the Binary Tree Level Order Traversal pattern. We can follow the same BFS approach. The only additional thing we will be doing is to append the last node of each level to the result array. Here is the visual representation of the algorithm: CodeHere is what our algorithm will look like; only the highlighted lines have changed: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from collections import deque# class TreeNode:# def __init__(self, val):# self.val = val# self.left, self.right = None, Noneclass Solution: def traverse(self, root): result = [] if root is None: return result queue = deque() queue.append(root) while queue: levelSize = len(queue) for i in range(0, levelSize): currentNode = queue.popleft() # if it is the last node of this level, add it to the result if i == levelSize - 1: result.append(currentNode.val) # insert the children of current node in the queue if currentNode.left: queue.append(currentNode.left) if currentNode.right: queue.append(currentNode.right) return resultdef main(): sol = Solution() root = TreeNode(12) root.left = TreeNode(7) root.right = TreeNode(1) root.left.left = TreeNode(9) root.right.left = TreeNode(10) root.right.right = TreeNode(5) root.left.left.left = TreeNode(3) result = sol.traverse(root) print(&quot;Tree right view: &quot;) for val in result: print(str(val) + &quot; &quot;, end=&#x27;&#x27;)main() Time complexityThe time complexity of the above algorithm is O(N), where ‘N’ is the total number of nodes in the tree. This is due to the fact that we traverse each node once. Space complexityThe space complexity of the above algorithm will be O(N) as we need to return a list containing the level order traversal. We will also need O(N) space for the queue. Since we can have a maximum of N/2 nodes at any level (this could happen only at the lowest level), therefore we will need O(N) space to store them in the queue. Similar QuestionsProblem 1: Given a binary tree, return an array containing nodes in its left view. The left view of a binary tree is the set of nodes visible when the tree is seen from the left side. Solution: We will be following a similar approach, but instead of appending the last element of each level we will be appending the first element of each level to the output array.","categories":[{"name":"Grokking Interview Pattern","slug":"Grokking-Interview-Pattern","permalink":"https://hasuer.github.io/categories/Grokking-Interview-Pattern/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hasuer.github.io/tags/Interview/"}]},{"title":"9. Pattern Hash Maps","slug":"9. Pattern Hash Maps","date":"2024-05-09T09:20:57.000Z","updated":"2024-05-28T03:28:07.562Z","comments":true,"path":"9-pattern-hash-maps/index.html","link":"","permalink":"https://hasuer.github.io/9-pattern-hash-maps/index.html","excerpt":"","text":"Introduction to HashingImagine you have a huge bookshelf (like, Hogwarts library size). You’ve got a new book and need to find a spot for it and later on, search it quickly every time you need it. Instead of scanning the whole shelf, you use a magical spell that tells you exactly where to place or find it. This magical spell takes the book’s title and gives you a specific location, like “4th shelf, 10th spot”. But remember! Even if you slightly change the book’s title, the spell gives a completely different spot. Now, let’s map this to computer science: Hashing: It’s a technique that takes an input (or ‘message’) and returns a fixed-size string, which looks random. The output, known as the hash value, is unique (mostly) to the given input. Hash Function: This is our “magical spell” that converts the input data (like our book title) into a fixed-length value. However, no magic is perfect. If two different inputs give the same hash, that’s called a collision. It’s like our spell accidentally pointing to the same spot for two different books. Good hash functions make these super rare. We will discuss this in detail later on. The following illustration depicts a generalized hashing scenario. But why hashing is important? Let’s find out! Why hashing?Hashing is a great tool to quickly access, protect, and verify data. Here are a few of the common use cases of hashing: Quick Data Retrieval: Hashing helps in accessing data super fast. With it, systems can quickly find a data piece without searching the whole database or list. Data Integrity Checks: When downloading a file from the web, the site may provide you with a hash value for that file. If even a tiny portion of that file changes during the download, its hash will differ. By comparing the provided hash with the hash of the downloaded file, you can determine whether the file is exactly as the original, or if it was tampered with during the transfer Password Security: Instead of storing actual passwords, systems store their hash. It’s like locking the real magical item away and just keeping a hologram on display. Hash Tables: Hashing is used in programming for efficient data structures like hash tables. It’s like having organized shelves for our books where each item has its designated spot. Cryptography: Some hash functions are used in cryptography to ensure data confidentiality and integrity. It’s like a spell that only allows certain wizards to read a message. Data Deduplication: If you’re saving data, and you don’t want duplicates, you can just compare their hashes. Same hash? It’s the same data. It ensures you’re not wasting space with repeated magical items. Load Balancing: In big systems serving many users, hashes can be used to decide which server should handle a particular request. It’s like deciding which magical portal to send a wizard based on their wand. Hashing has numerous applications in several practical domains. However, this section tries to cover Hashing for defining and implementing a retrieval efficient data structure called Hash Table, which will be our next lesson. Introduction to Hash TablesA Hash Table (also known as Hash Map), at its core, is a data structure that allows us to store and retrieve data efficiently. If we think about a real-life analogy, it’s like a library where each book (data) has a unique identifier (key) like ISBN, and all books are organized in a specific way to allow the librarian (hash function) to find and retrieve them quickly. In other words, a Hash Table implements an associative array abstract data type (or Dictionary ADT), mapping keys to values. A Hash Table uses a hash function to compute an index into an array of buckets or slots where the desired value is stored. There are four main elements to any Hash Table: Keys, Values, the Hash Function, and Buckets. Keys: In our library analogy, think of keys as the unique identifiers for each book. Keys are the inputs we feed into our hash function. They can be any data type - numbers, strings, or even objects. The crucial characteristic of keys is that they should be unique. If two pieces of data share the same key, it might lead to complications, like collisions (we’ll discuss this in detail later). Values: Values are the actual data that we store in our Hash Table. They could be anything from a single number to a complex object or even a function. Using the key, we can quickly retrieve the corresponding value from the Hash Table. Hash Function - H(x): We’ve touched on this before, but it’s worth emphasizing the importance of the hash function. This is the engine that drives a Hash Table. It’s responsible for transforming keys into hash values, which dictate where we store our data in the table. Buckets: Once the hash function processes our key, it produces a hash value. This value corresponds to a specific location or ‘bucket’ within the Hash Table. Think of buckets as shelves in our library, each one designated to store a specific book (or piece of data). Here are the three basic operations that are performed on Hash Tables: Insert(key, value) operation: Calculates the hash index H(key) and stores the key-value pair in the slot at that index. Search(key) operation: Computes H(key) to find the slot and returns the value associated with the key, or null if not present. Delete(key) operation: Removes the key-value pair stored at index H(key). A naive Hash Table implementationImagine once again a major public library that needs to store basic information, such as Key (ISBN), Title, and Placement Info, for all available books. This system is heavily used, with librarians frequently searching for books. This results in many retrieval requests. The frequent retrievals require an efficient solution that can quickly perform the search operation (ideally, in constant time). Therefore, the Hash table data structure perfectly suits the scenario. Let’s start by discussing our data model. We will use a dynamic array of the Record type to store the books’ information. Here is what our Record class looks like: 12345class Record: def __init__(self, key=-1, title=&quot;&quot;, placement_info=&quot;&quot;): self.Key = key self.Title = title self.PlacementInfo = placement_info ADT classNow, let’s look at the HashTable ADT class definition. The HashTable class has an HT_array pointer to store the address of the dynamically allocated array of records. The max_length property is the maximum number of records the hash table can hold. The length represents the current number of records in the Hash table. It increments and decrements with insertions and deletions, respectively. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class HashTable: def __init__(self, size): &quot;&quot;&quot; Initializes a HashTable instance. Args: size (int): The maximum number of elements the HashTable can store. &quot;&quot;&quot; self._max_length = size self._length = 0 self._HT_array = [Record() for _ in range(size)] def __del__(self): &quot;&quot;&quot;Destroys the HashTable instance and releases the memory.&quot;&quot;&quot; del self._HT_array def H(self, key): &quot;&quot;&quot; The Hash function. Args: key (int): The key for which the hash value is calculated. Returns: int: The calculated hash value. &quot;&quot;&quot; # Implement your hash function logic here def Insert(self, item): &quot;&quot;&quot; Inserts a record into the HashTable. Args: item (Record): The record to be inserted. Returns: bool: True if the record was inserted successfully, False otherwise. &quot;&quot;&quot; # Implement the Insert method logic here return False def Search(self, key): &quot;&quot;&quot; Searches for a record in the HashTable based on the given key. Args: key (int): The key to search for. Returns: Record or None: The record with the given key if found, None otherwise. &quot;&quot;&quot; # Implement the Search method logic here return None def Delete(self, key): &quot;&quot;&quot; Deletes a record from the HashTable based on the given key. Args: key (int): The key of the record to delete. Returns: bool: True if the record was deleted successfully, False otherwise. &quot;&quot;&quot; # Implement the Delete method logic here return False Defining the hash methodLet’s define our Hash method H() for this naive implementation. We will use the simplest modular Hashing for this scenario: 12def H(self, key): return key % self.max_length The above Hash function ensures we always get an index value in the range [0, max_length - 1]. Let’s move on to see how the simplified/ naive Insert() method works. Naive insertion operationThe Insert() method takes a new record as a parameter and checks if the maximum capacity of the HT_array is not reached. If the table still can have more records, the method calculates a proper index/ hash key for placing this item. After that, it puts the item at the computed index. 12345678910def Insert(self, item): if self.length == self.max_length: print(&quot;Hash table is full. Cannot insert the key-value pair.&quot;) return False index = self.H(item.Key) self.HT_array[index] = item self.length += 1 return True Point to ponder: What happens if two different keys map to the same array index? This implementation overwrites it. Indeed, it is a flaw we will address in the Solving Collisions section. Naive search operationNow, let’s explore how and why the Search() method will retrieve records in O(1) for us. Here is a naive implementation: 12345678def Search(self, key, returnedItem): index = self.H(key) if self.HT_array[index].Key == -1: return False # Item not found returnedItem.Key = self.HT_array[index].Key returnedItem.Title = self.HT_array[index].Title returnedItem.PlacementInfo = self.HT_array[index].PlacementInfo return True #Return true to indicate the record was found The Search() method applies the hash function H() on the passed key and checks if the hash table slot is empty or not. If this slot has a valid record, the Search() method assigns the record at this slot to the reference parameter. Also, it returns a true flag to indicate the operation’s success. The above implementation of Search() clearly takes constant time (i.e., ) time to retrieve/ search any record regardless of the size our table may grow. This is evident by the fact that you only have to apply the hash function only constant number of times to calculate the position of the searched item. Note: This naive implementation for the search doesn’t cover all aspects. We will discuss a more sophisticated method in the next lesson. Naive delete operationLike the search operation, this deletion operation first locates the item requiring a delete. Afterward, the deletion operation simply places a null or default object at the table slot. Here is what the naive implementation looks like: 12345678def Delete(self, key): index = self.H(key) if self.HT_array[index].Key == key: self.HT_array[index].Key = -1 # Mark the slot as empty self.length -= 1 return True return False # The slot is already empty or there is a different item at the slot Again, like the search operation, deletion also takes a constant time to locate and delete an item from the table. But, it is important to note that this naive implementation is just to get an overall idea of how the hash table works. However, it doesn’t cater to many exceptional cases; we will discuss those in the subsequent sections. Here is the complete code for the naive hash table implementation with a sample driver code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485class Record: def __init__(self, key=-1, title=&quot;&quot;, placement_info=&quot;&quot;): self.Key = key self.Title = title self.PlacementInfo = placement_infoclass HashTable: def __init__(self, size): # Pointer to store address of dynamically allocated array self.HT_array = [Record() for _ in range(size)] # To store maximum number of elements a Hash table can store self.max_length = size # To keep track of total records present in the hash table self.length = 0 def __del__(self): # Cleanup the dynamically allocated array del self.HT_array # The Hash function def H(self, key): return key % self.max_length # Defining naive insertion def Insert(self, item): if self.length == self.max_length: print(&quot;Hash table is full. Cannot insert the key-value pair.&quot;) return False index = self.H(item.Key) self.HT_array[index] = item self.length += 1 return True # Defining naive search def Search(self, key, returnedItem): index = self.H(key) if self.HT_array[index].Key == -1: # Record not found return False returnedItem.Key = self.HT_array[index].Key returnedItem.Title = self.HT_array[index].Title returnedItem.PlacementInfo = self.HT_array[index].PlacementInfo # Return true to indicate the record was found return True # Defining naive deletion def Delete(self, key): index = self.H(key) if self.HT_array[index].Key == key: # Mark the slot as empty self.HT_array[index].Key = -1 self.length -= 1 return True # The slot is already empty or there is a different item at the slot return False# The driver codeif __name__ == &quot;__main__&quot;: hashTable = HashTable(10) # Insert book information hashTable.Insert(Record(1001, &quot;Introduction to Programming&quot;, &quot;A2 Shelf&quot;)) hashTable.Insert(Record(1002, &quot;Data Structures and Algorithms&quot;, &quot;B1 Shelf&quot;)) hashTable.Insert(Record(1003, &quot;Database Management Systems&quot;, &quot;C3 Shelf&quot;)) # Retrieve book information book = Record() if hashTable.Search(1001, book): print(&quot;Book Information for Key&quot;, book.Key, &quot;:&quot;) print(&quot;Title:&quot;, book.Title) print(&quot;Placement Info:&quot;, book.PlacementInfo) else: print(&quot;No book information found for Key 1001&quot;) # Delete a book information hashTable.Delete(1001) # Retrieve the book status after deletion if hashTable.Search(1001, book): print(&quot;Book Information for Key&quot;, book.Key, &quot;:&quot;) print(&quot;Title:&quot;, book.Title) print(&quot;Placement Info:&quot;, book.PlacementInfo) else: print(&quot;No book information found for Key 1001&quot;) ImplementationHere is how different languages have implemented Hash Tables: Language API Java java.util.Map Or java.util.HashMap Python dict C++ std::unordered_map JavaScript Object or Map Issues with Hash TablesRemember, we said that our earlier Hash Table implementation was naive. By that, we meant that the code doesn’t cater to some frequently occurring issues. Let’s see what these issues really are. CollisionsA collision in a Hash Table occurs when an insert operation tries to insert an item at a table slot already occupied by another item. How can this ever happen? Let’s find out. Collision exampleReconsider our earlier example of the Hash Table for the public library book information storage. Assume, for the sake of simplicity, the Hash Table has the max_length equal to 10. Further, you need to insert the following book records in it: Key Title Placement Info 1008 Introduction to Algorithms A1 Shelf 1009 Data Structures: A Pseudocode Approach B2 Shelf 1010 System Design Interview Roadmap C3 Shelf 1011 Grokking the Coding Interview D4 Shelf 1021 Grokking the Art of Recursion for Coding Interviews E5 Shelf Here is the hash value calculation for the first four entries: So the hash table array would look something like this: Now, what happens if we try inserting the record with the Key 1021? The hash value for 1021 is the same as occupied by the book with the Key 1011. In this scenario, we say that a collision has occurred. The phenomenon is depicted in the following illustration. Collisions occur frequently in hash tables when two different keys hash to the same bucket. Without proper collision handling, lookup performance degrades from O(1) to O(n) linear search time. Managing collisions is crucial to efficient hash table implementation. OverflowsOverflow in a hash table occurs when the number of elements inserted exceeds the fixed capacity allocated for the underlying bucket array. For example, if you already have inserted information of ten books in the earlier discussed hash table, inserting the 11th one will cause an overflow. One important point to note here is that as the underlying bucket array starts filling towards its maximum capacity, the expectation of collisions starts increasing. Thereby the overall efficiency of hash table operations starts decreasing. An ideal hash table implementation must resolve collisions effectively and must act to avoid any overflow early. In the next section, we will explore different strategies for handling collisions. Resolving CollisionsRemember that our naive hash table implementation directly overwrote existing records when collisions occurred. This is inaccurate as it loses data on insertion. This section describes how we can avoid such data losses with the help of collision resolution techniques. Based on how we resolve the collisions, the collision resolution techniques are classified into two types: Open addressing / Closed hashing Chaining / Open hashing Let’s find out how these schemes help us resolve the collisions without losing any data. Open Addressing (Closed Hashing):Open addressing techniques resolve hash collisions by probing for the next available slot within the hash table itself. This approach is called open addressing since it opens up the entire hash table for finding an empty slot during insertion. It is also known as closed hashing because the insertion is restricted to existing slots within the table without using any external data structures. Depending on how you jump or probe to find the next empty slot, the closed hashing is further divided into multiple types. Here are the main collision resolution schemes used in the open-addressing scheme: Linear probing: Linear probing is the simplest way to handle collisions by linearly searching consecutive slots for the next empty location. Quadratic probing: When a collision occurs, the quadratic probing attempts to find an alternative empty slot for the key by using a quadratic function to probe the successive possible positions. Double hashing: It uses two hash functions to determine the next probing location in case of a successive collision. Random probing: Random probing uses a pseudo-random number generator (PRNG) to compute the step size or increment value for probes in case of collisions. Implementation of insertion, search, and deletion operations is slightly different for each type of the operations. Separate Chaining (Open Hashing):Selecting the right closed hashing technique for resolving collisions can be tough. You need to keep the pros and cons of different strategies in mind and then have to make a decision. Separate chaining offers a rather simpler chaining mechanism to resolve collisions. Each slot in the hash table points to a separate data structure, such as a linked-list. This linked-list or chain stores multiple elements that share the same hash index. When a collision occurs, new elements are simply appended to the existing list in the corresponding slot. Separate chaining is an “open hashing” technique because the hash table is “open” to accommodate multiple elements within a single bucket (usually using a chain) to handle collisions. Here is the generalized conceptual diagram for the chaining method: Example: Recall our earlier example of the hash table for storing books’ information. Assume you have a hash table (with open hashing) of size 11 and have the following situation: Now, here is what the hash table would look like after inserting a new book record (1724, &quot;Compilers Theory&quot;, &quot;E4 Shelf&quot;): The key 1724 hashes on 08. Therefore, the item with this key is appended at the end of the chain, pointed by table slot 08. Let’s now move on to implementing the hash table with separate chaining. A complete implementationInsertion in a hash table with separate chaining is simple. For an item with hash key x, you need to just append the item at the list/ chain linked to the x slot of the table. Similarly, deletion operation is also more straightforward. You don’t need to keep any deletion signs or marks. You can directly delete the item’s node from the chain linked to the relevant hash table slot. Here is a complete implementation of the hash table we developed for books storage: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394class Record: def __init__(self, key, title, placement_info): self.Key = key self.Title = title self.PlacementInfo = placement_infoclass HashTable: def __init__(self, size): self.buckets = [[] for _ in range(size)] self.max_length = size def H(self, key): return key % self.max_length def Insert(self, item): index = self.H(item.Key) # Check if the key already exists in the chain for record in self.buckets[index]: if record.Key == item.Key: return False # Key already exists in the chain, cannot insert self.buckets[index].append(item) return True def Search(self, key, returnedItem): index = self.H(key) # Search for the key in the chain for record in self.buckets[index]: if record.Key == key: returnedItem.Key = record.Key returnedItem.Title = record.Title returnedItem.PlacementInfo = record.PlacementInfo return True # Return True to indicate the record was found return False # Record not found def Delete(self, key): index = self.H(key) # Search for the key in the chain and delete if found for i, record in enumerate(self.buckets[index]): if record.Key == key: del self.buckets[index][i] return True return False # The key is not found in the chain def ShowTable(self): print(&quot;Index\\tValue (Key, Title, PlacementInfo)&quot;) for i in range(self.max_length): print(i, end=&quot;\\t&quot;) if not self.buckets[i]: print(&quot;[EMPTY BUCKET]&quot;) else: for j, record in enumerate(self.buckets[i]): if j &gt; 0: print(&quot;--&gt;&quot;, end=&quot; &quot;) print(&quot;(&#123;0&#125;, &#123;1&#125;, &#123;2&#125;)&quot;.format(record.Key, record.Title, record.PlacementInfo), end=&quot; &quot;) print()def main(): tableSize = 11 hashTable = HashTable(tableSize) # Insert initial book information hashTable.Insert(Record(1701, &quot;Internet of Things&quot;, &quot;G1 Shelf&quot;)) hashTable.Insert(Record(1712, &quot;Statistical Analysis&quot;, &quot;G1 Shelf&quot;)) hashTable.Insert(Record(1718, &quot;Grid Computing&quot;, &quot;H2 Shelf&quot;)) hashTable.Insert(Record(1735, &quot;UML Modeling&quot;, &quot;G1 Shelf&quot;)) hashTable.Insert(Record(1752, &quot;Professional Practices&quot;, &quot;G2 Shelf&quot;)) # Display the hash table after initial insertions print(&quot;\\nHash Table after initial insertions:&quot;) hashTable.ShowTable() # Insert the following record hashTable.Insert(Record(1725, &quot;Deep Learning with Python&quot;, &quot;C3 Shelf&quot;)) # Display the hash table after the last insertion print(&quot;\\nHash Table inserting Book Key 1725:&quot;) hashTable.ShowTable() # Delete two records hashTable.Delete(1701) hashTable.Delete(1718) # Display the hash table after deletions print(&quot;\\nHash Table after deleting 1701 and 1718:&quot;) hashTable.ShowTable()if __name__ == &quot;__main__&quot;: main() Perks of separate chainingSeparate chaining has the following perks over the closed hashing techniques: Dynamic Memory Usage: Insertions append new nodes at the chains. Unlike closed hashing, where we just put deletion mark, deleting items causes their nodes to completely removed from the chain. Thereby, the table with separate chaining can grow and shrink as per number of elements. Simple Implementation: Implementing separate chaining is straightforward, using linked lists to manage collisions, making the code easy to understand and maintain. Graceful Handling of Duplicates: This technique gracefully handles duplicate keys, allowing multiple records with the same key to be stored and retrieved accurately. Downsides of separate chainingSeparate chaining has the following downsides: Increased Memory Overhead: Separate chaining requires additional memory to store pointers or references to linked lists for each bucket, leading to increased memory overhead, especially when dealing with small data sets. Cache Inefficiency: As separate chaining involves linked lists, cache performance can be negatively impacted due to non-contiguous memory access when traversing the lists, reducing overall efficiency. External Fragmentation: The dynamic allocation of memory for linked lists can lead to external fragmentation, which may affect the performance of memory management in the system. Worst-Case Time Complexity: In the worst-case scenario, when multiple keys are hashed to the same bucket and form long linked lists, the time complexity for search, insert, and delete operations can degrade to O(n), making it less suitable for time-critical applications. Memory Allocation Overhead: Dynamic memory allocation for each new element can add overhead and might lead to performance issues when the system is under high memory pressure. Handling OverflowsClosed hashing techniques like linear probing experience overflow when entries fill up the fixed hash table slots. Overflow can loosely indicate that the table has exceeded the suitable load factor. Ideally, for closed hashing, the load-factor a = n / m should not cross 0.5, where n is the number of entries and m is table size. Otherwise, the hash table experiences a significant increase in collisions, problems in searching, and degrading performance and integrity of the table operations. Chaining encounters overflow when chain lengths become too long, thereby increasing the search time. The load-factor a can go up to 0.8 or 0.9 before performance is affected. Resizing the hash table can help alleviate the overflow issues. Let’s explore what resizing is and when it is suitable to do. ResizingResizing is increasing the size of the hash table to avoid overflows and maintain certain load-factor. Once the load-factor of the hash table increases a certain threshold (e.g., 0.5 for closed hashing and 0.9 for chaining), resizing gets activated to increase the size of the table. When resizing, do the old values remain in the same place in the new table? The answer is “No.” As resizing changes the table size, the values must be rehashed to maintain the correctness of the data structure. RehashingRehashing involves applying a new hash function (s) to all the entries in a hash table to make the table more evenly distributed. In context to resizing, it means recalculating hashes (according to the new table size) of all the entries in the old table and re-inserting those in the new table. Rehashing takes O(n) time for n entries. After rehashing, the new distribution of entries across the larger table leads to fewer collisions and improved performance. We perform rehashing periodically when the load-factor exceeds thresholds or based on metrics like average chain length. Resizing and Rehashing Process: Determine that the load-factor has exceeded the threshold (e.g., alpha &gt; 0.5 ) and that the hash table needs resizing. Create a new hash table with a larger capacity (e.g., double the size of the original table). Iterate through the existing hash table and rehash each element into the new one using the primary hash function with the new table size. After rehashing all the elements, the new hash table replaces the old one, and the old table is deallocated from memory. Selecting a Hash FunctionThroughout the hashing portion, we discussed only one or two hash functions. The question arises, how to develop a new hash function? Is there any technique to make your customized hash function? Let’s find out the answers. But first, we must know how to distinguish between a good and a bad hash function. Here are some ways to explain the characteristics of a good hash function in simple terms: Characteristics of a good hash function:Here are some characteristics that every good hash function must follow: - Uniformity and Distribution: The hash function should spread out keys evenly across all slots in the hash table. It should not cram keys into only a few slots. Each slot should have an equal chance of being hashed to, like spreading items randomly across shelves. This ensures a balanced distribution without crowded clusters in some places. Efficiency: It should require minimal processing power and time to compute. Complex and slow hash functions defeat the purpose of fast lookup. The faster, the better. Collision Reduction: Different keys should end up getting mapped to different slots as much as possible. If multiple keys keep colliding in the same slot, the hash table operations will deteriorate time efficiency over time. Hash function design techniques:Here are a few of the commonly used techniques for creating good hash functions: Division method The division method is one of the simplest and most widely used techniques to compute a hash code. It involves calculating the remainder obtained by dividing the key by the size of the hash table (the number of buckets). The remainder is taken as the hash code. Mathematically, the division method is expressed as: hash_key = key % table_size. The division method is simple to implement and computationally efficient. However, it may not be the best choice if the key distribution is not uniform or the table size is not a prime number, which may lead to clustering. Folding method The folding method involves dividing the key into smaller parts (subkeys) and then combining them to calculate the hash code. It is particularly useful when dealing with large keys or when the key does not evenly fit into the hash table size. There are several ways to perform folding: Digit sum: Split the key into groups of digits, and their sum is taken as the hash code. For example, you can hash the key 541236 using digit sum folding into a hash table of size 5 as: hash_key = (5+4+1+2+3+6)%2 = 21%5 = 1 . Reduction: Split the key in folds and use a reduction using any associative operation like XOR to reduce folds to a single value. Now, pass this single value through the simple division hash function to generate the final hash value. For example, suppose you want a 12-digit key 593048892357 to be hashed onto a table of size 11113. In folding with reduction, you will split it into 3 parts of 4 digits each: 5930,4889,2357. Then, you XOR (^) the parts and pass through an ordinary hash function as: hash_key=(5930 ^ 4889 ^ 2357)%table_size = 7041. We can also add the parts: hash_key = (5930 + 4889 + 2357) % table_size = 13176 % 11113=2063 The folding method can handle large keys efficiently and provides better key distribution than the division method. It finds common applications where the keys are lengthy or need to be split into subkeys for other purposes. Mid-square Method: The mid-square method involves squaring the key, extracting the middle part, and then using it as the hash code. This technique is particularly useful when keys are short and do not have patterns in the lower or upper digits. The steps for calculating mid-square are as follows: Square the key. Extract the K middle digits of the square. Apply simple division on these middle digits to get the final hash. For example, consider the key 3729, and we want to hash it into a hash table of size 10. Square the key: 3729x3729=13935241. Extract the middle digits to get the hash value: 935. Calculate the hash index: H(3729)=935%10=5. Therefore, the key 3729 is hashed into the hash table at index 5. The mid-square method is easy to implement and works well when the key values are uniformly distributed, providing a good spread of hash codes. However, it may not be suitable for all types of keys, especially those with patterns or significant leading/trailing zeros. In the next section, we will solve some coding interview problems related to Hash Tables. First Non-repeating Character (easy)387. First Unique Character in a String Design Gurus Problem StatementGiven a string, identify the position of the first character that appears only once in the string. If no such character exists, return -1. Examples Example 1: Input: “apple” Expected Output: 0 Justification: The first character ‘a’ appears only once in the string and is the first character. Example 2: Input: “abcab” Expected Output: 2 Justification: The first character that appears only once is ‘c’ and its position is 2. Example 3: Input: “abab” Expected Output: -1 Justification: There is no character in the string that appears only once. Constraints: 1 &lt;= s.length &lt;= 10^5 s consists of only lowercase English letters. SolutionTo solve this problem, we’ll use a hashmap to keep a record of each character in the string and the number of times it appears. First, iterate through the string and populate the hashmap with each character as the key and its frequency as the value. Then, go through the string again, this time checking each character against the hashmap. The first character that has a frequency of one (indicating it doesn’t repeat) is your target. This character is the first non-repeating character in the string. If no such character exists, the solution should indicate that as well. This two-pass approach ensures efficiency, as each character is checked against a pre-compiled frequency map. Initialization: Begin by creating a hashmap to store the frequency of each character in the string. This hashmap will help in identifying characters that appear only once. Frequency Count: Traverse the string from the beginning to the end. For each character, increment its count in the hashmap. First Unique Character: Traverse the string again from the beginning. For each character, check its frequency in the hashmap. If the frequency is 1, return its position as it’s the first unique character. No Unique Character: If the string is traversed completely without finding a unique character, return -1. Using a hashmap ensures that we can quickly determine the frequency of each character without repeatedly scanning the string. Algorithm Walkthrough: Given the input string “abcab”: Initialize a hashmap to store character frequencies. Traverse the string: ‘a’ -&gt; frequency is 1 ‘b’ -&gt; frequency is 1 ‘c’ -&gt; frequency is 1 ‘a’ -&gt; frequency is 2 ‘b’ -&gt; frequency is 2 Traverse the string again: ‘a’ has frequency 2 ‘b’ has frequency 2 ‘c’ has frequency 1, so return its position 2. Here is the visual representation of the algorithm: CodeHere is the code for this algorithm: 1234567891011121314151617181920212223class Solution: def firstUniqChar(self, s: str) -&gt; int: # Create a dictionary to store the frequency of each character freq = &#123;&#125; # Traverse the string to populate the dictionary with character frequencies for c in s: freq[c] = freq.get(c, 0) + 1 # Traverse the string again to find the first unique character for i, c in enumerate(s): if freq[c] == 1: return i # If no unique character is found, return -1 return -1if __name__ == &quot;__main__&quot;: sol = Solution() print(sol.firstUniqChar(&quot;apple&quot;)) # Expected: 0 print(sol.firstUniqChar(&quot;abcab&quot;)) # Expected: 2 print(sol.firstUniqChar(&quot;abab&quot;)) # Expected: -1 Time Complexity Populating the hashmap with frequencies: We traverse the entire string once to populate the hashmap with the frequency of each character. This operation takes O(n) time, where n is the length of the string. Finding the first unique character: We traverse the string again to find the first character with a frequency of 1. This operation also takes O(n) time. Given that these two operations are sequential and not nested, the overall time complexity is O(n) + O(n), which simplifies to O(n). Space Complexity Hashmap for frequencies: In the worst case, every character in the string is unique. For a string with only lowercase English letters, the maximum number of unique characters is 26. However, if we consider all possible ASCII characters, the number is 128. If we consider extended ASCII, it’s 256. In any case, this is a constant number. Therefore, the space complexity for the hashmap is O(1) because it doesn’t grow proportionally with the size of the input string. Input string: The space taken by the input string is not counted towards the space complexity, as it’s considered input space. Given the above, the overall space complexity of the algorithm is O(1). Conclusion The approach is efficient in terms of both time and space. The time complexity is linear, which means the algorithm’s runtime grows linearly with the size of the input. The space complexity is constant, indicating that the amount of additional space (memory) the algorithm uses does not grow with the size of the input. Largest Unique Number (easy)Leetcode 会员 Design Gurus Problem StatementGiven an array of integers, identify the highest value that appears only once in the array. If no such number exists, return -1. Examples: Example 1: Input: [5, 7, 3, 7, 5, 8] Expected Output: 8 Justification: The number 8 is the highest value that appears only once in the array. Example 2: Input: [1, 2, 3, 2, 1, 4, 4] Expected Output: 3 Justification: The number 3 is the highest value that appears only once in the array. Example 3: Input: [9, 9, 8, 8, 7, 7] Expected Output: -1 Justification: There is no number in the array that appears only once. Constraints: 1 &lt;= nums.length &lt;= 2000 0 &lt;= nums[i] &lt;= 1000 SolutionTo solve this problem, we utilize a hashmap to track the frequency of each number in the given array. The key idea is to iterate through the array, recording the count of each number in the hashmap. Once all elements are accounted for, we scan through the hashmap, focusing on elements with a frequency of one. Among these, we identify the maximum value. This approach ensures that we effectively identify the largest number that appears exactly once in the array, leveraging the hashmap for efficient frequency tracking and retrieval. Initialization: Start by creating a hashmap that will be used to store the frequency of each number in the array. This hashmap will be instrumental in identifying numbers that appear only once. Frequency Count: Traverse the entire array from the beginning to the end. For each number encountered, increment its count in the hashmap. This step ensures that by the end of the traversal, we have a complete record of how many times each number appears in the array. Identify Largest Unique Number: After populating the hashmap, traverse it to identify numbers with a frequency of 1. While doing so, keep track of the largest such number. If no number with a frequency of 1 is found, the result will be -1. Return Result: The final step is to return the largest number that has a frequency of 1. If no such number exists, return -1. This approach, which leverages the properties of a hashmap, ensures that we can quickly determine the frequency of each number without the need for nested loops or repeated scans of the array. Algorithm Walkthrough: Given the input array [5, 7, 3, 7, 5, 8]: Initialize a hashmap to store number frequencies. Traverse the array: 5 -&gt; frequency is 1 7 -&gt; frequency is 1 3 -&gt; frequency is 1 7 -&gt; frequency is 2 5 -&gt; frequency is 2 8 -&gt; frequency is 1 Traverse the hashmap: 5 has frequency 2 7 has frequency 2 3 has frequency 1 8 has frequency 1, and it’s the largest unique number. Here is the visual representation of the algorithm: CodeHere is the code for this algorithm: 123456789101112131415161718192021222324252627from collections import defaultdictfrom typing import Listclass Solution: def largestUniqueNumber(self, A: List[int]) -&gt; int: freq = &#123;&#125; # Populate the dictionary with number frequencies for num in A: freq[num] = freq.get(num, 0) + 1 maxUnique = -1 # Traverse the dictionary to find the largest unique number for key, value in freq.items(): if value == 1: maxUnique = max(maxUnique, key) return maxUniqueif __name__ == &quot;__main__&quot;: sol = Solution() print(sol.largestUniqueNumber([5, 7, 3, 7, 5, 8])) # Expected: 8 print(sol.largestUniqueNumber([1, 2, 3, 2, 1, 4, 4])) # Expected: 3 print(sol.largestUniqueNumber([9, 9, 8, 8, 7, 7])) # Expected: -1 Complexity AnalysisTime Complexity: The algorithm traverses the array once to populate the hashmap and then traverses the hashmap to find the largest unique number. Both operations are O(n), where n is the length of the array. Therefore, the overall time complexity is O(n). Space Complexity: The space complexity is determined by the hashmap, which in the worst case will have an entry for each unique number in the array. Therefore, the space complexity is O(n), where n is the number of unique numbers in the array. Maximum Number of Balloons (easy)1189. Maximum Number of Balloons Design Gurus Problem StatementGiven a string, determine the maximum number of times the word “balloon” can be formed using the characters from the string. Each character in the string can be used only once. Examples: Example 1: Input: “balloonballoon” Expected Output: 2 Justification: The word “balloon” can be formed twice from the given string. Example 2: Input: “bbaall” Expected Output: 0 Justification: The word “balloon” cannot be formed from the given string as we are missing the character ‘o’ twice. Example 3: Input: “balloonballoooon” Expected Output: 2 Justification: The word “balloon” can be formed twice, even though there are extra ‘o’ characters. Constraints: 1 &lt;= text.length &lt;= 10^4 text consists of lower case English letters only. SolutionTo solve this problem, you start by creating a hashmap to count the frequency of each letter in the given string. Since the word “balloon” contains specific letters with varying frequencies (like ‘l’ and ‘o’ appearing twice), you need to account for these in your hashmap. Once you have the frequency of each letter, the next step is to determine how many times you can form the word “balloon”. This is done by finding the minimum number of times each letter in “balloon” appears in the hashmap. The limiting factor will be the letter with the minimum frequency ratio to its requirement in the word “balloon”. This approach ensures a balance between utilizing the available letters and adhering to the letter composition of “balloon”. Character Frequency Count: Traverse the string and populate a hashmap with the frequency count of each character. Determine Maximum Count: Check the hashmap to determine the maximum number of times the word “balloon” can be formed. For characters ‘b’, ‘a’, and ‘n’, their frequency in the hashmap directly gives the number of times they can be used. For ‘l’ and ‘o’, we need to divide their frequency by 2. Result Calculation: The minimum value among the counts of ‘b’, ‘a’, ‘l’/2, ‘o’/2, and ‘n’ will give the maximum number of times the word “balloon” can be formed. Return the Result: Return the calculated minimum value as the final result. This approach is effective because it ensures that we account for the frequency of each character required to form the word “balloon”. Using a hashmap allows for efficient storage and retrieval of character frequencies. Algorithm Walkthrough: Given the input string “balloonballoooon”: Initialize an empty hashmap. Traverse the string and populate the hashmap with character frequencies: {‘b’:2, ‘a’:2, ‘l’:4, ‘o’:5, ‘n’:2}. Calculate the maximum number of times “balloon” can be formed: ‘b’ can be used 2 times. ‘a’ can be used 2 times. ‘l’ can be used 4/2 = 2 times. ‘o’ can be used 5/2 = 2.5 times, but since we need whole words, it’s 2 times. ‘n’ can be used 2 times. The minimum among these values is 2, which is the final result. Here is the visual representation of the algorithm: CodeHere is the code for this algorithm: 1234567891011121314151617181920212223242526272829from collections import defaultdictclass Solution: def maxNumberOfBalloons(self, text: str) -&gt; int: # Create a defaultdict to store character frequencies char_count = &#123;&#125; # Populate the defaultdict with character frequencies from the string for char in text: char_count[char] = char_count.get(char, 0) + 1 min_count = float(&#x27;inf&#x27;) # Calculate the maximum number of times &quot;balloon&quot; can be formed min_count = min(min_count, char_count.get(&#x27;b&#x27;, 0)) min_count = min(min_count, char_count.get(&#x27;a&#x27;, 0)) min_count = min(min_count, char_count.get(&#x27;l&#x27;, 0) // 2) min_count = min(min_count, char_count.get(&#x27;o&#x27;, 0) // 2) min_count = min(min_count, char_count.get(&#x27;n&#x27;, 0)) return min_countif __name__ == &quot;__main__&quot;: sol = Solution() print(sol.maxNumberOfBalloons(&quot;balloonballoon&quot;)) # Expected: 2 print(sol.maxNumberOfBalloons(&quot;bbaall&quot;)) # Expected: 0 print(sol.maxNumberOfBalloons(&quot;balloonballoooon&quot;)) # Expected: 2 Complexity AnalysisTime Complexity: The algorithm traverses the string once to populate the hashmap, which is O(n), where n is the length of the string. The subsequent operations are constant time. Therefore, the overall time complexity is O(n). Space Complexity: The space complexity is determined by the hashmap, which in the worst case will have an entry for each unique character in the string. However, since the English alphabet has a fixed number of characters, the space complexity is O(1). Longest Palindrome(easy)409. Longest Palindrome Design Gurus Problem Statement:Given a string, determine the length of the longest palindrome that can be constructed using the characters from the string. Return the maximum possible length of the palindromic string. Examples: Input: “applepie” Expected Output: 5 Justification: The longest palindrome that can be constructed from the string is “pepep”, which has a length of 5. There are are other palindromes too but they all will be of length 5. Input: “aabbcc” Expected Output: 6 Justification: We can form the palindrome “abccba” using the characters from the string, which has a length of 6. Input: “bananas” Expected Output: 5 Justification: The longest palindrome that can be constructed from the string is “anana”, which has a length of 5. Constraints: 1 &lt;= s.length &lt;= 2000 s consists of lowercase and/or uppercase English letters only. SolutionTo solve this problem, we can use a hashmap to keep track of the frequency of each character in the string. The idea is to use pairs of characters to form the palindrome. For example, if a character appears an even number of times, we can use all of them in the palindrome. If a character appears an odd number of times, we can use all except one of them in the palindrome. Additionally, if there’s any character that appears an odd number of times, we can use one of them as the center of the palindrome. Initialization: Start by initializing a hashmap to keep track of the characters and their frequencies. Character Counting: Iterate through the string and populate the hashmap with the frequency of each character. Palindrome Length Calculation: For each character in the hashmap, if it appears an even number of times, add its count to the palindrome length. If it appears an odd number of times, add its count minus one to the palindrome length. Also, set a flag indicating that there’s a character available for the center of the palindrome. Final Adjustment: If the center flag is set, add one to the palindrome length. Algorithm Walkthrough: Initialize a HashMap: We’ll use a hashmap to store the frequency of each character in the string. Populate the HashMap: For the string “bananas”, our hashmap will look like this: b: 1 a: 3 n: 2 s: 1 Determine Palindrome Length: We’ll iterate through the hashmap to determine the length of the palindrome we can form. Even Frequencies: For characters with even frequencies, we can use all of them in the palindrome. For our string, the character ‘n’ has an even frequency. ‘n’ can contribute 2 characters. So far, we have a contribution of 2 characters to the palindrome. Odd Frequencies: For characters with odd frequencies, we can use all but one of them in the palindrome. The central character of the palindrome can be any character with an odd frequency. For our string, characters ‘b’, ‘a’, and ‘s’ have odd frequencies. ‘b’ can contribute 0 characters (leaving out 1). ‘a’ can contribute 2 characters (leaving out 1). ‘s’ can contribute 0 characters (leaving out 1). Additionally, one of the characters left out from the odd frequencies can be used as the central character of the palindrome. Let’s use ‘a’ for this purpose. So, from the odd frequencies, we have a contribution of 2 characters to the palindrome, plus 1 for the central character. Total Length: Combining the contributions from even and odd frequencies, we get a total palindrome length of 2 (from even frequencies) + 3 (from odd frequencies) = 5. The longest palindrome that can be constructed from “bananas” is of length 5. Here is the visual representation of the algorithm: CodeHere is the code for this algorithm: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Solution: def longestPalindrome(self, s: str) -&gt; int: from collections import Counter # Get character frequencies # 这个就想不到 freq_map = Counter(s) length = 0 oddFound = False # Calculate the palindrome length for freq in freq_map.values(): if freq % 2 == 0: length += freq else: length += freq - 1 oddFound = True # Add the central character if any odd frequency was found if oddFound: length += 1 return length# Test the solutionsol = Solution()print(sol.longestPalindrome(&quot;bananas&quot;)) # Expected output: 5print(sol.longestPalindrome(&quot;applepie&quot;)) # Expected output: 7print(sol.longestPalindrome(&quot;racecar&quot;)) # Expected output: 7# 修改的版本from collections import Counterclass Solution: def longestPalindrome(self, s: str) -&gt; int: # Get character frequencies freq_map = &#123;&#125; for c in s: freq_map[c] = freq_map.get(c, 0) + 1 length = 0 oddFound = False # Calculate the palindrome length for freq in freq_map.values(): if freq % 2 == 0: length += freq else: length += freq - 1 oddFound = True # Add the central character if any odd frequency was found if oddFound: length += 1 return length# Test the solutionsol = Solution()print(sol.longestPalindrome(&quot;bananas&quot;)) # Expected output: 5print(sol.longestPalindrome(&quot;applepie&quot;)) # Expected output: 5print(sol.longestPalindrome(&quot;racecar&quot;)) # Expected output: 7 Time Complexity: Iterating through the string: We iterate through the entire string once to count the frequency of each character. This operation takes (O(n)) time, where (n) is the length of the string. Iterating through the hashmap: After counting the frequencies, we iterate through the hashmap to determine how many characters can be used to form the palindrome. In the worst case, this would be (O(26)) for the English alphabet, which is a constant time. However, in general terms, if we consider any possible character (not just English alphabet), this would be (O(k)), where (k) is the number of unique characters in the string. But since k &lt;= n , this can also be considered (O(n)) in the worst case. Combining the two steps, the overall time complexity is (O(n) + O(n) = O(n)). Space Complexity:Hashmap for character frequencies: The space taken by the hashmap is proportional to the number of unique characters in the string. In the worst case, this would be (O(26)) for the English alphabet, which is a constant space. However, in general terms, if we consider any possible character (not just English alphabet), this would be (O(k)), where (k) is the number of unique characters in the string. But since k &lt;= n, this can also be considered (O(n)) in the worst case. Thus, the space complexity of the algorithm is (O(n)). Ransom Note (easy)Top Interview 150 | 383. Ransom Note Design Gurus Problem StatementGiven two strings, one representing a ransom note and the another representing the available letters from a magazine, determine if it’s possible to construct the ransom note using only the letters from the magazine. Each letter from the magazine can be used only once. Examples: Example 1: Input: Ransom Note = “hello”, Magazine = “hellworld” Expected Output: true Justification: The word “hello” can be constructed from the letters in “hellworld”. Example 2: Input: Ransom Note = “notes”, Magazine = “stoned” Expected Output: true Justification: The word “notes” can be fully constructed from “stoned” from its first 5 letters. Example 3: Input: Ransom Note = “apple”, Magazine = “pale” Expected Output: false Justification: The word “apple” cannot be constructed from “pale” as we are missing one ‘p’. Constraints: 1 &lt;= ransomNote.length, magazine.length &lt;= 10^5 ransomNote and magazine consist of lowercase English letters. SolutionTo solve this problem, we will utilize a hashmap to keep track of the frequency of each character in the magazine. First, we iterate through the magazine, updating the hashmap with the count of each character. Then, we go through the ransom note. For each character in the note, we check if it exists in the hashmap and if its count is greater than zero. If it is, we decrease the count in the hashmap, indicating that we’ve used that letter. If at any point we find a character in the note that isn’t available in sufficient quantity in the magazine, we return false. If we successfully go through the entire note without this issue, we return true, indicating the note can be constructed from the magazine. Populate Frequency Map: Traverse the magazine string and populate a hashmap with the frequency of each character. Check Feasibility: Traverse the ransom note string. For each character, check its frequency in the hashmap. If the character is not present or its frequency is zero, return false. Otherwise, decrement the frequency of the character in the hashmap. Return Result: If we successfully traverse the ransom note without returning false, then it’s possible to construct the ransom note from the magazine. Return true. Using a hashmap allows for efficient storage and retrieval of character frequencies, ensuring that we can determine the feasibility of constructing the ransom note in linear time. Algorithm Walkthrough: Given the ransom note “hello” and the magazine “hellworld”: Initialize an empty hashmap. Traverse the magazine “hellworld” and populate the hashmap with character frequencies: {‘h’:1, ‘e’:1, ‘l’:3, ‘w’:1, ‘o’:1, ‘r’:1, ‘d’:1}. Traverse the ransom note “hello”. For each character: Check its frequency in the hashmap. If the frequency is zero or the character is not present, return false. Otherwise, decrement the frequency of the character in the hashmap. Since we can traverse the entire ransom note without returning false, return true. Here is the visual representation of the algorithm: CodeHere is the code for this algorithm: 123456789101112131415161718192021222324252627from collections import defaultdictclass Solution: def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool: # Create a defaultdict to store character frequencies from the magazine char_count = &#123;&#125; # Populate the defaultdict with character frequencies from the magazine for char in magazine: char_count[char] = char_count.get(char, 0) + 1 # Check if the ransom note can be constructed for char in ransomNote: if char_count.get(char, 0) == 0: return False char_count[char] -= 1 return Trueif __name__ == &quot;__main__&quot;: sol = Solution() print(sol.canConstruct(&quot;hello&quot;, &quot;hellworld&quot;)) # Expected: true print(sol.canConstruct(&quot;notes&quot;, &quot;stoned&quot;)) # Expected: true print(sol.canConstruct(&quot;apple&quot;, &quot;pale&quot;)) # Expected: false Complexity AnalysisTime Complexity: The algorithm traverses both the ransom note and the magazine once, making the time complexity O(n + m), where n is the length of the ransom note and m is the length of the magazine. Space Complexity: The space complexity is determined by the hashmap, which in the worst case will have an entry for each unique character in the magazine. However, since the English alphabet has a fixed number of characters, the space complexity is O(1).","categories":[{"name":"Grokking Interview Pattern","slug":"Grokking-Interview-Pattern","permalink":"https://hasuer.github.io/categories/Grokking-Interview-Pattern/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hasuer.github.io/tags/Interview/"}]},{"title":"8. Pattern Monotonic Stack","slug":"8. Pattern Monotonic Stack","date":"2024-05-08T09:18:45.000Z","updated":"2024-05-28T03:27:56.802Z","comments":true,"path":"8-pattern-monotonic-stack/index.html","link":"","permalink":"https://hasuer.github.io/8-pattern-monotonic-stack/index.html","excerpt":"","text":"Introduction to Monotonic StackDefinition of Monotonic StackA Monotonic Stack is a special kind of stack, a common data structure in computer science, which maintains its elements in a specific order. Unlike a traditional stack, where elements are placed on top of one another based on when they arrive, a Monotonic Stack ensures that the elements inside the stack remain in an increasing or decreasing order. This is achieved by enforcing specific push and pop rules, depending on whether we want an increasing or decreasing monotonic stack. Relevance in Coding Interviews Monotonic Stacks are powerful tools in coding interviews due to their unique capabilities. They are particularly effective when it comes to problems requiring us to find the next smaller or larger element in a sequence, often referred to as Next Greater Element (NGE) or Next Smaller Element (NSE) problems. In the context of an interview, understanding and implementing a Monotonic Stack can not only help you solve the problem at hand but also demonstrate a strong grasp of data structures and algorithms to your interviewer. It shows that you can identify and apply the right tool for the task, a crucial ability for any software engineer. Types of Monotonic StacksMonotonic Stacks can be broadly classified into two types: Monotonically Increasing Stack A Monotonically Increasing Stack is a stack where elements are arranged in an ascending order from the bottom to the top. Here, every new element that’s pushed onto the stack is greater than or equal to the element below it. If a new element is smaller, we pop the elements from the top of the stack until we find an element smaller than or equal to the new element, or the stack is empty. This way, the stack always maintains an increasing order. Monotonically Decreasing Stack Conversely, a Monotonically Decreasing Stack is a stack where elements are arranged in a descending order from the bottom to the top. When a new element arrives, if it’s larger than the element on the top, we keep popping the elements from the stack until we find an element that’s larger than or equal to the new element, or the stack is empty. This ensures that the stack always maintains a decreasing order. Identifying Problems Suitable for Monotonic StackRecognizing when to use a Monotonic Stack is a vital skill. Here are some key aspects to consider: Problem Characteristics Monotonic Stacks are typically useful when dealing with problems that involve analyzing sequences or arrays, especially when you need to find the next or previous larger or smaller element for each element in the array. If you encounter a problem where the solution seems to require some sort of sequential step-by-step comparison, it’s likely a good candidate for using a Monotonic Stack. Example Scenarios One classic sign that a Monotonic Stack might be helpful is when the problem description mentions finding the “next greater element” or the “next smaller element” in an array. Problems that involve finding maximum areas, such as in histograms, can also be solved effectively using Monotonic Stacks. Remember, the key is to identify patterns where a sequential step-by-step comparison is necessary. Constructing Monotonic StacksUnderstanding how to build Monotonic Stacks is key. We’ll break down this process for each type: Code Template for Monotonically Increasing Stack Here’s a general structure of a Monotonically Increasing Stack in pseudo-code: 12345create an empty stackfor each element in the array: while stack is not empty AND top of stack is more than the current element: pop the stack push the current element to stack This logic guarantees that for each element, all larger elements preceding it get popped, leaving the next smaller element (if it exists) at the top of the stack. Code Template for Monotonically Decreasing Stack Similarly, here’s a template for a Monotonically Decreasing Stack: 12345create an empty stackfor each element in the array: while stack is not empty AND top of stack is less than the current element: pop the stack push the current element to stack This structure ensures that for each element, all smaller elements preceding it get popped, leaving the next larger element (if it exists) at the top of the stack. Explanation of the Code Templates Both these templates work in a similar fashion. They loop through each element in the array, and for each one, they pop out the elements from the stack that are smaller (for increasing stack) or larger (for decreasing stack) than the current element. This ensures the stack stays monotonically increasing or decreasing. Understanding Time ComplexityGrasping the time complexity of Monotonic Stacks is critical for efficiency. Let’s break it down for both types: Time Complexity for Monotonically Increasing Stack In a Monotonically Increasing Stack, each element from the input array is pushed and popped from the stack exactly once. Therefore, even though there is a loop inside a loop, no element is processed more than twice. Hence, the time complexity of building a Monotonically Increasing Stack is O(n), where N is the number of elements in the array. Time Complexity for Monotonically Decreasing Stack The situation is similar for a Monotonically Decreasing Stack. Each element is processed only twice, once for the push operation and once for the pop operation. As a result, the time complexity remains linear - O(n), with N being the size of the array. To summarize, although the construction of Monotonic Stacks might look complex at first glance, they are impressively efficient. Each element in the input array is handled only twice (one push and one pop), making the overall time complexity linear. Next, we’ll explore some practice problems to help you get more comfortable with Monotonic Stacks. Note: 总结来说就是一般从前往后和从后往前都可以，但是应该是都需要一个结构（一般是一个map）来记录对应关系的，这道题的res就是起到了这个作用。但是一般都是从前往后遍历，在这个pattern中的例子基本都是从前往后遍历 Next Greater Element496. Next Greater Element I Design Gurus Problem StatementGiven two integer arrays nums1 and nums2, return an array answer such that answer[i] is the next greater number for every nums1[i] in nums2. The next greater element for an element x is the first element to the right of x that is greater than x. If there is no greater number, output -1 for that number. The numbers in nums1 are all present in nums2 and nums2 is a permutation of nums1. Examples Input: nums1 = [4,2,6], nums2 = [6,2,4,5,3,7] Output: [5,4,7] Explanation: The next greater number for 4 is 5, for 2 is 4, and for 6 is 7 in nums2. Input: nums1 = [9,7,1], nums2 = [1,7,9,5,4,3] Output: [-1,9,7] Explanation: The next greater number for 9 does not exist, for 7 is 9, and for 1 is 7 in nums2. Input: nums1 = [5,12,3], nums2 = [12,3,5,4,10,15] Output: [10,15,5] Explanation: The next greater number for 5 is 10, for 12 is 15, and for 3 is 4 in nums2. Constraints: 1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000 0 &lt;= nums1[i], nums2[i] &lt;= 10^4 All integers in nums1 and nums2 are unique. All the integers of nums1 also appear in nums2. SolutionThis problem requires us to find the next greater element for each element in nums1 by searching nums2. The output array contains either the next greater element or -1 if no such element exists. This problem can be solved using a Monotonic Stack and Hashmap. The Monotonic Stack helps to find the next greater element for each element in nums2. The Hashmap then maps each element to its next greater element. 这道题和Stack pattern 中的“Next greater element”都是构建了decreasing stack, 小的元素在栈顶，感觉是因为找的greater的元素？如果找的是smaller的元素是不是就是increaing stack 了, 不过前一道题是从后开始遍历的，这道题是从前开始遍历的. 经过实验，可以发现，前一道题也可以从前往后遍历，但是也需要像这道题一样需要一个hashmap来建立对应关系。同样的，这道题也可以像前一道题一样从后往前遍历。 总结来说就是一般从前往后和从后往前都可以，但是应该是都需要一个结构（一般是一个map）来记录对应关系的，这道题的res就是起到了这个作用。 Algorithm Walkthrough Initialize an empty stack and an empty hashmap. Loop through the nums2 array from left to right. For each number in nums2, while the stack is not empty and the current number is greater than the top element of the stack: Pop the element from the stack and add an entry to the hashmap with the popped element as the key and the current number as the value. Push the current number onto the stack. After the loop, any numbers remaining on the stack do not have a next greater element, so for each of these numbers, add an entry to the hashmap with the number as the key and -1 as the value. Finally, create an output array by mapping each number in nums1 to its corresponding value in the hashmap. CodeHere is the code for this algorithm: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from collections import dequeclass Solution: def nextGreaterElement(self, nums1, nums2): # Initialize stack and hashmap stack, hashmap = deque(), &#123;&#125; # stack, hashmap = [], &#123;&#125; # 原版，但是我比较习惯deque,而且不会对时间和空间复杂度有影响 # Process each number in nums2 for num in nums2: # Pop elements from the stack that are smaller than current number while stack and stack[-1] &lt; num: hashmap[stack.pop()] = num # Remember the next greater element for num # Push current number onto stack stack.append(num) # Map the numbers in nums1 to their next greater number return [hashmap.get(num, -1) for num in nums1]if __name__ == &quot;__main__&quot;: solution = Solution() nums1 = [4,2,6] nums2 = [6,2,4,5,3,7] print(solution.nextGreaterElement(nums1, nums2)) # 下面这个采用了从后往前的遍历方式，但是可以发现对于这道题来说，从前往后遍历也需要一个map来记录，所以从前往后和从后往前都是可以的 ，但是要不要map辅助，就需要看题目了。# 下面这个也过了leetcode,并且时间和空间上没有差别# 总结来说就是一般从前往后和从后往前都可以，但是应该是都需要一个结构（一般是一个map）来记录对应关系的，这道题的res就是起到了这个作用。**但是一般都是从前往后遍历**from collections import dequeclass Solution: def nextGreaterElement(self, nums1, nums2): # Initialize stack and hashmap stack = deque() # stack = [] # 原版，但是我比较习惯deque,而且不会对时间和空间复杂度有影响 greater_index_for_nums2 = &#123;&#125; # Process each number in nums2 for i in range(len(nums2) - 1, -1, -1): # Pop elements from the stack that are smaller than current number # 因为找的是greater所以这里的判断应该就是&lt;=的都弹出,直到遇到了大于的 while stack and stack[-1] &lt;= nums2[i]: stack.pop() if stack: greater_index_for_nums2[nums2[i]] = stack[-1] stack.append(nums2[i]) # print(greater_index_for_nums2) # Map the numbers in nums1 to their next greater number return [greater_index_for_nums2.get(num, -1) for num in nums1]if __name__ == &quot;__main__&quot;: solution = Solution() nums1 = [4, 2, 6] nums2 = [6, 2, 4, 5, 3, 7] print(solution.nextGreaterElement(nums1, nums2)) nums1 = [9, 7, 1] nums2 = [1, 7, 9, 5, 4, 3] print(solution.nextGreaterElement(nums1, nums2)) nums1 = [5, 12, 3] nums2 = [12, 3, 5, 4, 10, 15] print(solution.nextGreaterElement(nums1, nums2)) Time and Space ComplexityThe time complexity of this algorithm is O(n) , where N is the length of nums2, since each element is pushed and popped from the stack exactly once. The space complexity is O(n) as well, due to the additional space needed for the stack and the hashmap. Daily Temperatures739. Daily Temperatures Design Gurus Problem StatementGiven an array of integers temperatures representing daily temperatures, your task is to calculate how many days you have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead. Examples Input: temperatures = [70, 73, 75, 71, 69, 72, 76, 73] Output: [1, 1, 4, 2, 1, 1, 0, 0] Explanation: The first day’s temperature is 70 and the next day’s temperature is 73 which is warmer. So for the first day, you only have to wait for 1 day to get a warmer temperature. Hence, the first element in the result array is 1. The same process is followed for the rest of the days. Input: temperatures = [73, 72, 71, 70] Output: [0, 0, 0, 0] Explanation: As we can see, the temperature is decreasing every day. So, there is no future day with a warmer temperature. Hence, all the elements in the result array are 0. Input: temperatures = [70, 71, 72, 73] Output: [1, 1, 1, 0] Explanation: For the first three days, the next day is warmer. But for the last day, there is no future day with a warmer temperature. Hence, the result array is [1, 1, 1, 0]. Constraints: 1 &lt;= temperatures.length &lt;= 10^5 30 &lt;= temperatures[i] &lt;= 100 SolutionThis problem is quite similar to ‘Next Greater Element’. We can use a monotonically decreasing stack to find the next higher temperature. We will use a stack to store the indices of the temperatures array. We iterate over the array, and for each temperature, we check whether the current temperature is greater than the temperature at the index on the top of the stack. If it is, we update the corresponding position in the result array and pop the index from the stack. Algorithm Walkthrough Initialize an empty stack to store the indices of the temperatures array. Also, initialize a result array of the same length as temperatures with all values set to 0. Iterate over the temperatures array. For each temperature: While the stack is not empty and the current temperature is greater than the temperature at the index on the top of the stack, set the value in the result array at the top index of the stack to the difference between the current index and the top index of the stack. Pop the index from the stack. Push the current index onto the stack. Return the result array. CodeHere is how we can implement this algorithm: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from collections import dequeclass Solution: def dailyTemperatures(self, temperatures): stack = deque() # Initialize an empty stack to store indices of temperatures. # stack = [] # 原版，但是我比较习惯deque,而且不会对时间和空间复杂度有影响 res = [0] * len(temperatures) # Initialize a result list with zeros. for i in range(len(temperatures)): while stack and temperatures[i] &gt; temperatures[stack[-1]]: # While the stack is not empty and the current temperature is higher # than the temperature at the index stored at the top of the stack: idx = stack.pop() # Pop the top index from the stack. res[idx] = i - idx # Calculate the number of days until warmer temperature. stack.append(i) # Push the current index onto the stack. return resif __name__ == &quot;__main__&quot;: solution = Solution() print(solution.dailyTemperatures([70, 73, 75, 71, 69, 72, 76, 73])) # Output: [1, 1, 4, 2, 1, 1, 0, 0] print(solution.dailyTemperatures([73, 72, 71, 70])) # Output: [0, 0, 0, 0] print(solution.dailyTemperatures([70, 71, 72, 73])) # Output: [1, 1, 1, 0] # 当然也可以从后往前遍历，也可以过leetcode,并且时间和空间上没有任何差别from collections import dequeclass Solution: def dailyTemperatures(self, temperatures): stack = deque() # Initialize an empty stack to store indices of temperatures. res = [0] * len(temperatures) # Initialize a result list with zeros. for i in range(len(temperatures) - 1, -1, -1): idx = 0 # 这边是把不符合的（小于或者等于）的剔除，所以留下来的是warmer的温度 while stack and temperatures[i] &gt;= temperatures[stack[-1]]: # While the stack is not empty and the current temperature is higher # than the temperature at the index stored at the top of the stack: idx = stack.pop() # Pop the top index from the stack. if stack: res[i] = stack[-1] - i # Calculate the number of days until warmer temperature. stack.append(i) # Push the current index onto the stack. return resif __name__ == &quot;__main__&quot;: solution = Solution() print(solution.dailyTemperatures([70, 73, 75, 71, 69, 72, 76, 73])) # Output: [1, 1, 4, 2, 1, 1, 0, 0] print(solution.dailyTemperatures([73, 72, 71, 70])) # Output: [0, 0, 0, 0] print(solution.dailyTemperatures([70, 71, 72, 73])) # Output: [1, 1, 1, 0] Time and Space ComplexityThe time complexity of the algorithm is O(n), where N is the size of the temperatures array, since we process each temperature once. The space complexity is also O(n), where N is the size of the temperatures array, due to the extra space used by the stack and the output list. Remove Nodes From Linked List2487. Remove Nodes From Linked List Design Gurus Problem StatementGiven the head node of a singly linked list, modify the list such that any node that has a node with a greater value to its right gets removed. The function should return the head of the modified list. Examples: Input: 5 -&gt; 3 -&gt; 7 -&gt; 4 -&gt; 2 -&gt; 1Output: 7 -&gt; 4 -&gt; 2 -&gt; 1Explanation: 5 and 3 are removed as they have nodes with larger values to their right. Input: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5Output: 5Explanation: 1, 2, 3, and 4 are removed as they have nodes with larger values to their right. Input: 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1Output: 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1Explanation: None of the nodes are removed as none of them have nodes with larger values to their right. Constraints: The number of the nodes in the given list is in the range [1, 10^5]. 1 &lt;= Node.val &lt;= 1010^5 SolutionWe can the monotonic stack strategy to keep track of the highest-valued nodes in the linked list, ensuring that any node with a higher value to its right gets removed. Starting from the head of the list, we will traverse each node. At each node, we will check the value of the node against the node at the top of the stack. If the current node has a higher value, we will pop the top value from the stack. We will keep repeating this until we encounter a node with a higher value or the stack is empty. Then, the current node is pushed onto the stack. This process ensures that the stack only contains nodes in decreasing order from bottom to top. Detailed Walkthrough: Create an empty stack, stack. Initialize cur with the head of the linked list. Enter a loop that continues until cur becomes null: a. Enter an inner loop that continues as long as cur‘s value is greater than the value of the node at the top of stack: Pop the top node from stack. b. If stack is not empty, set the next of the node at the top of stack to cur. c. Push cur onto stack. d. Move cur to the next node in the linked list. After exiting the loop, return the bottom node of stack as the head of the modified linked list. If stack is empty, return null. CodeHere is how we can implement this algorithm: 123456789101112131415161718192021222324252627282930313233343536373839404142434445from collections import deque# class Node:# def __init__(self, value, next=None):# self.val = value# self.next = nextclass Solution: def removeNodes(self, head): stack = deque() # Create an empty stack to store nodes in descending order # stack = [] # 原版，但是我比较习惯deque,而且不会对时间和空间复杂度有影响 cur = head while cur: while stack and stack[-1].val &lt; cur.val: stack.pop() # Remove nodes from the stack that are smaller than the current node if stack: stack[-1].next = cur # Update the next pointer of the top node in the stack stack.append(cur) # Push the current node onto the stack cur = cur.next return stack.popleft() if stack else None # Return the head of the modified list, or None if the stack is empty # return stack[0] if stack else None # 这两句话都可以# Testing the solutionsolution = Solution()# Creating the linked list 5 -&gt; 3 -&gt; 7 -&gt; 4 -&gt; 2 -&gt; 1head1 = Node(5)head1.next = Node(3)head1.next.next = Node(7)head1.next.next.next = Node(4)head1.next.next.next.next = Node(2)head1.next.next.next.next.next = Node(1)head1 = solution.removeNodes(head1)# Printing the modified list: 7 -&gt; 4 -&gt; 2 -&gt; 1node = head1while node: print(node.val, end=&quot; -&gt; &quot; if node.next else &quot;\\n&quot;) node = node.next Time and Space ComplexityThe time complexity of this algorithm is O(n), where n is the number of nodes in the linked list. This is because every node is visited once while traversing the list. The inner loop may seem to increase the time complexity, but in fact, it doesn’t, because each node is pushed and popped from the stack at most once, so the total operations are still proportional to n. The space complexity is also O(n). This is due to the extra space required for the stack. In the worst-case scenario (when the list is sorted in ascending order), all the nodes will be pushed onto the stack, requiring n space. Therefore, we say the algorithm is linear in both time and space complexity. Remove All Adjacent Duplicates In String1047. Remove All Adjacent Duplicates In String Design Gurus Problem StatementGiven a string S, remove all adjacent duplicate characters recursively to generate the resultant string. Examples Input: s = &quot;abccba&quot; Output: &quot;&quot; Explanation: First, we remove “cc” to get “abba”. Then, we remove “bb” to get “aa”. Finally, we remove “aa” to get an empty string. Input: s = &quot;foobar&quot; Output: &quot;fbar&quot; Explanation: We remove “oo” to get “fbar”. Input: s = &quot;abcd&quot; Output: &quot;abcd&quot; Explanation: No adjacent duplicates so no changes. Constraints: 1 &lt;= s.length &lt;= 10^5 s consists of lowercase English letters. SolutionThis problem can be solved efficiently using a stack, which can mimic the process of eliminating adjacent duplicates. Algorithm Walkthrough Initialize an empty stack. Loop through the characters in the given string s. For each character: If the stack is not empty and the current character is the same as the top character on the stack, pop the character from the stack. Otherwise, push the current character onto the stack. Finally, build the result string from the characters remaining on the stack. CodeHere is the code for this algorithm: 12345678910111213141516171819202122232425262728293031from collections import dequeclass Solution: def removeDuplicates(self, s: str) -&gt; str: # Initialize stack stack = deque() # stack = [] # 原版，但是我比较习惯deque,而且不会对时间和空间复杂度有影响 # Process each character in s for c in s: # If the stack is not empty and the current character is the same as the top of the stack, # pop the character from the stack # 注意，这里只会消去重复出现偶数次的，如果是“acccd&quot;那么结果是&quot;acd&quot;,所以应该使用if # 如果是while else循环的话，那么&quot;abccba&quot;会输出”abcba“ if stack and c == stack[-1]: stack.pop() else: # Push the current character onto the stack stack.append(c) # Join the stack to a string return &#x27;&#x27;.join(stack)if __name__ == &quot;__main__&quot;: solution = Solution() print(solution.removeDuplicates(&quot;abccba&quot;)) # Output: &quot;&quot; print(solution.removeDuplicates(&quot;foobar&quot;)) # Output: &quot;fbar&quot; print(solution.removeDuplicates(&quot;abcd&quot;)) # Output: &quot;abcd&quot; print(solution.removeDuplicates(&quot;abcccd&quot;)) # Output: &quot;abcd&quot; Time and Space ComplexityThe time complexity of this algorithm is O(n), where N is the length of s, because we perform one operation per character in s. The space complexity is also O(n), as in the worst case, every character in s is pushed onto the stack. Remove All Adjacent Duplicates in String II1209. Remove All Adjacent Duplicates in String II Design Gurus Problem StatementYou are given a string s and an integer k. Your task is to remove groups of identical, consecutive characters from the string such that each group has exactly k characters. The removal of groups should continue until it’s no longer possible to make any more removals. The result should be the final version of the string after all possible removals have been made. Examples Input: s = &quot;abbbaaca&quot;, k = 3 Output: &quot;ca&quot; Explanation: First, we remove “bbb” to get “aaaca”. Then, we remove “aaa” to get “ca”. Input: s = &quot;abbaccaa&quot;, k = 3 Output: &quot;abbaccaa&quot; Explanation: There are no instances of 3 adjacent characters being the same. Input: s = &quot;abbacccaa&quot;, k = 3 Output: &quot;abb&quot; Explanation: First, we remove “ccc” to get “abbaaa”. Then, we remove “aaa” to get “abb”. Constraints: 1 &lt;= s.length &lt;= 10^5 2 &lt;= k &lt;= 10^4 s only contains lowercase English letters. SolutionThis problem can be solved by using a stack to keep track of the characters and their counts. We iterate through the string and add each character and its count to the stack. If the count of the top character of the stack becomes k, we remove that entry from the stack. The result string is then constructed from the remaining characters in the stack. Algorithm Walkthrough Initialize an empty stack. Each entry in the stack is a pair consisting of a character and its count. Loop through the characters in s. For each character: If the stack is not empty and the current character is the same as the top character on the stack, increment the count of the top character. Otherwise, add the current character and a count of 1 to the stack. If the count of the top character on the stack is k, pop the top character from the stack. Build the result string from the characters remaining on the stack. CodeHere is how we can implement this algorithm: 12345678910111213141516171819202122232425262728from collections import dequeclass Solution: def removeDuplicates(self, s: str, k: int) -&gt; str: stack = deque() # Initialize an empty stack to track characters and their counts. # stack = [] # 原版，但是我比较习惯deque,而且不会对时间和空间复杂度有影响 for c in s: # If the stack is not empty and the current character is the same as the top of the stack. if stack and stack[-1][0] == c: stack[-1][1] += 1 # Increment the count of the top character in the stack. else: stack.append([c, 1]) # Otherwise, push a new character-count pair onto the stack. if stack[-1][1] == k: # If the count of the top character in the stack reaches &#x27;k&#x27;. stack.pop() # Remove it from the stack. return &#x27;&#x27;.join(c * n for c, n in stack) # Reconstruct the string from the characters remaining in the stack.if __name__ == &quot;__main__&quot;: solution = Solution() print(solution.removeDuplicates(&quot;abbbaaca&quot;, 3)) # Output: &quot;ca&quot; print(solution.removeDuplicates(&quot;abbaccaa&quot;, 3)) # Output: &quot;abbaccaa&quot; print(solution.removeDuplicates(&quot;abbacccaa&quot;, 3)) # Output: &quot;abbaa&quot; print(solution.removeDuplicates(&quot;abbaccccaa&quot;, 3)) # Output: &quot;abbacaa&quot; Time and Space ComplexityThe time complexity of this algorithm is O(n), where N is the length of s, as we perform one operation per character. The space complexity is also O(n), as in the worst case, all characters are pushed onto the stack. Remove K Digits402. Remove K Digits Design Gurus Problem StatementGiven a non-negative integer represented as a string num and an integer k, delete k digits from num to obtain the smallest possible integer. Return this minimum possible integer as a string. Examples Input: num = &quot;1432219&quot;, k = 3 Output: &quot;1219&quot; Explanation: The digits removed are 4, 3, and 2 forming the new number 1219 which is the smallest. Input: num = &quot;10200&quot;, k = 1 Output: &quot;200&quot; Explanation: Removing the leading 1 forms the smallest number 200. Input: num = &quot;1901042&quot;, k = 4 Output: &quot;2&quot; Explanation: Removing 1, 9, 1, and 4 forms the number 2 which is the smallest possible. Constraints: 1 &lt;= k &lt;= num.length &lt;= 10^5 num consists of only digits. num does not have any leading zeros except for the zero itself. SolutionThe idea is to keep removing the peak digit from the number num. The peak digit in a number is a digit after which the next digit is smaller. By doing so, we are always trying to minimize the leftmost digit which will give us the smallest possible number. We can use a monotonically increasing stack to keep track of the decreasing peak digits. Algorithm Walkthrough Initialize an empty stack. Iterate over the digits in num. For each digit: While k is greater than 0, the stack is not empty and the current digit is smaller than the top digit on the stack, pop the top digit from the stack and decrease k by 1. Push the current digit onto the stack. If k is still greater than 0, pop k digits from the stack. Build the result string from the digits in the stack. Remove the leading zeros. If the result string is empty, return “0”. Otherwise, return the result string. CodeHere is how we can implement this algorithm: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120# 官方答案，时间复杂度比较小from collections import dequeclass Solution: def removeKdigits(self, num: str, k: int) -&gt; str: stack = deque() # stack = [] # 原版，但是我比较习惯deque,而且不会对时间和空间复杂度有影响 for digit in num: # 没有转化为int，确实也不需要 while k &gt; 0 and stack and stack[-1] &gt; digit: stack.pop() k -= 1 stack.append(digit) # Truncate the remaining K digits # 在pycharm中deque也可以使用[:]来切分,但是在leetcode中deque不可以 # stack = stack[:-k] if k &gt; 0 else stack # 所以如果要用deque的话就要这样写 while stack and k: stack.pop() k -= 1 # 这个忘记写了 # Remove any leading zeros return &quot;&quot;.join(stack).lstrip(&quot;0&quot;) or &quot;0&quot;if __name__ == &quot;__main__&quot;: solution = Solution() print(solution.removeKdigits(&quot;1432219&quot;, 3)) # Output: &quot;1219&quot; print(solution.removeKdigits(&quot;10200&quot;, 1)) # Output: &quot;200&quot; print(solution.removeKdigits(&quot;1901042&quot;, 4)) # Output: &quot;2&quot;# 自己写的，能过前三个测试用例（官方给的），但是第四个过不了（leetcode）from collections import dequeclass Solution: def removeKdigits(self, num: str, k: int) -&gt; str: stack = deque() for c in num: while stack and int(c) &lt; stack[-1] and k: stack.pop() k -= 1 if int(c) &gt; 0 or stack: stack.append(int(c)) if stack: return &quot;&quot;.join(str(c) for c in stack) return &quot;0&quot;if __name__ == &quot;__main__&quot;: solution = Solution() print(solution.removeKdigits(&quot;1432219&quot;, 3)) # Output: &quot;1219&quot; print(solution.removeKdigits(&quot;10200&quot;, 1)) # Output: &quot;200&quot; print(solution.removeKdigits(&quot;1901042&quot;, 4)) # Output: &quot;2&quot; # 自己写的v2,最后一个测试用例过不了（leetcode）from collections import dequeclass Solution: def removeKdigits(self, num: str, k: int) -&gt; str: stack = deque() for c in num: while stack and int(c) &lt; stack[-1] and k: stack.pop() k -= 1 if int(c) &gt; 0 or stack: stack.append(int(c)) while stack and k: stack.pop() if stack: return &quot;&quot;.join(str(c) for c in stack) return &quot;0&quot;if __name__ == &quot;__main__&quot;: solution = Solution() print(solution.removeKdigits(&quot;1432219&quot;, 3)) # Output: &quot;1219&quot; print(solution.removeKdigits(&quot;10200&quot;, 1)) # Output: &quot;200&quot; print(solution.removeKdigits(&quot;1901042&quot;, 4)) # Output: &quot;2&quot; print(solution.removeKdigits(&quot;9&quot;, 1)) # Output: &quot;0&quot; print(solution.removeKdigits(&quot;112&quot;, 1)) # Output: &quot;11&quot; # 自己写的v3，过了leetcodefrom collections import dequeclass Solution: def removeKdigits(self, num: str, k: int) -&gt; str: stack = deque() for c in num: while stack and int(c) &lt; stack[-1] and k: stack.pop() k -= 1 if int(c) &gt; 0 or stack: stack.append(int(c)) while stack and k: stack.pop() k -= 1 # 这个忘记写了 if stack: return &quot;&quot;.join(str(c) for c in stack) return &quot;0&quot;if __name__ == &quot;__main__&quot;: solution = Solution() print(solution.removeKdigits(&quot;1432219&quot;, 3)) # Output: &quot;1219&quot; print(solution.removeKdigits(&quot;10200&quot;, 1)) # Output: &quot;200&quot; print(solution.removeKdigits(&quot;1901042&quot;, 4)) # Output: &quot;2&quot; print(solution.removeKdigits(&quot;9&quot;, 1)) # Output: &quot;0&quot; print(solution.removeKdigits(&quot;112&quot;, 1)) # Output: &quot;11&quot; Time and Space Complexity Time: O(n) where N is the number of digits in input. Space: O(n) to store stack.","categories":[{"name":"Grokking Interview Pattern","slug":"Grokking-Interview-Pattern","permalink":"https://hasuer.github.io/categories/Grokking-Interview-Pattern/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hasuer.github.io/tags/Interview/"}]},{"title":"7. Pattern Stack","slug":"7. Pattern Stack","date":"2024-05-07T09:16:48.000Z","updated":"2024-05-28T03:27:52.825Z","comments":true,"path":"7-pattern-stack/index.html","link":"","permalink":"https://hasuer.github.io/7-pattern-stack/index.html","excerpt":"","text":"Introduction to StackStack is a linear data structure that follows a particular order of operation. This order can either be Last In First Out (LIFO) or First In Last Out (FILO). Imagine you have a pile of books that you plan to read. You keep adding books to the top of the pile. When you’re ready to start reading, you take a book from the top of the pile. The last book you added to the pile is the first one you read. That’s LIFO - the principle that stack data structures operate on. What makes stacks so unique is their simplicity and elegance. Despite being straightforward, they can be incredibly powerful when used in the right way. Real-world Examples of StacksBefore diving into technicalities, let’s familiarize ourselves with stacks in our daily lives. Stacks are everywhere around us, even if we might not notice them. Here are some examples to help you relate: Stack of Books: This is perhaps the simplest example. A pile of books is a stack. The book on the top was the last one added and will be the first one removed. Stack of Plates: Picture a stack of plates at a buffet. The first plate you’ll take is the one on top, which was the last one put on the stack. Web Browser History: Every time you visit a new webpage, it’s added to the top of your history stack. When you hit the back button, you’re “popping” pages off the top of the stack. Undo Function in Software Applications: The undo function in software applications uses a stack to remember actions. The most recent action is on top and will be the first one undone. Looking at these examples, it’s clear that stacks are not just a theoretical concept, but a practical one that we use unconsciously in our daily lives. With this understanding, let’s dive deeper into the operations that define stacks in data structures. The LIFO PrincipleAs mentioned earlier, stacks in data structures operate on the Last-In, First-Out (LIFO) principle. This means that the last item added to the stack is the first one that gets taken out. The LIFO principle is the heart of stack data structures. It governs how we add and remove elements, making stack operations predictable and consistent. With that, let’s explore the primary operations that you can perform on a stack. There are four key operations that you can perform on a stack: Push: This is how we add an element to the stack. The element is always added to the top. Pop: This is the removal of an element from the stack. The element removed is always from the top. Peek or Top: This operation allows us to see the element on the top of the stack without removing it. IsEmpty: This operation checks if the stack is empty. Let’s see these stack operations in detail in the next section. Operations on StackThis chapter aims to demystify the main operations involved in manipulating a stack: push, pop, peek, and isEmpty. We will examine these operations closely, detailing their functionality, providing coding examples, and highlighting their importance in problem-solving. Push OperationLet’s start with the push operation. As we’ve previously learned, push adds a new element to the top of the stack. Think of it like placing a new dish on top of a pile in your sink - the new dish (our data) is added to the top of the pile (our stack). In programming, the push operation usually involves a few steps. First, we check if there’s room to add a new element (we’ll discuss this in more detail when we talk about stack overflow). If there’s room, we add the new element to the top of the stack. Pop OperationNext, we have the pop operation, which removes the topmost element of the stack. It’s like removing the top dish from our pile in the sink. In code, popping an element from a stack is usually done in two parts. First, we check if there are any elements to remove (we’ll look at this more when we discuss stack underflow). If there are elements, we remove the top one. Peek or Top OperationThe peek or top operation is slightly different. Instead of adding or removing an element, this operation allows us to look at the top element of the stack without removing it. It’s like looking at the top dish in our sink pile without touching it. This operation can be handy when you need to know what’s on top of your stack, but you don’t want to change anything. It’s a read-only operation. IsEmpty OperationFinally, the isEmpty operation checks if the stack is empty. This operation is essential for preventing errors when popping an element from an empty stack (known as stack underflow). An empty stack will return true when the isEmpty operation is performed, while a stack with one or more elements will return false. Putting it All TogetherKnowing how each of these operations works is crucial. But, what’s more important is knowing how to use them together to solve problems. Here’s a brief coding example to show how these operations can be used together. 123456789101112131415161718192021222324252627class Stack: def __init__(self): # Initialize an empty list to represent the stack. self.stack = [] def isEmpty(self): # Check if the stack is empty by comparing it to an empty list. return self.stack == [] def push(self, data): # Add the given data to the top of the stack (end of the list). self.stack.append(data) def pop(self): if self.isEmpty(): # If the stack is empty, return a message indicating so. return &#x27;Stack is empty&#x27; # Remove and return the top element from the stack (last item in the list). return self.stack.pop() def peek(self): if self.isEmpty(): # If the stack is empty, return a message indicating so. return &#x27;Stack is empty&#x27; # Return the top element from the stack without removing it. return self.stack[-1] Dealing with Stack Overflow and UnderflowAs we discussed earlier, stack overflow and underflow are two situations you might encounter when working with stacks. Stack overflow occurs when you try to push an element onto a stack that’s already full, while stack underflow occurs when you try to pop an element from an empty stack. Handling these situations properly is crucial to preventing runtime errors and ensuring that your code runs smoothly. Depending on the programming language and the specific implementation of the stack, you might have different ways of handling these situations. It’s always a good idea to check for stack overflow and underflow before performing push and pop operations. Implementing Stack Data StructureIn this module, we’ll cover how to implement a stack data structure using different programming languages and data structures. This is where you’ll see how powerful, versatile, and useful stacks can be! Stack Implementation Using an ArrayImplementing a stack using an array is one of the most straightforward ways. Let’s see how you can do this in different programming languages: 12345678910111213141516171819202122232425262728293031323334353637383940class Stack: def __init__(self, size): # Initialize the stack with a specified size self.stack = [None] * size # Initialize the top pointer to -1, indicating an empty stack self.top = -1 def push(self, data): # Check if the stack is full if self.top == len(self.stack) - 1: raise Exception(&#x27;Stack is full&#x27;) # Increment the top pointer self.top += 1 # Add the data to the stack at the current top position self.stack[self.top] = data def pop(self): # Check if the stack is empty if self.isEmpty(): raise Exception(&#x27;Stack is empty&#x27;) # Retrieve the data from the top of the stack data = self.stack[self.top] # Remove the data from the stack by setting it to None self.stack[self.top] = None # Decrement the top pointer self.top -= 1 # Return the popped data return data def peek(self): # Check if the stack is empty if self.isEmpty(): raise Exception(&#x27;Stack is empty&#x27;) # Return the data at the top of the stack without removing it return self.stack[self.top] def isEmpty(self): # Check if the stack is empty by examining the top pointer return self.top == -1 The primary advantage of using an array for implementing a stack is that it’s simple and requires no additional setup. However, the size of the array can limit the stack size, leading to a stack overflow. Stack Implementation Using Linked ListAn alternative way of implementing a stack is by using a linked list. This method can overcome the size limitation issue present in the array implementation. The code will look something like this: 1234567891011121314151617181920212223242526272829class Stack: class Node: def __init__(self, data): self.data = data # Store the data in this node self.next = None # Initialize the next node as None def __init__(self): self.top = None # Initialize the top of the stack as None def pop(self): if self.top is None: raise IndexError(&quot;pop from empty stack&quot;) # Raise exception if the stack is empty item = self.top.data # Store the top item&#x27;s data self.top = self.top.next # Update the top to be the next node return item # Return the popped item def push(self, item): t = self.Node(item) # Create a new node with the provided data t.next = self.top # Set the next of this new node to be the current top self.top = t # Update the top to be the new node def peek(self): if self.top is None: raise IndexError(&quot;peek from empty stack&quot;) # Raise exception if the stack is empty return self.top.data # Return the top item&#x27;s data def is_empty(self): return self.top is None # Return True if the stack is empty, False otherwise The key difference here is that we’re using a Node class to create nodes and linking them together to form a stack. This method allows our stack to be dynamically sized, avoiding the overflow issue we saw with arrays. Here is how different programming languages implement the stack class: Language API Java java.util.Stack Python Implemented through List C++ std::stack JavaScript Implemented through Array Applications of Stack Now that we have gained a solid understanding of stack operations and their implementation, it’s time to bring it all together by exploring the real-world applications of stacks. This fascinating data structure has a multitude of uses across many different areas in computer science, from memory management and compiler design to problem-solving in data analysis. Let’s dive in! Memory ManagementOne of the primary uses of stacks is in memory management. Ever wondered how your computer remembers which functions it’s running and in which order? The answer is stacks! When a function is called in a program, the system ‘pushes’ it onto a call stack. When the function finishes running, it’s ‘popped’ off the stack. This mechanism allows for nested function calls, where one function can call another. This is also how recursion works in programming. When a function calls itself, each recursive call is added to the stack with its own set of variables. Once the base case is met, the functions start resolving and are popped off the stack one by one. Expression Evaluation and Syntax ParsingAnother critical application of stacks is in evaluating mathematical expressions and parsing syntax in code compilers. Consider an arithmetic expression like 2 + 3 * 4. Before performing the operations, we need to check the precedence of the operators to get the correct result. Here, stacks come in handy to apply the BODMAS rule (Bracket, Order, Division and Multiplication, Addition and Subtraction). Storing operators in a stack can help manage their execution order. Similar logic applies when compilers parse code syntax. They use stacks to check if all opening brackets have matching closing ones, which helps validate the syntax. Undo Mechanism in Software ApplicationsHave you ever wondered how the ‘undo’ feature works in software applications like text editors, image editors, or even web browsers? Once again, stacks save the day. Each action you perform is pushed onto a stack. When you hit ‘undo’, the most recent action is popped from the stack and reversed. It’s a practical and elegant solution to a problem we encounter every day! Backtracking AlgorithmsBacktracking algorithms solve problems by trying out solutions and undoing them if they don’t lead to a solution. This is common in puzzles like Sudoku, the Eight Queens problem, and the Knight’s Tour problem. In such scenarios, stacks are used to store the intermediate stages of the problem. When an attempted solution doesn’t work out, the algorithm can ‘pop’ back to a previous state and try a different path. It’s like having a ‘save game’ feature when you’re tackling a challenging puzzle! Depth-First Search (DFS)Stacks are also used in graph algorithms, specifically Depth-First Search (DFS). DFS explores a graph by visiting a node and recursively investigating all its unvisited neighbors. The algorithm uses a stack to remember which nodes to visit next when it finishes exploring a path. By ‘pushing’ unvisited nodes onto the stack and ‘popping’ them once visited, DFS systematically explores every node in the graph. This method is particularly useful in network routing, AI behavior in games, and detecting cycles in a graph. Web Page History in BrowsersFinally, an everyday example of stacks in action is web page history in a browser. When you click a link, your current page is ‘pushed’ onto a stack, and you’re taken to a new page. If you hit the ‘back’ button, your browser ‘pops’ the topmost page off the stack, taking you back to where you were. It’s a simple, intuitive way to navigate the vast expanse of the internet. ConclusionThrough these examples, you can see just how versatile and vital stacks are in computer science and everyday applications. Balanced ParenthesesTop Interview 150 | 20. Valid Parentheses Design Gurus Problem StatementGiven a string s containing (, ), [, ], &#123;, and &#125; characters. Determine if a given string of parentheses is balanced. A string of parentheses is considered balanced if every opening parenthesis has a corresponding closing parenthesis in the correct order. Example 1: Input: String s = “{[()]}”;Expected Output: trueExplanation: The parentheses in this string are perfectly balanced. Every opening parenthesis ‘{‘, ‘[‘, ‘(‘ has a corresponding closing parenthesis ‘}’, ‘]’, ‘)’ in the correct order. Example 2: Input: string s = “{[}]”;Expected Output: falseExplanation: The brackets are not balanced in this string. Although it contains the same number of opening and closing brackets for each type, they are not correctly ordered. The ‘]’ closes ‘[‘ before ‘{‘ can be closed by ‘}’, and similarly, ‘}’ closes ‘{‘ before ‘[‘ can be closed by ‘]’. Example 3: Input: String s = “(]”;Expected Output: falseExplanation: The parentheses in this string are not balanced. Here, ‘)’ does not have a matching opening parenthesis ‘(‘, and similarly, ‘]’ does not have a matching opening bracket ‘[‘. Constraints: 1 &lt;= s.length &lt;= 10^4 s consists of parentheses only &#39;()[]&#123;&#125;&#39;. SolutionTo solve this problem, we use a stack data structure. As we traverse the string, each time we encounter an opening parenthesis (‘(‘, ‘{‘, or ‘[‘), we push it onto the stack. When we find a closing parenthesis (‘)’, ‘}’, or ‘]’), we check if it matches the type of the opening parenthesis at the top of the stack. If it matches, we pop the top element from the stack; if not, or if the stack is empty when we find a closing parenthesis, the string is not balanced, and we return false. After processing the entire string, if the stack is empty, it means all parentheses were properly closed and nested, so we return true. Otherwise, we return false. Here is a step-by-step algorithm: Initialize an empty Stack. Iterate over the string of parentheses. If the current character is an opening parenthesis, push it onto the Stack. If the current character is a closing parenthesis, check the top of the Stack. If the Stack is empty, then the string is not balanced (there is a closing parenthesis without a matching opening parenthesis), so return false. If the top of the Stack is the matching opening parenthesis, pop it off the Stack. If the top of the Stack is not the matching opening parenthesis, then the string is not balanced, so return false. After checking all parentheses, if the Stack is empty, then the string is balanced, so return true. If the Stack is not empty, then there are unmatched opening parentheses, so the string is not balanced, return false. Algorithm WalkthroughLet’s consider the input “{[()]}”, and observe how algorithm works. Initialization: Start with an empty stack. Iteration 1: Character = ‘{‘ Stack before operation: [] Since ‘{‘ is an opening bracket, push it onto the stack. Iteration 2: Character = ‘[‘ Stack before operation: [‘{‘] Since ‘[‘ is an opening bracket, push it onto the stack. Iteration 3: Character = ‘(‘ Stack before operation: [‘{‘, ‘[‘] Since ‘(‘ is an opening bracket, push it onto the stack. Iteration 4: Character = ‘)’ Stack before operation: [‘{‘, ‘[‘, ‘(‘] ‘)’ is a closing bracket. The top of the stack is ‘(‘, which is the corresponding opening bracket for ‘)’. So, pop ‘(‘ from the stack. Iteration 5: Character = ‘]’ Stack before operation: [‘{‘, ‘[‘] ‘]’ is a closing bracket. The top of the stack is ‘[‘, which is the corresponding opening bracket for ‘]’. So, pop ‘[‘ from the stack. Iteration 6: Character = ‘}’ Stack before operation: [‘{‘] ‘}’ is a closing bracket. The top of the stack is ‘{‘, which is the corresponding opening bracket for ‘}’. So, pop ‘{‘ from the stack. Final Check: After processing all characters, check the stack. The stack is empty, indicating that all opening brackets were properly matched and closed. Therefore, the input string “{[()]}” is valid with properly balanced parentheses. CodeHere is how you can implement this algorithm: 1234567891011121314151617181920212223242526272829303132333435363738394041424344from collections import dequeclass Solution: def isValid(self, s: str) -&gt; bool: # Creating a stack to keep track of opening parentheses stack = deque() # stack = [] # 原版，但是我比较习惯deque,而且不会对时间和空间复杂度有影响 # Iterating through each character in the input string for c in s: # If the character is an opening parenthesis, push it onto the stack if c in [&#x27;(&#x27;, &#x27;&#123;&#x27;, &#x27;[&#x27;]: stack.append(c) else: # If stack is empty and we have a closing parenthesis, the string is not balanced if not stack: return False # Pop the top character from the stack top = stack.pop() # If the character is a closing parenthesis, check whether # it corresponds to the most recent opening parenthesis if c == &#x27;)&#x27; and top != &#x27;(&#x27;: return False if c == &#x27;&#125;&#x27; and top != &#x27;&#123;&#x27;: return False if c == &#x27;]&#x27; and top != &#x27;[&#x27;: return False # If the stack is empty, all opening parentheses had a corresponding closing match return not stack# Test cases to verify the solutionsol = Solution()test1 = &quot;&#123;[()]&#125;&quot;; # Should be validtest2 = &quot;&#123;[&#125;]&quot;; # Should be invalidtest3 = &quot;(]&quot;; # Should be invalidprint(&quot;Test 1:&quot;, sol.isValid(test1))print(&quot;Test 2:&quot;, sol.isValid(test2))print(&quot;Test 3:&quot;, sol.isValid(test3)) Time and Space Complexity AnalysisThe time complexity of this algorithm is O(n), where n is the length of the string. This is because we’re processing each character in the string exactly once. The space complexity is also O(n) in the worst-case scenario when all the characters in the string are opening parentheses, so we push each character onto the Stack. In the average case, however, the space complexity would be less than O(n). Reverse a String344. Reverse String Design Gurus Problem StatementGiven a string, write a function that uses a stack to reverse the string. The function should return the reversed string. ExamplesExample 1: 12Input: &quot;Hello, World!&quot;Output: &quot;!dlroW ,olleH&quot; Example 2: 12Input: &quot;OpenAI&quot;Output: &quot;IAnepO&quot; Example 3: 12Input: &quot;Stacks are fun!&quot;Output: &quot;!nuf era skcatS&quot; Constraints: 1 &lt;= s.length &lt;= 10^5 s[i] is a printable ascii character. SolutionThe solution to reverse a string can be elegantly achieved using a stack. The algorithm involves pushing each character of the string onto a stack and then popping them off, which naturally reverses their order. As we iterate through the string, each character is added to the top of the stack. Once the entire string has been processed, we remove the characters from the stack one by one and append them to a new string. This process ensures that the characters are appended in reverse order, as the last character pushed onto the stack will be the first to be popped off. This method efficiently reverses the string while maintaining the integrity of the original data. Here is the step-by-step algorithm. Initialize an empty stack. For each character in the input string, push the character into the stack. Initialize an empty string to hold the reversed string. While the stack is not empty, pop out the top character from the stack and append it to the reversed string. Finally, return the reversed string. CodeHere is how we can implement this algorithm: 1234567891011121314151617181920212223242526# Define a class named Solutionclass Solution: # Define a method called reverseString within the class def reverseString(self, s): # Convert the input string &#x27;s&#x27; into a list of characters and store it in the &#x27;stack&#x27; variable # 直接转换的写法可以记一下 stack = list(s) # Initialize an empty string to store the reversed string reversed_str = &#x27;&#x27; # Use a loop to pop characters from the &#x27;stack&#x27; and append them to &#x27;reversed_str&#x27; # This effectively reverses the order of characters in the string while stack: reversed_str += stack.pop() # Return the reversed string return reversed_str# Create an instance of the Solution classrs = Solution()# Test the reverseString method with different input strings and print the resultsprint(rs.reverseString(&quot;Hello, World!&quot;)) # Output: &quot;!dlroW ,olleH&quot;print(rs.reverseString(&quot;OpenAI&quot;)) # Output: &quot;IAnepO&quot;print(rs.reverseString(&quot;Stacks are fun!&quot;)) # Output: &quot;!nuf era skcatS&quot; Time and Space Complexity:Time Complexity: O(n), where n is the length of the input string. This is because we iterate through the string once to push all characters into the stack and then another time to pop all characters out of the stack. Space Complexity: O(n), where n is the length of the input string. This is because we use a stack to hold all characters of the string. Decimal to Binary ConversionDesign Gurus Problem StatementGiven a positive integer n, write a function that returns its binary equivalent as a string. The function should not use any in-built binary conversion function. ExamplesExample 1: 123Input: 2Output: &quot;10&quot;Explanation: The binary equivalent of 2 is 10. Example 2: 123Input: 7Output: &quot;111&quot;Explanation: The binary equivalent of 7 is 111. Example 3: 123Input: 18Output: &quot;10010&quot;Explanation: The binary equivalent of 18 is 10010. Constraints: 0 &lt;= num &lt;= 10^9 SolutionWe can use a stack to efficiently create the binary representation of a given decimal number. Our algorithm will take advantage of the ‘Last In, First Out’ property of stacks to reverse the order of the binary digits, since the binary representation is constructed from least significant bit to most significant bit, but needs to be displayed in the opposite order. The procedure involves repeatedly dividing the decimal number by 2, pushing the remainder onto the stack, which corresponds to the binary digit. When the number is reduced to 0, the algorithm pops elements off the stack and appends to the result string until the stack is empty, thereby reversing the order of digits. The result is the binary equivalent of the input decimal number. Here is a detailed walkthrough of the solution: First, the algorithm starts by creating an empty stack. A stack is chosen because of its “Last In, First Out” property which is perfect for this type of problem where we need to reverse the order of the operations. Then, it enters into a loop where the given number is repeatedly divided by 2. This is because the binary number system is base 2, and each bit represents a power of 2. Inside the loop, the remainder when the number is divided by 2 (which is either 0 or 1) is pushed onto the stack. This remainder is essentially the bit in the binary representation of the number. The number is then updated by integer division by 2 (in programming languages, this is usually denoted by num //= 2 or num = Math.floor(num / 2) or num /= 2). This step essentially “shifts” the number one bit to the right. Steps 3 and 4 are repeated until the number becomes zero. At this point, the stack contains the binary representation of the number, but in reverse order. This is because the first bit we calculated (the least significant bit, or the “rightmost” bit) is on the top of the stack, while the last bit we calculated (the most significant bit, or the “leftmost” bit) is on the bottom of the stack. So, the next step is to reverse this order. This is done by popping the stack until it’s empty and appending each popped bit to the result. Since a stack follows “Last In, First Out” rule, this will correctly reverse the order of the bits. Finally, the algorithm returns the result, which is the binary representation of the original number. CodeHere is how we can implement this algorithm: 1234567891011121314151617from collections import dequeclass Solution: def decimalToBinary(self, num): stack = deque() # Create an empty stack to hold binary digits. # stack = [] # 原版，但是我比较习惯deque,而且不会对时间和空间复杂度有影响 while num &gt; 0: # Continue the loop until num becomes 0. stack.appendleft(num % 2) # Push the remainder of num divided by 2 onto the stack. num //= 2 # Update num by integer division (floor division) by 2. return &#x27;&#x27;.join(str(i) for i in stack) # Convert the stack to a binary string.# Test casessol = Solution()print(sol.decimalToBinary(2)) # Output: &quot;10&quot; (Binary representation of 2)print(sol.decimalToBinary(7)) # Output: &quot;111&quot; (Binary representation of 7)print(sol.decimalToBinary(18)) # Output: &quot;10010&quot; (Binary representation of 18) Time and Space Complexity AnalysisThe time complexity of this algorithm is O(log(n)) due to the division by 2 at each step. The space complexity is also O(log(n)) because in each step we will be pushing an element on the stack, and there are a total of log(n) steps. Next Greater ElementDesign Gurus Problem StatementGiven an array, print the Next Greater Element (NGE) for every element. The Next Greater Element for an element x is the first greater element on the right side of x in the array. Elements for which no greater element exist, consider the next greater element as -1. ExamplesExample 1: 123Input: [4, 5, 2, 25]Output: [5, 25, 25, -1]Explanation: The NGE for 4 is 5, 5 is 25, 2 is 25, and there is no NGE for 25. Example 1: 12Input: [13, 7, 6, 12]Output: [-1, 12, 12, -1] Example 1: 12Input: [1, 2, 3, 4, 5]Output: [2, 3, 4, 5, -1] Constraints: 1 &lt;= arr.length &lt;= 10^4 -109 &lt;= arr[i] &lt;= 10^9 Solution:A simple algorithm is to run two loops: the outer loop picks all elements one by one, and the inner loop looks for the first greater element for the element picked by the outer loop. However, this algorithm has a time complexity of . We can use a more optimized approach using Stack data structure. The algorithm will leverage the nature of the stack data structure, where the most recently added (pushed) elements are the first ones to be removed (popped). Starting from the end of the array, the algorithm always maintains elements in the stack that are larger than the current element. This way, it ensures that it has a candidate for the “next larger element”. If there is no larger element, it assigns -1 to that position. It handles each element of the array only once, making it an efficient solution. Detailed Step-by-Step Walkthrough The function receives an array arr. Initialize an empty stack s and an output array res of size equal to the input array, with all elements initialized to -1. res will store the result, i.e., the next larger element for each position in the array. Start a loop that goes from the last index of the array to the first (0 index). In each iteration, while there are elements in the stack and the top element of the stack is less than or equal to the current element in the array, remove elements from the stack. This step ensures that we retain only the elements in the stack that are larger than the current element. After the popping process, if there is still an element left in the stack, it is the next larger element for the current array element. So, assign the top element of the stack to the corresponding position in the res array. Now, push the current array element into the stack. This action considers the current element as a possible “next larger element” for the upcoming elements in the remaining iterations. Repeat steps 4-6 for all the elements of the array. At the end of the loop, res will contain the next larger element for each position in the array. Return this array res. Algorithm WalkthroughLet’s consider the input and observe how above algorithm works. Initialize Data Structures: Input Array: [13, 7, 6, 12] Result Array: [0, 0, 0, 0] (Initially set to zeros) Stack: Empty (Will store elements during iteration) Processing Each Element (Reverse Order): The algorithm processes the array from right to left. Last Element (Value 12): Stack is empty, indicating no greater element for 12. Result Array: [0, 0, 0, -1] (Updates the last position to -1) Push element 12 onto the stack. Third Element (Value 6): Stack’s top element is 12, which is greater than 6. Result Array: [0, 0, 12, -1] (Updates the value at the third position to 12) Push element 6 onto the stack. Second Element (Value 7): Stack’s top element is 6, which is less than 7, so it’s popped. Next, the stack’s top element is 12, which is greater than 7. Result Array: [0, 12, 12, -1] (Updates the value at the second position to 12) Push element 7 onto the stack. First Element (Value 13): Stack’s top element is 7, which is less than 13, so it’s popped. Next, stack’s top element is 12, which is also less than 13, so it’s popped. Stack is now empty, indicating no greater element for 13. Result Array: [-1, 12, 12, -1] (Updates the first position to -1) Push element 13 onto the stack. Here is the visual representation of the algorithm: CodeHere is the code for this algorithm: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from collections import dequeclass Solution: def nextLargerElement(self, arr): # Initialize an empty stack and a result list with -1 values s = deque() # stack = [] # 原版，但是我比较习惯deque,而且不会对时间和空间复杂度有影响 res = [-1] * len(arr) # Iterate through the array in reverse order for i in range(len(arr) - 1, -1, -1): # While the stack is not empty and the top element of the stack is less than or equal to the current element while s and s[-1] &lt;= arr[i]: s.pop() # Pop elements from the stack until the condition is met if s: # If the stack is not empty, set the result for the current element to the top element of the stack res[i] = s[-1] s.append(arr[i]) # Push the current element onto the stack return ressol = Solution()print(sol.nextLargerElement([4, 5, 2, 25])) # Example usageprint(sol.nextLargerElement([13, 7, 6, 12])) # Example usageprint(sol.nextLargerElement([1, 2, 3, 4, 5])) # Example usage# 下面的是看了Monotonic Stack中的“Next Greater Element&quot;之后的想法，后面的那道题目也是找greater的，所以使用的是decreasing stack，小的元素在栈顶。这道题官方的解法是从后往前遍历，而后一道题使用的是从后往前遍历+hashmap辅助记住对应关系。经过实验可以发现，这道题也可以使用从后往前遍历+hashmap的方式来进行求解。不过后面Pattern的那道题也说明了从前往后遍历也有可能需要hashmap，这道题从前往后遍历不需要hashmap是特例，因为这里只有一个数组，而后面那道题有两个数组，如果不用hashmap,就要用arr.index方法，也比较复杂。# 总结来说就是一般从前往后和从后往前都可以，但是应该是都需要一个结构（一般是一个map）来记录对应关系的，这道题的res就是起到了这个作用。**但是一般来说都是从前往后遍历（下一个Pattern 单调栈）**。# 从前往后遍历，需要一个hashmap来记录对应关系from collections import dequeclass Solution: def nextLargerElement(self, arr): # Initialize an empty stack and a result list with -1 values s = deque() res = [-1] * len(arr) hashmap = &#123;&#125; # Iterate through the array in reverse order for i in range(0, len(arr)): # While the stack is not empty and the top element of the stack is less than or equal to the current element # 因为找的是greater所以这里的判断应该就是s[-1] &lt; arr[i]而不是s[-1] &lt;= arr[i] while s and s[-1] &lt; arr[i]: top = s.pop() # Pop elements from the stack until the condition is met hashmap[top] = arr[i] s.append(arr[i]) for i in range(len(arr)): if arr[i] in hashmap: res[i] = hashmap[arr[i]] return res # 上面四行可以用下面这一行代替 # return [hashmap.get(num, -1) for num in nums1]sol = Solution()print(sol.nextLargerElement([4, 5, 2, 25])) # Example usageprint(sol.nextLargerElement([13, 7, 6, 12])) # Example usageprint(sol.nextLargerElement([1, 2, 3, 4, 5])) # Example usage Time and Space ComplexityTime Complexity: The worst-case time complexity of this algorithm is O(n) as every element is pushed and popped from the stack exactly once. Space Complexity: The space complexity of this algorithm is O(n) as we are using a stack and an array to store the next greater elements. Sorting a StackDesign Gurus Problem StatementGiven a stack, sort it using only stack operations (push and pop). You can use an additional temporary stack, but you may not copy the elements into any other data structure (such as an array). The values in the stack are to be sorted in descending order, with the largest elements on top. Examples123456781. Input: [34, 3, 31, 98, 92, 23] Output: [3, 23, 31, 34, 92, 98]2. Input: [4, 3, 2, 10, 12, 1, 5, 6] Output: [1, 2, 3, 4, 5, 6, 10, 12]3. Input: [20, 10, -5, -1] Output: [-5, -1, 10, 20] SolutionThis problem can be solved by using a temporary stack as auxiliary storage. The algorithm takes an input stack and sorts it using a temporary stack tmpStack. The sorting process is done by continuously popping elements from the input stack and pushing them onto the tmpStack in sorted order, rearranging elements as necessary between the stacks until the original stack is empty. This algorithm leverages the LIFO (last in, first out) nature of a stack. It removes elements from the original stack one by one and uses a second stack to keep the elements sorted. If the top element of the sorted stack is larger than the current element, it moves the larger elements back to the original stack until it finds the correct spot for the current element, at which point it pushes the current element onto the sorted stack. Because of this, the smaller elements end up at the bottom of the sorted stack and the largest element on the top, resulting in a stack sorted in descending order from top to bottom. Detailed Step-by-Step Walkthrough The sort method receives an input stack. It initializes an empty temporary stack tmpStack. The algorithm enters a loop that continues until the input stack is empty. In each iteration, it pops the top element (tmp) from the input stack. Then it enters another loop, which continues as long as tmpStack is not empty and the top of tmpStack is larger than tmp. In each iteration of this inner loop, it pops the top element from tmpStack and pushes it back onto the input stack. After the inner loop ends, it pushes tmp onto tmpStack. The inner loop ensures that tmpStack is always sorted in descending order, with smaller elements at the bottom and larger elements at the top, and tmp is placed into its correct position in this order. Once the outer loop ends and the input stack is empty, tmpStack contains all the elements originally in the input stack but sorted in descending order. It then returns tmpStack. Algorithm Walkthrough Initial Setup: Input Stack (top to bottom): [34, 3, 31, 98, 92, 23] Temporary Stack (tmpStack): Empty Process Element: 23 Pop 23 from the input stack. tmpStack is empty, so push 23 onto tmpStack. Input Stack: [34, 3, 31, 98, 92], tmpStack: [23] Process Element: 92 Pop 92 from the input stack. Since 23 &lt; 92, push 92 onto tmpStack. Input Stack: [34, 3, 31, 98], tmpStack: [23, 92] Process Element: 98 Pop 98 from the input stack. Since 92 &lt; 98, push 98 onto tmpStack. Input Stack: [34, 3, 31], tmpStack: [23, 92, 98] Process Element: 31 Pop 31 from the input stack. Move elements from tmpStack to input stack until the correct position for 31 is found. Pop 98, then 92 from tmpStack and push them onto the input stack. Push 31 onto tmpStack. Input Stack: [34, 3, 98, 92], tmpStack: [23, 31] In next 2 iterations, pop 98, and 92 from input stack and push back to the tmpStack. Updated stack will be: Input Stack: [34, 3], tmpStack: [23, 31, 92, 98]. Process Element: 3 Pop 3 from the input stack. Move elements from tmpStack to input stack until the correct position for 3 is found. Pop 98, 92, 31, then 23 from tmpStack and push them onto the input stack. Push 3 onto tmpStack. Input Stack: [34, 98, 92, 31, 23], tmpStack: [3] In next 4 iterations, pop 98, 92, 31, and 23 from the input stack and push back to the tmpStack. Updated stack will be: Input Stack: [34], tmpStack: [3, 23, 31, 92, 98]. Process Element: 34 Pop 34 from the input stack. Move elements from tmpStack to input stack until the correct position for 34 is found. Pop 98, then 92 from tmpStack and push them onto the input stack. Push 34 onto tmpStack. Input Stack: [98, 92], tmpStack: [3, 23, 31, 34]. In next 2 iterations, pop 98, and 92 from the input stack and push to the tmpStack. Final Result: Input Stack: Empty tmpStack (Sorted, top to bottom): [3, 23, 31, 34, 92, 98] Here is the visual representation of the algorithm: CodeHere is the code for this algorithm: 123456789101112131415161718192021222324252627282930313233from collections import dequeclass Solution: def sortStack(self, stack): # Create an empty stack to store the sorted elements tempStack = deque() # tempStack = [] # 原版，但是我比较习惯deque,而且不会对时间和空间复杂度有影响 # Continue sorting until the original stack is empty while stack: # Pop the top element from the original stack temp = stack.pop() # Move elements from the temporary stack back to the original stack # until we find the correct position for the current element while tempStack and tempStack[-1] &gt; temp: stack.append(tempStack.pop()) # Place the current element in its correct sorted position in the temporary stack tempStack.append(temp) # Return the sorted stack # return tempStack # 原版 return list(tempStack) # 配合deque# Example usagesol = Solution();stack = [34, 3, 31, 98, 92, 23]print(&quot;Input: &quot;, stack)print(&quot;Sorted Output: &quot;, sol.sortStack(stack)) Time and Space ComplexityTime Complexity The time complexity of the sort stack algorithm is O(n\\^2) , where n is the number of elements in the stack. This is because, in the worst case, for every element that we pop from the input stack, we might have to pop all the elements in the temporary stack (and push them back to the original stack) to find the correct place to insert the element. Since we have to do this for all n elements, the time complexity is n n = n^2*. Space Complexity The space complexity of the algorithm is O(n). This is because we use an additional temporary stack to sort the elements. In the worst-case scenario, this temporary stack could store all the elements of the original stack. Thus, the space complexity is directly proportional to the number of elements in the input stack, making it linear, O(n). Please note that the space complexity does not count the input size itself (the input stack in this case), it only counts the extra space we use related to the size of the input. If we were to count the input size as well, the total space used would be O(2n), but since we drop the constant factor when expressing space complexity, so it remains O(n). Simplify PathTop Interview 150 | 71. Simplify Path Design Gurus Problem StatementGiven an absolute file path in a Unix-style file system, simplify it by converting “..” to the previous directory and removing any “.” or multiple slashes. The resulting string should represent the shortest absolute path. Examples:12345678910111. Input: &quot;/a//b////c/d//././/..&quot; Output: &quot;/a/b/c&quot; 2. Input: &quot;/../&quot; Output: &quot;/&quot;3. Input: &quot;/home//foo/&quot; Output: &quot;/home/foo&quot; Constraints: 1 &lt;= path.length &lt;= 3000 path consists of English letters, digits, period ‘.’, slash ‘/‘ or ‘_’. path is a valid absolute Unix path. SolutionTo simplify the path, we’ll use a stack to track the directories we’re currently in. We’ll split the input path into components by the “/“ character, then process each component one by one. If a component is “..”, we go to the previous directory by popping the top of the stack. If a component is “.” or an empty string, we do nothing. Otherwise, we push the component into the stack as a new directory. Detailed Algorithm steps: Split the input path by the “/“ character into an array of components. Initialize an empty stack. For each component in the array: If the component is “..”, pop the top of the stack (if it’s not already empty). Else if the component is “.” or an empty string, do nothing. Else, push the component into the stack as a new directory. Finally, combine the components in the stack into a string, separated by the “/“ character. Add a “/“ at the start to denote an absolute path. Algorithm walkthroughlet’s walk through the code using the input &quot;/a//b////c/d//././/..&quot; step by step: Initialize a Stack: A Stack&lt;String&gt; is created to store components of the simplified path. Split the Path: The input path &quot;/a//b////c/d//././/..&quot; is split using &quot;/&quot; as the delimiter. The resulting parts are: [&quot;&quot;, &quot;a&quot;, &quot;&quot;, &quot;b&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;c&quot;, &quot;d&quot;, &quot;&quot;, &quot;.&quot;, &quot;&quot;, &quot;.&quot;, &quot;&quot;, &quot;&quot;, &quot;..&quot;]. Empty strings and dots (&quot;.&quot;) represent the current directory and will be ignored in further processing. Process Each Part: First Part (&quot;&quot;): It’s empty, so it’s ignored. Second Part (&quot;a&quot;): It’s a directory name and is pushed onto the stack. Third Part (&quot;&quot;): Ignored. Fourth Part (&quot;b&quot;): Another directory name, pushed onto the stack. Next Several Parts (&quot;&quot;, &quot;&quot;, &quot;&quot;): All empty, so ignored. Part &quot;c&quot;: A directory name, pushed onto the stack. Part &quot;d&quot;: Another directory name, pushed onto the stack. Part &quot;.&quot;: Represents the current directory, ignored. Part &quot;.&quot; (again): Again, represents the current directory, ignored. Last Part (&quot;..&quot;): Represents moving up one directory. It pops &quot;d&quot; from the stack. After processing, the stack contains: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]. Reconstruct Simplified Path: A StringBuilder is used to construct the final simplified path. The stack is processed in LIFO (Last-In-First-Out) order. Each component is popped and appended to the start of the result string, preceded by &quot;/&quot;. After processing the stack, the StringBuilder contains &quot;/a/b/c&quot;. Return the Result: The StringBuilder is converted to a string and returned. For the given input, the output is &quot;/a/b/c&quot;. Here is the visual representation of the algorithm: CodeHere is the code for this algorithm: 1234567891011121314151617181920212223242526272829from collections import dequeclass Solution: def simplifyPath(self, path): # Create a stack to store the simplified path components stack = deque() # stack = [] # 原版，但是我比较习惯deque,而且不会对时间和空间复杂度有影响 # Split the input path string using &#x27;/&#x27; as a delimiter for p in path.split(&#x27;/&#x27;): if p == &#x27;..&#x27;: # If the component is &#x27;..&#x27;, pop the last component from the stack if stack: stack.pop() elif p and p != &#x27;.&#x27;: # If the component is not empty and not &#x27;.&#x27;, push it onto the stack stack.append(p) # Reconstruct the simplified path by joining components from the stack return &#x27;/&#x27; + &#x27;/&#x27;.join(stack)# Test casessol = Solution();print(sol.simplifyPath(&quot;/a//b////c/d//././/..&quot;)) # Expected output: &quot;/a/b/c&quot;print(sol.simplifyPath(&quot;/../&quot;)) # Expected output: &quot;/&quot;print(sol.simplifyPath(&quot;/home//foo/&quot;)) # Expected output: &quot;/home/foo&quot; Time and Space ComplexityThe time complexity of the algorithm is O(n), where n is the size of the input path, since we process each character once. The space complexity is also O(n), as we store each directory in a stack.","categories":[{"name":"Grokking Interview Pattern","slug":"Grokking-Interview-Pattern","permalink":"https://hasuer.github.io/categories/Grokking-Interview-Pattern/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hasuer.github.io/tags/Interview/"}]},{"title":"6. Pattern In-place Reversal of a LinkedList","slug":"6. Pattern In-place Reversal of a LinkedList","date":"2024-05-06T07:35:04.000Z","updated":"2024-05-28T03:27:47.057Z","comments":true,"path":"6-pattern-in-place-reversal-of-a-linkedlist/index.html","link":"","permalink":"https://hasuer.github.io/6-pattern-in-place-reversal-of-a-linkedlist/index.html","excerpt":"","text":"IntroductionIn a lot of problems, we are asked to reverse the links between a set of nodes of a LinkedList. Often, the constraint is that we need to do this in-place, i.e., using the existing node objects and without using extra memory. In-place Reversal of a LinkedList pattern describes an efficient way to solve the above problem. In the following chapters, we will solve a bunch of problems using this pattern. Let’s jump on to our first problem to understand this pattern. Reverse a LinkedList (easy)206. Reverse Linked List Design Gurus Educative.io Problem StatementGiven the head of a Singly LinkedList, reverse the LinkedList. Write a function to return the new head of the reversed LinkedList. Constraints: The number of nodes in the list is the range [0, 5000]. -5000 &lt;= Node.val &lt;= 5000 SolutionTo reverse a LinkedList, we need to reverse one node at a time. We will start with a variable current which will initially point to the head of the LinkedList and a variable previous which will point to the previous node that we have processed; initially previous will point to null. In a stepwise manner, we will reverse the current node by pointing it to the previous before moving on to the next node. Also, we will update the previous to always point to the previous node that we have processed. Here is the visual representation of our algorithm: CodeHere is what our algorithm will look like: 12345678910111213141516171819202122232425262728293031323334353637383940414243# class Node:# def __init__(self, value, next=None):# self.val = value# self.next = nextclass Solution: def reverse(self, head): previous, current, next = None, head, None while current is not None: next = current.next # temporarily store the next node current.next = previous # reverse the current node # before we move to the next node, point previous to the current node previous = current current = next # move on the next node return previousdef print_list(head): temp = head while temp is not None: print(temp.val, end=&quot; &quot;) # Use temp.val to access the value temp = temp.next print()def main(): sol = Solution() head = Node(2) head.next = Node(4) head.next.next = Node(6) head.next.next.next = Node(8) head.next.next.next.next = Node(10) print(&quot;Nodes of original LinkedList are: &quot;, end=&#x27;&#x27;) print_list(head) result = sol.reverse(head) print(&quot;Nodes of reversed LinkedList are: &quot;, end=&#x27;&#x27;) print_list(result)if __name__ == &quot;__main__&quot;: main() Time complexityThe time complexity of our algorithm will be O(N) where ‘N’ is the total number of nodes in the LinkedList. Space complexityWe only used constant space, therefore, the space complexity of our algorithm is O(1). *Reverse a Sub-list (medium)Top Interview 150 | 92. Reverse Linked List II Design Gurus Educative.io Problem StatementGiven the head of a LinkedList and two positions ‘p’ and ‘q’, reverse the LinkedList from position ‘p’ to ‘q’. Constraints: The number of nodes in the list is n. 1 &lt;= n &lt;= 500 -500 &lt;= Node.val &lt;= 500 1 &lt;= left &lt;= right &lt;= n SolutionThe problem follows the In-place Reversal of a LinkedList pattern. We can use a similar approach as discussed in Reverse a LinkedList. Here are the steps we need to follow: Skip the first p-1 nodes, to reach the node at position p. Remember the node at position p-1 to be used later to connect with the reversed sub-list. Next, reverse the nodes from p to q using the same approach discussed in Reverse a LinkedList. Connect the p-1 and q+1 nodes to the reversed sub-list. 思路和我的是一样的，比较好奇他是怎么解决P == 1的情况的 CodeHere is what our algorithm will look like: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class Node: def __init__(self, value, next=None): self.val = value self.next = nextclass Solution: def reverse(self, head, p, q): if p == q: return head # after skipping &#x27;p-1&#x27; nodes, current will point to &#x27;p&#x27;th node current, previous = head, None i = 0 while current is not None and i &lt; p - 1: previous = current current = current.next i += 1 # we are interested in three parts of the LinkedList, the part before index &#x27;p&#x27;, # the part between &#x27;p&#x27; and &#x27;q&#x27;, and the part after index &#x27;q&#x27; last_node_of_first_part = previous # after reversing the LinkedList &#x27;current&#x27; will become the last node of the sub-list last_node_of_sub_list = current # reverse之后的last_node next = None # will be used to temporarily store the next node i = 0 # reverse nodes between &#x27;p&#x27; and &#x27;q&#x27; while current is not None and i &lt; q - p + 1: next = current.next current.next = previous previous = current current = next i += 1 # connect with the first part if last_node_of_first_part is not None: # &#x27;previous&#x27; is now the first node of the sub-list last_node_of_first_part.next = previous # this means p == 1 i.e., we are changing the first node (head) of the LinkedList else: head = previous # connect with the last part last_node_of_sub_list.next = current return headdef print_list(head): temp = head while temp is not None: print(temp.val, end=&quot; &quot;) temp = temp.next print()def main(): sol = Solution() head = Node(1) head.next = Node(2) head.next.next = Node(3) head.next.next.next = Node(4) head.next.next.next.next = Node(5) print(&quot;Nodes of original LinkedList are: &quot;, end=&#x27;&#x27;) print_list(head) result = sol.reverse(head, 2, 4) print(&quot;Nodes of reversed LinkedList are: &quot;, end=&#x27;&#x27;) print_list(result)if __name__ == &quot;__main__&quot;: main() Time complexityThe time complexity of our algorithm will be O(N) where ‘N’ is the total number of nodes in the LinkedList. Space complexityWe only used constant space, therefore, the space complexity of our algorithm is O(1). Similar QuestionsProblem 1: Reverse the first ‘k’ elements of a given LinkedList. Solution: This problem can be easily converted to our parent problem; to reverse the first ‘k’ nodes of the list, we need to pass p=1 and q=k. Problem 2: Given a LinkedList with ‘n’ nodes, reverse it based on its size in the following way: If ‘n’ is even, reverse the list in a group of n/2 nodes. If n is odd, keep the middle node as it is, reverse the first ‘n/2’ nodes and reverse the last ‘n/2’ nodes. Solution: When ‘n’ is even we can perform the following steps: Reverse first ‘n/2’ nodes: head = reverse(head, 1, n/2) Reverse last ‘n/2’ nodes: head = reverse(head, n/2 + 1, n) When ‘n’ is odd, our algorithm will look like: head = reverse(head, 1, n/2) head = reverse(head, n/2 + 2, n) Please note the function call in the second step. We’re skipping two elements as we will be skipping the middle element. *Reverse every K-element Sub-list (medium)Similar |Top Interview 150 | 25. Reverse Nodes in k-Group Design Gurus Educative.io Problem StatementGiven the head of a LinkedList and a number ‘k’, reverse every ‘k’ sized sub-list starting from the head. If, in the end, you are left with a sub-list with less than ‘k’ elements, reverse it too. Constraints: The number of nodes in the list is n. 1 &lt;= k &lt;= n &lt;= 5000 0 &lt;= Node.val &lt;= 1000 SolutionThe problem follows the In-place Reversal of a LinkedList pattern and is quite similar to Reverse a Sub-list. The only difference is that we have to reverse all the sub-lists. We can use the same approach, starting with the first sub-list (i.e. p=1, q=k) and keep reversing all the sublists of size ‘k’. CodeMost of the code is the same as Reverse a Sub-list; only the highlighted lines have a majority of the changes: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# class Node:# def __init__(self, val, next=None):# self.val = val# self.next = nextclass Solution: def reverse(self, head, k): if k &lt;= 1 or head is None: return head current, previous = head, None while current is not None: # break if we&#x27;ve reached the end of the list last_node_of_previous_part = previous # after reversing the LinkedList &#x27;current&#x27; will become the last node of the sub-list last_node_of_sub_list = current next = None # will be used to temporarily store the next node i = 0 while current is not None and i &lt; k: # reverse &#x27;k&#x27; nodes next = current.next current.next = previous previous = current current = next i += 1 # connect with the previous part if last_node_of_previous_part is not None: last_node_of_previous_part.next = previous else: head = previous # connect with the next part last_node_of_sub_list.next = current previous = last_node_of_sub_list return headdef print_list(head): temp = head while temp is not None: print(temp.val, end=&quot; &quot;) temp = temp.next print()def main(): sol = Solution() head = Node(1) head.next = Node(2) head.next.next = Node(3) head.next.next.next = Node(4) head.next.next.next.next = Node(5) head.next.next.next.next.next = Node(6) head.next.next.next.next.next.next = Node(7) head.next.next.next.next.next.next.next = Node(8) print(&quot;Nodes of original LinkedList are: &quot;, end=&#x27;&#x27;) print_list(head) result = sol.reverse(head, 3) print(&quot;Nodes of reversed LinkedList are: &quot;, end=&#x27;&#x27;) print_list(result)main() Time complexityThe time complexity of our algorithm will be O(N) where ‘N’ is the total number of nodes in the LinkedList. Space complexityWe only used constant space, therefore, the space complexity of our algorithm is O(1). *Problem Challenge 1Design Gurus Educative.io Reverse alternating K-element Sub-list (medium)Given the head of a LinkedList and a number ‘k’, reverse every alternating ‘k’ sized sub-list starting from the head. If, in the end, you are left with a sub-list with less than ‘k’ elements, reverse it too. Constraints: The number of nodes in the list is n. 1 &lt;= k &lt;= n &lt;= 5000 0 &lt;= Node.val &lt;= 1000 SolutionThe problem follows the In-place Reversal of a LinkedList pattern and is quite similar to Reverse every K-element Sub-list. The only difference is that we have to skip ‘k’ alternating elements. We can follow a similar approach, and in each iteration after reversing ‘k’ elements, we will skip the next ‘k’ elements. CodeMost of the code is the same as Reverse every K-element Sub-list; only the highlighted lines have a majority of the changes: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# class Node:# def __init__(self, val, next=None):# self.val = val# self.next = nextclass Solution: def reverse(self, head, k): if k &lt;= 1 or head is None: return head current, previous = head, None while current is not None: # break if we&#x27;ve reached the end of the list last_node_of_previous_part = previous # after reversing the LinkedList &#x27;current&#x27; will become the last node of the sub-list last_node_of_sub_list = current next = None # will be used to temporarily store the next node # reverse &#x27;k&#x27; nodes i = 0 while current is not None and i &lt; k: next = current.next current.next = previous previous = current current = next i += 1 # connect with the previous part if last_node_of_previous_part is not None: last_node_of_previous_part.next = previous else: head = previous # connect with the next part last_node_of_sub_list.next = current # skip &#x27;k&#x27; nodes i = 0 while current is not None and i &lt; k: previous = current current = current.next i += 1 return headdef print_list(self): temp = self while temp is not None: print(temp.val, end=&quot; &quot;) temp = temp.next print()def main(): sol = Solution() head = Node(1) head.next = Node(2) head.next.next = Node(3) head.next.next.next = Node(4) head.next.next.next.next = Node(5) head.next.next.next.next.next = Node(6) head.next.next.next.next.next.next = Node(7) head.next.next.next.next.next.next.next = Node(8) print(&quot;Nodes of original LinkedList are: &quot;, end=&#x27;&#x27;) print_list(head) result = sol.reverse(head, 2) print(&quot;Nodes of reversed LinkedList are: &quot;, end=&#x27;&#x27;) print_list(result)main() Time complexityThe time complexity of our algorithm will be O(N) where ‘N’ is the total number of nodes in the LinkedList. Space complexityWe only used constant space, therefore, the space complexity of our algorithm is O(1). Problem Challenge 2Top Interview 150 | 61. Rotate List Design Gurus Educative.io Rotate a LinkedList (medium)Given the head of a Singly LinkedList and a number ‘k’, rotate the LinkedList to the right by ‘k’ nodes. SolutionAnother way of defining the rotation is to take the sub-list of ‘k’ ending nodes of the LinkedList and connect them to the beginning. Other than that we have to do three more things: Connect the last node of the LinkedList to the head, because the list will have a different tail after the rotation. The new head of the LinkedList will be the node at the beginning of the sublist. The node right before the start of sub-list will be the new tail of the rotated LinkedList. CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# class Node:# def __init__(self, Val, next=None):# self.val = Val# self.next = nextclass Solution: def rotate(self, head, rotations): if head is None or head.next is None or rotations &lt;= 0: return head # find the length and the last node of the list last_node = head list_length = 1 while last_node.next is not None: last_node = last_node.next list_length += 1 last_node.next = head # connect the last node with the head to make it a circular list rotations %= list_length # no need to do rotations more than the length of the list skip_length = list_length - rotations last_node_of_rotated_list = head # 找尾巴，这样下一个就是new_head for i in range(skip_length - 1): last_node_of_rotated_list = last_node_of_rotated_list.next # &#x27;last_node_of_rotated_list.next&#x27; is pointing to the sub-list of &#x27;k&#x27; ending nodes head = last_node_of_rotated_list.next last_node_of_rotated_list.next = None return headdef print_list(head): temp = head while temp is not None: print(temp.val, end=&quot; &quot;) temp = temp.next print()def main(): sol = Solution() head = Node(1) head.next = Node(2) head.next.next = Node(3) head.next.next.next = Node(4) head.next.next.next.next = Node(5) head.next.next.next.next.next = Node(6) print(&quot;Nodes of original LinkedList are: &quot;, end=&#x27;&#x27;) print_list(head) result = sol.rotate(head, 3) print(&quot;Nodes of rotated LinkedList are: &quot;, end=&#x27;&#x27;) print_list(result)main() Time complexityThe time complexity of our algorithm will be O(N) where ‘N’ is the total number of nodes in the LinkedList. Space complexityWe only used constant space, therefore, the space complexity of our algorithm is O(1).","categories":[{"name":"Grokking Interview Pattern","slug":"Grokking-Interview-Pattern","permalink":"https://hasuer.github.io/categories/Grokking-Interview-Pattern/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hasuer.github.io/tags/Interview/"}]},{"title":"5. Pattern Cyclic Sort","slug":"5. Pattern Cyclic Sort","date":"2024-05-05T06:41:54.000Z","updated":"2024-05-28T03:27:42.016Z","comments":true,"path":"5-pattern-cyclic-sort/index.html","link":"","permalink":"https://hasuer.github.io/5-pattern-cyclic-sort/index.html","excerpt":"","text":"IntroductionThis pattern describes an interesting approach to deal with problems involving arrays containing numbers in a given range. For example, take the following problem: You are given an unsorted array containing n numbers taken from the range 1 to n. The array can have duplicates, which means that some numbers will be missing. Find all the missing numbers. To efficiently solve this problem, we can use the fact that the input array contains numbers in the range of 1 to n. For example, to efficiently sort the array, we can try placing each number at its correct place, i.e., placing 1 at index &#39;0&#39;, placing 2 at index ‘1’, and so on. Once we are done with the sorting, we can iterate the array to find all indices missing the correct numbers. These will be our required numbers. Let’s jump on to our first problem to understand the Cyclic Sort pattern in action. *Cyclic Sort (easy)Design Gurus Educative.io Problem StatementWe are given an array containing ‘n’ objects. Each object, when created, was assigned a unique number from 1 to ‘n’ based on their creation sequence. This means that the object with sequence number ‘3’ was created just before the object with sequence number ‘4’. Write a function to sort the objects in-place on their creation sequence number in O(n) and without any extra space. For simplicity, let’s assume we are passed an integer array containing only the sequence numbers, though each number is actually an object. Example 1: 12Input: [3, 1, 5, 4, 2]Output: [1, 2, 3, 4, 5] Example 2: 12Input: [2, 6, 4, 3, 1, 5]Output: [1, 2, 3, 4, 5, 6] Example 3: 12Input: [1, 5, 6, 4, 3, 2]Output: [1, 2, 3, 4, 5, 6] Constraints: n == nums.length 1 &lt;= n &lt;= 10^4 0 &lt;= nums[i] &lt;= n SolutionAs we know, the input array contains numbers from the range 1 to n. We can use this fact to devise an efficient way to sort the numbers. Since all numbers are unique, we can try placing each number at its correct place, i.e., placing 1 at index ‘0’, placing 2 at index ‘1’, and so on. To place a number (or an object in general) at its correct index, we first need to find that number. If we first find a number and then place it at its correct place, it will take us O(N^2), which is not acceptable as mentioned in the problem statement. Instead, what if we iterate the array one number at a time, and if the current number we are iterating is not at the correct index, we swap it with the number at its correct index. This way, we will go through all numbers and place them at their correct indices, hence, sorting the whole array. Let’s see this visually with the above-mentioned Example-2: CodeHere is what our algorithm will look like: 这道题使用的算法有几个约束条件，一定要是连续的自然数，而且没有重复，虽然这里是从1开始的自然数，但是不从一开始也可以，只要加上一个偏置就好了 。 123456789101112131415161718192021222324class Solution: def sort(self, nums): i = 0 while i &lt; len(nums): # 数字从[1,n],所以数字1应该在index=0上 j = nums[i] - 1 # Calculate the index where the current element should be placed. # 这里需要注意的是需要把j = nums[i] - 1单独写出来 # 不然要是nums[i], nums[nums[i] - 1] = nums[nums[i] - 1], nums[i]会有问题 if nums[i] != nums[j]: # Check if the current element is not in its correct position. nums[i], nums[j] = nums[j], nums[i] # Swap the current element with the one at its correct position. else: i += 1 # If the current element is already in its correct position, move to the next element. return numsdef main(): sol = Solution() print(sol.sort([3, 1, 5, 4, 2])) print(sol.sort([2, 6, 4, 3, 1, 5])) print(sol.sort([1, 5, 6, 4, 3, 2]))main() Time complexityThe time complexity of the above algorithm is O(n). Although we are not incrementing the index i when swapping the numbers, this will result in more than ‘n’ iterations of the loop, but in the worst-case scenario, the while loop will swap a total of ‘n-1’ numbers and once a number is at its correct index, we will move on to the next number by incrementing i. So overall, our algorithm will take O(n) + O(n-1) which is asymptotically equivalent to O(n)。 Space complexityThe algorithm runs in constant space O(1). *Find the Missing Number (easy)268. Missing Number Design Gurus Educative.io Problem StatementWe are given an array containing ‘n’ distinct numbers taken from the range 0 to ‘n’. Since the array has only ‘n’ numbers out of the total ‘n+1’ numbers, find the missing number. Example 1: 12Input: [4, 0, 3, 1]Output: 2 Example 2: 12Input: [8, 3, 5, 2, 4, 6, 0, 1]Output: 7 Constraints: n == nums.length 1 &lt;= n &lt;= 10^4 0 &lt;= nums[i] &lt;= n All the numbers of nums are unique. SolutionThis problem follows the Cyclic Sort pattern. Since the input array contains unique numbers from the range 0 to ‘n’, we can use a similar strategy as discussed in Cyclic Sort to place the numbers on their correct index. Once we have every number in its correct place, we can iterate the array to find the index which does not have the correct number, and that index will be our missing number. However, there are two differences with Cyclic Sort: In this problem, the numbers are ranged from ‘0’ to ‘n’, compared to ‘1’ to ‘n’ in the Cyclic Sort. This will make two changes in our algorithm: In this problem, each number should be equal to its index, compared to index + 1 in the Cyclic Sort. Therefore =&gt; nums[i] == nums[nums[i]] Since the array will have ‘n’ numbers, which means array indices will range from 0 to ‘n-1’. Therefore, we will ignore the number ‘n’ as we can’t place it in the array, so =&gt; nums[i] &lt; nums.length Say we are at index i. If we swap the number at index i to place it at the correct index, we can still have the wrong number at index i. This was true in Cyclic Sort too. It didn’t cause any problems in Cyclic Sort as over there, we made sure to place one number at its correct place in each step, but that wouldn’t be enough in this problem as we have one extra number due to the larger range. Therefore, we will not move to the next number after the swap until we have a correct number at the index i. CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324252627class Solution: def findMissingNumber(self, nums): i, n = 0, len(nums) while i &lt; n: j = nums[i] # 范围是 [0,n), 所以数字1应该在index=1上 # 所以当nums[i]在[0,n)时，并且不在自己的位置上（nums[i] != nums[j]），那就要换位置 if nums[i] &lt; n and nums[i] != nums[j]: nums[i], nums[j] = nums[j], nums[i] # swap else: i += 1 # find the first number missing from its index, that will be our required number for i in range(n): if nums[i] != i: return i # 这个忘记了，需要加上 return n # 比如这个例子[0,1]def main(): sol = Solution() print(sol.findMissingNumber([4, 0, 3, 1])) print(sol.findMissingNumber([8, 3, 5, 2, 4, 6, 0, 1]))main() Time complexityThe time complexity of the above algorithm is O(n). In the while loop, although we are not incrementing the index i when swapping the numbers, this will result in more than ‘n’ iterations of the loop, but in the worst-case scenario, the while loop will swap a total of ‘n-1’ numbers and once a number is at its correct index, we will move on to the next number by incrementing i. In the end, we iterate the input array again to find the first number missing from its index, so overall, our algorithm will take O(n) + O(n-1) + O(n) which is asymptotically equivalent to O(n). Space complexityThe algorithm runs in constant space O(1). Find all Missing Numbers (easy)448. Find All Numbers Disappeared in an Array Design Gurus Educative.io Problem StatementWe are given an unsorted array containing numbers taken from the range 1 to ‘n’. The array can have duplicates, which means some numbers will be missing. Find all those missing numbers. Example 1: 123Input: [2, 3, 1, 8, 2, 3, 5, 1]Output: 4, 6, 7Explanation: The array should have all numbers from 1 to 8, due to duplicates 4, 6, and 7 are missing. Example 2: 12Input: [2, 4, 1, 2]Output: 3 Example 3: 12Input: [2, 3, 2, 1]Output: 4 Constraints: n == nums.length 1 &lt;= n &lt;= 10^5 1 &lt;= nums[i] &lt;= n SolutionThis problem follows the Cyclic Sort pattern and shares similarities with Find the Missing Number with one difference. In this problem, there can be many duplicates whereas in ‘Find the Missing Number’ there were no duplicates and the range was greater than the length of the array. However, we will follow a similar approach though as discussed in Find the Missing Number to place the numbers on their correct indices. Once we are done with the cyclic sort we will iterate the array to find all indices that are missing the correct numbers. CodeHere is what our algorithm will look like: 1234567891011121314151617181920212223242526272829class Solution: def findNumbers(self, nums): i = 0 # Initialize a pointer for iterating through the list. while i &lt; len(nums): # 范围是 [1,n], 所以数字1应该在index=0上 j = nums[i] - 1 # Calculate the target index for the current element. if nums[i] != nums[j]: # Check if the current element is not in its correct position. nums[i], nums[j] = nums[j], nums[i] # Swap the elements to their correct positions. else: i += 1 # If the current element is in the correct position, move to the next element. missingNumbers = [] for i in range(len(nums)): if nums[i] != i + 1: # Check if the element at index &#x27;i&#x27; is not in the correct position. missingNumbers.append(i + 1) # Add the missing number to the list. return missingNumbersdef main(): sol = Solution() print(sol.findNumbers([2, 3, 1, 8, 2, 3, 5, 1])) print(sol.findNumbers([2, 4, 1, 2])) print(sol.findNumbers([2, 3, 2, 1]))main() Time complexityThe time complexity of the above algorithm is O(n) Space complexityIgnoring the space required for the output array, the algorithm runs in constant space O(1). *Find the Duplicate Number (easy)287. Find the Duplicate Number Design Gurus Educative.io Problem StatementWe are given an unsorted array containing ‘n+1’ numbers taken from the range 1 to ‘n’. The array has only one duplicate but it can be repeated multiple times. Find that duplicate number without using any extra space. You are, however, allowed to modify the input array. Example 1: 12Input: [1, 4, 4, 3, 2]Output: 4 Example 2: 12Input: [2, 1, 3, 3, 5, 4]Output: 3 Example 3: 12Input: [2, 4, 1, 4, 4]Output: 4 Constraints: nums.length == n + 1 1 &lt;= n &lt;= 10^5 1 &lt;= nums[i] &lt;= n All the integers in nums appear only once except for precisely one integer which appears two or more times. SolutionThis problem follows the Cyclic Sort pattern and shares similarities with Find the Missing Number. Following a similar approach, we will try to place each number on its correct index. Since there is only one duplicate, if while swapping the number with its index both the numbers being swapped are same, we have found our duplicate! CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233343536373839404142# 按照之前几道题的思路写的如下：def find_number(nums): i = 0 while i &lt; len(nums): j = nums[i] - 1 if nums[i] != nums[j]: nums[i], nums[j] = nums[j], nums[i] else: i += 1 for i in range(len(nums)): if nums[i] != i + 1: return nums[i]# 以下是官方的，更加简洁一些class Solution: def find_duplicate(self, nums): i = 0 while i &lt; len(nums): if nums[i] != i + 1: # Check if the current element is in its correct position # 范围是 [1,n], 所以数字1应该在index=0上 # 当不在自己的位置上（nums[i] != nums[j]），那就要换位置 j = nums[i] - 1 # Calculate the correct index for the current element if nums[i] != nums[j]: # Check if the current element is not equal to the element at its correct index nums[i], nums[j] = nums[j], nums[i] # Swap the elements to their correct positions else: # We have found the duplicate return nums[i] else: i += 1 # Move to the next element return -1 # No duplicate founddef main(): sol = Solution() print(sol.find_duplicate([1, 4, 4, 3, 2])) print(sol.find_duplicate([2, 1, 3, 3, 5, 4])) print(sol.find_duplicate([2, 4, 1, 4, 4]))main() Time complexityThe time complexity of the above algorithm is O(n). Space complexityThe algorithm runs in constant space O(1) but modifies the input array. Similar ProblemsProblem 1: Can we solve the above problem in O(1) space and without modifying the input array? Solution: While doing the cyclic sort, we realized that the array will have a cycle due to the duplicate number and that the start of the cycle will always point to the duplicate number. This means that we can use the fast &amp; the slow pointer method to find the duplicate number or the start of the cycle similar to Start of LinkedList Cycle(Pattern 4 problem 3) 12345678910111213141516171819202122232425262728293031323334353637383940class Solution: def findDuplicate(self, arr): slow, fast = arr[0], arr[arr[0]] while slow != fast: slow = arr[slow] fast = arr[arr[fast]] # find cycle length current = arr[arr[slow]] cycleLength = 1 while current != arr[slow]: current = arr[current] cycleLength += 1 return self.find_start(arr, cycleLength) def find_start(self, arr, cycleLength): pointer1, pointer2 = arr[0], arr[0] # move pointer2 ahead &#x27;cycleLength&#x27; steps while cycleLength &gt; 0: pointer2 = arr[pointer2] cycleLength -= 1 # increment both pointers until they meet at the start of the cycle while pointer1 != pointer2: pointer1 = arr[pointer1] pointer2 = arr[pointer2] return pointer1def main(): sol = Solution() print(sol.findDuplicate([1, 4, 4, 3, 2])) print(sol.findDuplicate([2, 1, 3, 3, 5, 4])) print(sol.findDuplicate([2, 4, 1, 4, 4]))main() The time complexity of the above algorithm is O(n) and the space complexity is O(1). Find all Duplicate Numbers (easy)442. Find All Duplicates in an Array Design Gurus Educative.io Problem StatementWe are given an unsorted array containing ‘n’ numbers taken from the range 1 to ‘n’. The array has some duplicates, find all the duplicate numbers without using any extra space. Example 1: 12Input: [3, 4, 4, 5, 5]Output: [4, 5] Example 2: 12Input: [5, 4, 7, 2, 3, 5, 3]Output: [3, 5] Constraints: nums.length == n 1 &lt;= n &lt;= 10^5 1 &lt;= nums[i] &lt;= n Each element in nums appears once or twice. SolutionThis problem follows the Cyclic Sort pattern and shares similarities with Find the Duplicate Number. Following a similar approach, we will place each number at its correct index. After that, we will iterate through the array to find all numbers that are not at the correct indices. All these numbers are duplicates. CodeHere is what our algorithm will look like: 12345678910111213141516171819202122232425262728293031class Solution: def findNumbers(self, nums): i = 0 while i &lt; len(nums): # 范围是 [1,n], 所以数字1应该在index=0上 j = nums[i] - 1 # Calculate the index where the current element should be if it&#x27;s not a duplicate. # 当不在自己的位置上（nums[i] != nums[j]），那就要换位置 if nums[i] != nums[j]: # Check if the current element is not in its correct position. nums[i], nums[j] = nums[j], nums[ i] # Swap the current element with the element at its correct position. else: i += 1 # Move to the next element if the current element is already in its correct position. # 个人认为这里有问题，比如[3, 4, 4, 5, 5, 5, 5]就会返回[4,5,5,5]而不是[4,5] # 但是leetcode 442中说明了“each integer appears once or twice”那就不用考虑这个情况 # solution的解答也是对的 duplicateNumbers = [] for i in range(len(nums)): if nums[i] != i + 1: # Identify elements that are not in their correct positions, which are duplicates. duplicateNumbers.append(nums[i]) # Add the duplicates to the list. return duplicateNumbersdef main(): sol = Solution() print(sol.findNumbers([3, 4, 4, 5, 5])) print(sol.findNumbers([5, 4, 7, 2, 3, 5, 3]))main() Time complexityThe time complexity of the above algorithm is O(n). Space complexityIgnoring the space required for storing the duplicates, the algorithm runs in constant space O(1). Problem Challenge 1Design Gurus Educative.io Find the Corrupt Pair (easy)We are given an unsorted array containing ‘n’ numbers taken from the range 1 to ‘n’. The array originally contained all the numbers from 1 to ‘n’, but due to a data error, one of the numbers got duplicated which also resulted in one number going missing. Find both these numbers. Example 1: 123Input: [3, 1, 2, 5, 2]Output: [2, 4]Explanation: &#x27;2&#x27; is duplicated and &#x27;4&#x27; is missing. Example 2: 123Input: [3, 1, 2, 3, 6, 4]Output: [3, 5]Explanation: &#x27;3&#x27; is duplicated and &#x27;5&#x27; is missing. Constraints: 2 &lt;= nums.length &lt;= 10^4 1 &lt;= nums[i] &lt;= 10^4 SolutionThis problem follows the Cyclic Sort pattern and shares similarities with Find all Duplicate Numbers. Following a similar approach, we will place each number at its correct index. Once we are done with the cyclic sort, we will iterate through the array to find the number that is not at the correct index. Since only one number got corrupted, the number at the wrong index is the duplicated number and the index itself represents the missing number. CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324252627class Solution: def findNumbers(self, nums): i = 0 # Initialize a pointer for iteration through the array. while i &lt; len(nums): # 范围是 [1,n], 所以数字1应该在index=0上 j = nums[i] - 1 # Calculate the expected index for the current number. # 当不在自己的位置上（nums[i] != nums[j]），那就要换位置 if nums[i] != nums[j]: # Check if the current number is not at its expected index. nums[i], nums[j] = nums[j], nums[i] # Swap the current number with the one at its expected index. else: i += 1 # Move to the next element when no swap is needed. for i in range(len(nums)): if nums[i] != i + 1: # Find the first number that is not in its correct position. return [nums[i], i + 1] # Return the corrupted number and the number it should be. return [-1, -1] # Return [-1, -1] if no corruption is found.def main(): sol = Solution() print(sol.findNumbers([3, 1, 2, 5, 2])) print(sol.findNumbers([3, 1, 2, 3, 6, 4]))main() Time complexityThe time complexity of the above algorithm is O(n). Space complexityThe algorithm runs in constant space O(1). # Problem Challenge 241. First Missing Positive Design Gurus Educative.io Find the Smallest Missing Positive Number (medium)Given an unsorted array containing numbers, find the smallest missing positive number in it. Note: Positive numbers start from ‘1’. Example 1: 123Input: [-3, 1, 5, 4, 2]Output: 3Explanation: The smallest missing positive number is &#x27;3&#x27; Example 2: 12Input: [3, -2, 0, 1, 2]Output: 4 Example 3: 12Input: [3, 2, 5, 1]Output: 4 Example 4: 12Input: [33, 37, 5]Output: 1 Constraints: 1 &lt;= nums.length &lt;= 10^5 -231 &lt;= nums[i] &lt;= 2^31 - 1 SolutionThis problem follows the Cyclic Sort pattern and shares similarities with Find the Missing Number with one big difference. In this problem, the numbers are not bound by any range so we can have any number in the input array. However, we will follow a similar approach though as discussed in Find the Missing Number to place the numbers on their correct indices and ignore all numbers that are out of the range of the array (i.e., all negative numbers and all numbers greater than or equal to the length of the array). Once we are done with the cyclic sort we will iterate the array and the first index that does not have the correct number will be the smallest missing positive number! CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233class Solution: def findNumber(self, nums): i, n = 0, len(nums) # Rearrange the elements to place each positive integer at its correct index. # Negative numbers and numbers greater than the array size are ignored. while i &lt; n: j = nums[i] - 1 # j表示nums[i]应该在的index， 所以数字1应该在index=0上 # len(nums) &gt;= nums[i] &gt; 0的话，nums[i]就应该在nums中有一个正确的位置 # 所以如果不在（nums[i] != nums[j]），就要调换 if nums[i] &gt; 0 and nums[i] &lt;= n and nums[i] != nums[j]: nums[i], nums[j] = nums[j], nums[i] # Swap else: i += 1 # Find the first index where the element does not match its expected positive value. for i in range(n): if nums[i] != i + 1: return i + 1 # If all elements from 1 to n are present, return n + 1. # 这个忘记了，比如示例[0]就应该返回1 return len(nums) + 1def main(): sol = Solution() print(sol.findNumber([-3, 1, 5, 4, 2])) print(sol.findNumber([3, -2, 0, 1, 2])) print(sol.findNumber([3, 2, 5, 1]))main() Time complexityThe time complexity of the above algorithm is O(n). Space complexityThe algorithm runs in constant space O(1). *Problem Challenge 3Similar | 1539. Kth Missing Positive Number Design Gurus Educative.io Find the First K Missing Positive Numbers (hard)Given an unsorted array containing numbers and a number ‘k’, find the first ‘k’ missing positive numbers in the array. Example 1: 123Input: [3, -1, 4, 5, 5], k=3Output: [1, 2, 6]Explanation: The smallest missing positive numbers are 1, 2 and 6. Example 2: 123Input: [2, 3, 4], k=3Output: [1, 5, 6]Explanation: The smallest missing positive numbers are 1, 5 and 6. Example 3: 123Input: [-2, -3, 4], k=2Output: [1, 2]Explanation: The smallest missing positive numbers are 1 and 2. Constraints: 1 &lt;= nums.length &lt;= 1000 1 &lt;= nums[i] &lt;= 1000 1 &lt;= k &lt;= 1000 nums[i] &lt; nums[j] for 1 &lt;= i &lt; j &lt;= nums.length SolutionThis problem follows the Cyclic Sort pattern and shares similarities with Find the Smallest Missing Positive Number. The only difference is that, in this problem, we need to find the first ‘k’ missing numbers compared to only the first missing number. We will follow a similar approach as discussed in Find the Smallest Missing Positive Number to place the numbers on their correct indices and ignore all numbers that are out of the range of the array. Once we are done with the cyclic sort we will iterate through the array to find indices that do not have the correct numbers. If we are not able to find ‘k’ missing numbers from the array, we need to add additional numbers to the output array. To find these additional numbers we will use the length of the array. For example, if the length of the array is 4, the next missing numbers will be 4, 5, 6 and so on. One tricky aspect is that any of these additional numbers could be part of the array. Remember, while sorting, we ignored all numbers that are greater than or equal to the length of the array. So all indices that have the missing numbers could possibly have these additional numbers. To handle this, we must keep track of all numbers from those indices that have missing numbers. Let’s understand this with an example: 1nums: [2, 1, 3, 6, 5], k =2 After the cyclic sort our array will look like: 1nums: [1, 2, 3, 6, 5] From the sorted array we can see that the first missing number is ‘4’ (as we have ‘6’ on the fourth index) but to find the second missing number we need to remember that the array does contain ‘6’. Hence, the next missing number is ‘7’. CodeHere is what our algorithm will look like: 12345678910111213141516171819202122232425262728293031323334353637383940class Solution: def findNumbers(self, nums, k): n = len(nums) i = 0 while i &lt; len(nums): j = nums[i] - 1 # j表示nums[i]应该在的index， 所以数字1应该在index=0上 # 当不在自己的位置上（nums[i] != nums[j]），那就要换位置 if nums[i] &gt; 0 and nums[i] &lt;= n and nums[i] != nums[j]: nums[i], nums[j] = nums[j], nums[i] # Swap the current element with its correct position. else: i += 1 missingNumbers = [] extraNumbers = set() for i in range(n): if len(missingNumbers) &lt; k: if nums[i] != i + 1: missingNumbers.append(i + 1) # Add the missing number to the result list. extraNumbers.add(nums[i]) # Keep track of extra numbers encountered. # Add the remaining missing numbers candidateNumber = n + 1 while len(missingNumbers) &lt; k: # Ignore if the array contains the candidate number if candidateNumber not in extraNumbers: missingNumbers.append(candidateNumber) # Add remaining missing numbers to the result list. candidateNumber += 1 return missingNumbersdef main(): sol = Solution() print(sol.findNumbers([3, -1, 4, 5, 5], 3)) print(sol.findNumbers([2, 3, 4], 3)) print(sol.findNumbers([-2, -3, 4], 2))main() Time complexityThe time complexity of the above algorithm is O(n + k), as the last two for loops will run for O(n) and O(k) times respectively. Space complexityThe algorithm needs O(k) space to store the extraNumbers(the set).","categories":[{"name":"Grokking Interview Pattern","slug":"Grokking-Interview-Pattern","permalink":"https://hasuer.github.io/categories/Grokking-Interview-Pattern/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hasuer.github.io/tags/Interview/"}]},{"title":"4. Pattern Merge Intervals","slug":"4. Pattern Merge Intervals","date":"2024-05-04T05:23:13.000Z","updated":"2024-05-28T03:27:35.516Z","comments":true,"path":"4-pattern-merge-intervals/index.html","link":"","permalink":"https://hasuer.github.io/4-pattern-merge-intervals/index.html","excerpt":"","text":"IntroductionThis pattern describes an efficient technique to deal with overlapping intervals. In a lot of problems involving intervals, we either need to find overlapping intervals or merge intervals if they overlap. Given two intervals (‘a’ and ‘b’), there will be six different ways the two intervals can relate to each other: Understanding the above six cases will help us in solving all intervals related problems. Let’s jump onto our first problem to understand the Merge Interval pattern. *Merge Intervals (medium) Top Interview 150 | 56. Merge Intervals Similar | Top Interview 150 | 452. Minimum Number of Arrows to Burst Balloons Design Gurus Educative.io Problem StatementGiven a list of intervals, merge all the overlapping intervals to produce a list that has only mutually exclusive intervals. Example 1: 1234Intervals: [[1,4], [2,5], [7,9]]Output: [[1,5], [7,9]]Explanation: Since the first two intervals [1,4] and [2,5] overlap, we merged them into one [1,5]. Example 2: 123Intervals: [[6,7], [2,4], [5,9]]Output: [[2,4], [5,9]]Explanation: Since the intervals [6,7] and [5,9] overlap, we merged them into one [5,9]. Example 3: 1234Intervals: [[1,4], [2,6], [3,5]]Output: [[1,6]]Explanation: Since all the given intervals overlap, we merged them into one. onstraints: 1 &lt;= intervals.length &lt;= 10^4 intervals[i].length == 2 0 &lt;= start_i &lt;= end_i &lt;= 10^4 SolutionLet’s take the example of two intervals (‘a’ and ‘b’) such that a.start &lt;= b.start. There are four possible scenarios: Our goal is to merge the intervals whenever they overlap. For the above-mentioned three overlapping scenarios (2, 3, and 4), this is how we will merge them: The diagram above clearly shows a merging approach. Our algorithm will look like this: Sort the intervals on the start time to ensure a.start &lt;= b.start If ‘a’ overlaps ‘b’ (i.e. b.start &lt;= a.end), we need to merge them into a new interval ‘c’ such that: 12c.start = a.startc.end = max(a.end, b.end) We will keep repeating the above two steps to merge ‘c’ with the next interval if it overlaps with ‘c’. CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#class Interval:# def __init__(self, start, end):# self.start = start# self.end = enddef print_interval(i): print(&quot;[&quot; + str(i.start) + &quot;, &quot; + str(i.end) + &quot;]&quot;, end=&#x27;&#x27;)class Solution: def merge(self, intervals): if len(intervals) &lt; 2: return intervals # sort the intervals on the start time intervals.sort(key=lambda x: x.start) mergedIntervals = [] start = intervals[0].start end = intervals[0].end for i in range(1, len(intervals)): interval = intervals[i] if interval.start &lt;= end: # overlapping intervals, adjust the &#x27;end&#x27; end = max(interval.end, end) else: # non-overlapping interval, add the previous interval and reset mergedIntervals.append(Interval(start, end)) start = interval.start end = interval.end # add the last interval mergedIntervals.append(Interval(start, end)) return mergedIntervalsdef main(): sol = Solution() print(&quot;Merged intervals: &quot;, end=&#x27;&#x27;) for i in sol.merge([Interval(1, 4), Interval(2, 5), Interval(7, 9)]): print_interval(i) print() print(&quot;Merged intervals: &quot;, end=&#x27;&#x27;) for i in sol.merge([Interval(6, 7), Interval(2, 4), Interval(5, 9)]): print_interval(i) print() print(&quot;Merged intervals: &quot;, end=&#x27;&#x27;) for i in sol.merge([Interval(1, 4), Interval(2, 6), Interval(3, 5)]): print_interval(i) print()main() Time complexityThe time complexity of the above algorithm is O(N \\ logN)*, where ‘N’ is the total number of intervals. We are iterating the intervals only once which will take O(N), in the beginning though, since we need to sort the intervals, our algorithm will take O(N \\ logN)*. Space complexityThe space complexity of the above algorithm will be O(N) as we need to return a list containing all the merged intervals. We will also need O(N) space for sorting. For Java, depending on its version, Collection.sort() either uses Merge sort or Timsort, and both these algorithms need O(N) space. Overall, our algorithm has a space complexity of O(N). Similar ProblemsProblem 1: Given a set of intervals, find out if any two intervals overlap. Example: 123Intervals: [[1,4], [2,5], [7,9]]Output: trueExplanation: Intervals [1,4] and [2,5] overlap Solution: We can follow the same approach as discussed above to find if any two intervals overlap. *Insert Interval (medium)Top Interview 150 |57. Insert Interval Design Gurus Educative.io Problem StatementGiven a list of non-overlapping intervals sorted by their start time, insert a given interval at the correct position and merge all necessary intervals to produce a list that has only mutually exclusive intervals. Example 1: 123Input: Intervals=[[1,3], [5,7], [8,12]], New Interval=[4,6]Output: [[1,3], [4,7], [8,12]]Explanation: After insertion, since [4,6] overlaps with [5,7], we merged them into one [4,7]. Example 2: 123Input: Intervals=[[1,3], [5,7], [8,12]], New Interval=[4,10]Output: [[1,3], [4,12]]Explanation: After insertion, since [4,10] overlaps with [5,7] &amp; [8,12], we merged them into [4,12]. Example 3: 123Input: Intervals=[[2,3],[5,7]], New Interval=[1,4]Output: [[1,4], [5,7]]Explanation: After insertion, since [1,4] overlaps with [2,3], we merged them into one [1,4]. Constraints: 1 &lt;= intervals.length &lt;= 10^4 intervals[i].length == 2 0 &lt;= start_i &lt;= end_i &lt;= 10^5 intervals is sorted by start_i in ascending order. newInterval.length == 2 0 &lt;= start &lt;= end &lt;= 105 SolutionIf the given list was not sorted, we could have simply appended the new interval to it and used the merge() function from Merge Intervals. But since the given list is sorted, we should try to come up with a solution better than O(N \\ logN)* When inserting a new interval in a sorted list, we need to first find the correct index where the new interval can be placed. In other words, we need to skip all the intervals which end before the start of the new interval. So we can iterate through the given sorted listed of intervals and skip all the intervals with the following condition: 1intervals[i].end &lt; newInterval.start Once we have found the correct place, we can follow an approach similar to Merge Intervals to insert and/or merge the new interval. Let’s call the new interval ‘a’ and the first interval with the above condition ‘b’. There are five possibilities: The diagram above clearly shows the merging approach. To handle all four merging scenarios, we need to do something like this: 12c.start = min(a.start, b.start)c.end = max(a.end, b.end) Our overall algorithm will look like this: Skip all intervals which end before the start of the new interval, i.e., skip all intervals with the following condition: 1intervals[i].end &lt; newInterval.start Let’s call the last interval ‘b’ that does not satisfy the above condition. If ‘b’ overlaps with the new interval (a) (i.e. b.start &lt;= a.end), we need to merge them into a new interval ‘c’: 12c.start = min(a.start, b.start)c.end = max(a.end, b.end) We will repeat the above two steps to merge ‘c’ with the next overlapping interval. CodeHere is what our algorithm will look like: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#class Interval:# def __init__(self, start, end):# self.start = start# self.end = endclass Solution: def insert(self, intervals, new_interval): merged = [] i = 0 # skip (and add to output) all intervals that come before the &#x27;new_interval&#x27; while i &lt; len(intervals) and intervals[i].end &lt; new_interval.start: merged.append(intervals[i]) i += 1 # merge all intervals that overlap with &#x27;new_interval&#x27; while i &lt; len(intervals) and intervals[i].start &lt;= new_interval.end: new_interval.start = min(intervals[i].start, new_interval.start) new_interval.end = max(intervals[i].end, new_interval.end) i += 1 # insert the new_interval merged.append(new_interval) # add all the remaining intervals to the output while i &lt; len(intervals): merged.append(intervals[i]) i += 1 return mergeddef print_interval(i): print(&quot;[&quot; + str(i.start) + &quot;, &quot; + str(i.end) + &quot;]&quot;, end=&#x27;&#x27;)def main(): sol = Solution() intervals = [Interval(1, 3), Interval(5, 7), Interval(8, 12)] print(&quot;Intervals after inserting the new interval: &quot;,end=&quot;&quot;) for i in (sol.insert(intervals, Interval(4, 6))): print_interval(i) print() intervals = [Interval(1, 3), Interval(5, 7), Interval(8, 12)] print(&quot;Intervals after inserting the new interval: &quot;,end=&quot;&quot;) for i in (sol.insert(intervals, Interval(4, 10))): print_interval(i) print() intervals = [Interval(2, 3), Interval(5, 7)] print(&quot;Intervals after inserting the new interval: &quot;,end=&quot;&quot;) for i in (sol.insert(intervals, Interval(1, 4))): print_interval(i) print() main() Time complexityAs we are iterating through all the intervals only once, the time complexity of the above algorithm is O(N), where ‘N’ is the total number of intervals. Space complexityIgnoring the space needed for the result list, the algorithm runs in constant space O(1). If we include the result list, the space complexity will be O(N) as we need to return a list containing all the merged intervals. *Intervals Intersection (medium)Top Interview 150 |986. Interval List Intersections Design Gurus Educative.io Problem StatementGiven two lists of intervals, find the intersection of these two lists. Each list consists of disjoint intervals sorted on their start time. Example 1: 123Input: arr1=[[1, 3], [5, 6], [7, 9]], arr2=[[2, 3], [5, 7]]Output: [2, 3], [5, 6], [7, 7]Explanation: The output list contains the common intervals between the two lists. Example 2: 123Input: arr1=[[1, 3], [5, 7], [9, 12]], arr2=[[5, 10]]Output: [5, 7], [9, 10]Explanation: The output list contains the common intervals between the two lists. Constraints: 0 &lt;= arr1.length, arr2.length &lt;= 1000 arr1.length + arr2.length &gt;= 1 0 &lt;= start_i &lt; end_i &lt;= 10^9 end_i &lt; start_i+1 0 &lt;= start_j &lt; end_j &lt;= 10^9 end_j &lt; start_j+1 SolutionThis problem follows the Merge Intervals pattern. As we have discussed under Insert Intervals, there are five overlapping possibilities between two intervals ‘a’ and ‘b’. A close observation will tell us that whenever the two intervals overlap, one of the interval’s start time lies within the other interval. This rule can help us identify if any two intervals overlap or not. Now, if we have found that the two intervals overlap, how can we find the overlapped part? Again from the above diagram, the overlapping interval will be equal to: 12start = max(a.start, b.start)end = min(a.end, b.end) That is, the highest start time and the lowest end time will be the overlapping interval. So our algorithm will be to iterate through both the lists together to see if any two intervals overlap. If two intervals overlap, we will insert the overlapped part into a result list and move on to the next interval which is finishing early. CodeHere is what our algorithm will look like: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#class Interval:# def __init__(self, start, end):# self.start = start# self.end = endclass Solution: def merge(self, intervals_a, intervals_b): result = [] i, j, start, end = 0, 0, 0, 1 while i &lt; len(intervals_a) and j &lt; len(intervals_b): # check if intervals overlap and intervals_a[i]&#x27;s start time lies within the # other intervals_b[j] a_overlaps_b = intervals_a[i].start &gt;= intervals_b[j].start and intervals_a[i].start &lt;= intervals_b[j].end # check if intervals overlap and intervals_b[j]&#x27;s start time lies within the # other intervals_a[i] b_overlaps_a = intervals_b[j].start &gt;= intervals_a[i].start and intervals_b[j].start &lt;= intervals_a[i].end # store the the intersection part if (a_overlaps_b or b_overlaps_a): result.append([max(intervals_a[i].start, intervals_b[j].start), min( intervals_a[i].end, intervals_b[j].end)]) # move next from the interval which is finishing first if intervals_a[i].end &lt; intervals_b[j].end: i += 1 else: j += 1 return resultdef main(): sol = Solution() intervals_a = [Interval(1, 3), Interval(5, 6), Interval(7, 9)] intervals_b = [Interval(2, 3), Interval(5, 7)] print(&quot;Intervals Intersection: &quot;, end=&quot;&quot;) print(sol.merge(intervals_a,intervals_b)) intervals_a = [Interval(1, 3), Interval(5, 7), Interval(9, 12)] intervals_b = [Interval(5, 10)] print(&quot;Intervals Intersection: &quot;, end=&quot;&quot;) print(sol.merge(intervals_a,intervals_b))main() Time complexityAs we are iterating through both the lists once, the time complexity of the above algorithm is O(N+M), where ‘N’ and ‘M’ are the total number of intervals in the input arrays respectively. Space complexityIgnoring the space needed for the result list, the algorithm runs in constant space O(1). Conflicting Appointments (medium)Design Gurus Educative.io Problem StatementGiven an array of intervals representing ‘N’ appointments, find out if a person can attend all the appointments. Example 1: 123Appointments: [[1,4], [2,5], [7,9]]Output: falseExplanation: Since [1,4] and [2,5] overlap, a person cannot attend both of these appointments. Example 2: 123Appointments: [[6,7], [2,4], [8,12]]Output: trueExplanation: None of the appointments overlap, therefore a person can attend all of them. Example 3: 1234Appointments: [[4,5], [2,3], [3,6]]Output: falseExplanation: Since [4,5] and [3,6] overlap, a person cannot attend both of these appointments. Constraints: 1 &lt;= intervals.length &lt;= 10^4 intervals[i].length == 2 0 &lt;= starti &lt; endi &lt;= 10^6 SolutionThe problem follows the Merge Intervals pattern. We can sort all the intervals by start time and then check if any two intervals overlap. A person will not be able to attend all appointments if any two appointments overlap. CodeHere is what our algorithm will look like: 1234567891011121314151617181920212223242526272829303132#class Interval:# def __init__(self, start, end):# self.start = start# self.end = endclass Solution: def canAttendAllAppointments(self, intervals): intervals.sort(key=lambda x: x.start) for i in range(1, len(intervals)): # 注意这里是 &lt; 不是 &lt;=,因为&lt;=还是可以参加所有的预约的 if intervals[i].start &lt; intervals[i-1].end: # please note the comparison above, it is &quot;&lt;&quot; and not &quot;&lt;=&quot; # while merging we needed &quot;&lt;=&quot; comparison, as we will be merging the two # intervals having condition &quot;intervals[i][start] == intervals[i - 1][end]&quot; but # such intervals don&#x27;t represent conflicting appointments as one starts right # after the other return False return Truedef main(): sol = Solution() print(&quot;Can attend all appointments: &quot; + str(sol.canAttendAllAppointments([Interval(1, 4), Interval(2, 5), Interval(7, 9)]))) print(&quot;Can attend all appointments: &quot; + str(sol.canAttendAllAppointments([Interval(6, 7), Interval(2, 4),Interval(8, 12)]))) print(&quot;Can attend all appointments: &quot; + str(sol.canAttendAllAppointments([Interval(4, 5), Interval(2, 3), Interval(3, 6)])))main() Time complexityThe time complexity of the above algorithm is O(N\\logN)*, where ‘N’ is the total number of appointments. Though we are iterating the intervals only once, our algorithm will take O(N\\logN)* since we need to sort them in the beginning. Space complexityThe space complexity of the above algorithm will be O(N), which we need for sorting. For Java, Arrays.sort() uses Timsort, which needs O(N) space. Similar ProblemsProblem 1: Given a list of appointments, find all the conflicting appointments. Example: 1234Appointments: [[4,5], [2,3], [3,6], [5,7], [7,8]]Output: [4,5] and [3,6] conflict. [3,6] and [5,7] conflict. *Problem Challenge 1Design Gurus Educative.io Minimum Meeting Rooms (hard)Given a list of intervals representing the start and end time of ‘N’ meetings, find the minimum number of rooms required to hold all the meetings. Example 1: 1234Meetings: [[1,4], [2,5], [7,9]]Output: 2Explanation: Since [1,4] and [2,5] overlap, we need two rooms to hold these two meetings. [7,9] can occur in any of the two rooms later. Example 2: 123Meetings: [[6,7], [2,4], [8,12]]Output: 1Explanation: None of the meetings overlap, therefore we only need one room to hold all meetings. Example 3: 12345Meetings: [[1,4], [2,3], [3,6]]Output:2Explanation: Since [1,4] overlaps with the other two meetings [2,3] and [3,6], we need two rooms to hold all the meetings. Example 4: 12345Meetings: [[4,5], [2,3], [2,4], [3,5]]Output: 2Explanation: We will need one room for [2,3] and [3,5], and another room for [2,4] and [4,5]. Here is a visual representation of Example 4: SolutionLet’s take the above-mentioned example (4) and try to follow our Merge Intervals approach: Meetings: [[4,5], [2,3], [2,4], [3,5]] Step 1: Sorting these meetings on their start time will give us: [[2,3], [2,4], [3,5], [4,5]] Step 2: Merging overlapping meetings: [2,3] overlaps with [2,4], so after merging we’ll have =&gt; [[2,4], [3,5], [4,5]] [2,4] overlaps with [3,5], so after merging we’ll have =&gt; [[2,5], [4,5]] [2,5] overlaps [4,5], so after merging we’ll have =&gt; [2,5] Since all the given meetings have merged into one big meeting ([2,5]), does this mean that they all are overlapping and we need a minimum of four rooms to hold these meetings? You might have already guessed that the answer is NO! As we can clearly see, some meetings are mutually exclusive. For example, [2,3] and [3,5] do not overlap and can happen in one room. So, to correctly solve our problem, we need to keep track of the mutual exclusiveness of the overlapping meetings. Here is what our strategy will look like: We will sort the meetings based on start time. We will schedule the first meeting (let’s call it m1) in one room (let’s call it r1). If the next meeting m2 is not overlapping with m1, we can safely schedule it in the same room r1. If the next meeting m3 is overlapping with m2 we can’t use r1, so we will schedule it in another room (let’s call it r2). Now if the next meeting m4 is overlapping with m3, we need to see if the room r1 has become free. For this, we need to keep track of the end time of the meeting happening in it. If the end time of m2 is before the start time of m4, we can use that room r1, otherwise, we need to schedule m4 in another room r3. We can conclude that we need to keep track of the ending time of all the meetings currently happening so that when we try to schedule a new meeting, we can see what meetings have already ended. We need to put this information in a data structure that can easily give us the smallest ending time. A Min Heap would fit our requirements best. So our algorithm will look like this: Sort all the meetings on their start time. Create a min-heap to store all the active meetings. This min-heap will also be used to find the active meeting with the smallest end time. Iterate through all the meetings one by one to add them in the min-heap. Let’s say we are trying to schedule the meeting m1. Since the min-heap contains all the active meetings, so before scheduling m1 we can remove all meetings from the heap that have ended before m1, i.e., remove all meetings from the heap that have an end time smaller than or equal to the start time of m1. Now add m1 to the heap. The heap will always have all the overlapping meetings, so we will need rooms for all of them. Keep a counter to remember the maximum size of the heap at any time which will be the minimum number of rooms needed. CodeHere is what our algorithm will look like: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485# 没有class的版本，一样能过。没有定义class，所以在使用heap的时候吧list的两个元素反转了一下import heapqclass Solution: def findMinimumMeetingRooms(self, meetings): if not meetings: return 0 # sort the meetings by start time meetings.sort(key=lambda x: x[0]) minRooms = 0 minHeap = [] # 按照end由小到大排列 for meeting in meetings: # remove all meetings that have ended # 和最早的会议结束时间去比较，注意min_heap[0][0]是结束时间，因为在插入的时候 while minHeap and meeting[0] &gt;= minHeap[0][0]: heapq.heappop(minHeap) # add the current meeting into the minHeap heapq.heappush(minHeap, (meeting[1], meetings[0])) # all active meetings are in the minHeap, so we need rooms for all of them. minRooms = max(minRooms, len(minHeap)) return minRoomsif __name__ == &quot;__main__&quot;: sol = Solution() inputs = [ [(1, 4), (2, 5), (7, 9)], [(6, 7), (2, 4), (8, 12)], [(1, 4), (2, 3), (3, 6)], [(4, 5), (2, 3), (2, 4), (3, 5)] ] for input in inputs: result = sol.findMinimumMeetingRooms(input) print(&quot;Minimum meeting rooms required:&quot;, result) # 官方原版import heapq# class Meeting:# def __init__(self, start, end):# self.start = start# self.end = end # You can override/modify __lt__ as per your needsetattr(Meeting, &quot;__lt__&quot;, lambda self, other: self.end &lt; other.end)class Solution: def findMinimumMeetingRooms(self, meetings): if not meetings: return 0 # sort the meetings by start time meetings.sort(key=lambda x: x.start) minRooms = 0 minHeap = [] for meeting in meetings: # remove all meetings that have ended while minHeap and meeting.start &gt;= minHeap[0].end: heapq.heappop(minHeap) # add the current meeting into the minHeap heapq.heappush(minHeap, meeting) # all active meetings are in the minHeap, so we need rooms for all of them. minRooms = max(minRooms, len(minHeap)) return minRoomsif __name__ == &quot;__main__&quot;: sol = Solution() inputs = [ [Meeting(1, 4), Meeting(2, 5), Meeting(7, 9)], [Meeting(6, 7), Meeting(2, 4), Meeting(8, 12)], [Meeting(1, 4), Meeting(2, 3), Meeting(3, 6)], [Meeting(4, 5), Meeting(2, 3), Meeting(2, 4), Meeting(3, 5)] ] for input in inputs: result = sol.findMinimumMeetingRooms(input) print(&quot;Minimum meeting rooms required:&quot;, result) Time complexityThe time complexity of the above algorithm is O(N\\logN)*, where ‘N’ is the total number of meetings. This is due to the sorting that we did in the beginning. Also, while iterating the meetings we might need to poll/offer meeting to the priority queue. Each of these operations can take O(N\\logN)*. Overall our algorithm will take O(N\\logN)*. Space complexityThe space complexity of the above algorithm will be O(N) which is required for sorting. Also, in the worst case scenario, we’ll have to insert all the meetings into the Min Heap (when all meetings overlap) which will also take O(N) space. The overall space complexity of our algorithm is O(N). Similar ProblemsProblem 1: Given a list of intervals, find the point where the maximum number of intervals overlap. Problem 2: Given a list of intervals representing the arrival and departure times of trains to a train station, our goal is to find the minimum number of platforms required for the train station so that no train has to wait. Both of these problems can be solved using the approach discussed above. Problem Challenge 2Design Gurus Educative.io Maximum CPU Load (hard)We are given a list of Jobs. Each job has a Start time, an End time, and a CPU load when it is running. Our goal is to find the maximum CPU load at any time if all the jobs are running on the same machine. Example 1: 1234Jobs: [[1,4,3], [2,5,4], [7,9,6]]Output: 7Explanation: Since [1,4,3] and [2,5,4] overlap, their maximum CPU load (3+4=7) will be when both the jobs are running at the same time i.e., during the time interval (2,4). Example 2: 123Jobs: [[6,7,10], [2,4,11], [8,12,15]]Output: 15Explanation: None of the jobs overlap, therefore we will take the maximum load of any job which is 15. Example 3: 123Jobs: [[1,4,2], [2,4,1], [3,6,5]]Output: 8Explanation: Maximum CPU load will be 8 as all jobs overlap during the time interval [3,4]. SolutionThe problem follows the Merge Intervals pattern and can easily be converted to Minimum Meeting Rooms. Similar to ‘Minimum Meeting Rooms’ where we were trying to find the maximum number of meetings happening at any time, for ‘Maximum CPU Load’ we need to find the maximum number of jobs running at any time. We will need to keep a running count of the maximum CPU load at any time to find the overall maximum load. CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778# 没有class的版本，一样能过。没有定义class，所以在使用heap的时候吧list的两个元素反转了一下from heapq import *class Solution: def findMaxCPULoad(self, jobs): # sort the jobs by start time jobs.sort(key=lambda x: x[0]) max_cpu_load, current_cpu_load = 0, 0 min_heap = [] # 需要按照job的end来由小到大排序 for j in jobs: # remove all the jobs that have ended while min_heap and j[0] &gt;= min_heap[0][0]: current_cpu_load -= min_heap[0][2] heappop(min_heap) # add the current job into min_heap heappush(min_heap, (j[1], j[0], j[2])) current_cpu_load += j[2] max_cpu_load = max(max_cpu_load, current_cpu_load) return max_cpu_loaddef main(): sol = Solution() print(&quot;Maximum CPU load at any time: &quot; + str(sol.findMaxCPULoad([(1, 4, 3), (2, 5, 4), (7, 9, 6)]))) print(&quot;Maximum CPU load at any time: &quot; + str(sol.findMaxCPULoad([(6, 7, 10), (2, 4, 11), (8, 12, 15)]))) print(&quot;Maximum CPU load at any time: &quot; + str(sol.findMaxCPULoad([(1, 4, 2), (2, 4, 1), (3, 6, 5)])))main()# 官方版本from heapq import *#class job:# def __init__(self, start, end, cpu_load):# self.start = start# self.end = end# self.cpuLoad = cpu_load# You can override/modify __lt__ as per your needsetattr(Job, &quot;__lt__&quot;, lambda self, other: self.end &lt; other.end)class Solution: def findMaxCPULoad(self, jobs): # sort the jobs by start time jobs.sort(key=lambda x: x.start) max_cpu_load, current_cpu_load = 0, 0 min_heap = [] for j in jobs: # remove all the jobs that have ended while(len(min_heap) &gt; 0 and j.start &gt;= min_heap[0].end): current_cpu_load -= min_heap[0].cpuLoad heappop(min_heap) # add the current job into min_heap heappush(min_heap, j) current_cpu_load += j.cpuLoad max_cpu_load = max(max_cpu_load, current_cpu_load) return max_cpu_loaddef main(): sol = Solution() print(&quot;Maximum CPU load at any time: &quot; + str(sol.findMaxCPULoad([Job(1, 4, 3), Job(2, 5, 4), Job(7, 9, 6)]))) print(&quot;Maximum CPU load at any time: &quot; + str(sol.findMaxCPULoad([Job(6, 7, 10), Job(2, 4, 11), Job(8, 12, 15)]))) print(&quot;Maximum CPU load at any time: &quot; + str(sol.findMaxCPULoad([Job(1, 4, 2), Job(2, 4, 1), Job(3, 6, 5)])))main() Time complexityThe time complexity of the above algorithm is O(N\\logN)*, where ‘N’ is the total number of jobs. This is due to the sorting that we did in the beginning. Also, while iterating the jobs, we might need to poll/offer jobs to the priority queue. Each of these operations can take O(log\\N)*. Overall our algorithm will take O(N\\logN)* Space complexityThe space complexity of the above algorithm will be O(N), which is required for sorting. Also, in the worst case, we have to insert all the jobs into the priority queue (when all jobs overlap) which will also take O(N) space. The overall space complexity of our algorithm is O(N) **Problem Challenge 3Leetcode 会员 Design Gurus Educative.io Employee Free Time (hard)For ‘K’ employees, we are given a list of intervals representing the working hours of each employee. Our goal is to find out if there is a free interval that is common to all employees. You can assume that each list of employee working hours is sorted on the start time. Example 1: 123Input: Employee Working Hours=[[[1,3], [5,6]], [[2,3], [6,8]]]Output: [3,5]Explanation: Both the employess are free between [3,5]. Example 2: 123Input: Employee Working Hours=[[[1,3], [9,12]], [[2,4]], [[6,8]]]Output: [4,6], [8,9]Explanation: All employess are free between [4,6] and [8,9]. Example 3: 123Input: Employee Working Hours=[[[1,3]], [[2,4]], [[3,5], [7,9]]]Output: [5,7]Explanation: All employess are free between [5,7]. SolutionThis problem follows the Merge Intervals pattern. Let’s take the above-mentioned example (2) and visually draw it: 12Input: Employee Working Hours=[[[1,3], [9,12]], [[2,4]], [[6,8]]]Output: [4,6], [8,9] One simple solution can be to put all employees’ working hours in a list and sort them on the start time. Then we can iterate through the list to find the gaps.（一开始我想的） Let’s dig deeper. Sorting the intervals of the above example will give us: 1[1,3], [2,4], [6,8], [9,12] We can now iterate through these intervals, and whenever we find non-overlapping intervals (e.g., [2,4] and [6,8]), we can calculate a free interval (e.g., [4,6]). This algorithm will take O(N \\ logN)* time, where ‘N’ is the total number of intervals. This time is needed because we need to sort all the intervals. The space complexity will be O(N), which is needed for sorting. Can we find a better solution? Using a Heap to Sort the IntervalsOne fact that we are not utilizing is that each employee list is individually sorted! How about we take the first interval of each employee and insert it in a Min Heap. This Min Heap can always give us the interval with the smallest start time. Once we have the smallest start-time interval, we can then compare it with the next smallest start-time interval (again from the Heap) to find the gap. This interval comparison is similar to what we suggested in the previous approach. Whenever we take an interval out of the Min Heap, we can insert the next interval of the same employee. This also means that we need to know which interval belongs to which employee. CodeHere is what our algorithm will look like: 大致可以看懂，但是定义EmplyeeInterval有点复杂了，可以直接使用三元组代替。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687from heapq import *# class Interval:# def __init__(self, start, end):# self.start = start# self.end = endclass EmployeeInterval: def __init__(self, interval, employeeIndex, intervalIndex): self.interval = interval # interval representing employee&#x27;s working hours # index of the list containing working hours of this employee self.employeeIndex = employeeIndex self.intervalIndex = intervalIndex # index of the interval in the employee list def __lt__(self, other): # min heap based on meeting.start return self.interval.start &lt; other.interval.startclass Solution: def findEmployeeFreeTime(self, schedule): if schedule is None: return [] n = len(schedule) result, minHeap = [], [] # insert the first interval of each employee to the queue for i in range(n): heappush(minHeap, EmployeeInterval(schedule[i][0], i, 0)) previousInterval = minHeap[0].interval while minHeap: queueTop = heappop(minHeap) # if previousInterval is not overlapping with the next interval, insert a free # interval if previousInterval.end &lt; queueTop.interval.start: result.append(Interval(previousInterval.end, queueTop.interval.start)) previousInterval = queueTop.interval else: # overlapping intervals, update the previousInterval if needed if previousInterval.end &lt; queueTop.interval.end: previousInterval = queueTop.interval # if there are more intervals available for the same employee, add their next # interval employeeSchedule = schedule[queueTop.employeeIndex] if len(employeeSchedule) &gt; queueTop.intervalIndex + 1: heappush(minHeap, EmployeeInterval( employeeSchedule[queueTop.intervalIndex + 1], queueTop.employeeIndex, queueTop.intervalIndex + 1)) return resultdef print_interval(i): print(&quot;[&quot; + str(i.start) + &quot;, &quot; + str(i.end) + &quot;]&quot;, end=&#x27;&#x27;)def main(): sol = Solution() input = [[Interval(1, 3), Interval(5, 6)], [ Interval(2, 3), Interval(6, 8)]] print(&quot;Free intervals: &quot;, end=&#x27;&#x27;) for interval in sol.findEmployeeFreeTime(input): print_interval(interval) print() input = [[Interval(1, 3), Interval(9, 12)], [ Interval(2, 4)], [Interval(6, 8)]] print(&quot;Free intervals: &quot;, end=&#x27;&#x27;) for interval in sol.findEmployeeFreeTime(input): print_interval(interval) print() input = [[Interval(1, 3)], [ Interval(2, 4)], [Interval(3, 5), Interval(7, 9)]] print(&quot;Free intervals: &quot;, end=&#x27;&#x27;) for interval in sol.findEmployeeFreeTime(input): print_interval(interval) print()main() Time complexityThe time complexity of the above algorithm is O(N\\logK)*, where ‘N’ is the total number of intervals and ‘K’ is the total number of employees. This is due to the fact that we are iterating through the intervals only once (which will take O(N)), and every time we process an interval, we remove (and can insert) one interval in the Min Heap, (which will take O(N\\logK)*). At any time the heap will not have more than ‘K’ elements. Space complexityThe space complexity of the above algorithm will be O(K) as at any time the heap will not have more than ‘K’ elements.","categories":[{"name":"Grokking Interview Pattern","slug":"Grokking-Interview-Pattern","permalink":"https://hasuer.github.io/categories/Grokking-Interview-Pattern/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hasuer.github.io/tags/Interview/"}]},{"title":"3. Pattern Sliding Window","slug":"3. Pattern Sliding Window","date":"2024-05-03T03:11:31.000Z","updated":"2024-05-28T03:27:28.453Z","comments":true,"path":"3-pattern-sliding-window/index.html","link":"","permalink":"https://hasuer.github.io/3-pattern-sliding-window/index.html","excerpt":"","text":"IntroductionIn many problems dealing with an array (or a LinkedList), we are asked to find or calculate something among all the contiguous subarrays (or sublists) of a given size. For example, take a look at this problem: Given an array, find the average of all contiguous subarrays of size ‘K’ in it. Let’s understand this problem with a real input: 1Array: [1, 3, 2, 6, -1, 4, 1, 8, 2], K=5 Here, we are asked to find the average of all contiguous subarrays of size ‘5’ in the given array. Let’s solve this: For the first 5 numbers (subarray from index 0-4), the average is: (1+3+2+6-1)/5 =&gt; 2.2(1+3+2+6−1)/5=&gt;2.2 The average of next 5 numbers (subarray from index 1-5) is: (3+2+6-1+4)/5 =&gt; 2.8(3+2+6−1+4)/5=&gt;2.8 For the next 5 numbers (subarray from index 2-6), the average is: (2+6-1+4+1)/5 =&gt; 2.4(2+6−1+4+1)/5=&gt;2.4… Here is the final output containing the averages of all contiguous subarrays of size 5: 1Output: [2.2, 2.8, 2.4, 3.6, 2.8] A brute-force algorithm will be to calculate the sum of every 5-element contiguous subarray of the given array and divide the sum by ‘5’ to find the average. This is what the algorithm will look like: 123456789101112131415161718192021class Solution: def findAverages(self, K, arr): result = [] for i in range(len(arr)-K+1): # find sum of next &#x27;K&#x27; elements _sum = 0.0 for j in range(i, i+K): _sum += arr[j] result.append(_sum/K) # calculate average return resultdef main(): sol = Solution() result = sol.findAverages(5, [1, 3, 2, 6, -1, 4, 1, 8, 2]) print(&quot;Averages of subarrays of size K: &quot; + str(result))main() Time complexity: Since for every element of the input array, we are calculating the sum of its next ‘K’ elements, the time complexity of the above algorithm will be O(N\\K)* where ‘N’ is the number of elements in the input array. Can we find a better solution? Do you see any inefficiency in the above approach? The inefficiency is that for any two consecutive subarrays of size ‘5’, the overlapping part (which will contain four elements) will be evaluated twice. For example, take the above-mentioned input: As you can see, there are four overlapping elements between the subarray (indexed from 0-4) and the subarray (indexed from 1-5). Can we somehow reuse the sum we have calculated for the overlapping elements? The efficient way to solve this problem would be to visualize each contiguous subarray as a sliding window of ‘5’ elements. This means that when we move on to the next subarray, we will slide the window by one element. So, to reuse the sum from the previous subarray, we will subtract the element going out of the window and add the element now being included in the sliding window. This will save us from going through the whole subarray to find the sum and, as a result, the algorithm complexity will reduce to O(N). Here is the algorithm for the Sliding Window approach: 1234567891011121314151617181920212223class Solution: def findAverages(self, K, arr): result = [] windowSum, windowStart = 0.0, 0 for windowEnd in range(len(arr)): windowSum += arr[windowEnd] # add the next element # slide the window, no need to slide if we&#x27;ve not hit the required window size of &#x27;k&#x27; if windowEnd &gt;= K - 1: result.append(windowSum / K) # calculate the average windowSum -= arr[windowStart] # subtract the element going out windowStart += 1 # slide the window ahead return resultdef main(): sol = Solution() result = sol.findAverages(5, [1, 3, 2, 6, -1, 4, 1, 8, 2]) print(&quot;Averages of subarrays of size K: &quot; + str(result))main() In the following chapters, we will apply the Sliding Window approach to solve a few problems. In some problems, the size of the sliding window is not fixed. We have to expand or shrink the window based on the problem constraints. We will see a few examples of such problems in the next chapters. Let’s jump onto our first problem and apply the Sliding Window pattern. Maximum Sum Subarray of Size K (easy)Design Gurus Educative.io Problem StatementGiven an array of positive numbers and a positive number ‘k’, find the maximum sum of any contiguous subarray of size ‘k’. Example 1: 123Input: [2, 1, 5, 1, 3, 2], k=3 Output: 9Explanation: Subarray with maximum sum is [5, 1, 3]. Example 2: 123Input: [2, 3, 4, 1, 5], k=2 Output: 7Explanation: Subarray with maximum sum is [3, 4]. SolutionA basic brute force solution will be to calculate the sum of all ‘k’ sized subarrays of the given array to find the subarray with the highest sum. We can start from every index of the given array and add the next ‘k’ elements to find the subarray’s sum. Following is the visual representation of this algorithm for Example-1: CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324class Solution: def findMaxSumSubArray(self, k, arr): max_sum, window_sum = 0, 0 window_start = 0 for window_end in range(len(arr)): window_sum += arr[window_end] # add the next element # slide the window, no need to slide if we&#x27;ve not hit the required window size of &#x27;k&#x27; if window_end &gt;= k-1: max_sum = max(max_sum, window_sum) window_sum -= arr[window_start] # subtract the element going out window_start += 1 # slide the window ahead return max_sumdef main(): sol = Solution() print(&quot;Maximum sum of a subarray of size K: &quot; + str(sol.findMaxSumSubArray(3, [2, 1, 5, 1, 3, 2]))) print(&quot;Maximum sum of a subarray of size K: &quot; + str(sol.findMaxSumSubArray(2, [2, 3, 4, 1, 5])))main() Time ComplexityThe time complexity of the above algorithm will be O(N). Space ComplexityThe algorithm runs in constant space O(1). Smallest Subarray with a given sum (easy) Top Interview 150 | 209. Minimum Size Subarray Sum Design Gurus Educative.io Problem StatementGiven an array of positive numbers and a positive number ‘S’, find the length of the smallest contiguous subarray whose sum is greater than or equal to ‘S’. Return 0, if no such subarray exists. Example 1: 123Input: [2, 1, 5, 2, 3, 2], S=7 Output: 2Explanation: The smallest subarray with a sum great than or equal to &#x27;7&#x27; is [5, 2]. Example 2: 123Input: [2, 1, 5, 2, 8], S=7 Output: 1Explanation: The smallest subarray with a sum greater than or equal to &#x27;7&#x27; is [8]. Example 3: 123Input: [3, 4, 1, 1, 6], S=8 Output: 3Explanation: Smallest subarrays with a sum greater than or equal to &#x27;8&#x27; are [3, 4, 1] or [1, 1, 6]. Constraints: 1 &lt;= S &lt;= 10^9 1 &lt;= arr.length &lt;= 10^5 1 &lt;= arr[i] &lt;= 10^4 SolutionThis problem follows the Sliding Window pattern and we can use a similar strategy as discussed in Maximum Sum Subarray of Size K. There is one difference though: in this problem, the size of the sliding window is not fixed. Here is how we will solve this problem: First, we will add-up elements from the beginning of the array until their sum becomes greater than or equal to ‘S’. These elements will constitute our sliding window. We are asked to find the smallest such window having a sum greater than or equal to ‘S’. We will remember the length of this window as the smallest window so far. After this, we will keep adding one element in the sliding window (i.e. slide the window ahead), in a stepwise fashion. In each step, we will also try to shrink the window from the beginning. We will shrink the window until the window’s sum is smaller than ‘S’ again. This is needed as we intend to find the smallest window. This shrinking will also happen in multiple steps; in each step we will do two things: Check if the current window length is the smallest so far, and if so, remember its length. Subtract the first element of the window from the running sum to shrink the sliding window. Here is the visual representation of this algorithm for the Example-1: CodeHere is what our algorithm will look: 1234567891011121314151617181920212223242526272829import mathclass Solution: def findMinSubArray(self, s, arr): window_sum = 0 # Initialize the sum of the current window min_length = math.inf # Initialize the minimum length to positive infinity window_start = 0 # Initialize the start of the current window for window_end in range(0, len(arr)): window_sum += arr[window_end] # Add the next element to the window sum # Shrink the window as small as possible until &#x27;window_sum&#x27; is smaller than &#x27;s&#x27; while window_sum &gt;= s: min_length = min(min_length, window_end - window_start + 1) # Update the minimum length window_sum -= arr[window_start] # Remove the element going out of the window window_start += 1 # Slide the window ahead if min_length == math.inf: return 0 return min_lengthdef main(): sol = Solution() print(&quot;Smallest subarray length: &quot; + str(sol.findMinSubArray(7, [2, 1, 5, 2, 3, 2]))) print(&quot;Smallest subarray length: &quot; + str(sol.findMinSubArray(7, [2, 1, 5, 2, 8]))) print(&quot;Smallest subarray length: &quot; + str(sol.findMinSubArray(8, [3, 4, 1, 1, 6])))main() Time ComplexityThe time complexity of the above algorithm will be O(N). The outer for loop runs for all elements and the inner while loop processes each element only once, therefore the time complexity of the algorithm will be O(N+N) which is asymptotically equivalent to O(N). Space ComplexityThe algorithm runs in constant space O(1). Longest Substring with K Distinct Characters (medium)Design Gurus Educative.io Problem StatementGiven a string, find the length of the longest substring in it with no more than K distinct characters. You can assume that K is less than or equal to the length of the given string. Example 1: 123Input: String=&quot;araaci&quot;, K=2Output: 4Explanation: The longest substring with no more than &#x27;2&#x27; distinct characters is &quot;araa&quot;. Example 2: 123Input: String=&quot;araaci&quot;, K=1Output: 2Explanation: The longest substring with no more than &#x27;1&#x27; distinct characters is &quot;aa&quot;. Example 3: 123Input: String=&quot;cbbebi&quot;, K=3Output: 5Explanation: The longest substrings with no more than &#x27;3&#x27; distinct characters are &quot;cbbeb&quot; &amp; &quot;bbebi&quot;. Constraints: 1 &lt;= str.length &lt;= 5 * 104 0 &lt;= K &lt;= 50 SolutionThis problem follows the Sliding Window pattern and we can use a similar dynamic sliding window strategy as discussed in Smallest Subarray with a given sum. We can use a HashMap to remember the frequency of each character we have processed. Here is how we will solve this problem: First, we will insert characters from the beginning of the string until we have ‘K’ distinct characters in the HashMap. These characters will constitute our sliding window. We are asked to find the longest such window having no more than ‘K’ distinct characters. We will remember the length of this window as the longest window so far. After this, we will keep adding one character in the sliding window (i.e. slide the window ahead), in a stepwise fashion. In each step, we will try to shrink the window from the beginning if the count of distinct characters in the HashMap is larger than ‘K’. We will shrink the window until we have no more than ‘K’ distinct characters in the HashMap. This is needed as we intend to find the longest window. While shrinking, we’ll decrement the frequency of the character going out of the window and remove it from the HashMap if its frequency becomes zero. At the end of each step, we’ll check if the current window length is the longest so far, and if so, remember its length. Here is the visual representation of this algorithm for the Example-1: CodeHere is how our algorithm will look: 1234567891011121314151617181920212223242526272829303132333435363738class Solution: def findLength(self, str1, k): window_start = 0 max_length = 0 char_frequency = &#123;&#125; # in the following loop we&#x27;ll try to extend the range [window_start, window_end] for window_end in range(len(str1)): right_char = str1[window_end] if right_char not in char_frequency: char_frequency[right_char] = 0 char_frequency[right_char] += 1 # shrink the sliding window, until we are left with &#x27;k&#x27; distinct characters in # the char_frequency while len(char_frequency) &gt; k: left_char = str1[window_start] char_frequency[left_char] -= 1 if char_frequency[left_char] == 0: del char_frequency[left_char] window_start += 1 # shrink the window # remember the maximum length so far max_length = max(max_length, window_end-window_start + 1) return max_lengthdef main(): sol = Solution() print(&quot;Length of the longest substring: &quot; + str(sol.findLength(&quot;araaci&quot;, 2))) print(&quot;Length of the longest substring: &quot; + str(sol.findLength(&quot;araaci&quot;, 1))) print(&quot;Length of the longest substring: &quot; + str(sol.findLength(&quot;cbbebi&quot;, 3)))main() Time ComplexityThe time complexity of the above algorithm will be O(N) where ‘N’ is the number of characters in the input string. The outer for loop runs for all characters and the inner while loop processes each character only once, therefore the time complexity of the algorithm will be O(N+N)O(N+N) which is asymptotically equivalent to O(N). Space ComplexityThe space complexity of the algorithm is O(K), as we will be storing a maximum of ‘K+1’ characters in the HashMap. Fruits into Baskets (medium) 904. Fruit Into Baskets Design Gurus Educative.io You are visiting a farm to collect fruits. The farm has a single row of fruit trees. You will be given two baskets, and your goal is to pick as many fruits as possible to be placed in the given baskets. You will be given an array of characters where each character represents a fruit tree. The farm has following restrictions: Each basket can have only one type of fruit. There is no limit to how many fruit a basket can hold. You can start with any tree, but you can’t skip a tree once you have started. You will pick exactly one fruit from every tree until you cannot, i.e., you will stop when you have to pick from a third fruit type. Write a function to return the maximum number of fruits in both baskets. Example 1: 123Input: arr=[&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;A&#x27;, &#x27;C&#x27;] Output: 3 Explanation: We can put 2 &#x27;C&#x27; in one basket and one &#x27;A&#x27; in the other from the subarray [&#x27;C&#x27;, &#x27;A&#x27;, &#x27;C&#x27;] Example 2: 123Input: arr = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;B&#x27;, &#x27;B&#x27;, &#x27;C&#x27;] Output: 5 Explanation: We can put 3 &#x27;B&#x27; in one basket and two &#x27;C&#x27; in the other basket. This can be done if we start with the second letter: [&#x27;B&#x27;, &#x27;C&#x27;, &#x27;B&#x27;, &#x27;B&#x27;, &#x27;C&#x27;] Constraints: 1 &lt;= arr.length &lt;= 10^5 0 &lt;= arr[i] &lt; arr.length SolutionThis problem follows the Sliding Window pattern and is quite similar to Longest Substring with K Distinct Characters. In this problem, we need to find the length of the longest subarray with no more than two distinct characters (or fruit types!). This transforms the current problem into Longest Substring with K Distinct Characters where K=2. CodeHere is what our algorithm will look like, only the highlighted lines are different from Longest Substring with K Distinct Characters 1234567891011121314151617181920212223242526272829303132333435class Solution: def findLength(self, fruits): window_start = 0 max_length = 0 fruit_frequency = &#123;&#125; # try to extend the range [window_start, window_end] for window_end in range(len(fruits)): right_fruit = fruits[window_end] if right_fruit not in fruit_frequency: fruit_frequency[right_fruit] = 0 fruit_frequency[right_fruit] += 1 # shrink the sliding window, until we are left with &#x27;2&#x27; fruits in the fruit # frequency dictionary while len(fruit_frequency) &gt; 2: left_fruit = fruits[window_start] fruit_frequency[left_fruit] -= 1 if fruit_frequency[left_fruit] == 0: del fruit_frequency[left_fruit] window_start += 1 # shrink the window max_length = max(max_length, window_end-window_start + 1) return max_lengthdef main(): sol = Solution() print(&quot;Maximum number of fruits: &quot; + str(sol.findLength([&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;A&#x27;, &#x27;C&#x27;]))) print(&quot;Maximum number of fruits: &quot; + str(sol.findLength([&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;B&#x27;, &#x27;B&#x27;, &#x27;C&#x27;])))main() Time ComplexityThe time complexity of the above algorithm will be O(N) where ‘N’ is the number of characters in the input array. The outer for loop runs for all characters and the inner while loop processes each character only once, therefore the time complexity of the algorithm will be O(N+N)O(N+N) which is asymptotically equivalent to O(N). Space ComplexityThe algorithm runs in constant space O(1) as there can be a maximum of three types of fruits stored in the frequency map. Similar ProblemsProblem 1: Longest Substring with at most 2 distinct characters Given a string, find the length of the longest substring in it with at most two distinct characters. Solution: This problem is exactly similar to our parent problem. No-repeat Substring (hard)Top Interview 150 | 3. Longest Substring Without Repeating Characters Educative.io Problem StatementGiven a string, find the length of the longest substring which has no repeating characters. Example 1: 123Input: String=&quot;aabccbb&quot;Output: 3Explanation: The longest substring without any repeating characters is &quot;abc&quot;. Example 2: 123Input: String=&quot;abbbb&quot;Output: 2Explanation: The longest substring without any repeating characters is &quot;ab&quot;. Example 3: 123Input: String=&quot;abccde&quot;Output: 3Explanation: Longest substrings without any repeating characters are &quot;abc&quot; &amp; &quot;cde&quot;. SolutionThis problem follows the Sliding Window pattern and we can use a similar dynamic sliding window strategy as discussed in Longest Substring with K Distinct Characters. We can use a HashMap to remember the last index of each character we have processed. Whenever we get a repeating character we will shrink our sliding window to ensure that we always have distinct characters in the sliding window. CodeHere is what our algorithm will look like: 1234567891011121314151617181920212223242526def non_repeat_substring(str): start = 0 max_length = 0 char_index_map = &#123;&#125; for end in range(len(str)): right_char = str[end] if right_char in char_index_map: left_char = str[start] start = max(start, char_index_map[right_char] + 1) char_index_map[right_char] = end max_length = max(max_length, end - start + 1) return max_lengthdef main(): result = non_repeat_substring(&quot;aabccbb&quot;) print(&quot;Result: &quot; + str(result)) result = non_repeat_substring(&quot;abbb&quot;) print(&quot;Result: &quot; + str(result)) result = non_repeat_substring(&quot;abccde&quot;) print(&quot;Result: &quot; + str(result))if __name__ == &#x27;__main__&#x27;: main() Time ComplexityThe time complexity of the above algorithm will be O(N) where ‘N’ is the number of characters in the input string. Space ComplexityThe space complexity of the algorithm will be O(K) where KK is the number of distinct characters in the input string. This also means K&lt;=N, because in the worst case, the whole string might not have any repeating character so the entire string will be added to the HashMap. Having said that, since we can expect a fixed set of characters in the input string (e.g., 26 for English letters), we can say that the algorithm runs in fixed space O(1); in this case, we can use a fixed-size array instead of the HashMap. *Longest Substring with Same Letters after Replacement (hard)424. Longest Repeating Character Replacement Design Gurus Educative.io Problem StatementGiven a string with lowercase letters only, if you are allowed to replace no more than ‘k’ letters with any letter, find the length of the longest substring having the same letters after replacement. Example 1: 123Input: String=&quot;aabccbb&quot;, k=2Output: 5Explanation: Replace the two &#x27;c&#x27; with &#x27;b&#x27; to have a longest repeating substring &quot;bbbbb&quot;. Example 2: 123Input: String=&quot;abbcb&quot;, k=1Output: 4Explanation: Replace the &#x27;c&#x27; with &#x27;b&#x27; to have a longest repeating substring &quot;bbbb&quot;. Example 3: 123Input: String=&quot;abccde&quot;, k=1Output: 3Explanation: Replace the &#x27;b&#x27; or &#x27;d&#x27; with &#x27;c&#x27; to have the longest repeating substring &quot;ccc&quot;. Constraints: 1 &lt;= str.length &lt;= 10^5 s consists of only lowercase English letters. 0 &lt;= k &lt;= s.length SolutionThis problem follows the Sliding Window pattern, and we can use a similar dynamic sliding window strategy as discussed in Longest Substring with Distinct Characters. We can use a HashMap to count the frequency of each letter. We will iterate through the string to add one letter at a time in the window. We will also keep track of the count of the maximum repeating letter in any window (let’s call it maxRepeatLetterCount). So, at any time, we know that we do have a window with one letter repeating maxRepeatLetterCount times; this means we should try to replace the remaining letters. If the remaining letters are less than or equal to ‘k’, we can replace them all. If we have more than ‘k’ remaining letters, we should shrink the window as we cannot replace more than ‘k’ letters. While shrinking the window, we don’t need to update maxRepeatLetterCount. Since we are only interested in the longest valid substring, our sliding windows do not have to shrink, even if a window may cover an invalid substring. Either we expand the window by appending a character to the right or we shift the entire window to the right by one. We only expand the window when the frequency of the newly added character exceeds the historical maximum frequency (from a previous window that included a valid substring). In other words, we do not need to know the exact maximum count of the current window. The only thing we need to know is whether the maximum count exceeds the historical maximum count, and that can only happen because of the newly added char. CodeHere is what our algorithm will look like: 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution: def findLength(self, str1, k): window_start, max_length, max_repeat_letter_count = 0, 0, 0 frequency_map = &#123;&#125; # Try to extend the range [window_start, window_end] for window_end in range(len(str1)): right_char = str1[window_end] if right_char not in frequency_map: frequency_map[right_char] = 0 frequency_map[right_char] += 1 # we don&#x27;t need to place the maxRepeatLetterCount under the below &#x27;if&#x27;, see the # explanation in the &#x27;Solution&#x27; section above. # 也可以使用max(char_frequency.values())，还是感觉这个好理解一点 max_repeat_letter_count = max( max_repeat_letter_count, frequency_map[right_char]) # Current window size is from window_start to window_end, overall we have a letter # which is repeating &#x27;max_repeat_letter_count&#x27; times, this means we can have a window # which has one letter repeating &#x27;max_repeat_letter_count&#x27; times and the remaining # letters we should replace. If the remaining letters are more than &#x27;k&#x27;, it is the # time to shrink the window as we are not allowed to replace more than &#x27;k&#x27; letters # 这里也可以用while，但是看solution的说法 if (window_end - window_start + 1 - max_repeat_letter_count) &gt; k: left_char = str1[window_start] frequency_map[left_char] -= 1 window_start += 1 max_length = max(max_length, window_end - window_start + 1) return max_lengthdef main(): sol = Solution() print(sol.findLength(&quot;aabccbb&quot;, 2)) print(sol.findLength(&quot;abbcb&quot;, 1)) print(sol.findLength(&quot;abccde&quot;, 1))main() Time ComplexityThe time complexity of the above algorithm will be O(N) where ‘N’ is the number of letters in the input string. Space ComplexityAs we are expecting only the lower case letters in the input string, we can conclude that the space complexity will be O(26), to store each letter’s frequency in the HashMap, which is asymptotically equal to O(1). Longest Subarray with Ones after Replacement (hard)1004. Max Consecutive Ones III Design Gurus Educative.io Problem StatementGiven an array containing 0s and 1s, if you are allowed to replace no more than ‘k’ 0s with 1s, find the length of the longest contiguous subarray having all 1s. Example 1: 123Input: Array=[0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1], k=2Output: 6Explanation: Replace the &#x27;0&#x27; at index 5 and 8 to have the longest contiguous subarray of 1s having length 6. Example 2: 123Input: Array=[0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1], k=3Output: 9Explanation: Replace the &#x27;0&#x27; at index 6, 9, and 10 to have the longest contiguous subarray of 1s having length 9. Constraints: 1 &lt;= arr.length &lt;= 10^5 arr[i] is either 0 or 1. 0 &lt;= k &lt;= nums.length SolutionThis problem follows the Sliding Window pattern and is quite similar to Longest Substring with same Letters after Replacement. The only difference is that, in the problem, we only have two characters (1s and 0s) in the input arrays. Following a similar approach, we’ll iterate through the array to add one number at a time in the window. We’ll also keep track of the maximum number of repeating 1s in the current window (let’s call it maxOnesCount). So at any time, we know that we can have a window with 1s repeating maxOnesCount time, so we should try to replace the remaining 0s. If we have more than ‘k’ remaining 0s, we should shrink the window as we are not allowed to replace more than ‘k’ 0s. CodeHere is how our algorithm will look like: 12345678910111213141516171819202122232425262728293031class Solution: def findLength(self, arr, k): window_start, max_length, max_ones_count = 0, 0, 0 # Try to extend the range [window_start, window_end] for window_end in range(len(arr)): if arr[window_end] == 1: max_ones_count += 1 # Current window size is from window_start to window_end, overall we have a maximum # of 1s repeating &#x27;max_ones_count&#x27; times, this means we can have a window with # &#x27;max_ones_count&#x27; 1s and the remaining are 0s which should replace with 1s. # Now, if the remaining 0s are more than &#x27;k&#x27;, it is the time to shrink the window as # we are not allowed to replace more than &#x27;k&#x27; 0s if (window_end - window_start + 1 - max_ones_count) &gt; k: if arr[window_start] == 1: max_ones_count -= 1 window_start += 1 max_length = max(max_length, window_end - window_start + 1) return max_lengthdef main(): sol = Solution() print(sol.findLength([0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1], 2)) print(sol.findLength([0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1], 3))main() Time ComplexityThe time complexity of the above algorithm will be O(N) where ‘N’ is the count of numbers in the input array. Space ComplexityThe algorithm runs in constant space O(1). *Problem Challenge 1567. Permutation in String Design Gurus Educative.io Permutation in a String (hard)Given a string and a pattern, find out if the string contains any permutation of the pattern. Permutation is defined as the re-arranging of the characters of the string. For example, “abc” has the following six permutations: abc acb bac bca cab cba If a string has ‘n’ distinct characters it will have n! permutations. Example 1: 123Input: String=&quot;oidbcaf&quot;, Pattern=&quot;abc&quot;Output: trueExplanation: The string contains &quot;bca&quot; which is a permutation of the given pattern. Example 2: 123Input: String=&quot;odicf&quot;, Pattern=&quot;dc&quot;Output: falseExplanation: No permutation of the pattern is present in the given string as a substring. Example 3: 123Input: String=&quot;bcdxabcdy&quot;, Pattern=&quot;bcdyabcdx&quot;Output: trueExplanation: Both the string and the pattern are a permutation of each other. Example 4: 123Input: String=&quot;aaacb&quot;, Pattern=&quot;abc&quot;Output: trueExplanation: The string contains &quot;acb&quot; which is a permutation of the given pattern. Constraints: 1 &lt;= str.length, pat.length &lt;= 104 str and pat consist of lowercase English letters. SolutionThis problem follows the Sliding Window pattern and we can use a similar sliding window strategy as discussed in Longest Substring with K Distinct Characters. We can use a HashMap to remember the frequencies of all characters in the given pattern. Our goal will be to match all the characters from this HashMap with a sliding window in the given string. Here are the steps of our algorithm: Create a HashMap to calculate the frequencies of all characters in the pattern. Iterate through the string, adding one character at a time in the sliding window. If the character being added matches a character in the HashMap, decrement its frequency in the map. If the character frequency becomes zero, we got a complete match. If at any time, the number of characters matched is equal to the number of distinct characters in the pattern (i.e., total characters in the HashMap), we have gotten our required permutation. If the window size is greater than the length of the pattern, shrink the window to make it equal to the size of the pattern. At the same time, if the character going out was part of the pattern, put it back in the frequency HashMap. CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution: def findPermutation(self, str1, pattern): window_start, matched = 0, 0 char_frequency = &#123;&#125; for chr in pattern: if chr not in char_frequency: char_frequency[chr] = 0 char_frequency[chr] += 1 # our goal is to match all the characters from the &#x27;char_frequency&#x27; with the current # window try to extend the range [window_start, window_end] for window_end in range(len(str1)): right_char = str1[window_end] if right_char in char_frequency: # decrement the frequency of matched character char_frequency[right_char] -= 1 if char_frequency[right_char] == 0: matched += 1 # 这里的if也是可以缩进的，leetcode过了 if matched == len(char_frequency): return True # shrink the window by one character if window_end &gt;= len(pattern) - 1: left_char = str1[window_start] window_start += 1 if left_char in char_frequency: if char_frequency[left_char] == 0: matched -= 1 char_frequency[left_char] += 1 return Falsedef main(): sol = Solution() print(&#x27;Permutation exist: &#x27; + str(sol.findPermutation(&quot;oidbcaf&quot;, &quot;abc&quot;))) print(&#x27;Permutation exist: &#x27; + str(sol.findPermutation(&quot;odicf&quot;, &quot;dc&quot;))) print(&#x27;Permutation exist: &#x27; + str(sol.findPermutation(&quot;bcdxabcdy&quot;, &quot;bcdyabcdx&quot;))) print(&#x27;Permutation exist: &#x27; + str(sol.findPermutation(&quot;aaacb&quot;, &quot;abc&quot;)))main() Time ComplexityThe time complexity of the above algorithm will be O(N + M) where ‘N’ and ‘M’ are the number of characters in the input string and the pattern respectively. Space ComplexityThe space complexity of the algorithm is O(M) since in the worst case, the whole pattern can have distinct characters which will go into the HashMap. Problem Challenge 2438. Find All Anagrams in a String Design Gurus Educative.io String Anagrams (hard)Given a string and a pattern, find all anagrams of the pattern in the given string. Anagram is actually a Permutation of a string. For example, “abc” has the following six anagrams: abc acb bac bca cab cba Write a function to return a list of starting indices of the anagrams of the pattern in the given string. Example 1: 123Input: String=&quot;ppqp&quot;, Pattern=&quot;pq&quot;Output: [1, 2]Explanation: The two anagrams of the pattern in the given string are &quot;pq&quot; and &quot;qp&quot;. Example 2: 123Input: String=&quot;abbcabc&quot;, Pattern=&quot;abc&quot;Output: [2, 3, 4]Explanation: The three anagrams of the pattern in the given string are &quot;bca&quot;, &quot;cab&quot;, and &quot;abc&quot;. Constraints: 1 &lt;= s.length, p.length &lt;= 3 * 10^4 str and pattern consist of lowercase English letters. SolutionThis problem follows the Sliding Window pattern and is very similar to Permutation in a String. In this problem, we need to find every occurrence of any permutation of the pattern in the string. We will use a list to store the starting indices of the anagrams of the pattern in the string. CodeHere is what our algorithm will look like, only the highlighted lines have changed from Permutation in a String: 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution: def findStringAnagrams(self, str1, pattern): window_start, matched = 0, 0 char_frequency = &#123;&#125; for chr in pattern: if chr not in char_frequency: char_frequency[chr] = 0 char_frequency[chr] += 1 result_indices = [] # Our goal is to match all the characters from the &#x27;char_frequency&#x27; with the current # window try to extend the range [window_start, window_end] for window_end in range(len(str1)): right_char = str1[window_end] if right_char in char_frequency: # Decrement the frequency of matched character char_frequency[right_char] -= 1 if char_frequency[right_char] == 0: matched += 1 if matched == len(char_frequency): # Have we found an anagram? result_indices.append(window_start) # Shrink the sliding window if window_end &gt;= len(pattern) - 1: left_char = str1[window_start] window_start += 1 if left_char in char_frequency: if char_frequency[left_char] == 0: matched -= 1 # Before putting the character back, decrement the matched count char_frequency[left_char] += 1 # Put the character back return result_indicesdef main(): sol = Solution() print(sol.findStringAnagrams(&quot;ppqp&quot;, &quot;pq&quot;)) print(sol.findStringAnagrams(&quot;abbcabc&quot;, &quot;abc&quot;))main() Time ComplexityThe time complexity of the above algorithm will be O(N + M) where ‘N’ and ‘M’ are the number of characters in the input string and the pattern respectively. Space ComplexityThe space complexity of the algorithm is O(M) since in the worst case, the whole pattern can have distinct characters which will go into the HashMap. In the worst case, we also need O(N) space for the result list, this will happen when the pattern has only one character and the string contains only that character. Problem Challenge 3Top Interview 150 | 76. Minimum Window Substring Design Gurus Educative.io Smallest Window containing Substring (hard)Given a string and a pattern, find the smallest substring in the given string which has all the characters of the given pattern. Example 1: 123Input: String=&quot;aabdec&quot;, Pattern=&quot;abc&quot; Output: &quot;abdec&quot; Explanation: The smallest substring having all characters of the pattern is &quot;abdec&quot; Example 2: 123Input: String=&quot;aabdec&quot;, Pattern=&quot;abac&quot; Output: &quot;aabdec&quot; Explanation: The smallest substring having all characters occurrences of the pattern is &quot;aabdec&quot; Example 3: 123Input: String=&quot;abdbca&quot;, Pattern=&quot;abc&quot; Output: &quot;bca&quot; Explanation: The smallest substring having all characters of the pattern is &quot;bca&quot;. Example 4: 123Input: String=&quot;adcad&quot;, Pattern=&quot;abc&quot; Output: &quot;&quot; Explanation: No substring in the given string has all characters of the pattern Constraints: m == String.length n == Pattern.length 1 &lt;= m, n &lt;= 10^5 String and Pattern consist of uppercase and lowercase English letters. SolutionThis problem follows the Sliding Window pattern and has a lot of similarities with Permutation in a String with one difference. In this problem, we need to find a substring having all characters of the pattern which means that the required substring can have some additional characters and doesn’t need to be a permutation of the pattern. Here is how we will manage these differences: We will keep a running count of every matching instance of a character. Whenever we have matched all the characters, we will try to shrink the window from the beginning, keeping track of the smallest substring that has all the matching characters. We will stop the shrinking process as soon as we remove a matched character from the sliding window. One thing to note here is that we could have redundant matching characters, e.g., we might have two ‘a’ in the sliding window when we only need one ‘a’. In that case, when we encounter the first ‘a’, we will simply shrink the window without decrementing the matched count. We will decrement the matched count when the second ‘a’ goes out of the window. CodeHere is how our algorithm will look; only the highlighted lines have changed from Permutation in a String: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution: def findSubstring(self, str1, pattern): window_start, matched, substr_start = 0, 0, 0 min_length = len(str1) + 1 char_frequency = &#123;&#125; for chr in pattern: if chr not in char_frequency: char_frequency[chr] = 0 char_frequency[chr] += 1 # try to extend the range [window_start, window_end] for window_end in range(len(str1)): right_char = str1[window_end] if right_char in char_frequency: char_frequency[right_char] -= 1 if char_frequency[right_char] &gt;= 0: # Count every matching of a character matched += 1 # Shrink the window if we can, finish as soon as we remove a matched character while matched == len(pattern): if min_length &gt; window_end - window_start + 1: min_length = window_end - window_start + 1 substr_start = window_start left_char = str1[window_start] window_start += 1 if left_char in char_frequency: # Note that we could have redundant matching characters, therefore we&#x27;ll # decrement the matched count only when a useful occurrence of a matched # character is going out of the window if char_frequency[left_char] == 0: matched -= 1 char_frequency[left_char] += 1 if min_length &gt; len(str1): return &quot;&quot; return str1[substr_start:substr_start + min_length]def main(): sol = Solution() print(sol.findSubstring(&quot;aabdec&quot;, &quot;abc&quot;)) print(sol.findSubstring(&quot;aabdec&quot;, &quot;abac&quot;)) print(sol.findSubstring(&quot;abdbca&quot;, &quot;abc&quot;)) print(sol.findSubstring(&quot;adcad&quot;, &quot;abc&quot;))main() Time ComplexityThe time complexity of the above algorithm will be O(N + M) where ‘N’ and ‘M’ are the number of characters in the input string and the pattern respectively. Space ComplexityThe space complexity of the algorithm is O(M) since in the worst case, the whole pattern can have distinct characters which will go into the HashMap. In the worst case, we also need O(N) space for the resulting substring, which will happen when the input string is a permutation of the pattern. *Problem Challenge 4Top Interview 150 | 30. Substring with Concatenation of All Words Design Gurus Educative.io Words Concatenation (hard)Given a string and a list of words, find all the starting indices of substrings in the given string that are a concatenation of all the given words exactly once without any overlapping of words. It is given that all words are of the same length. Example 1: 123Input: String=&quot;catfoxcat&quot;, Words=[&quot;cat&quot;, &quot;fox&quot;]Output: [0, 3]Explanation: The two substring containing both the words are &quot;catfox&quot; &amp; &quot;foxcat&quot;. Example 2: 123Input: String=&quot;catcatfoxfox&quot;, Words=[&quot;cat&quot;, &quot;fox&quot;]Output: [3]Explanation: The only substring containing both the words is &quot;catfox&quot;. Constraints: 1 &lt;= words.length &lt;= 10^4 1 &lt;= words[i].length &lt;= 30 words[i] consists of only lowercase English letters. All the strings of words are unique. 1 &lt;= sum(words[i].length) &lt;= 10^5 SolutionThis problem follows the Sliding Window pattern and has a lot of similarities with Maximum Sum Subarray of Size K. We will keep track of all the words in a HashMap and try to match them in the given string. Here are the set of steps for our algorithm: Keep the frequency of every word in a HashMap. Starting from every index in the string, try to match all the words. In each iteration, keep track of all the words that we have already seen in another HashMap. If a word is not found or has a higher frequency than required, we can move on to the next character in the string. Store the index if we have found all the words. CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution: def findWordConcatenation(self, str1, words): if len(words) == 0 or len(words[0]) == 0: return [] word_frequency = &#123;&#125; for word in words: if word not in word_frequency: word_frequency[word] = 0 word_frequency[word] += 1 result_indices = [] words_count = len(words) word_length = len(words[0]) for i in range((len(str1) - words_count * word_length)+1): words_seen = &#123;&#125; for j in range(0, words_count): next_word_index = i + j * word_length # Get the next word from the string word = str1[next_word_index: next_word_index + word_length] if word not in word_frequency: # Break if we don&#x27;t need this word break # Add the word to the &#x27;words_seen&#x27; map if word not in words_seen: words_seen[word] = 0 words_seen[word] += 1 # No need to process further if the word has higher frequency than required if words_seen[word] &gt; word_frequency.get(word, 0): break if j + 1 == words_count: # Store index if we have found all the words result_indices.append(i) return result_indicesdef main(): sol = Solution() print(sol.findWordConcatenation(&quot;catfoxcat&quot;, [&quot;cat&quot;, &quot;fox&quot;])) print(sol.findWordConcatenation(&quot;catcatfoxfox&quot;, [&quot;cat&quot;, &quot;fox&quot;]))main() Time ComplexityThe time complexity of the above algorithm will be O(N M Len) where ‘N’ is the number of characters in the given string, ‘M’ is the total number of words, and ‘Len’ is the length of a word. Space ComplexityThe space complexity of the algorithm is O(M) since at most, we will be storing all the words in the two HashMaps. In the worst case, we also need O(N) space for the resulting list. So, the overall space complexity of the algorithm will be O(M+N).","categories":[{"name":"Grokking Interview Pattern","slug":"Grokking-Interview-Pattern","permalink":"https://hasuer.github.io/categories/Grokking-Interview-Pattern/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hasuer.github.io/tags/Interview/"}]},{"title":"2. Pattern Fast_Slow pointers","slug":"2. Pattern Fast_Slow pointers","date":"2024-05-01T16:36:30.000Z","updated":"2024-05-28T03:27:22.984Z","comments":true,"path":"2-pattern-fast-slow-pointers/index.html","link":"","permalink":"https://hasuer.github.io/2-pattern-fast-slow-pointers/index.html","excerpt":"","text":"IntroductionThe Fast &amp; Slow pointer approach, also known as the Hare &amp; Tortoise algorithm, is a pointer algorithm that uses two pointers which move through the array (or sequence/LinkedList) at different speeds. This approach is quite useful when dealing with cyclic LinkedLists or arrays. By moving at different speeds (say, in a cyclic LinkedList), the algorithm proves that the two pointers are bound to meet. The fast pointer should catch the slow pointer once both the pointers are in a cyclic loop. One of the famous problems solved using this technique was Finding a cycle in a LinkedList. Let’s jump onto this problem to understand the Fast &amp; Slow pattern. LinkedList Cycle (easy) Top Interview 150 | 141. Linked List Cycle Design Gurus Educative.io Problem StatementGiven the head of a Singly LinkedList, write a function to determine if the LinkedList has a cycle in it or not. Constraints: The number of the nodes in the list is in the range [0, 10^4]. 1 &lt;= Node.val &lt;= 10^5 SolutionImagine two racers running in a circular racing track. If one racer is faster than the other, the faster racer is bound to catch up and cross the slower racer from behind. We can use this fact to devise an algorithm to determine if a LinkedList has a cycle in it or not. Imagine we have a slow and a fast pointer to traverse the LinkedList. In each iteration, the slow pointer moves one step and the fast pointer moves two steps. This gives us two conclusions: If the LinkedList doesn’t have a cycle in it, the fast pointer will reach the end of the LinkedList before the slow pointer to reveal that there is no cycle in the LinkedList. The slow pointer will never be able to catch up to the fast pointer if there is no cycle in the LinkedList. If the LinkedList has a cycle, the fast pointer enters the cycle first, followed by the slow pointer. After this, both pointers will keep moving in the cycle infinitely. If at any stage both of these pointers meet, we can conclude that the LinkedList has a cycle in it. Let’s analyze if it is possible for the two pointers to meet. When the fast pointer is approaching the slow pointer from behind we have two possibilities: The fast pointer is one step behind the slow pointer. The fast pointer is two steps behind the slow pointer. All other distances between the fast and slow pointers will reduce to one of these two possibilities. Let’s analyze these scenarios, considering the fast pointer always moves first: If the fast pointer is one step behind the slow pointer: The fast pointer moves two steps and the slow pointer moves one step, and they both meet. If the fast pointer is two steps behind the slow pointer: The fast pointer moves two steps and the slow pointer moves one step. After the moves, the fast pointer will be one step behind the slow pointer, which reduces this scenario to the first scenario. This means that the two pointers will meet in the next iteration. This concludes that the two pointers will definitely meet if the LinkedList has a cycle. A similar analysis can be done where the slow pointer moves first. Here is a visual representation of the above discussion: CodeHere is what our algorithm will look like 12345678910111213141516171819202122232425262728293031323334#class Node:# def __init__(self, value, next=None):# self.val = value# self.next = nextclass Solution: def hasCycle(self, head): slow, fast = head, head while fast is not None and fast.next is not None: fast = fast.next.next # Move fast pointer two steps at a time slow = slow.next # Move slow pointer one step at a time if slow == fast: # Check if slow and fast pointers meet (cycle detected) return True # Found a cycle in the linked list return False # No cycle found in the linked listdef main(): sol = Solution() head = Node(1) head.next = Node(2) head.next.next = Node(3) head.next.next.next = Node(4) head.next.next.next.next = Node(5) head.next.next.next.next.next = Node(6) print(&quot;LinkedList has cycle: &quot; + str(sol.hasCycle(head))) head.next.next.next.next.next.next = head.next.next print(&quot;LinkedList has cycle: &quot; + str(sol.hasCycle(head))) head.next.next.next.next.next.next = head.next.next.next print(&quot;LinkedList has cycle: &quot; + str(sol.hasCycle(head)))main() Time ComplexityAs we have concluded above, once the slow pointer enters the cycle, the fast pointer will meet the slow pointer in the same loop. Therefore, the time complexity of our algorithm will be O(N) where ‘N’ is the total number of nodes in the LinkedList. Space ComplexityThe algorithm runs in constant space O(1). Similar ProblemsProblem 1: Given the head of a LinkedList with a cycle, find the length of the cycle. Solution: We can use the above solution to find the cycle in the LinkedList. Once the fast and slow pointers meet, we can save the slow pointer and iterate the whole cycle with another pointer until we see the slow pointer again to find the length of the cycle. Here is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#class Node:# def __init__(self, value, next=None):# self.val = value# self.next = nextclass Solution: def findCycleLength(self, head): # Initialize slow and fast pointers to the head of the linked list slow, fast = head, head # Traverse the linked list using slow and fast pointers while fast is not None and fast.next is not None: # Move fast pointer two steps at a time and slow pointer one step at a time fast = fast.next.next slow = slow.next # Check if the slow and fast pointers meet, indicating the presence of a cycle if slow == fast: # found the cycle return self.calculate_cycle_length(slow) return 0 def calculate_cycle_length(self, slow): current = slow cycle_length = 0 # Count the length of the cycle by moving through it while True: current = current.next cycle_length += 1 # If we reach the starting point, we have completed a full cycle if current == slow: break return cycle_lengthdef main(): sol = Solution() head = Node(1) head.next = Node(2) head.next.next = Node(3) head.next.next.next = Node(4) head.next.next.next.next = Node(5) head.next.next.next.next.next = Node(6) # Create a cycle in the linked list head.next.next.next.next.next.next = head.next.next # Find and print the length of the cycle print(&quot;LinkedList cycle length: &quot; + str(sol.findCycleLength(head))) # Create a longer cycle in the linked list head.next.next.next.next.next.next = head.next.next.next # Find and print the length of the longer cycle print(&quot;LinkedList cycle length: &quot; + str(sol.findCycleLength(head)))main() Time and Space Complexity: The above algorithm runs in O(N) time complexity and O(1) space complexity. Start of LinkedList Cycle (medium) 142. Linked List Cycle II Design Gurus Educative.io Problem StatementGiven the head of a Singly LinkedList that contains a cycle, write a function to find the starting node of the cycle. SolutionIf we know the length of the LinkedList cycle, we can find the start of the cycle through the following steps: Take two pointers. Let’s call them pointer1 and pointer2. Initialize both pointers to point to the start of the LinkedList. We can find the length of the LinkedList cycle using the approach discussed in LinkedList Cycle. Let’s assume that the length of the cycle is ‘K’ nodes. Move pointer2 ahead by ‘K’ nodes. Now, keep incrementing pointer1 and pointer2 until they both meet. As pointer2 is ‘K’ nodes ahead of pointer1, which means, pointer2 must have completed one loop in the cycle when both pointers meet. Their meeting point will be the start of the cycle. Let’s visually see this with the above-mentioned Example-1: We can use the algorithm discussed in LinkedList Cycle to find the length of the cycle and then follow the above-mentioned steps to find the start of the cycle. CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#class Node:# def __init__(self, value, next=None):# self.val = value# self.next = nextclass Solution: def findCycleStart(self, head): cycle_length = 0 # Find the LinkedList cycle using Floyd&#x27;s Tortoise and Hare algorithm slow, fast = head, head while (fast is not None and fast.next is not None): fast = fast.next.next # Move two steps at a time slow = slow.next # Move one step at a time if slow == fast: # Found the cycle cycle_length = self.calculate_cycle_length(slow) break return self.find_start(head, cycle_length) def calculate_cycle_length(self, slow): current = slow cycle_length = 0 # Calculate the length of the cycle by moving through it while True: current = current.next cycle_length += 1 if current == slow: # Reached back to the starting point of the cycle break return cycle_length def find_start(self, head, cycle_length): pointer1 = head pointer2 = head # Move pointer2 ahead &#x27;cycle_length&#x27; nodes while cycle_length &gt; 0: pointer2 = pointer2.next cycle_length -= 1 # Increment both pointers until they meet at the start of the cycle while pointer1 != pointer2: pointer1 = pointer1.next pointer2 = pointer2.next return pointer1def main(): sol = Solution() head = Node(1) head.next = Node(2) head.next.next = Node(3) head.next.next.next = Node(4) head.next.next.next.next = Node(5) head.next.next.next.next.next = Node(6) # Create a cycle by connecting nodes head.next.next.next.next.next.next = head.next.next print(&quot;LinkedList cycle start: &quot; + str(sol.findCycleStart(head).val)) # Create a different cycle head.next.next.next.next.next.next = head.next.next.next print(&quot;LinkedList cycle start: &quot; + str(sol.findCycleStart(head).val)) # Create a cycle that points back to the head head.next.next.next.next.next.next = head print(&quot;LinkedList cycle start: &quot; + str(sol.findCycleStart(head).val))main() Time ComplexityAs we know, finding the cycle in a LinkedList with ‘N’ nodes and also finding the length of the cycle requires O(N). Also, as we saw in the above algorithm, we will need O(N) to find the start of the cycle. Therefore, the overall time complexity of our algorithm will be O(N). Space ComplexityThe algorithm runs in constant space O(1). Happy Number (medium) Top Interview 150 | 202. Happy Number Design Gurus Educative.io Problem StatementAny number will be called a happy number if, after repeatedly replacing it with a number equal to the sum of the square of all of its digits, leads us to number ‘1’. All other (not-happy) numbers will never reach ‘1’. Instead, they will be stuck in a cycle of numbers which does not include ‘1’. Example 1: 123Input: 23 Output: true (23 is a happy number) Explanations: Here are the steps to find out that 23 is a happy number: 2^2 + 3 ^2 = 4 + 9 = 13 1^2 + 3^2 = 1 + 9 = 10 1^2 + 0^2 = 1 + 0 = 1 Example 2: 123Input: 12 Output: false (12 is not a happy number) Explanations: Here are the steps to find out that 12 is not a happy number: 1^2 + 2 ^2 = 1 + 4 = 5 5^2 = 25 2^2 + 5^2 = 4 + 25 = 29 2^2 + 9^2 = 4 + 81 = 85 8^2 + 5^2 = 64 + 25 = 89 8^2 + 9^2 = 64 + 81 = 145 1^2 + 4^2 + 5^2 = 1 + 16 + 25 = 42 4^2 + 2^2 = 16 + 4 = 20 2^2 + 0^2 = 4 + 0 = 4 4^2 = 16 1^2 + 6^2 = 1 + 36 = 37 3^2 + 7^2 = 9 + 49 = 58 5^2 + 8^2 = 25 + 64 = 89 Step ‘13’ leads us back to step ‘5’ as the number becomes equal to ‘89’, this means that we can never reach ‘1’, therefore, ‘12’ is not a happy number. Constraints: 1 &lt;= n &lt;= 231 - 1 SolutionThe process, defined above, to find out if a number is a happy number or not, always ends in a cycle. If the number is a happy number, the process will be stuck in a cycle on number ‘1,’ and if the number is not a happy number then the process will be stuck in a cycle with a set of numbers. As we saw in Example-2 while determining if ‘12’ is a happy number or not, our process will get stuck in a cycle with the following numbers: 89 -&gt; 145 -&gt; 42 -&gt; 20 -&gt; 4 -&gt; 16 -&gt; 37 -&gt; 58 -&gt; 89 We saw in the LinkedList Cycle problem that we can use the Fast &amp; Slow pointers method to find a cycle among a set of elements. As we have described above, each number will definitely have a cycle. Therefore, we will use the same fast &amp; slow pointer strategy to find the cycle and once the cycle is found, we will see if the cycle is stuck on number ‘1’ to find out if the number is happy or not. Here is the visual representation of this algorithm for Example-2: CodeHere is what our algorithm will look like: 12345678910111213141516171819202122232425262728class Solution: def find(self, num): slow, fast = num, num while True: slow = self.find_square_sum(slow) # move one step fast = self.find_square_sum(self.find_square_sum(fast)) # move two steps if slow == fast: # found the cycle break return slow == 1 # see if the cycle is stuck on the number &#x27;1&#x27; def find_square_sum(self, num): _sum = 0 while (num &gt; 0): digit = num % 10 _sum += digit * digit num //= 10 return _sumdef main(): sol = Solution() print(sol.find(23)) print(sol.find(12))main() Time ComplexityThe time complexity of the algorithm is difficult to determine. However we know the fact that all unhappy numbers eventually get stuck in the cycle: 4 -&gt; 16 -&gt; 37 -&gt; 58 -&gt; 89 -&gt; 145 -&gt; 42 -&gt; 20 -&gt; 4 This sequence behavior tells us two things: If the number NN is less than or equal to 1000, then we reach the cycle or ‘1’ in at most 1001 steps. For N &gt; 1000, suppose the number has ‘M’ digits and the next number is ‘N1’. From the above Wikipedia link, we know that the sum of the squares of the digits of ‘N’ is at most $9^2M$, or $81M$ (this will happen when all digits of ‘N’ are ‘9’). This means: $N1 &lt; 81M$ As we know $M = log(N+1)$ Therefore: $N1 &lt; 81 * log(N+1) =&gt; N1 = O(logN)$ This concludes that the above algorithm will have a time complexity of O(logN). Space ComplexityThe algorithm runs in constant space O(1). Middle of the LinkedList (easy)876. Middle of the Linked List Design Gurus Educative.io Problem StatementGiven the head of a Singly LinkedList, write a method to return the middle node of the LinkedList. If the total number of nodes in the LinkedList is even, return the second middle node. Example 1: 12Input: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; nullOutput: 3 Example 2: 12Input: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; nullOutput: 4 Example 3: 12Input: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; nullOutput: 4 Constraints: The number of nodes in the list is in the range [1, 100]. 1 &lt;= Node.val &lt;= 100 SolutionOne brute force strategy could be to first count the number of nodes in the LinkedList and then find the middle node in the second iteration. Can we do this in one iteration? We can use the Fast &amp; Slow pointers method such that the fast pointer is always twice the nodes ahead of the slow pointer. This way, when the fast pointer reaches the end of the LinkedList, the slow pointer will be pointing at the middle node. let’s visualize example 3 via the below diagram. CodeHere is what our algorithm will look like: 1234567891011121314151617181920212223242526272829303132333435363738394041#class Node:# def __init__(self, value, next=None):# self.val = value# self.next = next# Function to find the middle of a linked listdef findMiddle(head): slow = head fast = head # Traverse the linked list with two pointers (slow and fast) # until the fast pointer reaches the end or goes one step further while (fast is not None and fast.next is not None): slow = slow.next fast = fast.next.next # Return the node pointed to by the slow pointer, which is the middle return slow# Main function to test the findMiddle functiondef main(): head = Node(1) head.next = Node(2) head.next.next = Node(3) head.next.next.next = Node(4) head.next.next.next.next = Node(5) # Print the middle node&#x27;s value print(&quot;Middle Node: &quot; + str(findMiddle(head).val)) head.next.next.next.next.next = Node(6) # Print the middle node&#x27;s value after adding a new node print(&quot;Middle Node: &quot; + str(findMiddle(head).val)) head.next.next.next.next.next.next = Node(7) # Print the middle node&#x27;s value after adding another new node print(&quot;Middle Node: &quot; + str(findMiddle(head).val))# Call the main function to execute the codemain() Time complexityThe above algorithm will have a time complexity of O(N) where ‘N’ is the number of nodes in the LinkedList. Space complexityThe algorithm runs in constant space O(1). Problem Challenge 1234. Palindrome Linked List Design Gurus Educative.io Palindrome LinkedList (medium)Given the head of a Singly LinkedList, write a method to check if the LinkedList is a palindrome or not. Your algorithm should use constant space and the input LinkedList should be in the original form once the algorithm is finished. The algorithm should have O(N)O(N) time complexity where ‘N’ is the number of nodes in the LinkedList. Example 1: 12Input: 2 -&gt; 4 -&gt; 6 -&gt; 4 -&gt; 2 -&gt; nullOutput: true Example 2: 12Input: 2 -&gt; 4 -&gt; 6 -&gt; 4 -&gt; 2 -&gt; 2 -&gt; nullOutput: false Constraints: The number of nodes in the list is in the range [1, 10&lt;sup&gt;5&lt;/sup&gt;]. 0 &lt;= Node.val &lt;= 9 Solution As we know, a palindrome LinkedList will have nodes values that read the same backward or forward. This means that if we divide the LinkedList into two halves, the node values of the first half in the forward direction should be similar to the node values of the second half in the backward direction. As we have been given a Singly LinkedList, we can’t move in the backward direction. To handle this, we will perform the following steps: We can use the Fast &amp; Slow pointers method similar to Middle of the LinkedList to find the middle node of the LinkedList. Once we have the middle of the LinkedList, we will reverse the second half. Then, we will compare the first half with the reversed second half to see if the LinkedList represents a palindrome. Finally, we will reverse the second half of the LinkedList again to revert and bring the LinkedList back to its original form. Here is the visual representation of this algorithm for Example-2: CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#class Node:# def __init__(self, value, next=None):# self.val = value# self.next = nextclass Solution: def isPalindrome(self, head): if head is None or head.next is None: return True # find middle of the LinkedList slow, fast = head, head while (fast is not None and fast.next is not None): slow = slow.next fast = fast.next.next head_second_half = self.reverse(slow) # reverse the second half # store the head of reversed part to revert back later copy_head_second_half = head_second_half # compare the first and the second half while (head is not None and head_second_half is not None): if head.val != head_second_half.val: break # not a palindrome head = head.next head_second_half = head_second_half.next self.reverse(copy_head_second_half) # revert the reverse of the second half if head is None or head_second_half is None: # if both halves match return True return False def reverse(self, head): prev = None while (head is not None): next = head.next head.next = prev prev = head head = next return prevdef main(): sol = Solution() head = Node(2) head.next = Node(4) head.next.next = Node(6) head.next.next.next = Node(4) head.next.next.next.next = Node(2) print(&quot;Is palindrome: &quot; + str(sol.isPalindrome(head))) head.next.next.next.next.next = Node(2) print(&quot;Is palindrome: &quot; + str(sol.isPalindrome(head)))main() Time complexityThe above algorithm will have a time complexity of O(N) where ‘N’ is the number of nodes in the LinkedList. Space complexityThe algorithm runs in constant space O(1). # Problem Challenge 2143. Reorder List Design Gurus Educative.io Rearrange a LinkedList (medium)Given the head of a Singly LinkedList, write a method to modify the LinkedList such that the nodes from the second half of the LinkedList are inserted alternately to the nodes from the first half in reverse order. So if the LinkedList has nodes 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; null, your method should return 1 -&gt; 6 -&gt; 2 -&gt; 5 -&gt; 3 -&gt; 4 -&gt; null. Your algorithm should not use any extra space and the input LinkedList should be modified in-place. Example 1: 12Input: 2 -&gt; 4 -&gt; 6 -&gt; 8 -&gt; 10 -&gt; 12 -&gt; nullOutput: 2 -&gt; 12 -&gt; 4 -&gt; 10 -&gt; 6 -&gt; 8 -&gt; null Example 2: 12Input: 2 -&gt; 4 -&gt; 6 -&gt; 8 -&gt; 10 -&gt; nullOutput: 2 -&gt; 10 -&gt; 4 -&gt; 8 -&gt; 6 -&gt; null Constraints: The number of nodes in the list is in the range [1, 5 * 10^4]. 1 &lt;= Node.val &lt;= 1000 SolutionThis problem shares similarities with Palindrome LinkedList. To rearrange the given LinkedList we will follow the following steps: We can use the Fast &amp; Slow pointers method similar to Middle of the LinkedList to find the middle node of the LinkedList. Once we have the middle of the LinkedList, we will reverse the second half of the LinkedList. Finally, we’ll iterate through the first half and the reversed second half to produce a LinkedList in the required order. Here is the visual representation of this algorithm for Example-1: CodeHere is what our algorithm will look like: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#class Node:# def __init__(self, value, next=None):# self.val = value# self.next = nextclass Solution: def reorder(self, head): if head is None or head.next is None: return head # find middle of the LinkedList slow, fast = head, head while fast is not None and fast.next is not None: slow = slow.next fast = fast.next.next # slow is now pointing to the middle node head_second_half = self.reverse(slow) # reverse the second half head_first_half = head # rearrange to produce the LinkedList in the required order while head_first_half is not None and head_second_half is not None: temp = head_first_half.next head_first_half.next = head_second_half head_first_half = temp temp = head_second_half.next head_second_half.next = head_first_half head_second_half = temp # set the next of the last node to &#x27;None&#x27; if head_first_half is not None: head_first_half.next = None return head def reverse(self, head): prev = None while head is not None: next = head.next head.next = prev prev = head head = next return prev def print_list(self, head): temp = head while temp is not None: print(str(temp.val) + &quot; &quot;, end=&#x27;&#x27;) temp = temp.next print()def main(): sol = Solution() head = Node(2) head.next = Node(4) head.next.next = Node(6) head.next.next.next = Node(8) head.next.next.next.next = Node(10) head.next.next.next.next.next = Node(12) sol.reorder(head) sol.print_list(head)main() Time ComplexityThe above algorithm will have a time complexity of O(N) where ‘N’ is the number of nodes in the LinkedList. Space ComplexityThe algorithm runs in constant space O(1). #Problem Challenge 3457. Circular Array Loop Design Gurus Educative.io Cycle in a Circular Array (hard)We are given an array containing positive and negative numbers. Suppose the array contains a number ‘M’ at a particular index. Now, if ‘M’ is positive we will move forward ‘M’ indices and if ‘M’ is negative move backwards ‘M’ indices. You should assume that the array is circular which means two things: If, while moving forward, we reach the end of the array, we will jump to the first element to continue the movement. If, while moving backward, we reach the beginning of the array, we will jump to the last element to continue the movement. Write a method to determine if the array has a cycle. The cycle should have more than one element and should follow one direction which means the cycle should not contain both forward and backward movements. Example 1: 123Input: [1, 2, -1, 2, 2]Output: trueExplanation: The array has a cycle among indices: 0 -&gt; 1 -&gt; 3 -&gt; 0 Example 2: 123Input: [2, 2, -1, 2]Output: trueExplanation: The array has a cycle among indices: 1 -&gt; 3 -&gt; 1 Example 3: 123Input: [2, 1, -1, -2]Output: falseExplanation: The array does not have any cycle. Constraints: 1 &lt;= nums.length &lt;= 5000 `-1000 &lt;= nums[i] &lt;= 1000 nums[i] != 0 SolutionThis problem involves finding a cycle in the array and, as we know, the Fast &amp; Slow pointer method is an efficient way to do that. We can start from each index of the array to find the cycle. If a number does not have a cycle we will move forward to the next element. There are a couple of additional things we need to take care of: As mentioned in the problem, the cycle should have more than one element. This means that when we move a pointer forward, if the pointer points to the same element after the move, we have a one-element cycle. Therefore, we can finish our cycle search for the current element. The other requirement mentioned in the problem is that the cycle should not contain both forward and backward movements. We will handle this by remembering the direction of each element while searching for the cycle. If the number is positive, the direction will be forward and if the number is negative, the direction will be backward. So whenever we move a pointer forward, if there is a change in the direction, we will finish our cycle search right there for the current element. Here is the visual representation of this algorithm for Example-1: CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution: def loopExists(self, arr): for i in range(len(arr)): is_forward = arr[i] &gt;= 0 # if we are moving forward or not slow, fast = i, i # if slow or fast becomes &#x27;-1&#x27; this means we can&#x27;t find cycle for this number while True: # move one step for slow pointer slow = self.find_next_index(arr, is_forward, slow) # move one step for fast pointer fast = self.find_next_index(arr, is_forward, fast) if (fast != -1): # move another step for fast pointer fast = self.find_next_index(arr, is_forward, fast) if slow == -1 or fast == -1 or slow == fast: break if slow != -1 and slow == fast: return True return False def find_next_index(self, arr, is_forward, current_index): direction = arr[current_index] &gt;= 0 if is_forward != direction: return -1 # change in direction, return -1 next_index = (current_index + arr[current_index]) % len(arr) # one element cycle, return -1 if next_index == current_index: next_index = -1 return next_indexdef main(): sol = Solution() print(sol.loopExists([1, 2, -1, 2, 2])) print(sol.loopExists([2, 2, -1, 2])) print(sol.loopExists([2, 1, -1, -2]))main() Time ComplexityThe above algorithm will have a time complexity of O(N^2) where ‘N’ is the number of elements in the array. This complexity is due to the fact that we are iterating all elements of the array and trying to find a cycle for each element. Space ComplexityThe algorithm runs in constant space O(1). An Alternate ApproachIn our algorithm, we don’t keep a record of all the numbers that have been evaluated for cycles. We know that all such numbers will not produce a cycle for any other instance as well. If we can remember all the numbers that have been visited, our algorithm will improve to O(N) as, then, each number will be evaluated for cycles only once. We can keep track of this by creating a separate array however the space complexity of our algorithm will increase to O(N).","categories":[{"name":"Grokking Interview Pattern","slug":"Grokking-Interview-Pattern","permalink":"https://hasuer.github.io/categories/Grokking-Interview-Pattern/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hasuer.github.io/tags/Interview/"}]},{"title":"1. Pattern Two Pointers","slug":"1. Pattern Two Pointers","date":"2024-05-01T01:42:18.000Z","updated":"2024-05-28T03:27:15.829Z","comments":true,"path":"1-pattern-two-pointers/index.html","link":"","permalink":"https://hasuer.github.io/1-pattern-two-pointers/index.html","excerpt":"","text":"IntroductionIntroduction to Two Pointers Pattern In problems where we deal with sorted arrays (or linked-lists) and need to find a set of elements that fulfill certain constraints, the Two Pointers approach becomes quite useful. The set of elements could be a pair, a triplet or even a subarray. For example, take a look at the following problem: Given an array of sorted numbers and a target sum, find a pair in the array whose sum is equal to the given target. To solve this problem, we can consider each element one by one (indicated by the first pointer) and iterate through the remaining elements (indicated by the second pointer) to find a pair with the given sum. The time complexity of this algorithm will be , where ‘N’ is the number of elements in the input array. Given that the input array is sorted, an efficient approach would be to start with one pointer at the beginning and another pointer at the end. At every step, we will check if the numbers indicated by the two pointers add up to the target sum. If they do not, we have two options: If the sum of the two numbers indicated by the two pointers is greater than the target sum, this means that we need a pair with a smaller sum. To explore more pairs, we can decrement the end-pointer. If the sum of the two numbers indicated by the two pointers is smaller than the target sum, this means that we need a pair with a larger sum. To explore more pairs, we can increment the start-pointer. Here is the visual representation of this algorithm: The time complexity of the above algorithm will be O(N). In the following chapters, we will apply the Two Pointers approach to solve a few problems. Pair with Target Sum (easy) Similar | Top Interview 150 | 1. Two Sum Design Gurus Educative.io Problem StatementGiven an array of numbers sorted in ascending order and a target sum, find a pair in the array whose sum is equal to the given target. If no such pair exists return [-1, -1]. Write a function to return the indices of the two numbers (i.e. the pair) such that they add up to the given target. Example 1: 123Input: [1, 2, 3, 4, 6], target=6Output: [1, 3]Explanation: The numbers at index 1 and 3 add up to 6: 2+4=6 Example 2: 123Input: [2, 5, 9, 11], target=11Output: [0, 2]Explanation: The numbers at index 0 and 2 add up to 11: 2+9=11 Constraints: 2 &lt;= arr.length &lt;= 10^4 -109 &lt;= arr[i] &lt;= 10^9 -109 &lt;= target &lt;= 10^9 SolutionSince the given array is sorted, a brute-force solution could be to iterate through the array, taking one number at a time and searching for the second number through Binary Search. The time complexity of this algorithm will be O(N\\logN)*. Can we do better than this? We can follow the Two Pointers approach. We will start with one pointer pointing to the beginning of the array and another pointing at the end. At every step, we will see if the numbers pointed by the two pointers add up to the target sum. If they do, we have found our pair; otherwise, we will do one of two things: If the sum of the two numbers pointed by the two pointers is greater than the target sum, this means that we need a pair with a smaller sum. So, to try more pairs, we can decrement the end-pointer. If the sum of the two numbers pointed by the two pointers is smaller than the target sum, this means that we need a pair with a larger sum. So, to try more pairs, we can increment the start-pointer. Here is the visual representation of this algorithm for Example-1: CodeHere is what our algorithm will look like: 12345678910111213141516171819202122class Solution: def search(self, arr, target_sum): left, right = 0, len(arr) - 1 while(left &lt; right): current_sum = arr[left] + arr[right] if current_sum == target_sum: return [left, right] if target_sum &gt; current_sum: left += 1 # we need a pair with a bigger sum else: right -= 1 # we need a pair with a smaller sum return [-1, -1]def main(): sol = Solution(); print(sol.search([1, 2, 3, 4, 6], 6)) print(sol.search([2, 5, 9, 11], 11))main() Time Complexity Initialization: Constant time, O(1), as it involves assigning values to left and right. While Loop: The while loop runs as long as left is less than right. In the worst case, this loop iterates over all elements of the array once. This happens when no pair is found, or the pair is found at the extreme ends of the array. Each iteration involves a constant amount of work: calculating currentSum, comparing it with targetSum, and then incrementing left or decrementing right. Therefore, the loop runs in O(n) time, where is the number of elements in the array. Overall: The dominant factor in this algorithm is the while loop, making the overall time complexity O(n). Space Complexity The algorithm uses a fixed amount of extra space: variables left, right, and currentSum. It does not depend on the size of the input array, as no additional data structures are used that grow with the input size. Thus, the space complexity is O(1), constant space. In summary, the algorithm has a time complexity of O(n)and a space complexity of O(1). An Alternate approach Similar | Top Interview 150 | 1. Two Sum Instead of using a two-pointer or a binary search approach, we can utilize a HashTable to search for the required pair. We can iterate through the array one number at a time. Let’s say during our iteration we are at number ‘X’, so we need to find ‘Y’ such that “X + Y == Target”. We will do two things here: Search for ‘Y’ (which is equivalent to “Target - X“ in the HashTable. If it is there, we have found the required pair. Otherwise, insert “X” in the HashTable, so that we can search it for the later numbers. Here is what our algorithm will look like: 123456789101112131415161718class Solution: def pair_with_targetsum(self, arr, target_sum): nums = &#123;&#125; # to store numbers and their indices for i, num in enumerate(arr): if target_sum - num in nums: return [nums[target_sum - num], i] else: nums[num] = i return [-1, -1]def main(): sol = Solution() print(sol.pair_with_targetsum([1, 2, 3, 4, 6], 6)) print(sol.pair_with_targetsum([2, 5, 9, 11], 11))main() Time Complexity HashMap Initialization: Constant time, (O(1)). For Loop: The for loop iterates over each element of the array once. In each iteration, the algorithm checks if the element is already present in the HashMap (or dictionary in Python) and either returns a result or inserts an element into the HashMap. This element checking or insertion operations of a HashMap generally operate in (O(1)) time due to efficient hashing. However, in the worst case (e.g., when many hash collisions occur), these operations can degrade to (O(n)). Under the assumption of a good hash function with minimal collisions, these operations can be considered (O(1)). Therefore, the loop runs in (O(n)) time in the average case, where (n) is the number of elements in the array. Overall: The dominating factor in this algorithm is the for loop. Under the assumption of efficient hashing, the overall average time complexity is (O(n)). Space Complexity The algorithm uses a HashMap to store elements from the array. In the worst case, this map can store all elements of the array if no pair is found that adds up to the target sum Thus, the space complexity is proportional to the number of elements in the array, which is (O(n)). In summary, the algorithm has an average time complexity of (O(n)) and a space complexity of (O(n)). The time complexity can degrade to (O(n^2)) in the worst case due to potential hash collisions, but this is generally not the common case with a good hash function. Remove Duplicates (easy)Top Interview 150 | 26. Remove Duplicates from Sorted Array Similar | Top Interview 150 | 80. Remove Duplicates from Sorted Array II Similar | 83. Remove Duplicates from Sorted List Similar | Top Interview 150 | 82. Remove Duplicates from Sorted List II Similar | 1089. Duplicate Zeros Design Gurus Educative.io Find Non-Duplicate Number Instances Problem StatementGiven an array of sorted numbers, move all non-duplicate number instances at the beginning of the array in-place. The non-duplicate numbers should be sorted and you should not use any extra space so that the solution has constant space complexity i.e., . Move all the unique number instances at the beginning of the array and after moving return the length of the subarray that has no duplicate in it. Example 1: 123Input: [2, 3, 3, 3, 6, 9, 9]Output: 4Explanation: The first four elements after moving element will be [2, 3, 6, 9]. Example 2: 123Input: [2, 2, 2, 11]Output: 2Explanation: The first two elements after moving elements will be [2, 11]. Constraints: 1 &lt;= nums.length &lt;= 3 * 10^4 -100 &lt;= nums[i] &lt;= 100 nums is sorted in non-decreasing order. SolutionIn this problem, we need to separate the duplicate elements in-place such that the resultant length of the array remains sorted. As the input array is sorted, one way to do this is to shift the elements left whenever we encounter duplicates. In other words, we will keep one pointer for iterating the array and one pointer for placing the next non-duplicate number. So our algorithm will be to iterate the array and whenever we see a non-duplicate number we move it next to the last non-duplicate number we’ve seen. Here is the visual representation of this algorithm for Example-1: CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233343536class Solution: def moveElements(self, arr): # Initialize the index for the next non-duplicate element next_non_duplicate = 1 # Initialize the main loop index i = 0 # Iterate through the array while i &lt; len(arr): # Check if the current element is different from the previous element if arr[next_non_duplicate - 1] != arr[i]: # If different, update the next_non_duplicate element and copy the current element arr[next_non_duplicate] = arr[i] # Increment the next_non_duplicate index next_non_duplicate += 1 # Increment the main loop index i += 1 # Return the length of the modified array as the result return next_non_duplicate# Entry point of the programdef main(): # Create an instance of the Solution class sol = Solution() # Test the &#x27;moveElements&#x27; method with example arrays print(sol.moveElements([2, 3, 3, 3, 6, 9, 9])) # Output: 4 (modified array: [2, 3, 6, 9, 6, 9, 9]) print(sol.moveElements([2, 2, 2, 11])) # Output: 2 (modified array: [2, 11, 2, 11])# Execute the main functionmain() Time ComplexityThe time complexity of the above algorithm will be O(N), where ‘N’ is the total number of elements in the given array. Space ComplexityThe algorithm runs in constant space O(1). Similar QuestionsTop Interview 150 |27. Remove Element Problem 1: Given an unsorted array of numbers and a target ‘key’, remove all instances of ‘key’ in-place and return the new length of the array. Example 1: 123Input: [3, 2, 3, 6, 3, 10, 9, 3], Key=3Output: 4Explanation: The first four elements after removing every &#x27;Key&#x27; will be [2, 6, 10, 9]. Example 2: 123Input: [2, 11, 2, 2, 1], Key=2Output: 2Explanation: The first two elements after removing every &#x27;Key&#x27; will be [11, 1]. Solution: This problem is quite similar to our parent problem. We can follow a two-pointer approach and shift numbers left upon encountering the ‘key’. Here is what the code will look like: 123456789101112131415161718192021222324class Solution: def remove(self, arr, key): nextElement = 0 # Initialize a variable to keep track of the next non-&#x27;key&#x27; element index. # Iterate through the input array &#x27;arr&#x27;. for i in range(len(arr)): if arr[i] != key: # Check if the current element is not equal to &#x27;key&#x27;. arr[nextElement] = arr[i] # If not equal, copy the current element to the next available position. nextElement += 1 # Increment the nextElement index to prepare for the next non-&#x27;key&#x27; element. return nextElement # Return the length of the modified array, which represents the new length.def main(): sol = Solution() # Test case 1 print(&quot;Array new length: &quot; + str(sol.remove([3, 2, 3, 6, 3, 10, 9, 3], 3))) # Test case 2 print(&quot;Array new length: &quot; + str(sol.remove([2, 11, 2, 2, 1], 2)))main() Time and Space Complexity: The time complexity of the above algorithm will be O(N), where ‘N’ is the total number of elements in the given array. The algorithm runs in constant space O(1). Squaring a Sorted Array (easy) 977. Squares of a Sorted Array Design Gurus Educative.io Problem StatementGiven a sorted array, create a new array containing squares of all the number of the input array in the sorted order. Example 1: 12Input: [-2, -1, 0, 2, 3]Output: [0, 1, 4, 4, 9] Example 2: 12Input: [-3, -1, 0, 1, 2]Output: [0 1 1 4 9] Constraints: 1 &lt;= arr.length &lt;= 10^4 -104 &lt;= arr[i] &lt;= 10^4 arr is sorted in non-decreasing order. SolutionWe can use a brute-force approach to iterate the input array and calculate the square of each number. We can store these squares in a new array and then sort the resulting array using any sorting algorithm like Quicksort or Mergesort. Because of the sorting, this approach has a time complexity of O(N \\ logN)*, where N is the length of the input array. Here is a Python solution for this approach: 12def sorted_squares(nums): return sorted([num**2 for num in nums]) Can we do better than this? Can we avoid sorting? Is it possible to generate the output in sorted order? The tricky part is that we can have negative numbers in the input array, which makes it harder to generate the output array with squares in sorted order. One easier approach could be to first locate the index of the first positive number in the input array. After that, we can utilize the Two Pointers technique to iterate over the array, with one pointer moving forward to scan positive numbers, and the other pointer moving backward to scan negative numbers. At each step, we can compare the squares of the numbers pointed by both pointers and append the smaller square to the output array. For the above-mentioned Example-1, we will do something like this: Since the numbers at both ends can give us the largest square, an alternate approach could be to use two pointers starting at both ends of the input array. At any step, whichever pointer gives us the bigger square, we add it to the result array and move to the next/previous number. Please note that we will be appending the bigger square (as opposed to the previous approach) because the two pointers are moving from larger squares to smaller squares. For that, we will be inserting the squares at the end of the output array. For the above-mentioned Example-1, we will do something like this: Here’s a detailed walkthrough of the algorithm: We start by obtaining the length of the input array, arr, which we store in variable n. Then, we create a new array, squares, of the same length to hold the squared values. We also create a variable highestSquareIdx and set it to n - 1, the last index of squares, which will help us populate the squares array from the highest (rightmost) index towards the lowest (leftmost). We initialize two pointers, left and right, to 0 and n - 1, respectively. These pointers represent the indices of the elements at the start (lowest) and end (highest) of the array. We enter a loop that continues as long as left is less than or equal to right. In each iteration, we calculate the squares of the elements at the left and right indices, storing them in leftSquare and rightSquare respectively. We then compare leftSquare with rightSquare. The larger of these two squares is inserted at the position of highestSquareIdx in the squares array, and highestSquareIdx is decremented. If leftSquare was larger, we increment left to move towards the higher numbers in the array. If rightSquare was larger or equal, we decrement right to move towards the lower numbers in the array. We’re comparing absolute square values, so even if numbers in the array are negative, we’re dealing with their positive square. This process repeats, filling up the squares array from right to left, until left and right meet or cross each other. At this point, the squares array is filled with the squares of the numbers in the input array, sorted in ascending order. This array is then returned as the result. CodeHere is the code for the second approach discussed above: 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution: def makeSquares(self, arr): # Get the length of the input array n = len(arr) # Create a list to store the squares, initialized with zeros squares = [0 for x in range(n)] # Initialize the index for the highest square in the output array highestSquareIdx = n - 1 # Initialize two pointers for the left and right ends of the input array left, right = 0, n - 1 # Iterate over the input array from both ends towards the center while left &lt;= right: # Calculate the squares of the elements at the left and right pointers leftSquare = arr[left] * arr[left] rightSquare = arr[right] * arr[right] # Compare the squares and store the larger square in the output array if leftSquare &gt; rightSquare: squares[highestSquareIdx] = leftSquare left += 1 else: squares[highestSquareIdx] = rightSquare right -= 1 # Move to the next index in the output array highestSquareIdx -= 1 # Return the resulting list of squares return squaresdef main(): sol = Solution() # Test the makeSquares method with example inputs print(&quot;Squares: &quot; + str(sol.makeSquares([-2, -1, 0, 2, 3]))) print(&quot;Squares: &quot; + str(sol.makeSquares([-3, -1, 0, 1, 2])))main() Time complexityThe time complexity of the above algorithm will be O(N) as we are iterating the input array only once. Space complexityThe space complexity of the above algorithm will also be O(N); this space will be used for the output array. *Triplet Sum to Zero (medium) Top Interview 150 | 15. 3Sum Design Gurus Educative.io Problem StatementGiven an array of unsorted numbers, find all unique triplets in it that add up to zero. Example 1: 123Input: [-3, 0, 1, 2, -1, 1, -2]Output: [[-3, 1, 2], [-2, 0, 2], [-2, 1, 1], [-1, 0, 1]]Explanation: There are four unique triplets whose sum is equal to zero. smallest sum.&#x27; Example 2: 123Input: [-5, 2, -1, -2, 3]Output: [[-5, 2, 3], [-2, -1, 3]]Explanation: There are two unique triplets whose sum is equal to zero. Constraints: 3 &lt;= arr.length &lt;= 3000 -105 &lt;= arr[i] &lt;= 105 SolutionThis problem follows the Two Pointers pattern and shares similarities with Pair with Target Sum. A couple of differences are that the input array is not sorted and instead of a pair we need to find triplets with a target sum of zero. To follow a similar approach, first, we will sort the array and then iterate through it taking one number at a time. Let’s say during our iteration we are at number ‘X’, so we need to find ‘Y’ and ‘Z’ such that X + Y + Z == 0. At this stage, our problem translates into finding a pair whose sum is equal to “-X” (as from the above equation Y + Z == -X). Another difference from Pair with Target Sum is that we need to find all the unique triplets. To handle this, we have to skip any duplicate number. Since we will be sorting the array, so all the duplicate numbers will be next to each other and are easier to skip. Here is the detailed walk through of the algorithm: The method searchTriplets is the main method that orchestrates the process. The algorithm starts by sorting the input array. It then starts iterating over the array. For each element, it calls the method searchPair to find pairs in the rest of the array that add up to the negative value of the current element. The purpose of this is to find three numbers that add up to zero (i.e., the current number and two other numbers that add up to the negative of the current number). The searchPair method uses the two-pointer technique to find pairs that add up to a given target. It starts with one pointer at the beginning of the array (or the index after the current number) and another pointer at the end of the array. It calculates the sum of the numbers at the pointers, and if the sum is equal to the target, it adds a triplet consisting of the negative target (which is the number we’re currently processing in the searchTriplets method) and the two numbers that make up the sum to the result list. If the sum is less than the target, it means we need to increase the sum, so we move the left pointer one step to the right. If the sum is greater than the target, it means we need to decrease the sum, so we move the right pointer one step to the left. To avoid adding duplicate triplets to the list, the algorithm skips elements that are the same as the previous element both in the searchTriplets method and in the searchPair method. In the end, the searchTriplets method returns a list of all unique triplets in the array that add up to zero. Let’s visualize the example 2 via below diagram. CodeHere is what our algorithm will look like: 1234567891011121314151617181920212223242526272829303132333435363738class Solution: def searchTriplets(self, arr): arr.sort() triplets = [] for i in range(len(arr)): if i &gt; 0 and arr[i] == arr[i-1]: # skip same element to avoid duplicate triplets continue self.searchPair(arr, -arr[i], i+1, triplets) return triplets def searchPair(self, arr, target_sum, left, triplets): right = len(arr) - 1 while(left &lt; right): current_sum = arr[left] + arr[right] if current_sum == target_sum: # found the triplet triplets.append([-target_sum, arr[left], arr[right]]) left += 1 right -= 1 while left &lt; right and arr[left] == arr[left - 1]: left += 1 # skip same element to avoid duplicate triplets while left &lt; right and arr[right] == arr[right + 1]: right -= 1 # skip same element to avoid duplicate triplets elif target_sum &gt; current_sum: left += 1 # we need a pair with a bigger sum else: right -= 1 # we need a pair with a smaller sumdef main(): sol = Solution() print(sol.searchTriplets([-3, 0, 1, 2, -1, 1, -2])) print(sol.searchTriplets([-5, 2, -1, -2, 3]))main() Time complexitySorting the array will take O(N \\ logN)*. The searchPair() function will take O(N). As we are calling searchPair() for every number in the input array, this means that overall searchTriplets() will take O(N \\ logN + N^2)*, which is asymptotically equivalent to O(N^2). Space complexityIgnoring the space required for the output array, the space complexity of the above algorithm will be O(N)O(N) which is required for sorting. Triplet Sum Close to Target (medium) 16. 3Sum Closest Design Gurus Educative.io Problem StatementGiven an array of unsorted numbers and a target number, find a triplet in the array whose sum is as close to the target number as possible, return the sum of the triplet. If there are more than one such triplet, return the sum of the triplet with the smallest sum. Example 1: 123Input: [-1, 0, 2, 3], target=3 Output: 2Explanation: There are two triplets with distance &#x27;1&#x27; from the target: [-1, 0, 3] &amp; [-1, 2, 3]. Between these two triplets, the correct answer will be [-1, 0, 3] as it has a sum &#x27;2&#x27; which is less than the sum of the other triplet which is &#x27;4&#x27;. This is because of the following requirement: &#x27;If there are more than one such triplet, return the sum of the triplet with the smallest sum.&#x27; Example 2: 123Input: [-3, -1, 1, 2], target=1Output: 0Explanation: The triplet [-3, 1, 2] has the closest sum to the target. Example 3: 123Input: [1, 0, 1, 1], target=100Output: 3Explanation: The triplet [1, 1, 1] has the closest sum to the target. Example 4: 123Input: [0, 0, 1, 1, 2, 6], target=5Output: 4Explanation: There are two triplets with distance &#x27;1&#x27; from target: [1, 1, 2] &amp; [0, 0, 6]. Between these two triplets, the correct answer will be [1, 1, 2] as it has a sum &#x27;4&#x27; which is less than the sum of the other triplet which is &#x27;6&#x27;. This is because of the following requirement: &#x27;If there are more than one such triplet, return the sum of the triplet with the smallest sum.&#x27; Constraints: 3 &lt;= arr.length &lt;= 500 -1000 &lt;= arr[i] &lt;= 1000 -104 &lt;= target &lt;= 10^4 SolutionThis problem follows the Two Pointers pattern and is quite similar to “Triplet Sum to Zero”. We can follow a similar approach to iterate through the array, taking one number at a time. At every step, we will save the difference between the triplet and the target number, so that in the end, we can return the triplet with the closest sum. Here’s a detailed walkthrough of the algorithm: Initially, the method checks whether the input array arr is null or its length is less than 3. If either condition is true, the method throws an IllegalArgumentException, as it is impossible to find a triplet in these cases. The input array arr is then sorted in ascending order. Sorting is important as it allows us to move our pointers based on the sum we are getting and how close we are to the target sum. The smallestDifference variable is initialized to Integer.MAX_VALUE, which will keep track of the smallest difference we have found so far between our target sum and the sum of our current triplet. The function then iterates through arr using a for loop, stopping when it is two positions from the end of arr (arr.length - 2). This is because we are always looking for triplets and thus don’t need to consider the last two positions in this loop. Inside the for loop, two pointers, left and right, are initialized. left is set to i + 1 (one position to the right of our current position) and right is set to the last index of the array (arr.length - 1). We start a while that continues as long as left is less than right. Inside this loop, we calculate the difference between the target sum and the sum of the numbers at our current positions in the array (targetDiff). This allows us to see how close the current triplet sum is to our target sum. If targetDiff equals 0, that means the sum of our current triplet exactly matches the target sum, and we return the targetSum immediately as our result. Otherwise, we check if the absolute value of targetDiff is less than the absolute value of smallestDifference (meaning we’ve found a closer sum), or if it’s equal but targetDiff is greater (meaning it’s a larger sum that is equally close). If either condition is true, we update smallestDifference with targetDiff. Next, we check if targetDiff is greater than 0. If it is, we increment left to try and increase our current triplet sum (since the array is sorted, moving left to the right will increase the sum). If targetDiff is not greater than 0, we decrement right to decrease our triplet sum. This while loop continues until left and right cross, at which point we have examined all possible triplets for our current value of i. The for loop continues until we have tried every possible starting point for our triplet. Once all possible triplets have been considered, the function returns targetSum - smallestDifference. This is the sum of the triplet that was closest to our target sum. let’s visualize the example 4 via below diagram. CodeHere is what our algorithm will look like: 1234567891011121314151617181920212223242526272829303132333435363738import mathclass Solution: def searchTriplet(self, arr, target_sum): arr.sort() smallest_difference = math.inf for i in range(len(arr)-2): left = i + 1 right = len(arr) - 1 while (left &lt; right): target_diff = target_sum - arr[i] - arr[left] - arr[right] if target_diff == 0: # we&#x27;ve found a triplet with an exact sum return target_sum # return sum of all the numbers # the second part of the following &#x27;if&#x27; is to handle the smallest sum when we have # more than one solution if abs(target_diff) &lt; abs(smallest_difference) \\ or (abs(target_diff) == abs(smallest_difference) and target_diff &gt; smallest_difference): smallest_difference = target_diff # save the closest and the biggest difference if target_diff &gt; 0: left += 1 # we need a triplet with a bigger sum else: right -= 1 # we need a triplet with a smaller sum return target_sum - smallest_differencedef main(): sol = Solution() print(sol.searchTriplet([-1, 0, 2, 3], 2)) print(sol.searchTriplet([-3, -1, 1, 2], 1)) print(sol.searchTriplet([1, 0, 1, 1], 100)) print(sol.searchTriplet([0, 0, 1, 1, 2, 6], 5))main() Time complexitySorting the array will take O(N\\ logN)*. Overall searchTriplet() will take O(N \\ logN + N^2)*, which is asymptotically equivalent to O(N^2). Space complexityThe space complexity of the above algorithm will be O(N) which is required for sorting. Triplets with Smaller Sum (medium) Design Gurus Educative.io Problem StatementGiven an array arr of unsorted numbers and a target sum, count all triplets in it such that arr[i] + arr[j] + arr[k] &lt; target where i, j, and k are three different indices. Write a function to return the count of such triplets. Example 1: 123Input: [-1, 0, 2, 3], target=3 Output: 2Explanation: There are two triplets whose sum is less than the target: [-1, 0, 3], [-1, 0, 2] Example 2: 1234Input: [-1, 4, 2, 1, 3], target=5 Output: 4Explanation: There are four triplets whose sum is less than the target: [-1, 1, 4], [-1, 1, 3], [-1, 1, 2], [-1, 2, 3] Constraints: n == att.length 0 &lt;= n &lt;= 3500 -100 &lt;= arr[i] &lt;= 100 -100 &lt;= target &lt;= 100 SolutionThis problem follows the Two Pointers pattern and shares similarities with Triplet Sum to Zero. The only difference is that, in this problem, we need to find the triplets whose sum is less than the given target. To meet the condition i != j != k we need to make sure that each number is not used more than once. Following a similar approach, first we can sort the array and then iterate through it, taking one number at a time. Let’s say during our iteration we are at number ‘X’, so we need to find ‘Y’ and ‘Z’ such that X + Y + Z &lt; target. At this stage, our problem translates into finding a pair whose sum is less than “$ target - X$” (as from the above equation Y + Z == target - X). We can use a similar approach as discussed in Triplet Sum to Zero. Here’s a detailed walkthrough of the algorithm: The method searchTriplets starts by sorting the input array arr in ascending order. Sorting is important as it allows us to move our pointers based on the sum we are getting and how close we are to the target sum. The variable count is initialized to keep track of the total number of triplets found. The function then iterates through arr using a for loop, stopping when it is two positions from the end of arr (arr.length - 2). This is because we are always looking for triplets and thus don’t need to consider the last two positions in this loop. Inside the for loop, we call the searchPair function with the array, the target value minus the current element, and the current index. This function will find all pairs within the array from index first+1 to the end of the array whose sum with arr[i] is less than target. The return value, which is the count of such pairs, is added to count. The searchPair function initializes two pointers: left to first+1 and right to the last element in the array. It then enters a while loop that continues as long as left is less than right. In the loop, if the sum of the elements at the left and right indices is less than targetSum, this means we have found a valid pair, because adding arr[first] would still result in a sum less than target. Since the array is sorted, all the elements between left and right with arr[first] will also form valid triplets. So, we add all these pairs to our count by adding right - left to count. We then increment left to move towards higher numbers in the array. If the sum of the elements at left and right is not less than targetSum, we need a smaller sum. Since the array is sorted, to achieve a smaller sum, we need to reduce the value of the larger number. Hence, we decrement right. This process repeats until left and right cross, at which point we have examined all possible pairs for our current value of first. Once searchPair has processed all possible pairs for the given first index, it returns the count of valid pairs. The loop in searchTriplets continues until we have tried every possible starting point for our triplet. Once all possible triplets have been considered, the searchTriplets function returns count, the total number of triplets whose sum is less than target. Let’s visualize the example 2 via diagram below. CodeHere is what our algorithm will look like: 12345678910111213141516171819202122232425262728293031323334class Solution: def searchTriplets(self, arr, target): if len(arr) &lt; 3: return 0 arr.sort() count = 0 for i in range(len(arr)-2): count += self.searchPair(arr, target - arr[i], i) return count def searchPair(self, arr, target_sum, first): count = 0 left, right = first + 1, len(arr) - 1 while (left &lt; right): if arr[left] + arr[right] &lt; target_sum: # found the triplet # since arr[right] &gt;= arr[left], therefore, we can replace arr[right] by any # number between left and right to get a sum less than the target sum count += right - left left += 1 else: right -= 1 # we need a pair with a smaller sum return countdef main(): sol = Solution() print(sol.searchTriplets([-1, 0, 2, 3], 3)) print(sol.searchTriplets([-1, 4, 2, 1, 3], 5))main() Time complexitySorting the array will take O(N * logN). The searchPair() will take O(N)O(N). So, overall searchTriplets() will take O(N * logN + N^2), which is asymptotically equivalent to O(N^2). Space complexityIgnoring the space required for the output array, the space complexity of the above algorithm will be O(N) which is required for sorting if we are not using an in-place sorting algorithm. Similar ProblemsProblem: Write a function to return the list of all such triplets instead of the count. How will the time complexity change in this case? Solution: Following a similar approach, we can create a list containing all the triplets. Here is the code:: 12345678910111213141516171819202122232425262728293031class Solution: def triplet_with_smaller_sum(self, arr, target): arr.sort() triplets = [] for i in range(len(arr)-2): self.search_pair(arr, target - arr[i], i, triplets) return triplets def search_pair(self, arr, target_sum, first, triplets): left = first + 1 right = len(arr) - 1 while (left &lt; right): if arr[left] + arr[right] &lt; target_sum: # found the triplet # since arr[right] &gt;= arr[left], therefore, we can replace arr[right] by any # number between left and right to get a sum less than the target sum for i in range(right, left, -1): triplets.append([arr[first], arr[left], arr[i]]) left += 1 else: right -= 1 # we need a pair with a smaller sumdef main(): sol = Solution() print(sol.triplet_with_smaller_sum([-1, 0, 2, 3], 3)) print(sol.triplet_with_smaller_sum([-1, 4, 2, 1, 3], 5))main() Another simpler approach could be to check every triplet of the array with three nested loops and create a list of triplets that meet the required condition. Time complexitySorting the array will take O(N \\ logN)*. The searchPair(), in this case, will take O(N^2); the main while loop will run in O(N) but the nested for loop can also take O(N)O(N) - this will happen when the target sum is bigger than every triplet in the array. So, overall searchTriplets() will take O(N logN + N^3)*, which is asymptotically equivalent to O(N^3). Space complexityIgnoring the space required for the output array, the space complexity of the above algorithm will be O(N) which is required for sorting. *Subarray Product Less Than K 713. Subarray Product Less Than K Design Gurus Problem StatementGiven an array with positive numbers and a positive target number, find all of its contiguous subarrays whose product is less than the target number. Example 1: 123Input: [2, 5, 3, 10], target=30 Output: [2], [5], [2, 5], [3], [5, 3], [10] Explanation: There are six contiguous subarrays whose product is less than the target. Example 2: 123Input: [8, 2, 6, 5], target=50 Output: [8], [2], [8, 2], [6], [2, 6], [5], [6, 5] Explanation: There are seven contiguous subarrays whose product is less than the target. Constraints: 1 &lt;= arr.length &lt;= 3 * 104 1 &lt;= arr[i] &lt;= 1000 0 &lt;= k &lt;= 106 SolutionThis problem follows the Sliding Window and the Two Pointers pattern and shares similarities with Triplets with Smaller Sum with two differences: In this problem, the input array is not sorted. Instead of finding triplets with sum less than a target, we need to find all subarrays having a product less than the target. The implementation will be quite similar to Triplets with Smaller Sum. Here is a step-by-step explanation of the algorithm: The goal of this algorithm is to find all subarrays of a given integer array where the product of the numbers in the subarray is less than a specified target value. The algorithm uses a sliding window approach combined with a two-pointer method. A “window” of subarray is defined between the indices pointed to by two pointers, left and right. The window starts from the leftmost side of the array (both left and right at position 0) and slides to the right one element at a time, expanding the window. This expansion is represented by incrementing right. As we add a new element into the window (the right element), we multiply our current product with this new element. If at any point the product of the numbers within the window (from left to right) becomes greater than or equal to the target, we need to make the product smaller. This is achieved by moving the left pointer to the right (incrementing left), effectively excluding the left element from our window, and dividing our product by this removed element. We keep doing this until our product is less than target again. For each position of right, we create all possible subarrays that end at right, and that have a product less than the target. We do this by starting with a subarray that only includes the right element, then progressively adding the element to its left, and so on, until we reach the left pointer. All of these subarrays are added to the result. This process is repeated for each element in the array (each position of right), with the left boundary being adjusted as necessary. At the end of this process, result will contain all possible subarrays that have a product less than the target. In summary, this algorithm slides a window across the array, expanding and contracting this window as necessary, to find all subarrays where the product of the numbers is less than a target value. For each window, it generates all valid subarrays ending at the right edge of the window. Let’s walkthrough the example 1 through below diagram. CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution: def findSubarrays(self, arr, target): # Resultant list to store all valid subarrays. result = [] # Variable to store the product of elements in the current subarray. product = 1.0 # Left boundary of the current subarray. left = 0 # Iterate over the array using &#x27;right&#x27; as the right boundary of the current subarray. for right in range(len(arr)): # Update the product with the current element. product *= arr[right] # If the product is greater than or equal to the target, slide the left boundary to # the right until product is less than target. while product &gt;= target and left &lt; len(arr): product /= arr[left] left += 1 # Create a temporary list to store the current subarray. temp_list = [] # Iterate from &#x27;right&#x27; to &#x27;left&#x27; and add all these subarrays to the result. for i in range(right, left - 1, -1): # Add the current element at the beginning of the list. temp_list.insert(0, arr[i]) # Add the current subarray to the result. result.append(list(temp_list)) # Return the result. return result# Example usagesol = Solution()print(sol.findSubarrays([2, 5, 3, 10], 30))print(sol.findSubarrays([8, 2, 6, 5], 50)) Time ComplexityThe main for-loop managing the sliding window takes O(N) but creating subarrays can take up to O(N^2) in the worst case. Therefore overall, our algorithm will take O(N^3) . Space ComplexityIgnoring the space required for the output list, the algorithm runs in space which is used for the temp list. Can you try estimating how much space will be required for the output list? 1n + (n-1) + (n-2) + ... 3 + 2 + 1 The worst-case will happen when every subarray has a product less than the target! So the question will be, how many contiguous subarrays an array can have?It is definitely not all Permutations of the given array; is it all Combinations of the given array? It is not all the Combinations of all elements of the array! For an array with distinct elements, finding all of its contiguous subarrays is like finding the number of ways to choose two indices, i and j, in the array such that i &lt;= j. If there are a total of n elements in the array, here is how we can count all the contiguous subarrays: When i = 0, j can have any value from 0 to n-1, giving a total of n choices. When i = 1, j can have any value from 1 to n-1, giving a total of n-1 choices. Similarly, when i = 2, j can have n-2 choices. … … When i = n-1, j can only have only 1 choice. Let’s combine all the choices: Which gives us a total of: n * (n + 1) / 2. So, at most, we need space for O(N^2) output lists. At worst, each subarray can take O(N) space, so overall, our algorithm’s space complexity will be O(N^3). *Dutch National Flag Problem (medium) 75. Sort Colors Design Gurus Educative.io Problem StatementGiven an array containing 0s, 1s and 2s, sort the array in-place. You should treat numbers of the array as objects, hence, we can’t count 0s, 1s, and 2s to recreate the array. The flag of the Netherlands consists of three colors: red, white and blue; and since our input array also consists of three different numbers that is why it is called Dutch National Flag problem. Example 1: 12Input: [1, 0, 2, 1, 0]Output: [0 0 1 1 2] Example 2: 12Input: [2, 2, 0, 1, 2, 0]Output: [0 0 1 2 2 2 ] Constraints: n == arr.length 1 &lt;= n &lt;= 300 arr[i] is either 0, 1, or 2. SolutionThe brute force solution will be to use an in-place sorting algorithm like Heapsort which will take O(N \\ logN)*. Can we do better than this? Is it possible to sort the array in one iteration? We can use a Two Pointers approach while iterating through the array. Let’s say the two pointers are called low and high which are pointing to the first and the last element of the array respectively. So while iterating, we will move all 0s before low and all 2s after high so that in the end, all 1s will be between low and high. In the end, all 0s are on the left, all 1s are in the middle, and all 2s are on the right. Here’s a detailed walkthrough of the algorithm: We start by initializing three variables: low to 0, high to the last index of the array, and i also to 0. Low is meant to keep track of the latest position where a 0 should be placed, high is meant to keep track of the latest position where a 2 should be placed, and i is used to iterate through the array. We then start a loop that continues as long as i is less than or equal to high. In each iteration of the loop, we check the value of the array at the index i. If the value is 0, we swap the values at the indices i and low. We then increment both i and low, since we know that the new element at low is 0 (sorted in its correct place) and we can move to the next index. If the value is 1, we do nothing other than increment i. This is because we want 1s to be in the middle of the array. If the value is 2, we swap the values at i and high. However, after the swap, we only decrement high without incrementing i. This is because the new value at index i (after the swap) could be 0, 1 or 2, and we need to check this value again in the next iteration. The swap function simply switches the values at two given indices in the array. The process continues until i is greater than high, at which point every element in the array has been checked and placed in its correct position. Hence, the array is now sorted. Let’s consider the example 1 and understand it via visual representation. CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233class Solution: def sort(self, arr): # all elements &lt; low are 0, and all elements &gt; high are 2 # all elements from &gt;= low &lt; i are 1 low, high = 0, len(arr) - 1 i = 0 while(i &lt;= high): if arr[i] == 0: arr[i], arr[low] = arr[low], arr[i] # increment &#x27;i&#x27; and &#x27;low&#x27; i += 1 low += 1 elif arr[i] == 1: i += 1 else: # the case for arr[i] == 2 arr[i], arr[high] = arr[high], arr[i] # decrement &#x27;high&#x27; only, after the swap the number at index &#x27;i&#x27; could be 0, 1 or 2 high -= 1 return arrdef main(): sol = Solution() arr = [1, 0, 2, 1, 0] arr = sol.sort(arr) print(arr) arr = [2, 2, 0, 1, 2, 0] arr = sol.sort(arr) print(arr)main() Time complexityThe time complexity of the above algorithm will be O(N) as we are iterating the input array only once. Space complexityThe algorithm runs in constant space O(1). Problem Challenge 1 18. 4Sum Design Gurus Educative.io Quadruple Sum to Target (medium)Given an array of unsorted numbers and a target number, find all unique quadruplets in it, whose sum is equal to the target number. Example 1: 123Input: [4, 1, 2, -1, 1, -3], target=1Output: [-3, -1, 1, 4], [-3, 1, 1, 2]Explanation: Both the quadruplets add up to the target. Example 2: 123Input: [2, 0, -1, 1, -2, 2], target=2Output: [-2, 0, 2, 2], [-1, 0, 1, 2]Explanation: Both the quadruplets add up to the target. Constraints: 1 &lt;= nums.length &lt;= 200 -109 &lt;= nums[i] &lt;= 109 -109 &lt;= target &lt;= 109 SolutionThis problem follows the Two Pointers pattern and shares similarities with “Triplet Sum to Zero”. We can follow a similar approach to iterate through the array, taking one number at a time. At every step during the iteration, we will search for the quadruplets similar to Triplet Sum to Zero whose sum is equal to the given target. Here’s a detailed walkthrough of the algorithm: In searchQuadruplets, the array is first sorted in ascending order. Sorting is important as it allows us to navigate our pointers based on the sum we’re calculating and ensures that the generated quadruplets are in a predictable order. A List named quadruplets is created to store all the quadruplets found. The algorithm then loops over the array, stopping when there are less than four elements remaining (since we need groups of four). If the current element is the same as the previous one (and it’s not the first), we skip this iteration to avoid duplicate quadruplets. A nested loop is initiated from the next index of the outer loop. This loop also ensures that the current element isn’t the same as the previous one to avoid duplicates. The searchPairs function is called with the array, target value, indices of the first two elements, and the quadruplets list. This function will find pairs in the array (from second+1 index to the end) whose sum with arr[first] and arr[second] equals the target. Any valid quadruplets found are added to the quadruplets list. In searchPairs, two pointers left and right are initialized: left to second+1, and right to the last element of the array. It then enters a while loop that continues until left is less than right. Inside this loop, the sum of the elements at the current four indices (first, second, left, right) is calculated. If this sum equals targetSum, a valid quadruplet is found. This quadruplet is added to the quadruplets list, and both left and right pointers are moved inward. If the next elements are the same as the current elements of left and right respectively, they are skipped to avoid duplicates. If the calculated sum is less than targetSum, left is incremented to increase the sum (as the array is sorted), and if the sum is greater than targetSum, right is decremented to decrease the sum. This process repeats until left and right cross, by which point all possible pairs for the given first and second indices have been examined. Once searchPairs has processed all possible pairs for the given first and second indices, it returns, and the nested loop in searchQuadruplets continues until all possible starting points for quadruplets have been tried. Once all possible quadruplets have been considered, searchQuadruplets returns the quadruplets list. The main function in the code demonstrates usage of the searchQuadruplets function with two test cases. It runs searchQuadruplets with specified arrays and target sums, printing the results to the console. Let’s walkthrough the example 1 through diagram below. CodeHere is what our algorithm will look like: 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution: def searchQuadruplets(self, arr, target): arr.sort() quadruplets = [] for i in range(0, len(arr)-3): # skip same element to avoid duplicate quadruplets if i &gt; 0 and arr[i] == arr[i - 1]: continue for j in range(i + 1, len(arr)-2): # skip same element to avoid duplicate quadruplets if j &gt; i + 1 and arr[j] == arr[j - 1]: continue self.search_pairs(arr, target, i, j, quadruplets) return quadruplets def search_pairs(self,arr, target_sum, first, second, quadruplets): left = second + 1 right = len(arr) - 1 while (left &lt; right): quad_sum = arr[first] + arr[second] + arr[left] + arr[right] if quad_sum == target_sum: # found the quadruplet quadruplets.append( [arr[first], arr[second], arr[left], arr[right]]) left += 1 right -= 1 while (left &lt; right and arr[left] == arr[left - 1]): left += 1 # skip same element to avoid duplicate quadruplets while (left &lt; right and arr[right] == arr[right + 1]): right -= 1 # skip same element to avoid duplicate quadruplets elif quad_sum &lt; target_sum: left += 1 # we need a pair with a bigger sum else: right -= 1 # we need a pair with a smaller sumdef main(): sol = Solution() print(sol.searchQuadruplets([4, 1, 2, -1, 1, -3], 1)) print(sol.searchQuadruplets([2, 0, -1, 1, -2, 2], 2))main() Time complexitySorting the array will take O(NlogN). Overall searchQuadruplets() will take O(N \\ logN + N^3)*, which is asymptotically equivalent to O(N^3). Space complexityThe space complexity of the above algorithm will be O(N) which is required for sorting. # Problem Challenge 2 844. Backspace String Compare Design Gurus Educative.io Comparing Strings containing Backspaces (medium)Given two strings containing backspaces (identified by the character ‘#’), check if the two strings are equal. Example 1: 123Input: str1=&quot;xy#z&quot;, str2=&quot;xzz#&quot;Output: trueExplanation: After applying backspaces the strings become &quot;xz&quot; and &quot;xz&quot; respectively. Example 2: 123Input: str1=&quot;xy#z&quot;, str2=&quot;xyz#&quot;Output: falseExplanation: After applying backspaces the strings become &quot;xz&quot; and &quot;xy&quot; respectively. Example 3: 1234Input: str1=&quot;xp#&quot;, str2=&quot;xyz##&quot;Output: trueExplanation: After applying backspaces the strings become &quot;x&quot; and &quot;x&quot; respectively.In &quot;xyz##&quot;, the first &#x27;#&#x27; removes the character &#x27;z&#x27; and the second &#x27;#&#x27; removes the character &#x27;y&#x27;. Example 4: 123Input: str1=&quot;xywrrmp&quot;, str2=&quot;xywrrmu#p&quot;Output: trueExplanation: After applying backspaces the strings become &quot;xywrrmp&quot; and &quot;xywrrmp&quot; respectively. Constraints: 1 &lt;= str1.length, str2.length &lt;= 200 str1 and str2 only contain lowercase letters and ‘#’ characters. SolutionTo compare the given strings, first, we need to apply the backspaces. An efficient way to do this would be from the end of both the strings. We can have separate pointers, pointing to the last element of the given strings. We can start comparing the characters pointed out by both the pointers to see if the strings are equal. If, at any stage, the character pointed out by any of the pointers is a backspace (’#’), we will skip and apply the backspace until we have a valid character available for comparison. Here’s a detailed walkthrough of the algorithm: In the compare function, two pointers are initialized, index1 and index2, to the last index of str1 and str2, respectively. A while loop is started which continues until both pointers are less than zero, that is, both have traversed their strings completely in a reverse manner. Inside this loop, for each string, the getNextValidCharIndex function is called with the current pointer. This function returns the index of the next valid character in the string (traversing from back to front) by taking into account the backspace characters. i1 and i2 point to the index of the next valid character in the two strings. If both i1 and i2 are less than zero, it means the end of both strings has been reached, and the strings are considered equal. If only one of i1 or i2 is less than zero, it means the end of one string has been reached, but not the other, and the strings are not equal. If the characters at indices i1 and i2 are not the same, the strings are not equal. If none of the above conditions are met, the loop continues to the next valid characters in both strings. The getNextValidCharIndex function accepts a string and an index, and uses a backspace count to keep track of how many backspaces have been encountered. It then loops through the string backwards from the provided index until it encounters a valid character or reaches the beginning of the string. If a backspace character is found, the backspace count is incremented. If a non-backspace character is found and there are any counted backspaces, one backspace is subtracted from the count (to simulate the removal of the previous character), and the loop continues. If a non-backspace character is found and there are no backspaces left to account for, the loop breaks and the index of the valid character is returned. Here is the visual representation of this algorithm for Example 2: CodeHere is what our algorithm will look like: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution: def compare(self, str1, str2): # use two pointer approach to compare the strings index1 = len(str1) - 1 index2 = len(str2) - 1 # 注意这里是or (&quot;bbbextm&quot;, &quot;bbb#extm&quot;) while (index1 &gt;= 0 or index2 &gt;= 0): i1 = self.get_next_valid_char_index(str1, index1) i2 = self.get_next_valid_char_index(str2, index2) # 这个if是对于这个例子(&quot;ab##&quot;, &quot;c#d#&quot;) if i1 &lt; 0 and i2 &lt; 0: # reached the end of both the strings return True if i1 &lt; 0 or i2 &lt; 0: # reached the end of one of the strings return False if str1[i1] != str2[i2]: # check if the characters are equal return False index1 = i1 - 1 index2 = i2 - 1 return True def get_next_valid_char_index(self, str, index): backspace_count = 0 while (index &gt;= 0): if str[index] == &#x27;#&#x27;: # found a backspace character backspace_count += 1 elif backspace_count &gt; 0: # a non-backspace character backspace_count -= 1 else: break index -= 1 # skip a backspace or a valid character return indexdef main(): sol = Solution() print(sol.compare(&quot;xy#z&quot;, &quot;xzz#&quot;)) print(sol.compare(&quot;xy#z&quot;, &quot;xyz#&quot;)) print(sol.compare(&quot;xp#&quot;, &quot;xyz##&quot;)) print(sol.compare(&quot;xywrrmp&quot;, &quot;xywrrmu#p&quot;))main() Time complexityThe time complexity of the above algorithm will be O(M+N) where ‘M’ and ‘N’ are the lengths of the two input strings respectively. Space complexityThe algorithm runs in constant space O(1). Problem Challenge 3 581. Shortest Unsorted Continuous Subarray Design Gurus Educative.io Minimum Window Sort (medium)Given an array, find the length of the smallest subarray in it which when sorted will sort the whole array. Example 1: 123Input: [1, 2, 5, 3, 7, 10, 9, 12]Output: 5Explanation: We need to sort only the subarray [5, 3, 7, 10, 9] to make the whole array sorted Example 2: 123Input: [1, 3, 2, 0, -1, 7, 10]Output: 5Explanation: We need to sort only the subarray [1, 3, 2, 0, -1] to make the whole array sorted Example 3: 123Input: [1, 2, 3]Output: 0Explanation: The array is already sorted Example 4: 123Input: [3, 2, 1]Output: 3Explanation: The whole array needs to be sorted. Constraints: 1 &lt;= arr.length &lt;= 10^4 -105 &lt;= arr[i] &lt;= 10^5 SolutionAs we know, once an array is sorted (in ascending order), the smallest number is at the beginning and the largest number is at the end of the array. So if we start from the beginning of the array to find the first element which is out of sorting order i.e., which is smaller than its previous element, and similarly from the end of array to find the first element which is bigger than its previous element, will sorting the subarray between these two numbers result in the whole array being sorted? Let’s try to understand this with Example-2 mentioned above. In the following array, what are the first numbers out of sorting order from the beginning and the end of the array: 1[1, 3, 2, 0, -1, 7, 10] Starting from the beginning of the array the first number out of the sorting order is ‘2’ as it is smaller than its previous element which is ‘3’. Starting from the end of the array the first number out of the sorting order is ‘0’ as it is bigger than its previous element which is ‘-1’ As you can see, sorting the numbers between ‘3’ and ‘-1’ will not sort the whole array. To see this, the following will be our original array after the sorted subarray: 1[1, -1, 0, 2, 3, 7, 10] The problem here is that the smallest number of our subarray is ‘-1’ which dictates that we need to include more numbers from the beginning of the array to make the whole array sorted. We will have a similar problem if the maximum of the subarray is bigger than some elements at the end of the array. To sort the whole array we need to include all such elements that are smaller than the biggest element of the subarray. So our final algorithm will look like: From the beginning and end of the array, find the first elements that are out of the sorting order. The two elements will be our candidate subarray. Find the maximum and minimum of this subarray. Extend the subarray from beginning to include any number which is bigger than the minimum of the subarray. Similarly, extend the subarray from the end to include any number which is smaller than the maximum of the subarray. Here is the visual representation of this algorithm for Example 2: CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233343536373839404142434445import mathclass Solution: def sort(self, arr): low, high = 0, len(arr) - 1 # find the first number out of sorting order from the beginning while (low &lt; len(arr) - 1 and arr[low] &lt;= arr[low + 1]): low += 1 if low == len(arr) - 1: # if the array is sorted return 0 # find the first number out of sorting order from the end while (high &gt; 0 and arr[high] &gt;= arr[high - 1]): high -= 1 # find the maximum and minimum of the subarray subarray_max = -float(&#x27;inf&#x27;) subarray_min = float(&#x27;inf&#x27;) for k in range(low, high+1): subarray_max = max(subarray_max, arr[k]) subarray_min = min(subarray_min, arr[k]) # extend the subarray to include any number which is bigger than the minimum of # the subarray while (low &gt; 0 and arr[low-1] &gt; subarray_min): low -= 1 # extend the subarray to include any number which is smaller than the maximum of # the subarray while (high &lt; len(arr)-1 and arr[high+1] &lt; subarray_max): high += 1 return high - low + 1def main(): sol = Solution() print(sol.sort([1, 2, 5, 3, 7, 10, 9, 12])) print(sol.sort([1, 3, 2, 0, -1, 7, 10])) print(sol.sort([1, 2, 3])) print(sol.sort([3, 2, 1]))main() Time complexityThe time complexity of the above algorithm will be O(N). Space complexityThe algorithm runs in constant space O(1).","categories":[{"name":"Grokking Interview Pattern","slug":"Grokking-Interview-Pattern","permalink":"https://hasuer.github.io/categories/Grokking-Interview-Pattern/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hasuer.github.io/tags/Interview/"}]},{"title":"0.Introduction","slug":"0. Introduction","date":"2024-04-30T01:39:45.000Z","updated":"2024-05-28T03:25:56.466Z","comments":true,"path":"0-introduction/index.html","link":"","permalink":"https://hasuer.github.io/0-introduction/index.html","excerpt":"","text":"IntroductionWho should take this course?Thanks for choosing this course! We hope the techniques you learn here go a long way towards building solid algorithmic skills. Intended AudienceIf you want to work on your algorithms and problem-solving skills, this course is for you. Systematically, we will start with easier problems to develop an understanding of the underlying solution patterns and then apply these patterns to solve difficult ones. Every problem presented in this course has been solved in Java, Python, C++, and JavaScript. PrerequisitesYou need to have a basic understanding of common data-structures like Array, LinkedList, HashMap, Stack, Queue, Heap, and Graph. You should also be familiar with Recursion) and Big-O. Course OverviewThis course categorizes coding interview problems into a set of 16 patterns. Each pattern will be a complete tool - consisting of data structures, algorithms, and analysis techniques - to solve a specific category of problems. The goal is to develop an understanding of the underlying pattern, so that, we can apply that pattern to solve other problems. We have chosen each problem carefully such that it not only maps to the same pattern but also presents different constraints. Overall, the course has around 150 problems mapped to 16 patterns. The problems solved under these patterns use a varied set of algorithmic techniques. We will make use of Breadth-First Search and Depth-First Search to solve problems related to Trees and Graphs. Similarly, we will also cover Dynamic Programming, Backtracking, Recursion, Greedy algorithms, and Divide &amp; Conquer. We will start with a brief introduction of each pattern before jumping onto the problems. Under each pattern, the first problem will explain the underlying pattern in detail to build the concepts that can be applied to later problems. The later problems will focus on the different constraints each problem presents and how our algorithm needs to change to handle them. Let’s start with the Sliding Window pattern.","categories":[{"name":"Grokking Interview Pattern","slug":"Grokking-Interview-Pattern","permalink":"https://hasuer.github.io/categories/Grokking-Interview-Pattern/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hasuer.github.io/tags/Interview/"}]},{"title":"Ubuntu20.04安装配置MySQL8(详细)","slug":"Ubuntu20-04安装配置MySQL8","date":"2022-06-12T15:01:42.000Z","updated":"2022-06-12T17:59:52.398Z","comments":true,"path":"ubuntu20-04安装配置mysql8-详细/index.html","link":"","permalink":"https://hasuer.github.io/ubuntu20-04%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEmysql8-%E8%AF%A6%E7%BB%86/index.html","excerpt":"","text":"文章的第一节转载自原文连接 本文实现了服务器ubuntu18.04和虚拟机ubuntu20.04两个版本的MySQL8 的安装，和navicat的连接。其中ubuntu18.04对应第二节，ubuntu20.04是ubuntu focal的，对应第三节。 1. 彻底删除mysql5.71.1 查看mysql的依赖项1dpkg --list|grep mysql 1.2 卸载1sudo apt-get remove mysql-common 在卸载过程中输入yes 1.3 卸载（最后的版本数字根据自己具体的版本进行相应的修改）1sudo apt-get autoremove --purge mysql-server-5.7 1.4 清除残留数据1dpkg -l|grep ^rc|awk &#x27;&#123;print$2&#125;&#x27;|sudo xargs dpkg -P 出现下图界面，选择&lt;YES&gt; 1.5 再次查看依赖1dpkg --list|grep mysql 发现有如下残留 使用命令sudo apt-get autoremove --purge xxxx来卸载： 1sudo apt-get autoremove --purge php5.6-mysql 执行之后再次使用命令查看： 1dpkg --list|grep mysql 输入命令之后没有任何返回即成功，这里输入了两次： 2. 服务器（ubuntu18.04）安装MySQL82.1 使用命令下载存储库软件包1wget -c https://dev.mysql.com/get/mysql-apt-config_0.8.10-1_all.deb 2.2 使用命令安装上边下载的安装包1sudo dpkg -i mysql-apt-config_0.8.10-1_all.deb 安装过程中提示选择安装版本，默认安装的就是8.0版本，所以直接选择“OK”确认即可； 2.3 从所有已配置的存储库（包括新添加的 MySQL 8存储库）中下载最新的软件包信息：1sudo apt update 可能的报错： 解决： 查看签名列表： 1apt-key list 删除过期的签名；（del 后跟上条指令查到的pub） 1sudo apt-key del dsa1024 重新添加新的签名 GPG error: http://repo.mysql.com/apt/ubuntu focal InRelease: The following signatures couldn’t be verified because the public key is not available: NO_PUBKEY 467B942D3A79BD29 1sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 467B942D3A79BD29 之后继续执行更新命令: 1sudo apt update 2.4 安装MySQL81sudo apt install mysql-server 安装过程中会提示设置root密码。按照提示输入即可； 输入之后会出现选择加密方式的提示界面，我在网上的教程中看到默认的mysql8.0的加密方式与ubuntu18.04 及以上不兼容，所以选择5.x的加密方式；建议选择下边的那个： 2.5 验证1mysql -uroot -p [图片] 3. 在Ubuntu 20.04 LTS Focal Fossa上安装MySQL8在上一节中，执行命令sudo dpkg -i mysql-apt-config_0.8.10-1_all.deb的时候提示这是ubuntu focal系统，这里根据教程来安装。 Step 1: Update the system to the latest1sudo apt update Step 2: Install MySQL on Ubuntu 20.041sudo apt install mysql-server Step 3: Secure MySQL installation\\1sudo mysql_secure_installation 可能的问题： 设置完密码之后按照要求”Do you wish to continue with the password provided?”输入yes报错如下： [MySQL Failed! Error: SET PASSWORD has no significance for user ‘root’@’localhost’ as the authentication method used doesn’t store authentication data in the MySQL server. Please consider using ALTER USER](https://www.nixcraft.com/t/mysql-failed-error-set-password-has-no-significance-for-user-root-localhost-as-the-authentication-method-used-doesnt-store-authentication-data-in-the-mysql-server-please-consider-using-alter-user/4233) 解决： Open the terminal application. Terminate the mysql_secure_installation from another terminal using the killall command:sudo killall -9 mysql_secure_installation Start the mysql client:sudo mysql Run the following SQL query: 12ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;SetRootPasswordHere&#x27;;exit Then run the following command to secure it:sudo mysql_secure_installation When promoted for the password enter the SetRootPasswordHere (or whatever you set when you ran the above SQL query) That is all. 成功界面如下： Step 4: Test MySQL Community Server service1systemctl status mysql.service 1mysql -uroot -p 4. navicat 连接4.1 连接报错1103[图片] 原因:帐号不允许从远程登陆，只能在localhost。这个时候只要在localhost的那台电脑，登入mysql后，更改”mysql” 数据库里的 “user” 表里的 “host”项，从”localhost”改称”%” 在虚拟机/服务器上进入mysql: use mysql; select host, user from user; update user set host = &#39;%&#39; where user = &#39;root&#39;; flush privileges; service mysql restart 4.2 连接报错2003 在windows下，cmd 输入 1telnet 192.168.xxx.xxx 3306 在虚拟机下输入 1netstat -anp| grep 3306 修改/etc/mysql/mysql.conf.d/mysqld.cnf 需要root权限，sudo passwd root设置root密码， su进入root. 1vim /etc/mysql/mysql.conf.d/mysqld.cnf 把 bind-address = 127.0.0.1 改为 bind-address = 0.0.0.0 上面的意思是改为监听所有地址 重启MySQL 1service mysql restart","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://hasuer.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"Axios学习笔记","slug":"Axios学习笔记","date":"2022-02-25T07:03:16.000Z","updated":"2022-02-25T12:06:54.964Z","comments":true,"path":"axios学习笔记/index.html","link":"","permalink":"https://hasuer.github.io/axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html","excerpt":"","text":"此笔记转载自这里,对应的视频课程是尚硅谷Web前端axios入门与源码解析 预备工具 作为一个前端开发工程师，在后端还没有ready的时候，不可避免的要使用mock的数据。很多时候，我们并不想使用简单的静态数据，而是希望自己起一个本地的mock-server来完全模拟请求以及请求回来的过程。json-server是一个很好的可以替我们完成这一工作的工具。我们只需要提供一个json文件，或者写几行简单的js脚本就可以模拟出RESTful API的接口。 安装json-servernpm install -g json-server 创建db.json在一个文件夹下新建一个db.json文件 123456789&gt;&#123;&gt;&quot;posts&quot;: [ &#123; &quot;id&quot;: 1, &quot;title&quot;: &quot;json-server&quot;, &quot;author&quot;: &quot;typicode&quot; &#125;&gt;],&gt;&quot;comments&quot;: [ &#123; &quot;id&quot;: 1, &quot;body&quot;: &quot;some comment&quot;, &quot;postId&quot;: 1 &#125;&gt;],&gt;&quot;profile&quot;: &#123; &quot;name&quot;: &quot;typicode&quot; &#125;&gt;&#125; 启动json-server在当前文件夹下输入如下命令：json-server db.json 文档 一、Axios的理解与使用axios 是什么? 前端最流行的 ajax 请求库 react/vue 官方都推荐使用 axios 发 ajax 请求 文档: https://github.com/axios/axios axios 特点 基于 xhr + promise 的异步 ajax 请求库 浏览器端/node 端都可以使用 支持请求／响应拦截器 支持请求取消 请求/响应数据转换 批量发送多个请求 axios 常用语法 axios(config): 通用/最本质的发任意类型请求的方式 axios(url[, config]): 可以只指定 url 发 get 请求 axios.request(config): 等同于 axios(config) axios.get(url[, config]): 发 get 请求 axios.delete(url[, config]): 发 delete 请求 axios.post(url[, data, config]): 发 post 请求 axios.put(url[, data, config]): 发 put 请求 axios.defaults.xxx: 请求的默认全局配置 axios.interceptors.request.use(): 添加请求拦截器 axios.interceptors.response.use(): 添加响应拦截器 axios.create([config]): 创建一个新的 axios(它没有下面的功能) axios.Cancel(): 用于创建取消请求的错误对象 axios.CancelToken(): 用于创建取消请求的 token 对象 axios.isCancel(): 是否是一个取消请求的错误 axios.all(promises): 用于批量执行多个异步请求 axios.spread(): 用来指定接收所有成功数据的回调函数的方法 原理图 难点语法的理解和使用axios.create(config) 根据指定配置创建一个新的 axios, 也就就每个新 axios 都有自己的配置 新 axios 只是没有取消请求和批量发请求的方法, 其它所有语法都是一致的 为什么要设计这个语法? (1) 需求: 项目中有部分接口需要的配置与另一部分接口需要的配置不太一样, 如何处理 (2) 解决: 创建 2 个新 axios, 每个都有自己特有的配置, 分别应用到不同要 求的接口请求中 123456789101112131415161718//创建实例对象 /getJoke const duanzi = axios.create(&#123; baseURL: &#x27;https://api.apiopen.top&#x27;, timeout: 2000 &#125;); const onather = axios.create(&#123; baseURL: &#x27;https://b.com&#x27;, timeout: 2000 &#125;); //这里 duanzi 与 axios 对象的功能几近是一样的 // duanzi(&#123; // url: &#x27;/getJoke&#x27;, // &#125;).then(response =&gt; &#123; // console.log(response); // &#125;); duanzi.get(&#x27;/getJoke&#x27;).then(response =&gt; &#123; console.log(response.data) &#125;) 拦截器函数/ajax 请求/请求的回调函数的调用顺序 说明: 调用 axios()并不是立即发送 ajax 请求, 而是需要经历一个较长的流程 流程: 请求拦截器2 =&gt; 请求拦截器1 =&gt; 发ajax请求 =&gt; 响应拦截器1 =&gt; 响应拦截器 2 =&gt; 请求的回调 注意: 此流程是通过 promise 串连起来的, 请求拦截器传递的是 config, 响应 拦截器传递的是 response 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;script&gt; // Promise // 设置请求拦截器 config 配置对象 axios.interceptors.request.use(function (config) &#123; console.log(&#x27;请求拦截器 成功 - 1号&#x27;); //修改 config 中的参数 config.params = &#123; a: 100 &#125;; return config; &#125;, function (error) &#123; console.log(&#x27;请求拦截器 失败 - 1号&#x27;); return Promise.reject(error); &#125;); axios.interceptors.request.use(function (config) &#123; console.log(&#x27;请求拦截器 成功 - 2号&#x27;); //修改 config 中的参数 config.timeout = 2000; return config; &#125;, function (error) &#123; console.log(&#x27;请求拦截器 失败 - 2号&#x27;); return Promise.reject(error); &#125;); // 设置响应拦截器 axios.interceptors.response.use(function (response) &#123; console.log(&#x27;响应拦截器 成功 1号&#x27;); return response.data; // return response; &#125;, function (error) &#123; console.log(&#x27;响应拦截器 失败 1号&#x27;) return Promise.reject(error); &#125;); axios.interceptors.response.use(function (response) &#123; console.log(&#x27;响应拦截器 成功 2号&#x27;) return response; &#125;, function (error) &#123; console.log(&#x27;响应拦截器 失败 2号&#x27;) return Promise.reject(error); &#125;); //发送请求 axios(&#123; method: &#x27;GET&#x27;, url: &#x27;http://localhost:3000/posts&#x27; &#125;).then(response =&gt; &#123; console.log(&#x27;自定义回调处理成功的结果&#x27;); console.log(response); &#125;);&lt;/script&gt; 取消请求 基本流程 配置 cancelToken 对象 缓存用于取消请求的 cancel 函数 在后面特定时机调用 cancel 函数取消请求 在错误回调中判断如果 error 是 cancel, 做相应处理 实现功能 点击按钮, 取消某个正在请求中的请求, 实现功能 点击按钮, 取消某个正在请求中的请求 123456789101112131415161718192021222324252627282930&lt;script&gt; //获取按钮 const btns = document.querySelectorAll(&#x27;button&#x27;); //2.声明全局变量 let cancel = null; //发送请求 btns[0].onclick = function () &#123; //检测上一次的请求是否已经完成 if (cancel !== null) &#123; //取消上一次的请求 cancel(); &#125; axios(&#123; method: &#x27;GET&#x27;, url: &#x27;http://localhost:3000/posts&#x27;, //1. 添加配置对象的属性 cancelToken: new axios.CancelToken(function (c) &#123; //3. 将 c 的值赋值给 cancel cancel = c; &#125;) &#125;).then(response =&gt; &#123; console.log(response); //将 cancel 的值初始化 cancel = null; &#125;) &#125; //绑定第二个事件取消请求 btns[1].onclick = function () &#123;cancel(); &#125;&lt;/script&gt; 默认配置 12345678910111213&gt;//默认配置 axios.defaults.method = &#x27;GET&#x27;;//设置默认的请求类型为 GET axios.defaults.baseURL = &#x27;http://localhost:3000&#x27;;//设置基础 URL axios.defaults.params = &#123;id:100&#125;; axios.defaults.timeout = 3000;// btns[0].onclick = function()&#123; axios(&#123; url: &#x27;/posts&#x27; &#125;).then(response =&gt; &#123; console.log(response); &#125;) &#125; Axios的难点问题目录结构 ├── /dist/ # 项目输出目录├── /lib/ # 项目源码目录│ ├── /adapters/ # 定义请求的适配器 xhr、http│ │ ├── http.js # 实现 http 适配器(包装 http 包)│ │ └── xhr.js # 实现 xhr 适配器(包装 xhr 对象)│ ├── /cancel/ # 定义取消功能│ ├── /core/ # 一些核心功能│ │ ├── Axios.js # axios 的核心主类│ │ ├── dispatchRequest.js # 用来调用 http 请求适配器方法发送请求的函数│ │ ├── InterceptorManager.js # 拦截器的管理器│ │ └── settle.js # 根据 http 响应状态，改变 Promise 的状态│ ├── /helpers/ # 一些辅助方法│ ├── axios.js # 对外暴露接口│ ├── defaults.js # axios 的默认配置│ └── utils.js # 公用工具├── package.json # 项目信息├── index.d.ts # 配置 TypeScript 的声明文件└── index.js # 入口文件 axios 与 Axios 的关系 从语法上来说: axios 不是 Axios 的实例 从功能上来说: axios 是 Axios 的实例 axios 是 Axios.prototype.request 函数 bind()返回的函数 axios 作为对象有 Axios 原型对象上的所有方法, 有 Axios 对象上所有属性 instance 与 axios 的区别? 相同:(1) 都是一个能发任意请求的函数: request(config)(2) 都有发特定请求的各种方法: get()/post()/put()/delete()(3) 都有默认配置和拦截器的属性: defaults/interceptors 不同:(1) 默认配置很可能不一样(2) instance 没有 axios 后面添加的一些方法: create()/CancelToken()/all() axios运行的整体流程 整体流程:request(config) ==&gt; dispatchRequest(config) ==&gt; xhrAdapter(config) request(config):将请求拦截器 / dispatchRequest() / 响应拦截器 通过 promise 链串连起来, 返回 promise dispatchRequest(config):转换请求数据 ===&gt; 调用 xhrAdapter()发请求 ===&gt; 请求返回后转换响应数 据. 返回 promise xhrAdapter(config):创建 XHR 对象, 根据 config 进行相应设置, 发送特定请求, 并接收响应数据, 返回 promise 流程图: axios 的请求/响应拦截器是什么? 请求拦截器:Ⅰ- 在真正发送请求前执行的回调函数Ⅱ- 可以对请求进行检查或配置进行特定处理Ⅲ- 成功的回调函数, 传递的默认是 config(也必须是)Ⅳ- 失败的回调函数, 传递的默认是 error 响应拦截器Ⅰ- 在请求得到响应后执行的回调函数Ⅱ- 可以对响应数据进行特定处理Ⅲ- 成功的回调函数, 传递的默认是 responseⅣ- 失败的回调函数, 传递的默认是 error axios 的请求/响应数据转换器是什么? 请求转换器: 对请求头和请求体数据进行特定处理的函数 1234&gt;if (utils.isObject(data)) &#123;setContentTypeIfUnset(headers, &#x27;application/json;charset=utf-8&#x27;);return JSON.stringify(data);&gt;&#125; 响应转换器: 将响应体 json 字符串解析为 js 对象或数组的函数 1&gt;response.data = JSON.parse(response.data) response与error 的整体结构 response的整体结构 123&gt;&#123;&gt;data, status,statusText,headers,config,request&gt;&#125; error 的整体结构 123&gt;&#123;&gt;message,response,request,&gt;&#125; 如何取消未完成的请求? 当配置了 cancelToken 对象时, 保存 cancel 函数(1) 创建一个用于将来中断请求的 cancelPromise(2) 并定义了一个用于取消请求的 cancel 函数(3) 将 cancel 函数传递出来 调用 cancel()取消请求(1) 执行 cacel 函数, 传入错误信息 message(2) 内部会让 cancelPromise 变为成功, 且成功的值为一个 Cancel 对象(3) 在 cancelPromise 的成功回调中中断请求, 并让发请求的 proimse 失败,失败的 reason 为 Cancel 对象 Axios源码模拟实现axios 的创建过程模拟实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&gt;&lt;script&gt;&gt;//构造函数&gt;function Axios(config) &#123;//初始化this.defaults = config; //为了创建 default 默认属性this.intercepters = &#123; request: &#123;&#125;, response: &#123;&#125;&#125;&gt;&#125;&gt;//原型添加相关的方法&gt;Axios.prototype.request = function (config) &#123;console.log(&#x27;发送 AJAX 请求 请求的类型为 &#x27; + config.method);&gt;&#125;&gt;Axios.prototype.get = function (config) &#123;return this.request(&#123; method: &#x27;GET&#x27;&#125;);&gt;&#125;&gt;Axios.prototype.post = function (config) &#123;return this.request(&#123; method: &#x27;POST&#x27;&#125;);&gt;&#125;&gt;//声明函数&gt;function createInstance(config) &#123;//实例化一个对象let context = new Axios(config); // context.get() context.post() 但是不能当做函数使用 context() X//创建请求函数let instance = Axios.prototype.request.bind(context); // instance 是一个函数 并且可以 instance(&#123;&#125;) 此时 instance 不能 instance.get X//将 Axios.prototype 对象中的方法添加到instance函数对象中,才可以instance.get....Object.keys(Axios.prototype).forEach(key =&gt; &#123; instance[key] = Axios.prototype[key].bind(context); // this.default this.interceptors&#125;);//为 instance 函数对象添加属性 default 与 interceptorsObject.keys(context).forEach(key =&gt; &#123; instance[key] = context[key];&#125;);return instance;&gt;&#125;&gt;let axios = createInstance();&gt;//发送请求&gt;// axios(&#123;method:&#x27;POST&#x27;&#125;);&gt;axios.get(&#123;&#125;);&gt;axios.post(&#123;&#125;);&gt;&lt;/script&gt; axios发送请求过程详解 整体流程:request(config) ==&gt; dispatchRequest(config) ==&gt; xhrAdapter(config) request(config):将请求拦截器 / dispatchRequest() / 响应拦截器 通过 promise 链串连起来,返回 promise dispatchRequest(config):转换请求数据 ===&gt; 调用 xhrAdapter()发请求 ===&gt; 请求返回后转换响应数据. 返回 promise xhrAdapter(config):创建 XHR 对象, 根据 config 进行相应设置, 发送特定请求, 并接收响应数据,返回 promise 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&gt;&lt;script&gt; // axios 发送请求 axios Axios.prototype.request bind //1. 声明构造函数 function Axios(config) &#123; this.config = config; &#125; Axios.prototype.request = function (config) &#123; //发送请求 //创建一个 promise 对象 let promise = Promise.resolve(config); //声明一个数组 let chains = [dispatchRequest, undefined]; // undefined 占位 //调用 then 方法指定回调 let result = promise.then(chains[0], chains[1]); //返回 promise 的结果 return result; &#125; //2. dispatchRequest 函数 function dispatchRequest(config) &#123; //调用适配器发送请求 return xhrAdapter(config).then(response =&gt; &#123; //响应的结果进行转换处理 //.... return response; &#125;, error =&gt; &#123; throw error; &#125;); &#125; //3. adapter 适配器 function xhrAdapter(config) &#123; console.log(&#x27;xhrAdapter 函数执行&#x27;); return new Promise((resolve, reject) =&gt; &#123; //发送 AJAX 请求 let xhr = new XMLHttpRequest(); //初始化 xhr.open(config.method, config.url); //发送 xhr.send(); //绑定事件 xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; //判断成功的条件 if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123; //成功的状态 resolve(&#123; //配置对象 config: config, //响应体 data: xhr.response, //响应头 headers: xhr.getAllResponseHeaders(), //字符串 parseHeaders // xhr 请求对象 request: xhr, //响应状态码 status: xhr.status, //响应状态字符串 statusText: xhr.statusText &#125;); &#125; else &#123; //失败的状态 reject(new Error(&#x27;请求失败 失败的状态码为&#x27; + xhr.status)); &#125; &#125; &#125; &#125;); &#125; //4. 创建 axios 函数 let axios = Axios.prototype.request.bind(null); axios(&#123; method: &#x27;GET&#x27;, url: &#x27;http://localhost:3000/posts&#x27; &#125;).then(response =&gt; &#123; console.log(response); &#125;);&lt;/script&gt; 拦截器的模拟实现 array.shift()该方法用于把数组的第一个元素从其中删除，并返回第一个元素的值 思路为先将拦截器的响应回调与请求回调都压入一个数组中,之后进行遍历运行 promise = promise.then(chains.shift(), chains.shift()); 通过循环使用promise的then链条得到最终的结果—&gt;等式前面的promise将被最终的结果覆盖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&gt;&lt;!DOCTYPE html&gt;&gt;&lt;html lang=&quot;en&quot;&gt;&gt;&lt;head&gt;&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&gt;&lt;title&gt;拦截器&lt;/title&gt;&gt;&lt;!-- &lt;script src=&quot;./node_modules/axios/dist/mine-axios.js&quot;&gt;&lt;/script&gt; --&gt;&gt;&lt;/head&gt;&gt;&lt;body&gt;&gt;&lt;script&gt; //构造函数 function Axios(config)&#123; this.config = config; this.interceptors = &#123; request: new InterceptorManager(), response: new InterceptorManager(), &#125; &#125; //发送请求 难点与重点 Axios.prototype.request = function(config)&#123; //创建一个 promise 对象 let promise = Promise.resolve(config); //创建一个数组 const chains = [dispatchRequest, undefined]; //处理拦截器 //请求拦截器 将请求拦截器的回调 压入到 chains 的前面 request.handles = [] this.interceptors.request.handlers.forEach(item =&gt; &#123; chains.unshift(item.fulfilled, item.rejected); &#125;); //响应拦截器 this.interceptors.response.handlers.forEach(item =&gt; &#123; chains.push(item.fulfilled, item.rejected); &#125;); // console.log(chains); //遍历 while(chains.length &gt; 0)&#123; //array.shift() promise = promise.then(chains.shift(), chains.shift()); &#125; return promise; &#125; //发送请求 function dispatchRequest(config)&#123; //返回一个promise 队形 return new Promise((resolve, reject) =&gt; &#123; resolve(&#123; status: 200, statusText: &#x27;OK&#x27; &#125;); &#125;); &#125; //创建实例 let context = new Axios(&#123;&#125;); //创建axios函数 let axios = Axios.prototype.request.bind(context); //将 context 属性 config interceptors 添加至 axios 函数对象身上 Object.keys(context).forEach(key =&gt; &#123; axios[key] = context[key]; &#125;); //拦截器管理器构造函数 function InterceptorManager()&#123; this.handlers = []; &#125; InterceptorManager.prototype.use = function(fulfilled, rejected)&#123; this.handlers.push(&#123; fulfilled, rejected &#125;) &#125; //以下为功能测试代码 // 设置请求拦截器 config 配置对象 axios.interceptors.request.use(function one(config) &#123; console.log(&#x27;请求拦截器 成功 - 1号&#x27;); return config; &#125;, function one(error) &#123; console.log(&#x27;请求拦截器 失败 - 1号&#x27;); return Promise.reject(error); &#125;); axios.interceptors.request.use(function two(config) &#123; console.log(&#x27;请求拦截器 成功 - 2号&#x27;); return config; &#125;, function two(error) &#123; console.log(&#x27;请求拦截器 失败 - 2号&#x27;); return Promise.reject(error); &#125;); // 设置响应拦截器 axios.interceptors.response.use(function (response) &#123; console.log(&#x27;响应拦截器 成功 1号&#x27;); return response; &#125;, function (error) &#123; console.log(&#x27;响应拦截器 失败 1号&#x27;) return Promise.reject(error); &#125;); axios.interceptors.response.use(function (response) &#123; console.log(&#x27;响应拦截器 成功 2号&#x27;) return response; &#125;, function (error) &#123; console.log(&#x27;响应拦截器 失败 2号&#x27;) return Promise.reject(error); &#125;); //发送请求 axios(&#123; method: &#x27;GET&#x27;, url: &#x27;http://localhost:3000/posts&#x27; &#125;).then(response =&gt; &#123; console.log(response); &#125;);&gt;&lt;/script&gt;&gt;&lt;/body&gt;&gt;&lt;/html&gt; 请求取消功能模拟实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&gt;&lt;!DOCTYPE html&gt;&gt;&lt;html lang=&quot;en&quot;&gt;&gt;&lt;head&gt;&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&gt;&lt;title&gt;取消请求&lt;/title&gt;&gt;&lt;link crossorigin=&#x27;anonymous&#x27; href=&quot;https://cdn.bootcss.com/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;&gt;rel=&quot;stylesheet&quot;&gt;&gt;&lt;!-- &lt;script src=&quot;./node_modules/axios/dist/mine-axios.js&quot;&gt;&lt;/script&gt; --&gt;&gt;&lt;/head&gt;&gt;&lt;body&gt;&gt;&lt;div class=&quot;container&quot;&gt;&gt;&lt;h2 class=&quot;page-header&quot;&gt;axios取消请求&lt;/h2&gt;&gt;&lt;button class=&quot;btn btn-primary&quot;&gt; 发送请求 &lt;/button&gt;&gt;&lt;button class=&quot;btn btn-warning&quot;&gt; 取消请求 &lt;/button&gt;&gt;&lt;/div&gt;&gt;&lt;script&gt;&gt;//构造函数&gt;function Axios(config) &#123;this.config = config;&gt;&#125;&gt;//原型 request 方法&gt;Axios.prototype.request = function (config) &#123;return dispatchRequest(config);&gt;&#125;&gt;//dispatchRequest 函数&gt;function dispatchRequest(config) &#123;return xhrAdapter(config);&gt;&#125;&gt;//xhrAdapter&gt;function xhrAdapter(config) &#123;//发送 AJAX 请求return new Promise((resolve, reject) =&gt; &#123; //实例化对象 const xhr = new XMLHttpRequest(); //初始化 xhr.open(config.method, config.url); //发送 xhr.send(); //处理结果 xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; //判断结果 if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123; //设置为成功的状态 resolve(&#123; status: xhr.status, statusText: xhr.statusText &#125;); &#125; else &#123; reject(new Error(&#x27;请求失败&#x27;)); &#125; &#125; &#125; //关于取消请求的处理 if (config.cancelToken) &#123; //对 cancelToken 对象身上的 promise 对象指定成功的回调 config.cancelToken.promise.then(value =&gt; &#123; xhr.abort(); //将整体结果设置为失败 reject(new Error(&#x27;请求已经被取消&#x27;)) &#125;); &#125;&#125;)&gt;&#125;&gt;//创建 axios 函数&gt;const context = new Axios(&#123;&#125;);&gt;const axios = Axios.prototype.request.bind(context);&gt;//CancelToken 构造函数&gt;function CancelToken(executor) &#123;//声明一个变量var resolvePromise;//为实例对象添加属性this.promise = new Promise((resolve) =&gt; &#123; //将 resolve 赋值给 resolvePromise resolvePromise = resolve&#125;);//调用 executor 函数executor(function () &#123; //执行 resolvePromise 函数 resolvePromise();&#125;);&gt;&#125;&gt;//获取按钮 以上为模拟实现的代码&gt;const btns = document.querySelectorAll(&#x27;button&#x27;);&gt;//2.声明全局变量&gt;let cancel = null;&gt;//发送请求&gt;btns[0].onclick = function () &#123;//检测上一次的请求是否已经完成if (cancel !== null) &#123; //取消上一次的请求 cancel();&#125;//创建 cancelToken 的值let cancelToken = new CancelToken(function (c) &#123; cancel = c;&#125;);axios(&#123; method: &#x27;GET&#x27;, url: &#x27;http://localhost:3000/posts&#x27;, //1. 添加配置对象的属性 cancelToken: cancelToken&#125;).then(response =&gt; &#123; console.log(response); //将 cancel 的值初始化 cancel = null;&#125;)&gt;&#125;&gt;//绑定第二个事件取消请求&gt;btns[1].onclick = function () &#123;cancel();&gt;&#125;&gt;&lt;/script&gt;&gt;&lt;/body&gt;&gt;&lt;/html&gt; 原作者对于某些问题解答与理解axios同步与异步转换,在外部取值12345678910111213141516171819202122232425262728293031323334const axios = require (&#x27;axios&#x27;); //创建实例对象 const $http = axios.create(&#123; baseURL: &#x27;http://localhost:53000&#x27;, timeout: 11000 //请求超时时间&#125;);let resolveCommon = ()=&gt; &#123; let data=$http(&#123; url:&quot;/test&quot;&#125;) .then(v=&gt;v.data) //等于 `.then(v=&gt;&#123;return v&#125;)` console.log(data) //打印结果: Promise &#123; &lt;pending&gt; &#125; &#125;;let resolveAsync=async ()=&gt; &#123; let data=await $http(&#123; url:&quot;/test&quot;&#125;) .then(v=&gt;v.data) //等于 `.then(v=&gt;&#123;return v&#125;)`,我再then()中返回出去,让外部承接 console.log(data) //获得正确的值 /** * 打印结果&#123; id: 1000,course_name: &#x27;这是请求数据1&#x27;, autor: &#x27;袁明&#x27;, college: &#x27;金并即总变史&#x27;,category_Id: 2&#125; * */ //模拟新增数据,将上一步的结果简单加工一下 data.course_name=data.course_name+1 $http(&#123; url:&quot;/test&quot;, method:&quot;put&quot;, data &#125;).then(v=&gt;&#123; console.log(v) //直接打印了 需要再取出参照上一步 &#125;)&#125;;resolveCommon() //调用普通promise函数resolveAsync() //调用await+async","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://hasuer.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"Promise学习笔记","slug":"Promise学习笔记","date":"2022-02-23T13:58:50.000Z","updated":"2022-02-25T06:57:38.671Z","comments":true,"path":"promise学习笔记/index.html","link":"","permalink":"https://hasuer.github.io/promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html","excerpt":"","text":"笔记转载自这里，有适当改动。 视频教程是尚硅谷Web前端Promise教程从入门到精通 Promise的理解与使用 1、概念: ​ Promise是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。 通俗讲，Promise是一个许诺、承诺,是对未来事情的承诺，承诺不一定能完成，但是无论是否能完成都会有一个结果。 Pending 正在做。。。 Resolved 完成这个承诺 Rejected 这个承诺没有完成，失败了 ​ Promise 用来预定一个不一定能完成的任务，要么成功，要么失败 ​ 在具体的程序中具体的体现，通常用来封装一个异步任务，提供承诺结果 Promise 是异步编程的一种解决方案，主要用来解决回调地狱的问题，可以有效的减少回调嵌套。真正解决需要配合async/await 2、特点: ​ (1)对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。 ​ (2)一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。 3、缺点: ​ (1)无法取消Promise，一旦新建它就会立即执行，无法中途取消。和一般的对象不一样，无需调用。 ​ (2)如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。 ​ (3)当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成） Promise是什么?理解 抽象表达: ​ 1) Promise 是一门新的技术(ES6 规范) ​ 2)Promise 是 JS 中进行异步编程的新解决方案 备注：旧方案是单纯使用回调函数 具体表达: 1) 从语法上来说: Promise 是一个构造函数 2) 从功能上来说: promise 对象用来封装一个异步操作并可以获取其成功/ 失败的结果值 promise 的状态promise 的状态 实例对象中的一个属性 『PromiseState』 pending 未决定的 resolved / fullfilled 成功 rejected 失败 promise 的状态改变 pending 变为 resolved pending 变为 rejected 说明: 只有这 2 种, 且一个 promise 对象只能改变一次 无论变为成功还是失败, 都会有一个结果数据 成功的结果数据一般称为 value, 失败的结果数据一般称为 reason promise的基本流程 promise的基本使用使用 promise 封装基于定时器的异步1234567891011121314151617181920212223242526272829&lt;script &gt; function doDelay(time) &#123; // 1. 创建 promise 对象(pending 状态), 指定执行器函数 return new Promise((resolve, reject) =&gt; &#123; // 2. 在执行器函数中启动异步任务 console.log(&#x27;启动异步任务&#x27;) setTimeout(() =&gt; &#123; console.log(&#x27;延迟任务开始执行...&#x27;) const time = Date.now() // 假设: 时间为奇数代表成功, 为偶数代表失败 if (time % 2 === 1) &#123; // 成功了 // 3. 1. 如果成功了, 调用 resolve()并传入成功的 value resolve(&#x27;成功的数据 &#x27; + time) &#125; else &#123; // 失败了 // 3.2. 如果失败了, 调用 reject()并传入失败的 reason reject(&#x27;失败的数据 &#x27; + time) &#125; &#125;, time) &#125;) &#125;const promise = doDelay(2000)promise.then(// promise 指定成功或失败的回调函数来获取成功的 vlaue 或失败的 reason value =&gt; &#123;// 成功的回调函数 onResolved, 得到成功的 vlaue console.log(&#x27;成功的 value: &#x27;, value) &#125;, reason =&gt; &#123; // 失败的回调函数 onRejected, 得到失败的 reason console.log(&#x27;失败的 reason: &#x27;, reason) &#125;, ) &lt; /script&gt; 使用 promise 封装 ajax 异步请求12345678910111213141516171819202122232425262728293031323334&lt;script &gt; /* 可复用的发 ajax 请求的函数: xhr + promise */ function promiseAjax(url) &#123; return new Promise((resolve, reject) =&gt; &#123; const xhr = new XMLHttpRequest() xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState !== 4) return const &#123; status, response &#125; = xhr // 请求成功, 调用 resolve(value) if (status &gt;= 200 &amp;&amp; status &lt; 300) &#123; resolve(JSON.parse(response)) &#125; else &#123; // 请求失败, 调用 reject(reason) reject(new Error(&#x27;请求失败: status: &#x27; + status)) &#125; &#125; xhr.open(&quot;GET&quot;, url) xhr.send() &#125;) &#125;promiseAjax(&#x27;https://api.apiopen.top2/getJoke?page=1&amp;count=2&amp;type=vid eo &#x27;) .then( data =&gt; &#123; console.log(&#x27;显示成功数据&#x27;, data) &#125;, error =&gt; &#123; alert(error.message) &#125; ) &lt;/script&gt; fs模块使用Promise123456789101112131415161718192021222324252627282930313233343536const fs = require(&#x27;fs&#x27;);//回调函数 形式---------------------------------------------------- fs.readFile(&#x27;./resource/content.txt&#x27;, (err, data) =&gt; &#123; // 如果出错 则抛出错误 if(err) throw err; //输出文件内容 console.log(data.toString()); &#125;);//Promise 形式-----------------------------------------------------------/** * 封装一个函数 mineReadFile 读取文件内容 * 参数: path 文件路径 * 返回: promise 对象 */function mineReadFile(path)&#123; return new Promise((resolve, reject) =&gt; &#123; //读取文件 require(&#x27;fs&#x27;).readFile(path, (err, data) =&gt;&#123; //判断 if(err) reject(err); //成功 resolve(data); &#125;); &#125;);&#125;mineReadFile(&#x27;./resource/content.txt&#x27;).then(value=&gt;&#123; //输出文件内容 console.log(value.toString());&#125;, reason=&gt;&#123; console.log(reason);&#125;); 异常穿透 可以在每个then()的第二个回调函数中进行err处理,也可以利用异常穿透特性,到最后用catch去承接统一处理,两者一起用时,前者会生效(因为err已经将其处理,就不会再往下穿透)而走不到后面的catch 在每个.then()中我可以将数据再次传出给下一个then() 123456mineReadFile(&#x27;./11.txt&#x27;).then(result=&gt;&#123; console.log(result.toString()) return result&#125;,err=&gt;console.log(err)).then(data=&gt;console.log(data,&quot;2222222&quot;)).catch(err=&gt;console.log(&quot;这是catch的&quot;)) util.promisify方法 可以将函数直接变成promise的封装方式,不用再去手动封装 12345678910//引入 util 模块const util = require(&#x27;util&#x27;);//引入 fs 模块const fs = require(&#x27;fs&#x27;);//返回一个新的函数let mineReadFile = util.promisify(fs.readFile);mineReadFile(&#x27;./resource/content.txt&#x27;).then(value =&gt; &#123; console.log(value.toString());&#125;); 为什么要用Promise?指定回调函数的方式更加灵活 旧的: 必须在启动异步任务前指定 promise: 启动异步任务 =&gt; 返回promie对象 =&gt; 给promise对象绑定回调函 数(甚至可以在异步任务结束后指定/多个) 支持链式调用, 可以解决回调地狱问题什么是回调地狱 回调函数嵌套调用, 外部回调函数异步执行的结果是嵌套的回调执行的条件 回调地狱的缺点? 不便于阅读 不便于异常处理 解决方案? promise 链式调用, 用来解决回调地狱问题，但是只是简单的改变格式，并没有彻底解决上面的问题真正要解决上述问题，一定要利用promise再加上await和async关键字实现异步传同步 终极解决方案? promise +async/await Promise中的常用 API 概述 此处列举几个最常用的API的概述,如果想看详细描述的可以继续往下看下方的 Promise方法的具体使用 描述 Promise 构造函数: Promise (excutor) {} (1) executor 函数: 执行器 (resolve, reject) =&gt; {} (2) resolve 函数: 内部定义成功时我们调用的函数 value =&gt; {} (3) reject 函数: 内部定义失败时我们调用的函数 reason =&gt; {} 说明: executor 会在 Promise 内部立即**同步调用**,异步操作在执行器中执行,换话说Promise支持同步也支持异步操作 Promise.prototype.then 方法: (onResolved, onRejected) =&gt; {} (1) onResolved 函数: 成功的回调函数 (value) =&gt; {} (2) onRejected 函数: 失败的回调函数 (reason) =&gt; {} 说明: 指定用于得到成功 value 的成功回调和用于得到失败 reason 的失败回调 返回一个新的 promise 对象 Promise.prototype.catch 方法: (onRejected) =&gt; {} (1) onRejected 函数: 失败的回调函数 (reason) =&gt; {} 说明: then()的语法糖, 相当于: then(undefined, onRejected) (2) 异常穿透使用:当运行到最后,没被处理的所有异常错误都会进入这个方法的回调函数中 Promise.resolve 方法: (value) =&gt; {} (1) value: 成功的数据或 promise 对象 说明: 返回一个成功/失败的 promise 对象,直接改变promise状态 Promise.resolve(value) 用结果 value 创建一个 resolved 的 promise。 如同： 1&gt;let promise = new Promise(resolve =&gt; resolve(value)); 12&gt;let p3 = Promise.reject(new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;OK&#x27;); &#125;)); &gt;console.log(p3); Promise.reject 方法: (reason) =&gt; {} (1) reason: 失败的原因 说明: 返回一个失败的 promise 对象,直接改变promise状态,代码示例同上 Promise.reject(error) 用 error 创建一个 rejected 的 promise。 如同： 1&gt;let promise = new Promise((resolve, reject) =&gt; reject(error)); 实际上，这个方法几乎从未被使用过。 Promise.all 方法: (promises) =&gt; {} promises: 包含 n 个 promise 的数组 说明: 返回一个新的 promise, 只有所有的 promise 都成功才成功, 只要有一 个失败了就直接失败 12345&gt;let p1 = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;成功&#x27;); &#125;)&gt;let p2 = Promise.reject(&#x27;错误错误错误&#x27;);&gt;let p3 = Promise.resolve(&#x27;也是成功&#x27;)&gt;const result = Promise.all([p1, p2, p3]);&gt;console.log(result); Promise.race 方法: (promises) =&gt; {} (1) promises: 包含 n 个 promise 的数组 说明: 返回一个新的 promise, 第一个完成的 promise 的结果状态就是最终的结果状态, 如p1延时,开启了异步,内部正常是同步进行,所以p2&gt;p3&gt;p1,结果是P2 12345678910&gt;let p1 = new Promise((resolve, reject) =&gt; &#123;setTimeout(() =&gt; &#123; resolve(&#x27;OK&#x27;);&#125;, 1000);&gt;&#125;)&gt;let p2 = Promise.resolve(&#x27;Success&#x27;);&gt;let p3 = Promise.resolve(&#x27;Oh Yeah&#x27;);&gt;//调用&gt;const result = Promise.race([p1, p2, p3]);&gt;console.log(result); Promise的几个关键问题如何改变 promise 的状态? (1) resolve(value): 如果当前是 pending 就会变为 resolved (2) reject(reason): 如果当前是 pending 就会变为 rejected (3) 抛出异常: 如果当前是 pending 就会变为 rejected 一个 promise 指定多个成功/失败回调函数, 都会调用吗? 当 promise 改变为对应状态时都会调用,改变状态后,多个回调函数都会调用,并不会自动停止 12345&gt;let p = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;OK&#x27;);&#125;);&gt;///指定回调 - 1&gt;p.then(value =&gt; &#123; console.log(value); &#125;);&gt;//指定回调 - 2&gt;p.then(value =&gt; &#123; alert(value);&#125;); 改变 promise 状态和指定回调函数谁先谁后? (1) 都有可能, 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调 ​ 先指定回调再改变状态(异步):先指定回调—&gt; 再改变状态 —&gt;改变状态后才进入异步队列执行回调函数 ​ 先改状态再指定回调(同步):改变状态 —&gt;指定回调 并马上执行回调 (2) 如何先改状态再指定回调? —&gt;注意:指定并不是执行 ​ ① 在执行器中直接调用 resolve()/reject() —&gt;即,不使用定时器等方法,执行器内直接同步操作 ​ ② 延迟更长时间才调用 then() —&gt;即,在.then()这个方法外再包一层例如延时器这种方法 (3) 什么时候才能得到数据? ​ ① 如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据 ​ ② 如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据 1234567&gt;let p = new Promise((resolve, reject) =&gt; &#123;&gt;//异步写法,这样写会先指定回调,再改变状态&gt;setTimeout(() =&gt; &#123;resolve(&#x27;OK&#x27;); &#125;, 1000);&gt;//这是同步写法,这样写会先改变状态,再指定回调&gt;resolve(&#x27;OK&#x27;); &gt;&#125;);&gt;p.then(value =&gt; &#123;console.log(value);&#125;, reason =&gt; &#123;&#125;) (4) 个人理解—结合源码 ​ 源码中,promise的状态是通过一个默认为pending的变量进行判断,所以当你resolve/reject延时(异步导致当then加载时,状态还未修改)后,这时直接进行p.then()会发现,目前状态还是进行中,所以只是这样导致只有同步操作才能成功. ​ 所以promise将传入的回调函数拷贝到promise对象实例上,然后在resolve/reject的执行过程中再进行调用,达到异步的目的 ​ 具体代码实现看下方自定义promise Ⅳ-promise.then()返回的新 promise 的结果状态由什么决定? (1) 简单表达: 由 then()指定的回调函数执行的结果决定 (2) 详细表达: ​ ① 如果抛出异常, 新 promise 变为 rejected, reason 为抛出的异常 ​ ② 如果返回的是非 promise 的任意值, 新 promise 变为 resolved, value 为返回的值 ​ ③ 如果返回的是另一个新 promise, 此 promise 的结果就会成为新 promise 的结果 123456789101112131415161718&gt;let p = new Promise((resolve, reject) =&gt; &#123;&gt;resolve(&#x27;ok&#x27;);&gt;&#125;);&gt;//执行 then 方法&gt;let result = p.then(value =&gt; &#123;&gt;console.log(value);&gt;// 1. 抛出错误 ,变为 rejected&gt;throw &#x27;出了问题&#x27;;&gt;// 2. 返回结果是非 Promise 类型的对象,新 promise 变为 resolved&gt;return 521;&gt;// 3. 返回结果是 Promise 对象,此 promise 的结果就会成为新 promise 的结果&gt;return new Promise((resolve, reject) =&gt; &#123;&gt;// resolve(&#x27;success&#x27;);&gt;reject(&#x27;error&#x27;);&gt;&#125;);&gt;&#125;, reason =&gt; &#123;&gt;console.warn(reason);&gt;&#125;); promise 如何串连多个操作任务? (1) promise 的 then()返回一个新的 promise, 可以开成 then()的链式调用 (2) 通过 then 的链式调用串连多个同步/异步任务,这样就能用then()将多个同步或异步操作串联成一个同步队列 123456&gt;&lt;script&gt;&gt;let p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123;resolve(&#x27;OK&#x27;); &#125;, 1000); &#125;);&gt;p.then(value =&gt; &#123;return new Promise((resolve, reject) =&gt; &#123; resolve(&quot;success&quot;); &#125;);&#125;)&gt;.then(value =&gt; &#123;console.log(value);&#125;)&gt;.then(value =&gt; &#123; console.log(value);&#125;) // 输出undifined, 因为上面一个调用没有返回值&gt;&lt;/script&gt; promise 异常传透? 当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调 前面任何操作出了异常, 都会传到最后失败的回调中处理 1234567891011121314151617&gt;getJSON(&#x27;./hong.json&#x27;) .then(function(posts) &#123; throw new Error(&#x27;抛出异常&#x27;) &#125;).then(res=&gt;console.log(res),e=&gt;console.log(&#x27;被then的错误回调捕获&#x27;,e) ) .catch(function(error) &#123; // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log(&#x27;错误捕获: &#x27;, error);&#125;);&gt;//执行结果: 被then的错误回调捕获 Error: 抛出异常&gt;/******************** 利用异常穿透 ****************************************/&gt;getJSON(&#x27;./hong.json&#x27;) .then(function(posts) &#123; throw new Error(&#x27;抛出异常&#x27;) &#125;).then(res=&gt;console.log(res) ) //此处差异,不指定 reject 回调,利用异常穿透传到最后 .catch(function(error) &#123; console.log(&#x27;错误捕获: &#x27;, error);&#125;);&gt;//执行结果: 错误捕获: Error: 抛出异常 注:可以在每个then()的第二个回调函数中进行err处理,也可以利用异常穿透特性,到最后用catch去承接统一处理,两者一起用时,前者会生效(因为err已经将其处理,就不会再往下穿透)而走不到后面的catch 中断 promise 链? 在关键问题2中,可以得知,当promise状态改变时,他的链式调用都会生效,那如果我们有这个一个实际需求:我们有5个then(),但其中有条件判断,如当我符合或者不符合第三个then条件时,要直接中断链式调用,不再走下面的then,该如何? (1) 当使用 promise 的 then 链式调用时, 在中间中断, 不再调用后面的回调函数 (2) 办法: 在回调函数中返回一个 pendding 状态的promise 对象 1234567&gt;&lt;script&gt;&gt;let p = new Promise((resolve, reject) =&gt; &#123;setTimeout(() =&gt; &#123; resolve(&#x27;OK&#x27;);&#125;, 1000);&#125;);&gt;p.then(value =&gt; &#123;return new Promise(() =&gt; &#123;&#125;);&#125;)//有且只有这一个方式&gt;.then(value =&gt; &#123; console.log(222);&#125;)&gt;.then(value =&gt; &#123; console.log(333);&#125;)&gt;.catch(reason =&gt; &#123;console.warn(reason);&#125;);&gt;&lt;/script&gt; 5、 Promise的实际应用 举两个栗子 Ⅰ - 加载图片 我们可以将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化。 12345678&gt;const preloadImage = function (path) &#123; return new Promise(function (resolve, reject) &#123; const image = new Image(); image.onload = resolve; image.onerror = reject; image.src = path; &#125;);&gt;&#125;; Ⅱ - Generator 函数与 Promise 的结合 使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个Promise对象。 1234567891011121314151617181920212223242526272829303132&gt;function getFoo () &#123;&gt;return new Promise(function (resolve, reject)&#123;&gt;resolve(&#x27;foo&#x27;);&gt;&#125;);&gt;&#125;&gt;const g = function* () &#123;&gt;try &#123;&gt;const foo = yield getFoo();&gt;console.log(foo);&gt;&#125; catch (e) &#123;&gt;console.log(e);&gt;&#125;&gt;&#125;;&gt;function run (generator) &#123;&gt;const it = generator();&gt;function go(result) &#123;&gt;if (result.done) return result.value;&gt;return result.value.then(function (value) &#123;return go(it.next(value));&gt;&#125;, function (error) &#123;return go(it.throw(error));&gt;&#125;);&gt;&#125;&gt;go(it.next());&gt;&#125;&gt;run(g); 上面代码的 Generator 函数g之中，有一个异步操作getFoo，它返回的就是一个Promise对象。函数run用来处理这个Promise对象，并调用下一个next方法。 Promise API 用法详解 ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。 此部分是对于 Promise API 用法的详解 ,尽量详细地列举其常见用法,所以篇幅较长 基本用法举个创造 Promise 实例的栗子 下面代码创造了一个Promise实例。 1234const promise = new Promise(function(resolve, reject) &#123;if (/* 异步操作成功 */) resolve(value); //将该 Promise 修改为成功且返回else reject(error); //将该 Promise 修改为失败且返回&#125;); Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。 resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 使用 [ then ] 方法分别指定 成功/失败 的回调 Promise实例生成以后，可以用 [ then() ] 方法分别指定resolved状态和rejected状态的回调函数。 12345&gt;promise.then(function(value) &#123;&gt;// 当promise状态返回为resolve 时会执行的回调函数&gt;&#125;, function(error) &#123;&gt;// 当promise状态返回为rejected 时会执行的回调函数&gt;&#125;); [ then ] 方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。 举个 Promise 对象的简单栗子 下面是一个Promise对象的简单例子。 setTimeout的第三个参数是给第一个函数的参数，而且是先于第一个参数(即回调函数)执行的 123456789&gt;function timeout(ms) &#123; //声明一个方法, 传入的 参数ms 为延时器时间&gt;return new Promise((resolve, reject) =&gt; &#123; //这行代码实际效果: 当 [ms] 毫秒后 执行 resolve(&#x27;努力学习的汪&#x27;) setTimeout(resolve, ms, &#x27;努力学习的汪&#x27;); &gt;&#125;);&gt;&#125;&gt;timeout(1000).then((value) =&gt; &#123; console.log(value) &#125;);&gt;//打印结果 : 努力学习的汪 上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，Promise实例的状态变为resolved，就会触发then方法绑定的回调函数。 Promise 新建后就会立即执行 1234567891011121314&gt;let promise = new Promise(function(resolve, reject) &#123;&gt;console.log(&#x27;Promise&#x27;);&gt;resolve();&gt;&#125;);&gt;promise.then(function() &#123;&gt;console.log(&#x27;resolved.&#x27;);&gt;&#125;);&gt;console.log(&#x27;Hi!&#x27;);&gt;// Promise&gt;// Hi!&gt;// resolved //可以发现,明明then是在 Hi 前面,却最后打印 上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。 实际上,这个运行结果相关知识点是 [ 宏任务与微任务 ] ,单独梳理在下方.这里可以先初步理解为: JS是单线程的,至上往下运行,在声明 Promise 时实际上已经执行到了内部方法 为何 resolve() 运行后没有立即打印? JS中用来存储待执行回调函数的队列包含2个不同特定的列队 宏队列:用来保存待执行的宏任务(回调),比如:定时器回调/ajax回调/dom事件回调 微队列:用来保存待执行的微任务(回调),比如:Promise的回调/muntation回调 JS执行时会区别这2个队列: JS执行引擎首先必须执行所有的初始化同步任务代码 每次准备取出第一个宏任务执行前,都要将所有的微任务一个一个取出来执行 举个异步加载图片的栗子 123456789101112131415161718&gt;function loadImageAsync(url) &#123;&gt;return new Promise(function(resolve, reject) &#123;&gt;const image = new Image();&gt;image.onload = function() &#123;&gt;console.log(&#x27;图片加载成功&#x27;)&gt;resolve(image);&gt;&#125;;&gt;image.onerror = function() &#123;&gt;reject(new Error(`无法从 $&#123;url&#125; 中加载图片` ));&gt;&#125;;&gt;image.src = url;&gt;&#125;);&gt;&#125;&gt;loadImageAsync(&#x27;正确的url&#x27;) //打印图片加载成功&gt;loadImageAsync(&#x27;错误的url&#x27;) //抛出异常 上面代码中，使用Promise包装了一个图片加载的异步操作。如果加载成功，就调用resolve方法，否则就调用reject方法。 举个用Promise对象实现的 Ajax 操作的栗子 Ajax知识点不懂的同学要去补一下: 这里可以看原作者梳理的ajax笔记 —&gt; 点我跳转 12345678910111213141516171819202122&gt;const getJSON = function(url) &#123;&gt;const promise = new Promise(function(resolve, reject)&#123;&gt;const handler = function() &#123;&gt;if (this.readyState !== 4) return; //当readyState 为4 时直接返回,不修改 promise 状态&gt;if (this.status === 200) resolve(this.response); //返回状态为 200 时将状态修改为成功,且将响应内容返回&gt;else reject(new Error(this.statusText)); //失败时抛出异常&gt;&#125;;&gt;const client = new XMLHttpRequest(); //实例化xml实例&gt;client.open(&quot;GET&quot;, url); //下面这几行都是对xml实例进行配置,不懂的同学要去补一下ajax知识点&gt;client.onreadystatechange = handler;&gt;client.responseType = &quot;json&quot;;&gt;client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);&gt;client.send();&gt;&#125;);&gt;return promise;&gt;&#125;;&gt;getJSON(&quot;./hong.json&quot;).then(function(json) &#123;&gt;console.log(&#x27;Contents: &#x27; , json);&gt;&#125;, function(error) &#123;&gt;console.error(&#x27;出错了&#x27;, error);&gt;&#125;); 上面代码中，getJSON是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。 小贴士:此处可能有同学想尝试却发现读取本地文件会有跨域问题,这边教一下你们 resolve() 的参数可以是另一个 Promise 实例 如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。 123&gt;const p1 = new Promise(function (resolve, reject) &#123;&#125;);&gt;const p2 = new Promise(function (resolve, reject) &#123; resolve(p1) &#125;) 上面代码中，p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。 注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。 123456789101112&gt;const p1 = new Promise(function (resolve, reject) &#123;&gt;setTimeout(() =&gt; reject(new Error(&#x27;p1的状态改为错误&#x27;)), 0)&gt;&#125;)&gt;const p2 = new Promise(function (resolve, reject) &#123;&gt;setTimeout(() =&gt; resolve(p1), 3000) //将p1 传给p2&gt;&#125;)&gt;p2.then(result =&gt; console.log(result),result=&gt;console.log(&#x27;失败&#x27;))&gt;.catch(error =&gt; console.log(&#x27;catch异常捕获:&#x27;+error))&gt;//首先报错&gt;//运行三秒后打印: 失败 上面代码运行后执行效果: 首先马上会打印一个报错 : “Uncaught (in promise) Error: p1的状态改为错误” (红色报错) 然后等3秒后再打印: ‘失败’ 注意: 如果 p2.then() 中没有写 reject 回调函数(第二个参数),则会被 catch 捕获,变为catch异常捕获:Error: p1的状态改为错误 解释: 首先前面说过,promise定义时就会立即执行,所以刚开始就运行了 p1 的reject(),所以直接控制台报错了 resolve方法返回的是p1。由于p2返回的是另一个 Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态 总结来说,promise返回promise这种嵌套形式,将由最内层的promise决定外层的状态 调用resolve或reject并不会终结 Promise 的参数函数的执行 调用resolve或reject并不会终结 Promise 的参数函数的执行。 12345678&gt;new Promise((resolve, reject) =&gt; &#123;&gt;resolve(1);&gt;console.log(2);&gt;&#125;).then(r =&gt; &#123;&gt;console.log(r);&gt;&#125;);&gt;// 2&gt;// 1 上面代码中，调用resolve(1)以后，后面的console.log(2)还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。 建议在修改状态函数前加return 一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。 12345&gt;new Promise((resolve, reject) =&gt; &#123;&gt;return resolve(1);&gt;// 后面的语句不会执行&gt;console.log(2);&gt;&#125;) 有同学可能就会问了,不加感觉也没啥事啊,反正我在这个函数体内就是要做这些操作,放在 resolve/reject前后好像都不影响啊! 这里我给举个实际场景 不加 return 导致的错误场景举🌰 一般来说,错误发生在 Promise 内,是不会传到外部的,只会在 Promise 内部消化,详见下方API详解部分的 ②Promise.prototype.catch()) 1234567&gt;const promise = new Promise(function (resolve, reject) &#123;&gt;resolve(&#x27;成功了&#x27;); //如果你加了 return , 函数执行到此步就停止了&gt;setTimeout(function () &#123; throw new Error(&#x27;错误错误!!!!!&#x27;) &#125;, 0)&gt;&#125;);&gt;promise.then(function (value) &#123; console.log(value) &#125;);&gt;// ok&gt;// Uncaught Error: 错误错误!!!! 上面代码中，Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。 Ⅱ - API 用法详解 此处将对于所有API进行详细剖析,参照资料为 阮一峰的ES6日志(原作者这里没有给出链接） Promise.prototype.then() Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。 then方法返回的是一个新的Promise实例 then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。 12345&gt;getJSON(&quot;./hong.json&quot;).then(function(json) &#123;&gt;return json.name;&gt;&#125;).then(function(name) &#123;&gt;console.log(`My name is $&#123;name&#125;` )&gt;&#125;); 上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。 采用链式的then, 会等待前一个Promise状态发生改变才会被调用 采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。 123456&gt;getJSON(&quot;./hong.json&quot;)&gt;.then(function(json) &#123; return getJSON(json.name)&#125;)&gt;.then(&gt;function (name) &#123; console.log(&quot;resolved: My name is &quot;, name)&#125;, &gt;function (err)&#123; console.log(&quot;rejected: &quot;, err)&#125;&gt;); 上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为resolved，就调用第一个回调函数，如果状态变为rejected，就调用第二个回调函数。 使用箭头函数简写 如果采用箭头函数，上面的代码可以写得更简洁 (实际代码中基本都是这样写了) 123456&gt;getJSON(&quot;./hong.json&quot;)&gt;.then(json =&gt; getJSON(json.name) )&gt;.then( name =&gt; console.log(&quot;resolved: My name is &quot;, name), &gt;err =&gt; console.log(&quot;rejected: &quot;, err)&gt;); Promise.prototype.catch() Promise.prototype.catch()方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。 基本用法 123456&gt;getJSON(&#x27;./hong.json&#x27;)&gt;.then(function(posts) &#123;&#125;)&gt;.catch(function(error) &#123; // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log(&#x27;发生错误！&#x27;, error); &#125;); 上面代码中，getJSON()方法返回一个 Promise 对象 如果该对象状态变为resolved，则会调用then()方法指定的回调函数； 如果异步操作抛出错误，状态就会变为rejected，就会调用catch()方法指定的回调函数，处理这个错误 另外，then()方法指定的回调函数，如果运行中抛出错误，也会被catch()方法捕获。 被 catch 方法捕获的前提是前方的 then() 方法中没有对 rejected 进行捕获处理(即没有写reject回调函数) 12345&gt;p.then((val) =&gt; console.log(&#x27;指定成功回调:&#x27;, val))&gt;.catch((err) =&gt; console.log(&#x27;在catch中进行 rejected 的处理&#x27;, err));&gt;// 等同于&gt;p.then((val) =&gt; console.log(&#x27;指定成功回调:&#x27;, val))&gt;.then(null, (err) =&gt; console.log(&quot;等同于另起一个then,只指定 rejected 的处理&quot;, err)); reject()方法的作用，等同于抛出错误 1234567&gt;const promise = new Promise(function(resolve, reject) &#123;&gt;throw new Error(&#x27;直接抛出错误&#x27;);&gt;&#125;);&gt;promise.catch(function(error) &#123;&gt;console.log(&#x27;异常捕获: &#x27;,error);&gt;&#125;);&gt;//异常捕获: Error: 直接抛出错误 上面代码中，promise抛出一个错误，就被catch()方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。 1234567891011121314151617181920212223&gt;/****************** 写法一 ***************************************/&gt;const promise = new Promise(function(resolve, reject) &#123;&gt;try &#123;&gt;throw new Error(&#x27;直接抛出错误&#x27;);&gt;&#125; catch(e) &#123;&gt;console.log(&#x27;进入catch,然后再用 reject(e)抛出 &#x27;)&gt;reject(e) &gt;&#125;&gt;&#125;);&gt;promise.catch(function(error) &#123;&gt;console.log(error);&gt;&#125;);&gt;//进入catch,然后再用 reject(e)抛出 &gt;//Error: 直接抛出错误&gt;/****************** 写法二 ***************************************/&gt;const promise1 = new Promise(function(resolve, reject) &#123;&gt;reject(new Error(&#x27;使用 reject() 抛出错误&#x27;));&gt;&#125;);&gt;promise1.catch(function(error) &#123;&gt;console.log(error);&gt;&#125;);&gt;//Error: 使用 reject() 抛出错误 比较上面两种写法，可以发现reject()方法的作用，等同于抛出错误,所以不必用try..catch()去承接后再去抛出了 如果 Promise 状态已经被修改，再抛出错误是无效的 12345678&gt;const promise = new Promise(function(resolve, reject) &#123;&gt;resolve(&#x27;成功了&#x27;); //换成 reject(&#x27;成功了&#x27;) 结果也是一样的&gt;throw new Error(&#x27;成功后扔抛出异常&#x27;);&gt;&#125;);&gt;promise&gt;.then(function(value) &#123; console.log(value) &#125;)&gt;.catch(function(error) &#123; console.log(error) &#125;);&gt;// 成功了 上面代码中，Promise 在resolve/reject语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了(前面有说过) Promise 对象的错误具有 “冒泡” 性质 Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。 123456789&gt;getJSON(&#x27;./hong.json&#x27;) //第一个promise&gt;.then(function(post) &#123; //第二个promise return getJSON(post.commentURL)&#125;)&gt;.then(function(comments) &#123; //第三个promise&#125;)&gt;.catch(function(error) &#123; // 处理前面三个Promise产生的错误&#125;); 上面代码中，一共有三个 Promise 对象(then返回的仍可能是一个Promise对象)：一个由getJSON()产生，两个由then()产生。它们之中任何一个抛出的错误，都会被最后一个catch()捕获。 也是因为这个特性,有了 异常穿透问题 异常穿透问题 当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调 前面任何操作出了异常, 都会传到最后失败的回调中处理 1234567891011121314151617&gt;getJSON(&#x27;./hong.json&#x27;)&gt;.then(function(posts) &#123; throw new Error(&#x27;抛出异常&#x27;) &#125;).then(res=&gt;console.log(res),e=&gt;console.log(&#x27;被then的错误回调捕获&#x27;,e) )&gt;.catch(function(error) &#123; // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log(&#x27;错误捕获: &#x27;, error);&#125;);&gt;//执行结果: 被then的错误回调捕获 Error: 抛出异常&gt;/******************** 利用异常穿透 ****************************************/&gt;getJSON(&#x27;./hong.json&#x27;)&gt;.then(function(posts) &#123; throw new Error(&#x27;抛出异常&#x27;) &#125;).then(res=&gt;console.log(res) ) //此处差异,不指定 reject 回调,利用异常穿透传到最后&gt;.catch(function(error) &#123; console.log(&#x27;错误捕获: &#x27;, error);&#125;);&gt;//执行结果: 错误捕获: Error: 抛出异常 注:可以在每个then()的第二个回调函数中进行err处理,也可以利用异常穿透特性,到最后用catch去承接统一处理,两者一起用时,前者会生效(因为err已经将其处理,就不会再往下穿透)而走不到后面的catch 建议使用 catch() 进行异常处理 一般来说，不要在then()方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。 12345678910&gt;// bad&gt;promise&gt;.then(&gt;data=&gt; console.log(&#x27;成功&#x27;,data),&gt;err=&gt;console.log(&#x27;失败了&#x27;,err));&gt;/********* 好的写法 ********************/&gt;promise&gt;.then( data=&gt; console.log(&#x27;成功&#x27;,data)) //只指定成功回调&gt;.catch( err=&gt;console.log(&#x27;失败了&#x27;,err)); 上面代码中，第二种写法要好于第一种写法: 理由是第二种写法可以捕获前面then方法执行中的错误 也更接近同步的写法（try/catch） 因此, 建议总是使用catch()方法，而不使用then()方法的第二个参数。 与传统 try/catch 代码块的差异 跟传统的try/catch代码块不同的是，如果没有使用catch()方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。 123456789101112&gt;const someAsyncThing = function() &#123;&gt;return new Promise(function(resolve, reject) &#123;&gt;// 下面一行会报错，因为hong 没有声明&gt;resolve( hong );&gt;&#125;);&gt;&#125;;&gt;//Promise 的 then() 处理,但不处理异常&gt;someAsyncThing().then(function() &#123; console.log(&#x27;只指定成功回调,不处理异常错误&#x27;) &#125;);&gt;setTimeout(() =&gt; &#123; console.log(&#x27;努力学习的汪&#x27;) &#125;, 2000);&gt;// Uncaught (in promise) ReferenceError: hong is not defined&gt;// 努力学习的汪 上面代码中，someAsyncThing()函数产生的 Promise 对象，内部有语法错误。 浏览器运行到这一行，会打印出错误提示Uncaught (in promise) ReferenceError: hong is not defined 但是不会退出进程、终止脚本执行, 2 秒之后还是会输出努力学习的汪。 这就是说，Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。 catch()方法后还能跟 then() 方法 一般总是建议，Promise 对象后面要跟catch()方法，这样可以处理 Promise 内部发生的错误。catch()方法返回的还是一个 Promise 对象，因此后面还可以接着调用then()方法。 123456789101112&gt;const someAsyncThing = function() &#123;&gt;return new Promise(function(resolve, reject) &#123;&gt;// 下面一行会报错，因为 hong 没有声明&gt;resolve( hong );&gt;&#125;);&gt;&#125;;&gt;someAsyncThing()&gt;.catch(function(error) &#123; console.log(&#x27;捉到错误咯:&#x27;, error)&#125;)&gt;.then(function() &#123; console.log(&#x27;错误捕获后我还要浪&#x27;) &#125;);&gt;//捉到错误咯: ReferenceError: hong is not defined&gt;//错误捕获后我还要浪 上面代码运行完catch()方法指定的回调函数，会接着运行后面那个then()方法指定的回调函数。 如果没有报错，则会跳过catch()方法。 1234&gt;Promise.resolve(&#x27;硬是成功了&#x27;)&gt;.catch(function(error) &#123; console.log(&#x27;捉错误&#x27;, error) &#125;)&gt;.then(v =&gt; console.log(&#x27;catch后面的then: &#x27;,v) );&gt;//catch后面的then: 硬是成功了 上面的代码因为没有报错，跳过了catch()方法，直接执行后面的then()方法。此时，要是then()方法里面报错，就与前面的catch()无关了。 catch()方法之中，还能再抛出错误 catch()方法之中，还能再抛出错误。 123456789101112131415161718&gt;const someAsyncThing = function() &#123;&gt;return new Promise(function(resolve, reject) &#123;&gt;// 下面一行会报错，因为 hong 没有声明&gt;resolve( hong );&gt;&#125;);&gt;&#125;;&gt;someAsyncThing()&gt;.then(() =&gt; someOtherAsyncThing()) &gt;.catch(function(error) &#123; console.log(&#x27;ctach:&#x27;, error); // 下面一行会报错，因为 sum 没有声明 sum ++;&#125;)&gt;.then(function() &#123; console.log(&#x27;捕获后的then()&#x27;)&#125;);&gt;// ctach: [ReferenceError: hong is not defined]&gt;// Uncaught (in promise) ReferenceError: sum is not defined 上面代码中，catch()方法抛出一个错误，因为后面没有别的catch()方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。 1234567891011&gt;someAsyncThing().then(function() &#123;&gt;return someOtherAsyncThing();&gt;&#125;).catch(function(error) &#123;&gt;console.log(&#x27;catch: &#x27;, error);&gt;// 下面一行会报错，因为 sum 没有声明&gt;sum ++;&gt;&#125;).catch(function(error) &#123;&gt;console.log(&#x27;catch()后的catch: &#x27;, error);&gt;&#125;);&gt;//catch: ReferenceError: hong is not defined&gt;//catch()后的catch: ReferenceError: sum is not defined 上面代码中，第二个catch()方法用来捕获前一个catch()方法抛出的错误。 Promise.prototype.finally() finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。 1234&gt;promise&gt;.then(result =&gt; &#123;···&#125;)&gt;.catch(error =&gt; &#123;···&#125;)&gt;.finally(() =&gt; &#123;···&#125;); 上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。 finally方法的回调函数不接受任何参数， 这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。 这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。 a) finally本质上是then方法的特例 123456789&gt;promise&gt;.finally(() =&gt; &#123;&#125;);&gt;// 等同于&gt;promise&gt;.then(&gt;result =&gt; result ,&gt;error =&gt; throw error&gt;); 上面代码中，如果不使用finally方法，同样的语句需要为成功和失败两种情况各写一次。有了finally方法，则只需要写一次。 它的实现 它的实现也很简单。 1234567&gt;Promise.prototype.finally = function (callback) &#123;&gt;let P = this.constructor;&gt;return this.then(&gt;value =&gt; P.resolve(callback()).then(() =&gt; value),&gt;reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;)&gt;);&gt;&#125;; 上面代码中，不管前面的 Promise 是fulfilled还是rejected，都会执行回调函数callback。 从上面的实现还可以看到，finally方法总是会返回原来的值(传入什么即传出什么) 1234567891011&gt;// resolve 的值是 undefined&gt;Promise.resolve(2).then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;)&gt;// resolve 的值是 2&gt;Promise.resolve(2).finally(() =&gt; &#123;&#125;)&gt;// reject 的值是 undefined&gt;Promise.reject(3).then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;)&gt;// reject 的值是 3&gt;Promise.reject(3).finally(() =&gt; &#123;&#125;) Promise.all() Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 1&gt;const p = Promise.all([p1, p2, p3]); Promise.all()方法接受一个数组作为参数， p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。 另外，Promise.all()方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。 返回的状态由什么决定? p的状态由p1、p2、p3决定，分成两种情况。 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 下面是一个具体的例子。12345678910&gt;// 生成一个Promise对象的数组&gt;const promises = [&#x27;hong&#x27;, 1, 2, 3, 4, 5].map(item &#123;&gt;return getJSON( item+&#x27;.json&#x27;);&gt;&#125;);&gt;Promise.all(promises).then(function (posts) &#123;&gt;// ...&gt;&#125;).catch(function(reason)&#123;&gt;// ...&gt;&#125;); 上面代码中，promises是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态 都 变成fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数。 下面是另一个例子12345678910111213&gt;const databasePromise = connectDatabase(); //假设定义了一个异步方法,此方法能拿到你需要的所有数据&gt;const booksPromise = databasePromise //定义一个方法,在 databasePromise() 执行后寻找其内部书本信息&gt;.then(findAllBooks);&gt;const userPromise = databasePromise //定义一个方法,在 databasePromise() 执行后寻找其内部当前用户信息&gt;.then(getCurrentUser);&gt;Promise.all([&gt;booksPromise,&gt;userPromise&gt;])&gt;.then(([books, user]) =&gt; pickTopRecommendations(books, user)); 上面代码中，booksPromise和userPromise是两个异步操作，只有等到它们的结果都返回了，才会触发pickTopRecommendations这个回调函数。 如果参数中的Promise实例定义了自己的catch方法 ? 注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。 1234567891011121314151617181920&gt;//定义一个状态将为成功的的promise&gt;const p1 = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;hello&#x27;)&#125;)&gt;.then(result =&gt; result)&gt;.catch(e =&gt; e);&gt;//定义一个将抛出错误的promise&gt;const p2 = new Promise((resolve, reject) =&gt; &#123; throw new Error(&#x27;报错了&#x27;) &#125;)&gt;.then(result =&gt; result)&gt;.catch(e =&gt;&#123;&gt;console.log(&#x27;p2自己的catch捕获: &#x27;, e)&gt;return e; //异常获取后原样返回,不做修改&gt;&#125;);&gt;//调用 Promise.all 方法&gt;Promise.all([p1, p2])&gt;.then(result =&gt; console.log(&#x27; Promise.all 方法中的成功回调: &#x27;, result))&gt;.catch(e =&gt; console.log(&quot; Promise.all 方法中的catch&quot;, e));&gt;//p2自己的catch捕获: Error: 报错了&gt;// Promise.all 方法中的成功回调: (2) [&#x27;hello&#x27;, Error: 报错了] 上面代码中， p1会resolved，p2首先会rejected 但是p2有自己的catch方法，该方法返回的是一个新的 Promise 实例，p2指向的实际上是这个实例。 该实例执行完catch方法后，也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved 因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数 如果参数中的Promise实例 没有 定义自己的catch方法 ? 如果p2没有自己的catch方法，就会调用Promise.all()的catch方法。 1234567891011121314&gt;//定义一个状态将为成功的的promise&gt;const p1 = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;hello&#x27;)&#125;)&gt;.then(result =&gt; result)&gt;//定义一个将抛出错误的promise&gt;const p2 = new Promise((resolve, reject) =&gt; &#123; throw new Error(&#x27;报错了&#x27;) &#125;)&gt;.then(result =&gt; result)&gt;//调用 Promise.all 方法&gt;Promise.all([p1, p2])&gt;.then(result =&gt; console.log(&#x27; Promise.all 方法中的成功回调: &#x27;, result))&gt;.catch(e =&gt; console.log(&quot; Promise.all 方法中的catch&quot;, e));&gt;// Promise.all 方法中的catch Error: 报错了 Promise.race() Promise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。 1&gt;const p = Promise.race([p1, p2, p3]); 上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。 Promise.race()方法的参数与Promise.all()方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve()方法，将参数转为 Promise 实例，再进一步处理。 举个简单的🌰 如p1延时,开启了异步,内部正常是同步进行,所以p2&gt;p3&gt;p1,结果是P2 12345678910&gt;let p1 = new Promise((resolve, reject) =&gt; &#123;&gt;setTimeout(() =&gt; &#123;&gt;resolve(&#x27;OK&#x27;);&gt;&#125;, 1000);&gt;&#125;)&gt;let p2 = Promise.resolve(&#x27;Success&#x27;);&gt;let p3 = Promise.resolve(&#x27;Oh Yeah&#x27;);&gt;//调用&gt;const result = Promise.race([p1, p2, p3]);&gt;console.log(result); 举个应用实🌰 下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为reject，否则变为resolve。 12345678910&gt;const p = Promise.race([&gt;fetch(&#x27;https://gitee.com/hongjilin&#x27;),&gt;new Promise(function (resolve, reject) &#123;&gt;setTimeout(() =&gt; reject(new Error(&#x27;请求超时!!!!&#x27;)), 5000)&gt;&#125;)&gt;]);&gt;p&gt;.then(console.log)&gt;.catch(console.error); 上面代码中，如果 5 秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数。 是不是很好用又简单 Promise.allSettled() Promise.allSettled()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。 只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束。 该方法由 ES2020 引入。 举个简单的🌰 12345678&gt;const promises = [&gt;fetch(&#x27;https://gitee.com/hongjilin&#x27;),&gt;fetch(&#x27;https://github.com/Hongjilin&#x27;),&gt;fetch(&#x27;./hong.json&#x27;),&gt;];&gt;loading = true; //请求前将 loading 改为true ; 页面出现滚动加载图标蒙层&gt;await Promise.allSettled(promises);&gt;loading = false; 上面代码对服务器发出三个请求，等到三个请求都结束，不管请求成功还是失败，加载的滚动图标就会消失。 该方法返回的新的 Promise 实例，一旦结束，状态总是fulfilled，不会变成rejected 该方法返回的新的 Promise 实例，一旦结束，状态总是fulfilled，不会变成rejected。状态变成fulfilled后，Promise 的监听函数接收到的参数是一个数组，每个成员对应一个传入Promise.allSettled()的 Promise 实例。 1234567891011121314&gt;const resolved = Promise.resolve(&#x27;返回成功状态的promise&#x27;);&gt;const rejected = Promise.reject(&#x27;返回失败状态的promise&#x27;);&gt;const allSettledPromise = Promise.allSettled([resolved, rejected]);&gt;// Promise.allSettled 得到的新实例状态只会是 `fulfilled`&gt;allSettledPromise.then(function (results) &#123;&gt;console.log(results); //注意,这是 `fulfilled` 的回调函数,只有其状态为成功才能进到这里&gt;&#125;);&gt;/*&gt;[&#123; &quot;status&quot;: &quot;fulfilled&quot;, &quot;value&quot;: &quot;返回成功状态的promise&quot; &#125;,&#123; &quot;status&quot;: &quot;rejected&quot;, &quot;reason&quot;: &quot;返回失败状态的promise&quot; &#125;&gt;]&gt;*/ Promise.allSettled()的返回值allSettledPromise，状态只可能变成fulfilled(注意,是 allSettledPromise 的状态,而不是内部的promise实例) 它的监听函数接收到的参数是数组results。该数组的每个成员都是一个对象，对应的是传入Promise.allSettled()的 Promise 实例。 每个对象都有status属性，该属性的值只可能是字符串fulfilled或字符串rejected。 fulfilled时，对象有value属性，rejected时有reason属性，对应两种状态的返回值。 举个返回值用法的🌰 12345678910&gt;const promises = [ fetch(&#x27;./hong.json&#x27;), fetch(&#x27;https://gitee.com/hongjilin&#x27;) ];&gt;const results = await Promise.allSettled(promises);&gt;// 过滤出成功的请求&gt;const successfulPromises = results.filter(item =&gt; item.status === &#x27;fulfilled&#x27;);&gt;// 过滤出失败的请求，并取得它们的失败原因&gt;const errors = results&gt;.filter(p =&gt; p.status === &#x27;rejected&#x27;)&gt;.map(p =&gt; p.reason); 有时候，我们不关心异步操作的结果，只关心这些操作有没有结束。这时，Promise.allSettled()方法就很有用。如果没有这个方法，想要确保所有操作都结束，就很麻烦。Promise.all()方法无法做到这一点。 123456789&gt;const urls = [ &#x27;https://gitee.com/hongjilin&#x27; ,&#x27;https://github.com/Hongjilin&#x27;];&gt;const requests = urls.map(x =&gt; fetch(x));&gt;//举例用 Promise.all 尝试实现,很明显,难以实现&gt;try &#123;&gt;await Promise.all(requests);&gt;console.log(&#x27;所有请求都成功。&#x27;);&gt;&#125; catch &#123;&gt;console.log(&#x27;至少一个请求失败，其他请求可能还没结束。&#x27;);&gt;&#125; 上面代码中，Promise.all()无法确定所有请求都结束。想要达到这个目的，写起来很麻烦，有了Promise.allSettled()，这就很容易了 Promise.any() ES2021 引入了Promise.any()方法。该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。 与 Promise.race() 方法的区别 Promise.any()跟Promise.race()方法很像，只有一点不同，就是不会因为某个 Promise 变成rejected状态而结束。 1234567891011&gt;const promises = [&gt;fetch(&#x27;https://gitee.com/hongjilin&#x27;).then(() =&gt; &#x27;a&#x27;),&gt;fetch(&#x27;https://github.com/Hongjilin&#x27;).then(() =&gt; &#x27;b&#x27;),&gt;fetch(&#x27;./hong.json&#x27;).then(() =&gt; &#x27;c&#x27;),&gt;];&gt;try &#123;&gt;const first = await Promise.any(promises);&gt;console.log(first);&gt;&#125; catch (error) &#123;&gt;console.log(error);&gt;&#125; 上面代码中，Promise.any()方法的参数数组包含三个 Promise 操作。其中只要有一个变成fulfilled，Promise.any()返回的 Promise 对象就变成fulfilled。如果所有三个操作都变成rejected，那么await命令就会抛出错误。 Promise.any() 抛出的错误 Promise.any()抛出的错误，不是一个一般的错误，而是一个 AggregateError 实例。它相当于一个数组，每个成员对应一个被rejected的操作所抛出的错误。下面是 AggregateError 的实现示例。 123456&gt;new AggregateError() extends Array -&gt; AggregateError&gt;const err = new AggregateError();&gt;err.push(new Error(&quot;first error&quot;));&gt;err.push(new Error(&quot;second error&quot;));&gt;throw err; 捕捉错误时，如果不用try...catch结构和 await 命令，可以像下面这样写。 12345678&gt;Promise.any(promises).then(&gt;(first) =&gt; &#123;&gt;// Any of the promises was fulfilled.&gt;&#125;,&gt;(error) =&gt; &#123;&gt;// All of the promises were rejected.&gt;&#125;&gt;); 再举个🌰 下面是一个例子。 1234567891011&gt;const resolved = Promise.resolve(&#x27;成功&#x27;);&gt;const rejected = Promise.reject(&#x27;失败了&#x27;);&gt;const alsoRejected = Promise.reject(&#x27;太失败了&#x27;);&gt;Promise.any([resolved, rejected, alsoRejected]).then(function (result) &#123;&gt;console.log(result); // 成功&gt;&#125;);&gt;Promise.any([rejected, alsoRejected]).catch(function (results) &#123;&gt;console.log(results); //AggregateError: All promises were rejected&gt;&#125;); 三个Promise中有一个为成功,则总的结果就是成功,三个中全部失败,才会变成失败 Promise.resolve() 有时需要将现有对象转为 Promise 对象，Promise.resolve()方法就起到这个作用。 1&gt;const jsPromise = Promise.resolve($.ajax(&#x27;https://gitee.com/hongjilin&#x27;)); 上面代码将 jQuery 生成的deferred对象，转为一个新的 Promise 对象。 Promise.resolve()等价于下面的写法。 123&gt;Promise.resolve(&#x27;努力学习的汪&#x27;)&gt;// 等价于&gt;new Promise(resolve =&gt; resolve(&#x27;努力学习的汪&#x27;)) Promise.resolve()方法的参数分成四种情况 参数是一个 Promise 实例 如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。 参数是一个thenable对象 thenable对象指的是具有then方法的对象，比如下面这个对象。 12345&gt;let thenable = &#123;then: function(resolve, reject) &#123; resolve(&#x27;成功&#x27;);&#125;&gt;&#125;; Promise.resolve()方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then()方法。 12345678&gt;let thenable = &#123;then: function(resolve, reject) &#123; resolve(&#x27;成功&#x27;) &#125;&gt;&#125;;&gt;let p1 = Promise.resolve(thenable);&gt;p1.then(function (value) &#123;console.log(value); // &#x27;成功&#x27;&gt;&#125;); 上面代码中，thenable对象的then()方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then()方法指定的回调函数，输出 ‘成功’。 参数不是具有then()方法的对象，或根本就不是对象 如果参数是一个原始值，或者是一个不具有then()方法的对象，则Promise.resolve()方法返回一个新的 Promise 对象，状态为resolved。 123456&gt;const p = Promise.resolve(&#x27;努力学习的汪&#x27;);&gt;p.then(function (s) &#123;&gt;console.log(s)&gt;&#125;);&gt;// 努力学习的汪 上面代码生成一个新的 Promise 对象的实例p。 由于字符串 努力学习的汪 不属于异步操作（判断方法是字符串对象不具有 then 方法） 返回 Promise 实例的状态从一生成就是resolved，所以回调函数会立即执行 Promise.resolve()方法的参数会同时传给回调函数作为其参数 不带有任何参数 Promise.resolve()方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。 所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用Promise.resolve()方法。 123&gt;const p = Promise.resolve();&gt;p.then(function () &#123;&#125;); 上面代码的变量p就是一个 Promise 对象。 需要注意的是，立即resolve()的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时 —&gt; 不懂的同学请看 JavaScript笔记中的#4事件循环模型event-loop机制 ,本人在此有进行详细的解析 12345678910111213&gt;setTimeout(function () &#123;&gt;console.log(&#x27;three&#x27;); //这里是新的一轮事件循环&gt;&#125;, 0);&gt;Promise.resolve().then(function () &#123;&gt;console.log(&#x27;two&#x27;); //本轮同步代码结束后,新一轮事件循环前,就执行&gt;&#125;);&gt;console.log(&#x27;one&#x27;);&gt;// one&gt;// two&gt;// three 上面代码中，setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.resolve()在本轮“事件循环”结束时执行，console.log(&#39;one&#39;)则是立即执行，因此最先输出。 Promise.reject() Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。 12345678&gt;const p = Promise.reject(&#x27;出错了&#x27;);&gt;// 等同于&gt;const p = new Promise((resolve, reject) =&gt; reject(&#x27;出错了&#x27;))&gt;p.then(null, function (s) &#123;&gt;console.log(s)&gt;&#125;);&gt;// 出错了 上面代码生成一个 Promise 对象的实例p，状态为rejected，回调函数会立即执行。 Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。 12345&gt;Promise.reject(&#x27;出错了&#x27;)&gt;.catch(e =&gt; &#123;&gt;console.log(e === &#x27;出错了&#x27;)&gt;&#125;)&gt;// true 上面代码中，Promise.reject()方法的参数是一个字符串，后面catch()方法的参数e就是这个字符串。 Promise.try() 实际开发中，经常遇到一种情况：不知道或者不想区分，函数f是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管f是否包含异步操作，都用then方法指定下一步流程，用catch方法处理f抛出的错误。一般就会采用下面的写法。 1&gt;Promise.resolve().then(f) 上面的写法有一个缺点，就是如果f是同步函数，那么它会在本轮事件循环的末尾执行。 12345&gt;const f = () =&gt; console.log(&#x27;now&#x27;);&gt;Promise.resolve().then(f);&gt;console.log(&#x27;next&#x27;);&gt;// next&gt;// now 上面代码中，函数f是同步的，但是用 Promise 包装了以后，就变成异步执行了。 那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？ 写法一 : 用async函数来写 该知识点如果不懂的可以继续往下看,这是ES6的另外一块知识点内容 12345&gt;const f = () =&gt; console.log(&#x27;now&#x27;);&gt;(async () =&gt; f())();&gt;console.log(&#x27;next&#x27;);&gt;// now&gt;// next 上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的async函数，因此如果f是同步的，就会得到同步的结果；如果f是异步的，就可以用then指定下一步，就像下面的写法。 12&gt;(async () =&gt; f())()&gt;.then(...) 需要注意的是，async () =&gt; f()会吃掉f()抛出的错误。所以，如果想捕获错误，要使用promise.catch方法。 123&gt;(async () =&gt; f())()&gt;.then(...)&gt;.catch(...) 写法二 : 使用new Promise() 123456789&gt;const f = () =&gt; console.log(&#x27;now&#x27;);&gt;(&gt;() =&gt; new Promise(&gt;resolve =&gt; resolve(f())&gt;)&gt;)();&gt;console.log(&#x27;next&#x27;);&gt;// now&gt;// next 上面代码也是使用立即执行的匿名函数，执行new Promise()。这种情况下，同步函数也是同步执行的。 Promise.try的引出 鉴于这是一个很常见的需求，所以现在有一个提案，提供Promise.try方法替代上面的写法。 12345&gt;const f = () =&gt; console.log(&#x27;now&#x27;);&gt;Promise.try(f);&gt;console.log(&#x27;next&#x27;);&gt;// now&gt;// next 事实上，Promise.try存在已久，Promise 库Bluebird、Q和when，早就提供了这个方法。 由于Promise.try为所有操作提供了统一的处理机制，所以如果想用then方法管理流程，最好都用Promise.try包装一下。这样有许多好处，其中一点就是可以更好地管理异常。 123456&gt;function getUsername(userId) &#123;&gt;return database.users.get(&#123;id: userId&#125;)&gt;.then(function(user) &#123;&gt;return user.name;&gt;&#125;);&gt;&#125; 上面代码中，database.users.get()返回一个 Promise 对象，如果抛出异步错误，可以用catch方法捕获，就像下面这样写。 123&gt;database.users.get(&#123;id: userId&#125;)&gt;.then(...)&gt;.catch(...) 但是database.users.get()可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用try...catch去捕获。 1234567&gt;try &#123;&gt;database.users.get(&#123;id: userId&#125;)&gt;.then(...)&gt;.catch(...)&gt;&#125; catch (e) &#123;&gt;// ...&gt;&#125; 上面这样的写法就很笨拙了，这时就可以统一用promise.catch()捕获所有同步和异步的错误。 123&gt;Promise.try(() =&gt; database.users.get(&#123;id: userId&#125;))&gt;.then(...)&gt;.catch(...) 事实上，Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码块。 自定义Promise手写 下方的Promise.prototype.then与Promise.resolve为什么一个挂载在prototype而另一个挂载在实例对象上? 解:原因是分别为静态方法与实例方法 —&gt;上面的需要new实例化的时候自动继承实例prototype上的方法和属性,所以用实例对象.then()来调用,而下面的Promise.resolve是静态方法,不用new,是可以直接Promise.resolve()调用 此部分可以跳过不看,类似手撕源码 Promise的实例方法实现初始结构搭建 html引入,该章节后续html大部分重复 除非必要,否则不再放上来 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Promise-封装 | 1 - 初始结构搭建&lt;/title&gt; &lt;script src=&quot;./promise.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; let p = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;OK&#x27;); &#125;); p.then(value =&gt; &#123; console.log(value); &#125;, reason=&gt;&#123; console.warn(reason); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; promise.js —&gt;使用原生写法,最后会改为class写法 123function Promise(executor)&#123;&#125;//添加 then 方法Promise.prototype.then = function(onResolved, onRejected)&#123;&#125; resolve 与 reject构建与基础实现 使用const self = this;保存this执行,使function中可以取得当前实例 ps:可以不使用该方法保存,但是下方function需要改为箭头函数,否则function默认指向是window 之后代码默认使用self保存this,箭头函数方式将在最后改为class写法时使用 默认设置 PromiseState = &#39;pending&#39;以及 PromiseResult = null,这就是promise状态基础 123456789101112131415161718192021222324252627//声明构造函数function Promise(executor) &#123; //添加属性 this.PromiseState = &#x27;pending&#x27;; this.PromiseResult = null; //保存实例对象的 this 的值/* 此处可以不写,但是下面function方法需要改为箭头函数,否则function默认指向是window */ const self = this; //resolve 函数 function resolve(data) &#123;-------------------------------------------- //1. 修改对象的状态 (promiseState) self.PromiseState = &#x27;fulfilled&#x27;; // resolved //2. 设置对象结果值 (promiseResult) self.PromiseResult = data; &#125; //reject 函数 function reject(data) &#123;---------------------------------------------- //1. 修改对象的状态 (promiseState) self.PromiseState = &#x27;rejected&#x27;; // //2. 设置对象结果值 (promiseResult) self.PromiseResult = data; &#125; //同步调用『执行器函数』 executor(resolve, reject);&#125;//添加 then 方法Promise.prototype.then = function (onResolved, onRejected) &#123;&#125; throw 抛出异常改变状态 在2的基础上进行修改:将执行器放入try-catch()中 在catch中使用reject()修改 promise 对象状态为『失败』 1234567try &#123; //同步调用『执行器函数』 executor(resolve, reject); &#125; catch (e) &#123; //修改 promise 对象状态为『失败』 reject(e); &#125; 状态只能修改一次 基于2 3代码中resolve和reject方法进修改 在成功与失败函数中添加判断if(self.PromiseState !== &#39;pending&#39;) return;,如果进入函数时状态不为pending直接退出,这样就能做到状态只能从pending改至其他状态且做到只能改一次 12345678910111213141516171819202122232425262728html调用-------------------------------------------------------- let p = new Promise((resolve, reject) =&gt; &#123; reject(&quot;error&quot;); resolve(&#x27;OK&#x27;); //抛出异常 // throw &quot;error&quot;; &#125;); console.log(p);promise.js修改-------------------------------------------------------- //resolve 函数 function resolve(data)&#123; //判断状态 if(self.PromiseState !== &#x27;pending&#x27;) return; //1. 修改对象的状态 (promiseState) self.PromiseState = &#x27;fulfilled&#x27;;// resolved //2. 设置对象结果值 (promiseResult) self.PromiseResult = data; &#125; //reject 函数 function reject(data)&#123; //判断状态 if(self.PromiseState !== &#x27;pending&#x27;) return; //1. 修改对象的状态 (promiseState) self.PromiseState = &#x27;rejected&#x27;;// //2. 设置对象结果值 (promiseResult) self.PromiseResult = data; &#125; hen 方法执行回调基础实现 修改Promise.prototype.then方法 传入then(成功回调,失败回调),当调用then后,会判断当前this.PromiseState的状态,当其为成功时调用成功回调,失败时调用失败回调 12345678910111213141516html调用------------------------------------------------------------ let p = new Promise((resolve, reject) =&gt; &#123; // resolve(&#x27;OK&#x27;);// reject(&quot;Error&quot;); throw &quot;ERROR&quot;; &#125;); p.then( value =&gt; &#123;console.log(value); &#125;, reason =&gt; &#123;console.warn(reason);&#125; )promise.js修改与实现-----------------------------------------------------//添加 then 方法Promise.prototype.then = function (onResolved, onRejected) &#123; //调用回调函数 PromiseState if (this.PromiseState === &#x27;fulfilled&#x27;) &#123;onResolved(this.PromiseResult);&#125; if (this.PromiseState === &#x27;rejected&#x27;) &#123;onRejected(this.PromiseResult);&#125;&#125; 异步任务 then 方法实现 此处对于5有四处修改,下面上js代码 当我运行异步代码后,我的执行器内部代码还未返回(因为用了定时器,里面的代码进入了异步队列),所以当我下面的.then()运行时:我的p为pending状态,所以根本不会执行resolve与reject方法 解:添加判断pending状态,将当前回调函数保存到实例对象(存到实例上是为了更方便)中,这样后续改变状态时候才调用得到 为什么要将回调保存到实例上而不是直接调用? 理由:因为我的回调函数需要在我的promise状态改变后(成功或者失败),再根据状态选择运行哪个函数所以当你调用then()时却检测到状态为pending,说明这时候的promise在异步队列 不能直接运行成功或者失败函数 解决:因为resolve与reject方法与then()不在同一个作用域中,并不能共享then(成功回调,失败回调)的参数,所以在判断状态为pending时将回调保存到实例对象上.然后将回调函数的调用放在resolve()与reject()中 这样当我代码运行到异步队列的resolve()或reject()时,就可以在这个函数中运行回调函数,实现异步then 此处的then仍有瑕疵,需要继续完善 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849html调用------------------------------------------------------------ //实例化对象 let p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123;reject(&quot;error&quot;); /* resolve(&#x27;OK&#x27;);*/&#125;, 1000); &#125;); p.then(value =&gt; &#123;console.log(value);&#125;,reason =&gt; &#123; console.warn(reason);&#125;); console.log(p);promise.js修改与实现-----------------------------------------------------//声明构造函数function Promise(executor) &#123; this.PromiseState = &#x27;pending&#x27;; this.PromiseResult = null; // 声明属性 this.callback = &#123;&#125;; -----------新添加1 const self = this; //resolve 函数 function resolve(data) &#123; //判断状态 if (self.PromiseState !== &#x27;pending&#x27;) return; self.PromiseState = &#x27;fulfilled&#x27;; self.PromiseResult = data; //调用成功的回调函数 加判断的原因是防止无回调报错 if (self.callback.onResolved) &#123; self.callback.onResolved(data); &#125; ------------新添加2 最重要 &#125; //reject 函数 function reject(data) &#123; if (self.PromiseState !== &#x27;pending&#x27;) return; self.PromiseState = &#x27;rejected&#x27;; self.PromiseResult = data; //执行回调 if (self.callback.onResolved) &#123; self.callback.onResolved(data);&#125; ------------新添加3 &#125; try &#123;executor(resolve, reject);&#125; catch (e) &#123;reject(e);&#125;&#125;//添加 then 方法Promise.prototype.then = function (onResolved, onRejected) &#123; //调用回调函数 PromiseState if (this.PromiseState === &#x27;fulfilled&#x27;) &#123;onResolved(this.PromiseResult);&#125; if (this.PromiseState === &#x27;rejected&#x27;) &#123; onRejected(this.PromiseResult);&#125; //判断 pending 状态 if (this.PromiseState === &#x27;pending&#x27;) &#123; ------------新添加4 //保存回调函数 this.callback = &#123; onResolved: onResolved, onRejected: onRejected &#125; &#125;&#125; 指定多个回调 基于6代码进行修改 只展示修改部分代码 6中保存回调函数的方式有BUG,如果我有多个.then(),后面加载的回调函数会覆盖之前的回调函数,导致最后回调函数有且只有最后一个 解:使用数组的方式进行存储回调函数,调用时也是用数组循环取出 此处的then仍有瑕疵,需要继续完善 1234567891011121314151617181920212223242526272829303132333435363738394041html调用------------------------------------------------------------//实例化对象 let p = new Promise((resolve, reject) =&gt; &#123;setTimeout(() =&gt; &#123;reject(&#x27;No&#x27;);&#125;, 1000);&#125;); p.then(value =&gt; &#123; console.log(value);&#125;, reason=&gt;&#123;console.warn(reason);&#125;); p.then(value =&gt; &#123; alert(value);&#125;, reason=&gt;&#123; alert(reason);&#125;); console.log(p);promise.js修改与实现-----------------------------------------------------Promise.prototype.then = function (onResolved, onRejected) &#123; //resolve 函数 function resolve(data)&#123; ..... //调用成功的回调函数 // if (self.callback.onResolved) &#123; self.callback.onResolved(data); &#125; self.callbacks.forEach(item =&gt; &#123; --------修改1 item.onResolved(data); &#125;); &#125; //reject 函数 function reject(data)&#123; ...... //执行失败的回调 // if (self.callback.onResolved) &#123; self.callback.onResolved(data);&#125; self.callbacks.forEach(item =&gt; &#123; ------修改2 item.onRejected(data); &#125;); &#125; //添加 then 方法Promise.prototype.then = function(onResolved, onRejected)&#123; ........ //判断 pending 状态 if(this.PromiseState === &#x27;pending&#x27;)&#123; //保存回调函数 // this.callback = &#123; onResolved: onResolved, onRejected: onRejected &#125; this.callbacks.push(&#123; --------修改3 onResolved: onResolved, onRejected: onRejected &#125;); &#125;&#125; 同步任务 then 返回结果 在之前的then运行结果中得知,我们使用 [ then ] 后的返回结果是其回调函数的返回结果,而我们需要的返回结果是一个新的promise对象 解:所以我们在then中return new Promise(),使其得到的是一个新的promise对象 在为解决问题1后产生一个新问题:新的promise对象因为没有用rejerect与resolve方法,导致返回的状态一直是pending 解:在新的promise中判断运行回调函数后的返回值是什么,然后根据其不同类型给其赋予不同状态 ​ Ⅰ-if(result instanceof Promise):返回值一个新的②promise对象(因为是新的promise的回调函数返回值,称②promise对象),在返回值(因为是promise对象)的.then()回调函数中使用rejerect与resolve方法,将其自身的状态赋予外层的promise, ​ 即 回调函数中的promise 赋值 给then返回值 , 所以 最终返回状态==回调函数中的新promise状态 ​ Ⅱ-如果返回值是一个非promise对象,返回状态设置为成功 ​ Ⅲ-如果返回值是一个异常,返回状态设置为失败 12345678910111213141516171819202122232425262728293031323334html调用------------------------------------------------------------ //实例化对象 let p = new Promise((resolve, reject) =&gt; &#123;resolve(&#x27;OK&#x27;);&#125;); //执行 then 方法 const res = p.then( value =&gt; &#123; throw &quot;FAIL&quot;;&#125;, reason =&gt; &#123; console.warn(reason);&#125;); console.log(res);promise.js修改与实现-----------------------------------------------------//添加 then 方法Promise.prototype.then = function(onResolved, onRejected)&#123; return new Promise((resolve, reject) =&gt; &#123; //调用回调函数 PromiseState // if(this.PromiseState === &#x27;fulfilled&#x27;)&#123; onResolved(this.PromiseResult);&#125; 未修改时代码 if(this.PromiseState === &#x27;fulfilled&#x27;)&#123; -------修改1 try&#123; //获取回调函数的执行结果 let result = onResolved(this.PromiseResult); //判断 if(result instanceof Promise)&#123;//如果是 Promise 类型的对象,我就将下一个promise结果赋予外层 result.then(v =&gt; &#123; resolve(v); &#125;,r=&gt;&#123;reject(r);&#125;) &#125;else&#123;resolve(result);&#125; //如果返回的不是promise对象,都将其赋予成功状态 &#125;catch(e)&#123; rejerect(e); //如果出错了,则返回失败状态 &#125; &#125; if(this.PromiseState === &#x27;rejected&#x27;)&#123; onRejected(this.PromiseResult);&#125;------此部分修改与修改1一样 //判断 pending 状态 if(this.PromiseState === &#x27;pending&#x27;)&#123; this.callbacks.push(&#123; onResolved: onResolved, onRejected: onRejected&#125;); &#125; &#125;)&#125; 异步任务 then 返回结果 异步任务是修改if(this.PromiseState === &#39;pending&#39;)后面的值,原因参考6,下面代码只举例这部分修改 因为我们需要增加then状态修改,所以在我们保存回调函数这一步我们可以对于回调函数进行加工,添加判断其回调函数的返回值的代码块再存入实例的回调函数中 Ⅰ-声明一个新的函数:其内部功能-&gt;先运行onResolved回调函数,再将其返回值取出,进行判断其返回值(这个过程同8) Ⅱ-加工后存入实例回调函数数组,之后在resolve与reject方法中调用即可(同6) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950html调用------------------------------------------------------------ //实例化对象 let p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123;reject(&quot;Error&quot;);&#125;, 1000)&#125;); // resolve(&#x27;OK&#x27;); //执行 then 方法 const res = p.then(value =&gt; &#123; // return &#x27;oh Yeah&#x27;; //如果有返回,根据其返回值得到相应的状态:字符串为成功,抛出为错误 throw &#x27;error&#x27;; &#125;, reason =&gt; &#123; console.warn(reason, &quot;xx&quot;); //如果只是打印没返回,则实际上时返回一个undefined, //在我们封装js中,undefined会判定为非promise对象,所以状态为成功,结果为undefined return &quot;sss&quot; // throw &#x27;error&#x27;; &#125;); console.log(res);promise.js修改与实现----------------------------------------------------- //判断 pending 状态 if (this.PromiseState === &#x27;pending&#x27;) &#123; //保存回调函数 this.callbacks.push(&#123; onResolved: function () &#123; try &#123; //执行成功回调函数 let result = onResolved(self.PromiseResult); //判断 其结果 if (result instanceof Promise) &#123; result.then( v =&gt; &#123; resolve(v);&#125;, r =&gt; &#123;reject(r);&#125; ) &#125; else &#123;resolve(result);&#125; &#125; catch (e) &#123;reject(e);&#125; &#125;, onRejected: function () &#123; try &#123; //执行成功回调函数 let result = onRejected(self.PromiseResult); //判断 if (result instanceof Promise) &#123; result.then( v =&gt; &#123;resolve(v); &#125;, r =&gt; &#123;reject(r);&#125; ) &#125; else &#123;resolve(result);&#125; &#125; catch (e) &#123; reject(e); &#125; &#125; &#125;); &#125; then方法代码优化 在8、9、10中可以看出,其判断与改变返回结果状态的代码块是基本重复的,所以可以将其抽出 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//添加 then 方法Promise.prototype.then = function (onResolved, onRejected) &#123; const self = this; return new Promise((resolve, reject) =&gt; &#123; 封装函数---------------------------------------------------------------------------- function callback(type) &#123; try &#123; //获取回调函数的执行结果 let result = type(self.PromiseResult); //判断 if (result instanceof Promise) &#123; //如果是 Promise 类型的对象 result.then(v =&gt; &#123; resolve(v); &#125;, r =&gt; &#123; reject(r); &#125;) &#125; else &#123; //结果的对象状态为『成功』 resolve(result); &#125; &#125; catch (e) &#123; reject(e); &#125; &#125; ----------------------------------------------------------------------------------- //调用回调函数 PromiseState if (this.PromiseState === &#x27;fulfilled&#x27;) &#123; callback(onResolved); &#125; if (this.PromiseState === &#x27;rejected&#x27;) &#123; callback(onRejected); &#125; //判断 pending 状态 if (this.PromiseState === &#x27;pending&#x27;) &#123; //保存回调函数 this.callbacks.push(&#123; onResolved: function () &#123; callback(onResolved); &#125;, onRejected: function () &#123; callback(onRejected); &#125; &#125;); &#125; &#125;)&#125; catch 方法与异常穿透与值传递 异常穿透:添加catch 方法,并且需要进行回调函数为undefined的处理 当我then()中只传一个回调或者不传回调函数时,运行代码会报错,因为运行时调用的回调函数是undefined 解:进行回调函数判断,当其为空时,基于默认回调函数内容:直接往外抛出这样下方的then() or catch()就可以承接到异常或者值 12345678910111213141516171819202122html调用------------------------------------------------------------ //实例化对象 let p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123;resolve(&#x27;OK&#x27;); &#125;, 1000); &#125;); //值传递 p.then() .then(value =&gt; &#123;console.log(222);&#125;) .then(value =&gt; &#123;console.log(333);&#125;) .catch(reason =&gt; &#123;console.warn(reason);&#125;);promise.js修改与实现-----------------------------------------------------//添加 then 方法Promise.prototype.then = function (onResolved, onRejected) &#123; ... -----------修改1 if (typeof onRejected !== &#x27;function&#x27;) &#123;onRejected = reason =&gt; &#123; throw reason;&#125;&#125; if (typeof onResolved !== &#x27;function&#x27;) &#123; onResolved = value =&gt; value;&#125; ....&#125;//添加 catch 方法 Promise.prototype.catch = function(onRejected)&#123; ---------------异常穿透 修改2 return this.then(undefined, onRejected);&#125; Promise的静态方法实现Promise.resolve 封装 判断传入的参数是否为promise对象: Ⅰ-如果为promise:将其状态与结果赋值给外层promise对象 Ⅱ-如果为非promise:状态设置为成功 1234567891011121314151617181920html调用------------------------------------------------------------ const p = Promise.resolve(&#x27;OK&#x27;); const p2 = Promise.resolve(new Promise((resolve, reject) =&gt; &#123; reject(&quot;error&quot;);// resolve(&#x27;Success&#x27;); &#125;)); const p3 = Promise.resolve(Promise.resolve(&#x27;Oh Yeah&#x27;)); console.log(p3);promise.js修改与实现-----------------------------------------------------//添加 resolve 方法Promise.resolve = function(value)&#123; //返回promise对象 return new Promise((resolve, reject) =&gt; &#123; if(value instanceof Promise)&#123; value.then( v=&gt;&#123;resolve(v);&#125;, r=&gt;&#123;reject(r);&#125; )&#125;else&#123;resolve(value); &#125;//状态设置为成功 &#125;);&#125; Promise.resolve 封装 不同于resolve,这个方法只要把传入参数再次传出去,并将状态改为失败即可 12345678910111213141516html调用------------------------------------------------------------ //Promise.reject const p = Promise.reject(&#x27;Error&#x27;); const p2 = Promise.reject(new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;OK&#x27;); &#125;)); console.log(p); console.log(p2);promise.js修改与实现-----------------------------------------------------//添加 reject 方法Promise.reject = function (reason) &#123; return new Promise((resolve, reject) =&gt; &#123; reject(reason); &#125;);&#125; Promise.all 封装 遍历传入的promise数组,每当遍历结果是成功,则用计数器记录,当计数器等同于数组长度,则全部成功,这时候可以返回成功状态 如果当数组中任意一个promise的执行结果是reject,直接中断,返回状态为失败 12345678910111213141516171819202122232425262728293031323334html调用------------------------------------------------------------ let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123;resolve(&#x27;OK&#x27;); &#125;, 1000) &#125;) let p2 = Promise.reject(&#x27;Success&#x27;); let p3 = Promise.resolve(&#x27;Oh Yeah&#x27;); //调用 all 方法 let result = Promise.all([p1, p2, p3]); console.log(result);promise.js修改与实现-----------------------------------------------------//添加 all 方法Promise.all = function (promises) &#123; //返回结果为promise对象 return new Promise((resolve, reject) =&gt; &#123; //声明变量 let count = 0; let arr = []; //遍历 for (let i = 0; i &lt; promises.length; i++) &#123; promises[i].then(v =&gt; &#123; //得知对象的状态是成功 //每个promise对象 都成功 count++; //将当前promise对象成功的结果 存入到数组中 arr[i] = v; //判断 if (count === promises.length) &#123;resolve(arr);&#125;//修改状态 &#125;, r =&gt; &#123; reject(r); &#125;); &#125; &#125;);&#125; Promise.race 封装 直接谁先执行就返回谁的运行结果即可 12345678910111213141516171819202122232425html调用------------------------------------------------------------ let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123;resolve(&#x27;OK&#x27;);&#125;); &#125;); let p2 = Promise.reject(&#x27;Success&#x27;); let p3 = Promise.resolve(&#x27;Oh Yeah&#x27;); //调用 race 方法 let result = Promise.race([p1, p2, p3]); console.log(result);promise.js修改与实现-----------------------------------------------------//添加 race 方法Promise.race = function (promises) &#123; return new Promise((resolve, reject) =&gt; &#123; for (let i = 0; i &lt; promises.length; i++) &#123; promises[i].then(v =&gt; &#123; //修改返回对象的状态为 『成功』 resolve(v); &#125;, r =&gt; &#123; //修改返回对象的状态为 『失败』 reject(r); &#125;) &#125; &#125;);&#125; 其他优化回调函数『异步执行』 如果我们运行下面代码,正确顺序是: 111 —&gt; 333 —&gt;444 123456789101112let p1 = new Promise((resolve, reject) =&gt; &#123; reject(&#x27;OK&#x27;); console.log(111); &#125;); p1.then(value =&gt; &#123; console.log(222); &#125;, reason =&gt; &#123; console.log(444); &#125;); console.log(333); 但当我们运行之前封装的 Promise 代码时,结果却是:111 —&gt; 444 —&gt; 333 我们需要将我们的then方法变成异步方法 我们只要在以下四处地方的回调函数调用外层包裹一层定时器(不一定是定时器,开启异步即可),即可做到异步操作 123456789101112131415161718192021&gt;function resolve(data)&#123; setTimeout(() =&gt; &#123; self.callbacks.forEach(item =&gt; &#123; item.onResolved(data); &#125;); &#125;);--修改1 &#125; //reject 函数 function reject(data)&#123; setTimeout(() =&gt; &#123; self.callbacks.forEach(item =&gt; &#123; item.onRejected(data); &#125;); &#125;);---修改2 &#125;&gt;//添加 then 方法&gt;Promise.prototype.then = function(onResolved, onRejected)&#123; return new Promise((resolve, reject) =&gt; &#123; //调用回调函数 PromiseState /* 修改前代码 if (this.PromiseState === &#x27;fulfilled&#x27;) &#123; callback(onResolved); &#125; if (this.PromiseState === &#x27;rejected&#x27;) &#123; callback(onRejected); */ if(this.PromiseState === &#x27;fulfilled&#x27;)&#123;setTimeout(() =&gt; &#123; callback(onResolved);&#125;);&#125; -----修改3 if(this.PromiseState === &#x27;rejected&#x27;)&#123; setTimeout(() =&gt; &#123; callback(onRejected);&#125;); ---修改4 &#125; &#125; 相关原理参照js事件循环机制、宏任务与微任务 class改写promise 其中将self=this保存this指向方式改为箭头函数表示(在上面示例中也有效果) 将其改为class写法 下面为promisedemo.js代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180&gt;class Promise &#123;//构造方法constructor(executor) &#123; //添加属性 this.PromiseState = &#x27;pending&#x27;; this.PromiseResult = null; //声明属性 this.callbacks = []; //保存实例对象的 this 的值 //resolve 函数 let resolve = (data) =&gt; &#123; //判断状态 if (this.PromiseState !== &#x27;pending&#x27;) return; //1. 修改对象的状态 (promiseState) this.PromiseState = &#x27;fulfilled&#x27;; // resolved //2. 设置对象结果值 (promiseResult) this.PromiseResult = data; //调用成功的回调函数 setTimeout(() =&gt; &#123; this.callbacks.forEach(item =&gt; &#123; item.onResolved(data); &#125;); &#125;); &#125; //reject 函数 let reject = (data) =&gt; &#123; //判断状态 if (this.PromiseState !== &#x27;pending&#x27;) return; //1. 修改对象的状态 (promiseState) this.PromiseState = &#x27;rejected&#x27;; // //2. 设置对象结果值 (promiseResult) this.PromiseResult = data; //执行失败的回调 setTimeout(() =&gt; &#123; this.callbacks.forEach(item =&gt; &#123; item.onRejected(data); &#125;); &#125;); &#125; try &#123; //同步调用『执行器函数』 executor(resolve, reject); &#125; catch (e) &#123; //修改 promise 对象状态为『失败』 reject(e); &#125;&#125;//then 方法封装then(onResolved, onRejected) &#123; //判断回调函数参数 if (typeof onRejected !== &#x27;function&#x27;) &#123; onRejected = reason =&gt; &#123; throw reason; &#125; &#125; if (typeof onResolved !== &#x27;function&#x27;) &#123; onResolved = value =&gt; value; //value =&gt; &#123; return value&#125;; &#125; return new Promise((resolve, reject) =&gt; &#123; //封装函数 let callback = (type) =&gt; &#123; try &#123; //获取回调函数的执行结果 let result = type(this.PromiseResult); //判断 if (result instanceof Promise) &#123; //如果是 Promise 类型的对象 result.then(v =&gt; &#123; resolve(v); &#125;, r =&gt; &#123; reject(r); &#125;) &#125; else &#123; //结果的对象状态为『成功』 resolve(result); &#125; &#125; catch (e) &#123; reject(e); &#125; &#125; //调用回调函数 PromiseState if (this.PromiseState === &#x27;fulfilled&#x27;) &#123; setTimeout(() =&gt; &#123; callback(onResolved); &#125;); &#125; if (this.PromiseState === &#x27;rejected&#x27;) &#123; setTimeout(() =&gt; &#123; callback(onRejected); &#125;); &#125; //判断 pending 状态 if (this.PromiseState === &#x27;pending&#x27;) &#123; //保存回调函数 this.callbacks.push(&#123; onResolved: function () &#123; callback(onResolved); &#125;, onRejected: function () &#123; callback(onRejected); &#125; &#125;); &#125; &#125;)&#125;//catch 方法catch (onRejected) &#123; return this.then(undefined, onRejected);&#125;//添加 resolve 方法static resolve(value) &#123; //返回promise对象 return new Promise((resolve, reject) =&gt; &#123; if (value instanceof Promise) &#123; value.then(v =&gt; &#123; resolve(v); &#125;, r =&gt; &#123; reject(r); &#125;) &#125; else &#123; //状态设置为成功 resolve(value); &#125; &#125;);&#125;//添加 reject 方法static reject(reason) &#123; return new Promise((resolve, reject) =&gt; &#123; reject(reason); &#125;);&#125;//添加 all 方法static all(promises) &#123; //返回结果为promise对象 return new Promise((resolve, reject) =&gt; &#123; //声明变量 let count = 0; let arr = []; //遍历 for (let i = 0; i &lt; promises.length; i++) &#123; // promises[i].then(v =&gt; &#123; //得知对象的状态是成功 //每个promise对象 都成功 count++; //将当前promise对象成功的结果 存入到数组中 arr[i] = v; //判断 if (count === promises.length) &#123; //修改状态 resolve(arr); &#125; &#125;, r =&gt; &#123; reject(r); &#125;); &#125; &#125;);&#125;//添加 race 方法static race(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; for (let i = 0; i &lt; promises.length; i++) &#123; promises[i].then(v =&gt; &#123; //修改返回对象的状态为 『成功』 resolve(v); &#125;, r =&gt; &#123; //修改返回对象的状态为 『失败』 reject(r); &#125;) &#125; &#125;);&#125;&gt;&#125; html文件调用 123456789101112131415161718192021222324252627282930&gt;&lt;!DOCTYPE html&gt;&gt;&lt;html lang=&quot;en&quot;&gt;&gt;&lt;head&gt;&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&gt;&lt;title&gt;class版本封装&lt;/title&gt;&gt;&lt;script src=&quot;./promisedemo.js&quot;&gt;&lt;/script&gt;&gt;&lt;/head&gt;&gt;&lt;body&gt;&gt;&lt;script&gt;&gt;let p1 = new Promise((resolve, reject) =&gt; &#123;setTimeout(() =&gt; &#123; // resolve(&quot;OK&quot;); reject(&quot;Erosssr&quot;);&#125;)&gt;&#125;);&gt;p1.then(value =&gt; &#123;console.log(value);&gt;&#125;, reason =&gt; &#123;console.warn(reason);&gt;&#125;);&gt;console.log(Promise.resolve(&#x27;OK&#x27;));&gt;&lt;/script&gt;&gt;&lt;/body&gt;&gt;&lt;/html&gt; Promise+ async + await 1)Promise==&gt;异步2)await==&gt;异步转同步 await 可以理解为是 async wait 的简写。await 必须出现在 async 函数内部，不能单独使用。 await 后面可以跟任何的JS 表达式。虽然说 await 可以等很多类型的东西，但是它最主要的意图是用来等待 Promise 对象的状态被 resolved。如果await的是 promise对象会造成异步函数停止执行并且等待 promise 的解决,如果等的是正常的表达式则立即执行 3)async==&gt;同步转异步 方法体内部的某个表达式使用await修饰，那么这个方法体所属方法必须要用async修饰所以使用awit方法会自动升级为异步方法 4)mdn文档 async await async函数 函数的返回值为 promise 对象 promise 对象的结果由 async 函数执行的返回值决定 await表达式 await 右侧的表达式一般为 promise 对象, 但也可以是其它的值 如果表达式是 promise 对象, await 返回的是 promise 成功的值 如果表达式是其它值, 直接将此值作为 await 的返回值 注意 await 必须写在 async 函数中, 但 async 函数中可以没有 await 如果 await 的 promise 失败了, 就会抛出异常, 需要通过 try…catch 捕获处理 原作者对某些问题理解解答如何在Promise外部使用Promise的结果 用到的本章节知识: 1、axios本质上就是一个promise,所以下面用定时器+Promise模拟axios,效果一样,可以将new Promise(resolve =&gt; &#123;setTimeout(function() &#123; resolve(&quot;promise普通结果&quot;); &#125;, 1000); &#125;)等价于axios(&#123;&#125;) 2、resolve() 与reject()是修改Promise状态并往外抛出的,一个Promise只能改变一次状态,所以一个primise中只能调用一次 3、 上一步抛出后可以在下面 的.then()中获取到 Ⅰ-如果没有用.then(),则值会抛往Promise外部 Ⅱ-如果声明了.then(),则值会被.then()接住,放到里面处理,如果需要再次抛出—某些业务场景需要 ,然后在下一个then()或者外部使用, 则可以 .then(v=&gt;return v) —-前提这个链式调用前曾使用过resolve() 与reject()才用return,不然就用这两个resolve() 与reject() 123456789101112131415161718192021222324252627282930313233&gt;//讲解时写的简单demo&gt;let resolveCommon = ()=&gt; &#123;&gt;let result=&quot;普通promise初始值&quot;&gt;result=new Promise(resolve =&gt; &#123;setTimeout(function() &#123; resolve(&quot;promise普通结果&quot;); &#125;, 1000); &#125;)&gt;console.log(result)&gt;//打印结果: Promise &#123; &lt;pending&gt; &#125; &gt;&#125;;&gt;let resolveAsync=async ()=&gt; &#123;&gt;let result=&quot;await+async的promise初始值&quot;&gt;result=await new Promise(resolve =&gt; &#123; setTimeout(function() &#123; resolve(&quot;这是async+await结果&quot;); &#125;, 1000);&#125;)&gt;console.log(result)&gt;//打印结果: 这是async+await结果 这里就是正确的值,你可以在下一步进行正常使用,也可以用在下一步的promise中&gt;//------------------------------------------------------&gt;//在第二个promise中调用使用&gt;let result2=&quot;&quot;&gt;result2= await new Promise(resolve =&gt; &#123; setTimeout(function() &#123; resolve(result+&quot;+经过第二个promise加工&quot;); &#125;, 1000);&#125;)&gt;.then(v=&gt;&#123;&gt;console.log(&quot;第二个promise的then()中打印并返回:&quot;,v)&gt;return v+&quot;,经过then()加工返回&quot;&gt;&#125;)&gt;console.log(&quot;最终结果:第二个promise外部结果打印,&quot;,result2)&gt;//---------------------------------------------&gt;&#125;;&gt;resolveCommon() //调用普通promise函数&gt;resolveAsync() //调用await+async&gt;/**&gt;运行结果&gt;1.resolveCommon() 运行结果: Promise &#123; &lt;pending&gt; &#125;&gt;2.resolveAsync() 运行结果: &gt;这是async+await结果&gt;第二个promise的then()中打印并返回: 这是async+await结果+经过第二个promise加工&gt;最终结果:第二个promise外部结果打印, 这是async+await结果+经过第二个promise加工,经过then()加工返回&gt;*/ 原因解析: new Promise()是一个异步任务,会加到异步队列中,而正常运行比如console.log()是同步运行的(即从上往下运行),会加到同步队列 所以 Promise()通常是会在同一等级的同步任务之后才得到结果的 所以你得到的是一个挂起的 Promise { } 对象 而await则是让跟在后面的异步任务转为同步任务(效果如此,就通俗来讲,具体概念需要自学),所以result就能得到一个已经修改状态为成功或者失败的值 所以下面的任务就可以使用到这个值 为什么这些操作要放在同一个async fn()=&gt;{} 中? 1)Promise==&gt;异步 2)await==&gt;异步转同步 await 可以理解为是 async wait 的简写。await 必须出现在 async 函数内部，不能单独使用。 await 后面可以跟任何的JS 表达式。虽然说 await 可以等很多类型的东西，但是它最主要的意图是用来等待 Promise 对象的状态被 resolved。如果await的是 promise对象会造成异步函数停止执行并且等待 promise 的解决,如果等的是正常的表达式则立即执行 3)async==&gt;同步转异步 方法体内部的某个表达式使用await修饰，那么这个方法体所属方法必须要用async修饰所以使用awit方法会自动升级为异步方法 宏任务与微任务说明 原理图: 说明: JS中用来存储待执行回调函数的队列包含2个不同特定的列队 宏队列:用来保存待执行的宏任务(回调),比如:定时器回调/ajax回调/dom事件回调 微队列:用来保存待执行的微任务(回调),比如:Promise的回调/muntation回调 JS执行时会区别这2个队列: JS执行引擎首先必须执行所有的初始化同步任务代码 每次准备取出第一个宏任务执行前,都要将所有的微任务一个一个取出来执行 同步任务 —&gt; 微任务 —&gt; 宏任务 Ⅱ-代码与示例 你需要一些栗子来帮助验证自己的想法是否正确,尽量先不看结果去自己思考下打印结果顺序 1、代码示例:a) 首先给出注释的栗子举一个 此处会给出每个打印放入什么队列,加深你的印象 1234567891011121314151617181920212223setTimeout(() =&gt; &#123; console.log(&#x27;timeout callback1（）&#x27;) //立即放入宏队列 Promise.resolve(3).then((value) =&gt; &#123; console.log(&#x27;Promise onResolved3()&#x27;, value) //当这个宏任务执行后 立马放入微队列,所以这个微任务执行完后下个宏任务才能执行 &#125;) &#125;, 0) setTimeout(() =&gt; &#123; console.log(&#x27;timeout callback2（）&#x27;) //立即放入宏队列, &#125;, 0) Promise.resolve(1).then((value) =&gt; &#123; console.log(&#x27;Promise onResolved1()&#x27;, value) //立即放入微队列 setTimeout(() =&gt; &#123; console.log(&#x27;timeout callback3（）&#x27;, value) //立即放入宏任务 &#125;, 0) &#125;) Promise.resolve(2).then((value) =&gt; &#123; console.log(&#x27;Promise onResolved2()&#x27;, value) //立即放入微队列 &#125;)console.log(&#x27;同步代码&#x27;) //同步代码立即执行 结果放在下方,就怕你不小心瞄到 b) 尝试自己思考下 尝试自己脑海中用自己理解 ‘运行’ 一下, 然后把结果写下来,再去下面结果做对比 123456789&gt;setTimeout(() =&gt; console.log(&#x27;代码开始执行&#x27;), 0)&gt;new Promise((resolve, reject) =&gt; &#123; console.log(&#x27;开始for循环&#x27;) for (let i = 0; i &lt; 10000; i++) &#123; i == 99 &amp;&amp; resolve() &#125;&gt;&#125;).then(() =&gt; console.log(&#x27;执行then函数&#x27;))&gt;console.log(&#x27;代码执行结束&#x27;) 2、示例结果:a) 第一个栗子的结果 1234567&gt;&#x27;同步代码&#x27;,&gt;&#x27;Promise onResolved1()&#x27;,&gt;&#x27;Promise onResolved2()&#x27;,&gt;&#x27;timeout callback1（）&#x27;,&gt;&#x27;Promise onResolved3()&#x27;,&gt;&#x27;timeout callback2（）&#x27;,&gt;&#x27;timeout callback3（）&#x27; b) 第二个栗子的结果 PS: 可以忽略undefined这个打印结果, 因为这会加重我们对于宏任务与微任务的理解负担. 当然人都是会好奇的,没有打破砂锅问到底的精神呢也当不了一个好程序员,那我就在下方额外给出解释 五、对浏览器console控制台输出undefined的分析Ⅰ- 出现场景 Ⅱ - 尝试输入其他内容进行分析 那么做个合理推测: 应该是在控制台输入的内容,它的 返回值 会显示出来,这让我们不禁想到JS的 [ eval() ] Ⅲ - eval（string） 其作用是将 接收的 string 字符串作为参数，对其进行JavaScript 表达式或语句 计算，返回得到的值； 如果是没有返回值的表达式或语句，则会返回 undefined ； 如果没有合法的表达式和语句，则会抛出 SyntaxError 异常 。 于是我们可以猜测Console控制台的实质 就是 调用了eval（）函数 Ⅳ - 验证一下 大家都是聪明人,看到这个结果应该就不用我组织语言来解释了吧 Ⅴ - 分析其在宏任务与微任务的打印顺序 首先看图: 可以看到 [ undefined ] 实在微任务完成后,宏任务执行前 打印","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://hasuer.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"Nginx学习笔记","slug":"Nginx学习笔记","date":"2022-02-23T12:37:35.000Z","updated":"2022-02-25T06:01:54.829Z","comments":true,"path":"nginx学习笔记/index.html","link":"","permalink":"https://hasuer.github.io/nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html","excerpt":"","text":"Nginx 简介Nginx概述Nginx (“engine x”)是一个高性能的 HTTP 和反向代理服务器 特点是占有内存少，并发能力强，事实上 nginx 的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用 nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等 Nginx 作为 web 服务器Nginx可以作为静态页面的 web 服务器，同时还支持 CGI 协议的动态语言，比如 pe rl 、 php等。但是不支持 java 。 Java 程序只能通过与 tomcat 配合完成。 Nginx 专为性能优化而开发，性能是其最重要的考量 实现上非常注重效率 ，能经受高负载的考验 有报告表明能支持高达 50,000 个并发连接数。 https://lnmp.org/nginx.html 正向代理Nginx不仅可以做反向代理，实现负载均衡。还能用作正向代理来进行上网等功能。 正向代理：如果把局域网外的Internet 想象成一个巨大的资源库，则局域网中的客户端要访问 Internet ，则需要通过代理服务器来访问，这种代理服务就称为正向代理。 反向代理反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器 IP 地址。 负载均衡客户端发送多个请求到服务器，服务器处理请求，有一些可能要与数据库进行交互，服务器处理完毕后，再将结果返回给客户端。 这种架构模式对于早期的系统相对单一，并发请求相对较少的情况下是比较适合的，成本也低。但是随着信息数量的不断增长，访问量和数据量的飞速增长，以及系统业务的复杂度增加，这种架构会造成服务器相应客户端的请求日益缓慢，并发量特别大的时候，还容易造成服务器直接崩溃。很明显这是由于服务器性能的瓶颈造成的问题，那么如何解决这种情况呢？ 我们首先想到的可能是升级服务器的配置，比如提高CPU执行频率，加大内存等提高机器的物理性能来解决此问题，但是我们知道摩尔定律的日益失效，硬件的性能提升已经不能满足日益提升的需求了。最明显的一个例子，天猫双十一当天，某个热销商品的瞬时访问量是极其庞大的，那么类似上面的系统架构，将机器都增加到现有的顶级物理配置，都是不能够满足需求的。那么怎么办呢？ 上面的分析我们去掉了增加服务器物理配置来解决问题的办法，也就是说纵向解决问题的办法行不通了，那么横向增加服务器的数量呢？这时候集群的概念产生了，单个服务器解决不了，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡 动静分离为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。 Nginx 安装进入 nginx 官网，下载http://nginx.org/ 安装 nginx第一步，安装 pcrewget http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre8.37.tar.gz 解压文件，./configure完成后，回到 pcre 目录下执行 make再执行make install 第二步，安装 openssl第三步，安装 zlibyum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel 第四步,安装 nginx 解压缩 nginx xx.tar.gz 包。 进入解压缩目录 执行 ./configure 。 make &amp;&amp; make install 查看开放的端口号firewall-cmd --list all设置开放的端口号firewall-cmd --add-service=http --permanentsudo firewall-cmd --add -port=80/tcp --permanent重启防火墙firewall-cmd --reload nginx 常用的命令和配置文件nginx 常用的命令 启动命令 在/usr/local/nginx/sbin 目录下执行 ./nginx 关闭命令在/usr/local/nginx/sbin 目录下执行 ./nginx -s stop 重新加载命令在/usr/local/nginx/sbin 目录下执行 ./nginx -s reload nginx.conf 配置文件nginx 安装目录下，其默认的配置文件都放在这个目录的 conf 目录下，而 主配置文件 nginx.conf 也在其中，后续对 nginx 的使用基本上都是对此配置文件进行相应的修改 配置文件中有很多 开头的表示注释内容，我们去掉所有以 # 开头的段落，精简之后的内容如下： 根据上述文件，我们可以很明显的将 nginx.conf 配置文件分为三部分： 第一部分：全局块从配置文件开始到 events 块之间的内容，主要会设置一些影响nginx 服务器整体运行的配置指令，主要包括配置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以及配置文件的引入等。 比如上面第一行配置的： 这是 Nginx 服务器并发处理服务的关键配置，worker_processes 值越大，可以支持的并发处理量也越多，但是会受到硬件、软件等设备的制约 第二部分：events块比如上面的配置： events 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word process 可以同时支持的最大连接数等。 上述例子就表示每个 work process 支持的最大连接数为 1024. 这部分的配置对 Nginx 的性能影响较大，在实际中应该灵活配置。 第三部分：http块 这算是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。 需要注意的是：http 块也可以包括 http全局块、server 块。 http 全局块http全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。 server 块这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。 每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。 而每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。 全局 server 块 最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或IP配置。 location 块 一个 server 块可以配置多个 location 块。 这块的主要作用是基于 Nginx 服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟主机名称（也可以是IP别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。 nginx 配置实例 反向代理反向代理实例一实现效果：使用 n ginx 反向代理，访问 www 123 com 直接跳转到 127.0.0.1:8080 实验代码 启动一个 tomcat ，浏览器地址栏输入 127.0.0.1:8080 ，出现如下界面 通过修改本地 host 文件，将 www. 123 .com 映射到 127.0.0.1 配置完成之后，我们便可以通过www.123.com:8080 访问到第一步出现的 Tomcat初始界面。那么如何只需要输入www.123.com便可以跳转到 Tomcat初始界面呢？便用到 nginx的反向代理。 在 nginx.conf配置文件中增加如下配置 如上配置，我们监听80端口，访问域名为www.123.com，不加端口号时默认为80端口，故访问该域名时会跳转到127.0.0.1:8080路径上。在浏览器端输入 www.123.com 结果如下： 反向代理实例二实现效果：使用 nginx 反向代理， 根据访问的路径跳转到不同端口的服务中nginx 监听端口为 9001访问 http://127.0.0.1:9001/edu/ 直接跳转到 127.0.0.1:8081访问 http://127.0.0.1:9001/vod/ 直接跳转到 127.0.0.1:8082 实验代码第一步，准备两个 tomcat ，一个 8001 端口，一个 8002 端口，并准备好测试的页面第二步，修改 nginx 的配置文件在http 块中添加 server{} location 指令说明该指令用于匹配 URL。 语法如下： 1、= ：用于不含正则表达式的 uri 前，要求请求字符串与 uri 严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求。 2、~：用于表示 uri 包含正则表达式，并且区分大小写。 3、~*：用于表示 uri 包含正则表达式，并且不区分大小写。 4、^~：用于不含正则表达式的 uri 前，要求 Nginx 服务器找到标识 uri 和请求字符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location 块中的正则 uri 和请求字符串做匹配。 注意：如果 url 包含正则表达式，则必须要有 ~ 或者 ~\\ 标识。 nginx 配置实例 负载均衡实现效果： 配置负载均衡 实验代码 首先准备两个同时启动的 Tomcat 在 nginx.conf 中进行配置 随着互联网信息的爆炸性增长，负载均衡（load balance ）已经不再是一个很陌生的话题顾名思义，负载均衡即是将负载分摊到不同的服务单元，既保证服务的可用性，又保证响应足够快，给用户很好的体验。快速增长的访问量和数据流量催生了各式各样的负载均衡产品，很多专业的负载均衡硬件提供了很好的功能，但却价格不菲，这使得负载均衡软件大受欢迎，nginx 就是其中的一个，在 linux 下有 Nginx 、 LVS 、 Haproxy 等等服务可以提供负载均衡服务，而且 Nginx 提供了几种分配方式 策略: 1、轮询（默认）每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。2、weightweight代表权 重默认为 1, 权重越高被分配的客户端越多。指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 例如： 1234upstream server_pool&#123; server 192.168.5.21 weight=10; server 192.168.5.22 weight=10; &#125; 3、ip_hash每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 例如： 12345upstream server_pool&#123; ip_hash; server 192.168.5.21:80; server 192.168.5.22:80; &#125; 4、fair（第三方） 按后端服务器的响应时间来分配请求，响应时间短的优先分配。 12345upstream server_pool&#123; server 192.168.5.21:80; server 192.168.5.22:80; fair; &#125; nginx 配置实例 动静分离Nginx 动静分离简单来说就是把动态跟静态请求分开，不能理解成只是单纯的把动态页面和静态页面物理分离。严格意义上说应该是动态请求跟静态请求分开，可以理解成使用Nginx 处理静态页面，Tomcat处理动态页面。 动静分离从目前实现角度来讲大致分为两种， 一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案； 另外一种方法就是动态跟静态文件混合在一起发布，通过 nginx 来分开。 通过 location 指定不同的后缀名实现不同的请求转发。通过 expires 参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量。具体 Expires 定义：是给一个资源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。此种方法非常适合不经常变动的资源。（如果经常更新的文件，不建议使用 Expires 来缓存），我这里设置 3d，表示在这 3 天之内访问这个 URL，发送一个请求，比对服务器该文件最后更新时间没有变化，则不会从服务器抓取，返回状态码 304，如果有修改，则直接从服务器重新下载，返回状态码 200。 实验代码 项目资源准备 进行 nginx 配置找到 nginx 安装目录，打开 /conf/nginx.conf 配置文件， 添加监听端口、访问名字重点是添加location,最后检查 Nginx 配置是否正确即可，然后测试动静分离是否成功，之需要删除后端 tomcat服务器上的某个静态文件，查看是否能访问，如果可以访问说明静态资源 nginx 直接返回了，不走后端 tomcat 服务器.","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://hasuer.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"AJAX学习笔记","slug":"AJAX学习笔记","date":"2022-02-23T06:53:23.000Z","updated":"2022-02-23T10:33:09.519Z","comments":true,"path":"ajax学习笔记/index.html","link":"","permalink":"https://hasuer.github.io/ajax%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html","excerpt":"","text":"本笔记是视频课程的笔记。【尚硅谷】3小时AJAX入门到精通 笔记转载自这里,做了适当改动。 此部分知识为学习axios预备知识,预备知识链:ajax —&gt; promise —&gt; axios —&gt; react/vue Ajax简介 AJAX 简介 AJAX 全称为 Asynchronous JavaScript And XML，就是异步的 JS 和 XML。 通过 AJAX 可以在浏览器中向服务器发送异步请求，最大的优势：无刷新获取数据。 AJAX 不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式。 XML简介 XML 可扩展标记语言。 XML 被设计用来传输和存储数据。 XML 和 HTML 类似，不同的是 HTML 中都是预定义标签，而 XML 中没有预定义标签， 全都是自定义标签，用来表示一些数据。 比如说我有一个学生数据： name = “孙悟空” ; age = 18 ; gender = “男” ; 123456用 XML 表示：&lt;student&gt; &lt;name&gt;孙悟空&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;gender&gt;男&lt;/gender&gt;&lt;/student&gt; 现在已经被 JSON 取代了。 1&#123;&quot;name&quot;:&quot;孙悟空&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;&#125; Ajax的特点AJAX 的优点 可以无需刷新页面而与服务器端进行通信。 允许你根据用户事件来更新部分页面内容。 Ajax的缺点 没有浏览历史，不能回退 存在跨域问题(同源) SEO (搜索引擎优化）不友好，爬虫无法爬到 HTTP简介 HTTP（hypertext transport protocol）协议『超文本传输协议』，协议详细规定了浏览器和万维网服务器之间互相通信的规则、约定,、规则 请求报文 123456789重点是格式与参数行 POST /s?ie=utf-8 HTTP/1.1 头 Host: atguigu.com Cookie: name=guigu Content-type: application/x-www-form-urlencoded User-Agent: chrome 83空行体 username=admin&amp;password=admin 响应报文 12345678910111213行 HTTP/1.1 200 OK头 Content-Type: text/html;charset=utf-8 Content-length: 2048 Content-encoding: gzip空行 体 &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;尚硅谷&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; Chrome网络控制台查看通信报文 1、Network —&gt; Hearders 请求头 2、Network —&gt; Response 响应体:通常返回的是html 原生Ajax 1、XMLHttpRequest，AJAX 的所有操作都是通过该对象进行的。 2、当你前端想设置自定义的请求头时,需要如此后端设置响应头 123//表示接收任意类型的请求 app.all(&#x27;/server&#x27;, (request, response) =&gt; &#123; //响应头 允许跨域 运行自定义响应头 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;*&#x27;);&#125; 3、ajax请求状态:xhr.readyState 0：请求未初始化，还没有调用 open()。 1：请求已经建立，但是还没有发送，还没有调用 send()。 2：请求已发送，正在处理中（通常现在可以从响应中获取内容头）。 3：请求在处理中；通常响应中已有部分数据可用了，没有全部完成。 4：响应已完成；您可以获取并使用服务器的响应了 Ajax的使用 使用步骤: 1234567891011121314151617181920212223241) 创建 XMLHttpRequest 对象var xhr = new XMLHttpRequest();2) 设置请求信息xhr.open(method, url);//可以设置请求头，一般不设置xhr.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;);3) 发送请求xhr.send(body) //get 请求不传 body 参数，只有 post 请求使用4) 接收响应//xhr.responseXML 接收 xml 格式的响应数据//xhr.responseText 接收文本格式的响应数据xhr.onreadystatechange = function ()&#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; var text = xhr.responseText; console.log(text); &#125;&#125;/*0: 请求未初始化1: 服务器连接已建立2: 请求已接收3: 请求处理中4: 请求已完成，且响应已就绪*/ Get方式12345678910111213141516171819202122232425262728293031//绑定事件btn.onclick = function () &#123; //1. 创建对象 const xhr = new XMLHttpRequest(); //2. 初始化 设置请求方法和 url // 使用&amp;分割参数 xhr.open(&#x27;GET&#x27;, &#x27;http://127.0.0.1:8000/server?a=100&amp;b=200&amp;c=300&#x27;); //3. 发送 xhr.send(); //4. 事件绑定 处理服务端返回的结果 // on when 当....时候 // readystate 是 xhr 对象中的属性, 表示状态 0 1 2 3 4 // change 改变 xhr.onreadystatechange = function () &#123; //判断 (服务端返回了所有的结果) if (xhr.readyState === 4) &#123; //判断响应状态码 200 404 403 401 500 // 2xx 成功 if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123; //处理结果 行 头 空行 体 //响应 // console.log(xhr.status);//状态码 // console.log(xhr.statusText);//状态字符串 // console.log(xhr.getAllResponseHeaders());//所有响应头 // console.log(xhr.response);//响应体 //设置 result 的文本 result.innerHTML = xhr.response; &#125; else &#123;&#125; &#125; &#125;&#125; Post方式12345678910111213141516171819202122232425//绑定事件 result.addEventListener(&quot;mouseover&quot;, function()&#123; //1. 创建对象 const xhr = new XMLHttpRequest(); //2. 初始化 设置类型与 URL xhr.open(&#x27;POST&#x27;, &#x27;http://127.0.0.1:8000/server&#x27;); //设置请求头 xhr.setRequestHeader(&#x27;Content-Type&#x27;,&#x27;application/x-www-form-urlencoded&#x27;) // 下面这个是自定义的头信息，在后端代码中要设置允许所有的请求头，否则失败 xhr.setRequestHeader(&#x27;name&#x27;,&#x27;atguigu&#x27;); //3. 发送 xhr.send(&#x27;a=100&amp;b=200&amp;c=300&#x27;); // xhr.send(&#x27;a:100&amp;b:200&amp;c:300&#x27;); // xhr.send(&#x27;1233211234567&#x27;); //4. 事件绑定 xhr.onreadystatechange = function()&#123; //判断 if(xhr.readyState === 4)&#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123; //处理服务端返回的结果 result.innerHTML = xhr.response; &#125; &#125; &#125; &#125;); 解决ie缓存问题 问题：在一些浏览器中(IE),由于缓存机制的存在，ajax 只会发送的第一次请求，剩余多次请求不会再发送给浏览器而是直接加载缓存中的数据。 解决方式：浏览器的缓存是根据 url地址来记录的，所以我们只需要修改 url 地址 即可避免缓存问题 xhr.open(&quot;get&quot;,&quot;/testAJAX?t=&quot;+Date.now()); 请求超时与网络异常 当你的请求时间过长,或者无网络时,进行的相应处理 1234567891011121314151617181920212223btn.addEventListener(&#x27;click&#x27;, function()&#123; const xhr = new XMLHttpRequest(); //超时设置 2s 设置 xhr.timeout = 2000; //超时回调 xhr.ontimeout = function()&#123; alert(&quot;网络异常, 请稍后重试!!&quot;); &#125; //网络异常回调 xhr.onerror = function()&#123; alert(&quot;你的网络似乎出了一些问题!&quot;); &#125; xhr.open(&quot;GET&quot;,&#x27;http://127.0.0.1:8000/delay&#x27;); xhr.send(); xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4)&#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status&lt; 300)&#123; result.innerHTML = xhr.response; &#125; &#125; &#125; &#125;) 取消请求 在请求发出去后但是未响应完成时可以进行取消请求操作 1234567891011const btns = document.querySelectorAll(&#x27;button&#x27;);let x = null;btns[0].onclick = function()&#123; x = new XMLHttpRequest(); x.open(&quot;GET&quot;,&#x27;http://127.0.0.1:8000/delay&#x27;); x.send();&#125;// abortbtns[1].onclick = function()&#123; x.abort();&#125; 重复请求问题 利用之前取消请求知识点,当我点击时判断之前请求是否在发送中,如果是,则停止请求 123456789101112131415btns[0].onclick = function()&#123; //判断标识变量 if(isSending) x.abort();// 如果正在发送, 则取消该请求, 创建一个新的请求 x = new XMLHttpRequest(); //修改 标识变量的值 isSending = true; x.open(&quot;GET&quot;,&#x27;http://127.0.0.1:8000/delay&#x27;); x.send(); x.onreadystatechange = function()&#123; if(x.readyState === 4)&#123; //修改标识变量 isSending = false; &#125; &#125; &#125; 常见三种Ajax请求方式jQuery发送AJAX请求 jQuery有三种发送请求方法: 当你只是简单的请求数据,可以直接使用前两种方式请求,当你需要设置的东西较多的时候,可以使用$.ajax()方法 $.get()12345$(&#x27;button&#x27;).eq(0).click(function()&#123; $.get(&#x27;http://127.0.0.1:8000/jquery-server&#x27;, &#123;a:100, b:200&#125;, function(data)&#123; console.log(data); &#125;,&#x27;json&#x27;); &#125;); $.post()12345$(&#x27;button&#x27;).eq(1).click(function()&#123; $.post(&#x27;http://127.0.0.1:8000/jquery-server&#x27;, &#123;a:100, b:200&#125;, function(data)&#123; console.log(data); &#125;); &#125;); $.ajax123456789101112131415161718192021222324252627$(&#x27;button&#x27;).eq(2).click(function()&#123; $.ajax(&#123; //url url: &#x27;http://127.0.0.1:8000/jquery-server&#x27;, //参数 data: &#123;a:100, b:200&#125;, //请求类型 type: &#x27;GET&#x27;, //响应体结果 dataType: &#x27;json&#x27;, //成功的回调 success: function(data)&#123; console.log(data); &#125;, //超时时间 timeout: 2000, //失败的回调 error: function()&#123; console.log(&#x27;出错啦!!&#x27;); &#125;, //头信息 headers: &#123; c:300, d:400 &#125; &#125;); &#125;); Axios发送AJAX请求axios.get() axios.get(url,data,params) 1234567891011121314151617181920//配置 baseURL axios.defaults.baseURL = &#x27;http://127.0.0.1:8000&#x27;; btns[0].onclick = function () &#123; //GET 请求 axios.get(&#x27;/axios-server&#x27;, &#123; //url 参数 params: &#123; id: 100, vip: 7 &#125;, //请求头信息 headers: &#123; name: &#x27;atguigu&#x27;, age: 20 &#125; &#125;).then(value =&gt; &#123; console.log(value); &#125;); &#125; axios.post() axios.post(url,data,params) 12345678910111213141516171819 //配置 baseURL axios.defaults.baseURL = &#x27;http://127.0.0.1:8000&#x27;; btns[1].onclick = function () &#123; axios.post(&#x27;/axios-server&#x27;, &#123; username: &#x27;admin&#x27;, password: &#x27;admin&#x27; &#125;, &#123; //url params: &#123; id: 200, vip: 9 &#125;, //请求头参数 headers: &#123; height: 180, weight: 180, &#125; &#125;); &#125; axios() 常用 axios({}) 12345678910111213141516171819202122232425262728293031323334 //配置 baseURL axios.defaults.baseURL = &#x27;http://127.0.0.1:8000&#x27;;btns[2].onclick = function () &#123; axios(&#123; //请求方法 method: &#x27;POST&#x27;, //url url: &#x27;/axios-server&#x27;, //url参数 params: &#123; vip: 10, level: 30 &#125;, //头信息,此部分如果使用自定义的头信息,需要服务端进行相应修改,正常不设置 headers: &#123; a: 100, b: 200 &#125;, //请求体参数 data: &#123; username: &#x27;admin&#x27;, password: &#x27;admin&#x27; &#125; &#125;).then(response =&gt; &#123; //响应状态码 console.log(response.status); //响应状态字符串 console.log(response.statusText); //响应头信息 console.log(response.headers); //响应体 console.log(response.data); &#125;) &#125; Fetch发送AJAX请求 代码示例 1234567891011121314151617btn.onclick = function () &#123; fetch(&#x27;http://127.0.0.1:8000/fetch-server?vip=10&#x27;, &#123; //请求方法 method: &#x27;POST&#x27;, //请求头 headers: &#123; name: &#x27;atguigu&#x27; &#125;, //请求体 body: &#x27;username=admin&amp;password=admin&#x27; &#125;).then(response =&gt; &#123; // return response.text(); return response.json(); &#125;).then(response =&gt; &#123; console.log(response); &#125;); &#125; 跨域与解决 1、什么是跨越？ 一个网页向另一个不同域名/不同协议/不同端口的网页请求资源，这就是跨域。 跨域原因产生：在当前域名请求网站中，默认不允许通过ajax请求发送其他域名。 2、为什么会产生跨域请求？ 因为浏览器使用了同源策略 3、什么是同源策略？ 同源策略是Netscape提出的一个著名的安全策略，现在所有支持JavaScript的浏览器都会使用这个策略。同源策略是浏览器最核心也最基本的安全功能，如果缺少同源策略，浏览器的正常功能可能受到影响。可以说web是构建在同源策略的基础之上的，浏览器只是针对同源策略的一种实现。 同源： 协议、域名、端口号 必须完全相同。 违背同源策略就是跨域。 4、为什么浏览器要使用同源策略？ 是为了保证用户的信息安全，防止恶意网站窃取数据，如果网页之间不满足同源要求，将不能: 1、共享Cookie、LocalStorage、IndexDB 2、获取DOM 3、AJAX请求不能发送 5、跨域的五个解决方式: 1、前端使用jsonp （不推荐使用） 2、后台Http请求转发 3、后台配置同源Cors （推荐） 4、使用SpringCloud网关 5、使用nginx做转发 (推荐) 本课程提到了其中的两种: jsonP 1)JSONP 是什么? JSONP(JSON with Padding)，是一个非官方的跨域解决方案，纯粹凭借程序员的聪明 才智开发出来，只支持 get 请求。 2)JSONP 怎么工作的？ 在网页有一些标签天生具有跨域能力，比如：img link iframe script。 JSONP 就是利用 script 标签的跨域能力来发送请求的。 jsonP的使用1234567891011121314151617181920 // 1. 动态的创建一个 script 标签------------------------------------------------------------ var script = document.createElement(&quot;script&quot;);//2. 设置 script 的 src， 设置回调函数 script.src = &quot;http://localhost:3000/testAJAX?callback=abc&quot;; function abc(data) &#123; alert(data.name); &#125;; // 3. 将 script 添加到 body 中 document.body.appendChild(script); // 4. 服务器中路由的处理------------------------------------------------------ router.get(&quot;/testAJAX&quot;, function (req, res) &#123; console.log(&quot;收到请求&quot;); var callback = req.query.callback; var obj = &#123; ame: &quot;孙悟空&quot;, age: 18 &#125; res.send(callback + &quot;(&quot; + JSON.stringify(obj) + &quot;)&quot;); &#125;); jQuery发送jsonP请求1234567891011121314151617181920212223242526//前端代码-----------------------------------------------------------------------------------$(&#x27;button&#x27;).eq(0).click(function () &#123; $.getJSON(&#x27;http://127.0.0.1:8000/jquery-jsonp-server?callback=?&#x27;, function (data) &#123; $(&#x27;#result&#x27;).html(` 名称: $&#123;data.name&#125;&lt;br&gt; 校区: $&#123;data.city&#125; `) &#125;);&#125;);//服务端代码-----------------------------------------------------------app.all(&#x27;/jquery-jsonp-server&#x27;, (request, response) =&gt; &#123; // response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;); const data = &#123; name: &#x27;尚硅谷&#x27;, city: [&#x27;北京&#x27;, &#x27;上海&#x27;, &#x27;深圳&#x27;] &#125;; //将数据转化为字符串 let str = JSON.stringify(data); //接收 callback 参数 let cb = request.query.callback; //返回结果 // $&#123;&#125; 可以将str转变成对象 response.end(`$&#123;cb&#125;($&#123;str&#125;)`);&#125;); 原作者开发封装的jsonP插件 1、代价:需要前后端联动 2、精髓:自动的由插件生成方法名,并在当前的页面动态的生成函数,然后再生成的函数里头调用用户预留的回调函数 3、插件：自动化的去模拟基于script去实现跨域请求的过程（对用户来说是黑盒子） 4、参数拼接：url已经是带参的。和不带参的 5、id优化 额可以添加一个容器来管理id 1、前端调用测试封装好的jsonP代码 123456789101112//测试调用函数 let test=function () &#123; jsonP.req(&#123; url:&quot;http://localhost:3000/jsonpx&quot;, data:&#123; a:&quot;111&quot; &#125;, callback:function (result) &#123; alert(&quot;成功&quot;+result) &#125; &#125;) &#125; 2、服务端测试代码 12345678router.get(&#x27;/jsonpx&#x27;, async function (req, resp, next) &#123; let callback=req.query.callback; let data=req.query.a; if (!data)&#123; resp.send(`$&#123;callback&#125;(&#x27;洪jl:我是服务端代码&#x27;)`) &#125; resp.send(`$&#123;callback&#125;(&#x27;洪jl:我是服务端代码`+data+`&#x27;)`)&#125;) 3、封装原生代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;script&gt; /**author:@hongjilin * 1.声明一个jsonP插件对象 * 作用：隔开作用域 */ let jsonP = &#123;&#125;; /** *2.在插件对象中创建两个名字备用符数组 */ jsonP.char = &#123; Number: &#x27;0123456789&#x27;, Letter: &#x27;qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM&#x27; &#125; /** * 通过随机数抽取备用字符数组库拼凑函数id * @param charLen * @param numLen */ jsonP.newFunId = function (charLen, numLen) &#123; let id = &#x27;&#x27;; for (let i = 0; i &lt; charLen; i++) &#123; id += this.char.Letter.charAt(Math.random() * 52) &#125; for (let j = 0; j &lt; numLen; j++) &#123; id += Math.floor(Math.random() * 10); &#125; return id; &#125; /** * 拼接路径 * @param url * @param key * @param value */ jsonP.jointUrl = function (url, key, value) &#123; if (url &amp;&amp; key &amp;&amp; value) &#123; let sign = &quot;&amp;&quot; //如果是第一次 if (url.indexOf(&#x27;?&#x27;) == -1) &#123; sign = &#x27;?&#x27; &#125; url += sign + key + &quot;=&quot; + value &#125; return url; &#125; /** 封装err属性方便 */ jsonP.err = function (msg) &#123; console.error(msg) &#125; /** * 发送请求函数 * @param options */ jsonP.req = function (options) &#123; let jsonId=&#123;&#125;; //1.生成方法名 jsonId.funId = this.newFunId(4,8); let Userurl = options.url; let Userdata = options.data; if (!options) &#123; this.err(&quot;输入不能空&quot;) return; &#125; else if (!Userurl) &#123; this.err(&quot;url不能空&quot;) return; &#125; else if (!Userdata) &#123; //如果没有data,初始化 Userdata = &#123;&#125;; &#125; //将函数名赋值给userdata的回调函数属性中 Userdata.callback = jsonId.funId; for (let key in Userdata) &#123; Userurl = this.jointUrl(Userurl, key, Userdata[key]) &#125; let script = document.createElement(&#x27;script&#x27;); script.setAttribute(&quot;id&quot; , jsonId.funId); script.setAttribute(&quot;src&quot; , Userurl); //动态生成函数 let callback=function (result) &#123; console.log(&quot;xxxxxxx&quot;) //业务逻辑回调 if (options.callback)&#123; try &#123; options.callback(result) &#125;catch (e) &#123; this.err(e.message) &#125; &#125; //善后 let tmp=document.getElementById(jsonId.funId) tmp.parentNode.removeChild(tmp); eval(jsonId.funId+&#x27;=null&#x27;) &#125; eval(&quot;window.&quot;+jsonId.funId+&quot;=function(result)&#123; callback(result) &#125;&quot;) document.head.appendChild(script) &#125;&lt;/script&gt; CORS 1、CORS文档链接 2、CORS是什么? CORS（Cross-Origin Resource Sharing），跨域资源共享。CORS 是官方的跨域解决方 案，它的特点是不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持 get 和 post 请求。跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些 源站通过浏览器有权限访问哪些资源 3、CORS是怎么工作的? CORS 是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应 以后就会对响应放行。 代码示例1234567891011app.all(&#x27;/cors-server&#x27;, (request, response) =&gt; &#123; //设置响应头 //响应首部中可以携带一个 Access-Control-Allow-Origin 字段 response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); //Access-Control-Allow-Headers 首部字段用于预检请求的响应。其指明了实际请求中允许携带的首部字 response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &#x27;*&#x27;); //Access-Control-Allow-Methods 首部字段用于预检请求的响应。其指明了实际请求所允许使用的 HTTP response.setHeader(&quot;Access-Control-Allow-Method&quot;, &#x27;*&#x27;); // response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://127.0.0.1:5500&quot;); response.send(&#x27;hello CORS&#x27;);&#125;); HTTP 响应首部字段 本节列出了规范所定义的响应首部字段。上一小节中，我们已经看到了这些首部字段在实际场景中是如何工作的。 Access-Control-Allow-Origin 响应首部中可以携带一个 Access-Control-Allow-Origin 字段，其语法如下: 1Access-Control-Allow-Origin: &lt;origin&gt; | * 其中，origin 参数的值指定了允许访问该资源的外域 URI。对于不需要携带身份凭证的请求，服务器可以指定该字段的值为通配符，表示允许来自所有域的请求。 例如，下面的字段值将允许来自 http://mozilla.com 的请求： 1Access-Control-Allow-Origin: http://mozilla.com 如果服务端指定了具体的域名而非“*”，那么响应首部中的 Vary 字段的值必须包含 Origin。这将告诉客户端：服务器对不同的源站返回不同的内容。 Access-Control-Expose-Headers 译者注：在跨源访问时，XMLHttpRequest对象的getResponseHeader()方法只能拿到一些最基本的响应头，Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。 Access-Control-Expose-Headers 头让服务器把允许浏览器访问的头放入白名单，例如： 1Access-Control-Expose-Headers: X-My-Custom-Header, X-Another-Custom-Header 这样浏览器就能够通过getResponseHeader访问X-My-Custom-Header和 X-Another-Custom-Header 响应头了。 Access-Control-Max-Age Access-Control-Max-Age 头指定了preflight请求的结果能够被缓存多久，请参考本文在前面提到的preflight例子。 1Access-Control-Max-Age: &lt;delta-seconds&gt; delta-seconds 参数表示preflight请求的结果在多少秒内有效。 Access-Control-Allow-Credentials Access-Control-Allow-Credentials 头指定了当浏览器的credentials设置为true时是否允许浏览器读取response的内容。当用在对preflight预检测请求的响应中时，它指定了实际的请求是否可以使用credentials。请注意：简单 GET 请求不会被预检；如果对此类请求的响应中不包含该字段，这个响应将被忽略掉，并且浏览器也不会将相应内容返回给网页。 1Access-Control-Allow-Credentials: true Access-Control-Allow-Methods Access-Control-Allow-Methods 首部字段用于预检请求的响应。其指明了实际请求所允许使用的 HTTP 方法。 1Access-Control-Allow-Methods: &lt;method&gt;[, &lt;method&gt;]* Access-Control-Allow-Headers Access-Control-Allow-Headers 首部字段用于预检请求的响应。其指明了实际请求中允许携带的首部字段。 1Access-Control-Allow-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]* HTTP 请求首部字段 本节列出了可用于发起跨源请求的首部字段。请注意，这些首部字段无须手动设置。 当开发者使用 XMLHttpRequest 对象发起跨源请求时，它们已经被设置就绪。 Origin Origin 首部字段表明预检请求或实际请求的源站。 1Origin: &lt;origin&gt; origin 参数的值为源站 URI。它不包含任何路径信息，只是服务器名称。 Note: 有时候将该字段的值设置为空字符串是有用的，例如，当源站是一个 data URL 时。 注意，在所有访问控制请求（Access control request）中，Origin 首部字段总是被发送 Access-Control-Request-Method Access-Control-Request-Method 首部字段用于预检请求。其作用是，将实际请求所使用的 HTTP 方法告诉服务器。 1Access-Control-Request-Method: &lt;method&gt; Access-Control-Request-Headers Access-Control-Request-Headers 首部字段用于预检请求。其作用是，将实际请求所携带的首部字段告诉服务器。 1Access-Control-Request-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]* 服务端代码示例 配合以上前端代码的服务端代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153//1. 引入expressconst express = require(&#x27;express&#x27;);//2. 创建应用对象const app = express();//3. 创建路由规则// request 是对请求报文的封装// response 是对响应报文的封装app.get(&#x27;/server&#x27;, (request, response) =&gt; &#123; //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); //设置响应体 response.send(&#x27;HELLO AJAX - 2&#x27;);&#125;);//可以接收任意类型的请求 app.all(&#x27;/server&#x27;, (request, response) =&gt; &#123; //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); //响应头 response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;*&#x27;); //设置响应体 response.send(&#x27;HELLO AJAX POST&#x27;);&#125;);//JSON 响应app.all(&#x27;/json-server&#x27;, (request, response) =&gt; &#123; //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;*&#x27;); //响应一个数据 const data = &#123; name: &#x27;atguigu&#x27; &#125;; //对对象进行字符串转换 let str = JSON.stringify(data); //设置响应体 response.send(str);&#125;);//针对 IE 缓存app.get(&#x27;/ie&#x27;, (request, response) =&gt; &#123; //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); //设置响应体 response.send(&#x27;HELLO IE - 5&#x27;);&#125;);//延时响应app.all(&#x27;/delay&#x27;, (request, response) =&gt; &#123; //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;*&#x27;); setTimeout(() =&gt; &#123; //设置响应体 response.send(&#x27;延时响应&#x27;); &#125;, 1000)&#125;);//jQuery 服务app.all(&#x27;/jquery-server&#x27;, (request, response) =&gt; &#123; //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;*&#x27;); // response.send(&#x27;Hello jQuery AJAX&#x27;); const data = &#123; name: &#x27;尚硅谷&#x27; &#125;; // 只能send字符串数据，不能直接发送data，所以这里使用了JSON.stringfy()方法 response.send(JSON.stringify(data));&#125;);//axios 服务app.all(&#x27;/axios-server&#x27;, (request, response) =&gt; &#123; //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;*&#x27;); // response.send(&#x27;Hello jQuery AJAX&#x27;); const data = &#123; name: &#x27;尚硅谷&#x27; &#125;; // 只能send字符串数据，不能直接发送data，所以这里使用了JSON.stringfy()方法 response.send(JSON.stringify(data));&#125;);//fetch 服务app.all(&#x27;/fetch-server&#x27;, (request, response) =&gt; &#123; //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;*&#x27;); // response.send(&#x27;Hello jQuery AJAX&#x27;); const data = &#123; name: &#x27;尚硅谷&#x27; &#125;; // 只能send字符串数据，不能直接发送data，所以这里使用了JSON.stringfy()方法 response.send(JSON.stringify(data));&#125;);//jsonp服务app.all(&#x27;/jsonp-server&#x27;, (request, response) =&gt; &#123; // response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;); const data = &#123; name: &#x27;尚硅谷atguigu&#x27; &#125;; //将数据转化为字符串 let str = JSON.stringify(data); //返回结果 response.end(`handle($&#123;str&#125;)`);&#125;);//用户名检测是否存在app.all(&#x27;/check-username&#x27;, (request, response) =&gt; &#123; // response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;); const data = &#123; exist: 1, msg: &#x27;用户名已经存在&#x27; &#125;; //将数据转化为字符串 let str = JSON.stringify(data); //返回结果 response.end(`handle($&#123;str&#125;)`);&#125;);//app.all(&#x27;/jquery-jsonp-server&#x27;, (request, response) =&gt; &#123; // response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;); const data = &#123; name: &#x27;尚硅谷&#x27;, city: [&#x27;北京&#x27;, &#x27;上海&#x27;, &#x27;深圳&#x27;] &#125;; //将数据转化为字符串 let str = JSON.stringify(data); //接收 callback 参数 let cb = request.query.callback; //返回结果 response.end(`$&#123;cb&#125;($&#123;str&#125;)`);&#125;);app.all(&#x27;/cors-server&#x27;, (request, response) =&gt; &#123; //设置响应头 response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &#x27;*&#x27;); response.setHeader(&quot;Access-Control-Allow-Method&quot;, &#x27;*&#x27;); // response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://127.0.0.1:5500&quot;); response.send(&#x27;hello CORS&#x27;);&#125;);//4. 监听端口启动服务app.listen(8000, () =&gt; &#123; console.log(&quot;服务已经启动, 8000 端口监听中....&quot;);&#125;);","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://hasuer.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"Git学习笔记","slug":"Git学习笔记","date":"2021-07-07T12:59:22.000Z","updated":"2022-02-23T12:42:59.056Z","comments":true,"path":"git学习笔记/index.html","link":"","permalink":"https://hasuer.github.io/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html","excerpt":"","text":"Git命令行操作本地库初始化进入文件夹 12git init注意：生成的 .git 目录中存放的是本地库相关文件，不要删除 设置签名这里设置的签名和GitHub中的用户，密码没有关系。 项目(仓库)级别仅在当前本地库有效 12git config user.name tom #设置用户名tomgit config user.email liu@qq.com #设置用户邮箱 系统用户级别仅在当前登录的操作系统用户有效 12git config --global user.name tomgit config --global user.email liu@qq.com 仅仅加了一个 --global 优先级别：项目级别 &gt; 系统级别 项目级别的作用范围更小，类似于局部变量 &gt; 全局变量。二者必须要有其一。 信息保存位置：~/.gitconfig 文件 查看方式：cat .git/config 查看当前用户（global）配置 git config --global --list查看当前仓库配置信息 git config --local --list 基本操作状态查看1git status #查看工作区、暂存区状态 添加1234git add fileName #指定文件git add . #所有说明：将工作区的文件添加到暂存区git rm --cached filename #将暂存区的文件撤销 提交12git commit -m &#x27;commit message&#x27; fileName说明：将暂存区内容提交到本地库 查看历史记录12345git log git reflog #常用，说明：HEAD@&#123;移动到当前版本需要多少步&#125;git log --greph #图形显示,更直观git log --pretty=oneline #漂亮一行显示git log --oneline #简洁显示 前进后退 基于索引值推荐 12git reset --hard 指针位置例子：git reset --hard a6ace91 #回到这个状态 使用 ^ 符号只能后退 1git reset --hard HEAD^例子：git reset --hard HEAD^^注意：几个 ^ 表示后退几步 使用 ~ 符号只能后退 1git reset --hard HEAD~n例子：git reset --hard HEAD~3 reset的三个参数比较123456soft: - 仅本地库移动HEAD 指针mixed： - 在本地库移动HEAD指针 - 重置暂存区hard： - 在本地库移动HEAD指针 - 重置暂存区 - 重置工作区 删除文件并找回 相当于建立一个快照，虽然删除了，但只要添加到暂存区，就能找回 如果文件删除之后已经commit了，那么在log里就有有一条记录，这时，使用git reset --hard 指针位置来还原。 如果删除文件之后只是add,没有commit，那么log中没有新的记录，使用git reset --hard HEAD来刷新工作区。 文件差异比较123git diff 文件名 #工作区文件和暂存区比较git diff 哈希值 文件名 #工作区文件和本地库历史记录比较git diff #不带文件名，则比较多个文件 分支管理什么是分支管理 在版本控制中，使用推进多个任务 分支的好处 同时并行推进多个功能开发，提高开发效率 某一分支开发失败，不会对其它分支有任何影响 分支操作 创建分支 1git branch 分支名 查看分支 12git branchgit branch -v 切换分支 12git checkout 分支名git checkout -b 分支名 #创建分支并直接切换到该分支 合并分支相当于把修改了的文件拉过来 第一步：切换到接收修改的分支名上 git checkout [分支名] 第二步：执行merge命令 git merge [分支名] 删除分支 1git branch -d 分支名 解决冲突 冲突的表现 冲突的解决 第一步：编辑，删除特殊标记&lt;&lt;&lt; === 第二步：修改到满意位置，保存退出 第三步：添加到缓存区 git add 文件名 第四步：提交到本地库git commit -m &#39;日志信息&#39; 注意：后面一定不能带文件名 Git 结合Github创建远程库地址别名1234git remote -v #查看远程地址别名git remote add 别名 远程地址 例子：git remote add origin https://xx 这里的 origin 是别名的意思 推送开发修改完把本地库的文件推送到远程仓库 前提是提交到了本地库才可以推送 123git push 别名 分支名git push -u 别名 分支名 #-u指定默认主机 例子：git push origin master 克隆完整的把远程库克隆到本地`克隆下来后不要在主分支里面做开发 `clone进行一次，从无到有的过程，更新用pull 12git clone 远程地址 例子：git clone https://xx 常见建立仓库方式 建立仓库 —&gt; 打开空文件夹（还没有项目） —&gt; 克隆下来 建立仓库 —&gt; 打开项目文件夹（已经有项目）—&gt; 初始化仓库 —&gt; 设置remote仓库链接 拉取pull = fetch + merge 把远程库中的内容拉取到本地库，但是在本地库没有 被更新，这个时候当前分支（本地库）是看不到变化的，只有进入origin/分支名才能看到变化。这个时候在本地的分支执行merge命令之后才能在本地的分支看到变化。 本地存在clone下来的文件 就用pull更新 1234pull = fetch + merge git fetch [远程地址别名] [分支名] git merge [远程地址别名] [分支名] git pull [远程地址别名] [分支名] 解决冲突注意：解决冲突后的提交是不能带文件名的 如果不是基于GitHub 远程库的最新版所做的修改，不能推送，必须先拉取。 拉取下来后如果进入冲突状态，则按照“分支冲突解决”操作解决即可。 rebase提交记录简洁不分叉 没学懂，感觉有点鸡肋 混眼熟 1git rebase -i 索引号git rebase -i HEAD~3 #合并最近三条记录说明：在vim编辑里面改成s beyond compare用软件解决冲突 11.安装 ： beyond compare 2.配置： git config --local merge.tool bc3 #合并名称 git config --local mergetool.path &#x27;/usr/local/bin/bcomp&#x27; #软件路径 git config --local mergetool.keepBackup false #False不用保存备份3.应用： git mergetool说明：--local指只在当前操作系统有效 跨团队合作代码review之后合并 适用于个人 邀请成员:Settings —&gt; Collaborators —&gt;填写用户名 —&gt;打开链接接受邀请 企业 创建一个组织 方便管理 review 组织做review 通过Pull request 给开源社区共享代码 点击别人仓库的fork 到自己的仓库 — &gt; 然后clone下来 修改后推送到远程库 —&gt; 点击Pull Request请求 —&gt; Create pull request发消息 Tag标签为了清晰的版本管理，公司一般不会直接使用commit提交 1git tag -a v1.0 -m &#x27;版本介绍&#x27; #创建本地tag信息git tag -d v1.0 #删除taggit push origin --tags #将本地tag信息推送到远程库git pull origin --tags #拉取到本地git checkout v.10 #切换taggit clone -b v0.1 地址 #指定tag下载代码 SSH 免密登录 进入当前的家目录 1$ cd ~ 删除.ssh目录 1$ rm -rvf .ssh 运行命令生成SSH密钥目录 123$ ssh-keygen -t rsa -C [Github邮箱]或者 $ ssh-keygen (会让你设置SSH的登录密码，可以不输入，一直Enter) 进入.ssh目录查看文件列表 12$ cd .ssh$ ls -la 查看id_rsa.pub的内容 1$ cat id_rsa.pub 在GitHub上建立SSH Key, 把刚刚生成的ssh密钥填进去。 保证本地库对应的远程库是SSH方式的。 如果没有： 1git add remote origin_ssh[(这是别名) [SSH地址] 然后就可以愉快的push啦~~ 123git push [别名] [分支名]# 这里要注意，如果你在本地库只建立了一个远程地址，# 那么不用使用[别名]和[分支名]。如果有多个才要使用。 Git工作流概念1在项目开发过程中使用Git的方式 分类集中式工作流像SVN一样，集中式工作流有一个中央仓库，所有的修改都提交到了Master分支上 GitFlow工作流 *主干分支master 开发分支develop 修复分支hotfix 预发布分支release 功能分支feature GitFlow 有独立的分支，让发布迭代过程更流畅。 Forking 工作流在 GitFlow 基础上， 充分利用了 Git 的 Fork 和 pull request 的功能以达到代码审核的目的。 安全可靠地管理大团队的开发者","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://hasuer.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[]}],"categories":[{"name":"Grokking Interview Pattern","slug":"Grokking-Interview-Pattern","permalink":"https://hasuer.github.io/categories/Grokking-Interview-Pattern/"},{"name":"技术笔记","slug":"技术笔记","permalink":"https://hasuer.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hasuer.github.io/tags/Interview/"}]}