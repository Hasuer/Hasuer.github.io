{"meta":{"title":"Hasuer's Studio.","subtitle":"","description":"","author":"Hasuer","url":"https://hasuer.github.io","root":"/"},"pages":[{"title":"about","date":"2020-09-30T17:10:37.000Z","updated":"2020-09-30T17:11:32.046Z","comments":true,"path":"about/index.html","permalink":"https://hasuer.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"34. Conclusions","slug":"34. Conclusions","date":"2024-05-28T03:13:20.000Z","updated":"2024-05-28T03:14:08.128Z","comments":true,"path":"34-conclusions/index.html","link":"","permalink":"https://hasuer.github.io/34-conclusions/index.html","excerpt":"","text":"Where to Go from HereFeedbackFor feedback, comments, and suggestions, please contact us at hello@designgurus.org Other coursesHere are a few of other courses prepared by Design Gurus: Grokking Dynamic Programming Patterns for Coding Interviews Grokking the Object Oriented Design Interview","categories":[],"tags":[]},{"title":"24. Pattern Topological Sort (Graph)","slug":"24. Pattern Topological Sort (Graph)","date":"2024-05-03T06:25:49.000Z","updated":"2024-05-28T02:14:20.199Z","comments":true,"path":"24-pattern-topological-sort-graph/index.html","link":"","permalink":"https://hasuer.github.io/24-pattern-topological-sort-graph/index.html","excerpt":"","text":"416. Partition Equal Subset Sum Design Gurus Educative.io IntroductionTopological Sort is used to find a linear ordering of elements that have dependencies on each other. For example, if event ‘B’ is dependent on event ‘A’, ‘A’ comes before ‘B’ in topological ordering. This pattern defines an easy way to understand the technique for performing topological sorting of a set of elements and then solves a few problems using it. Let’s see this pattern in action. *Topological Sort (medium)Design Gurus Educative.io Problem StatementTopological Sort of a directed graph (a graph with unidirectional edges) is a linear ordering of its vertices such that for every directed edge (U, V) from vertex U to vertex V, U comes before V in the ordering. Given a directed graph, find the topological ordering of its vertices. Example 1: 1234Input: Vertices=4, Edges=[3, 2], [3, 0], [2, 0], [2, 1]Output: Following are the two valid topological sorts for the given graph:1) 3, 2, 0, 12) 3, 2, 1, 0 Example 2: 1234567Input: Vertices=5, Edges=[4, 2], [4, 3], [2, 0], [2, 1], [3, 1]Output: Following are all valid topological sorts for the given graph:1) 4, 2, 3, 0, 12) 4, 3, 2, 0, 13) 4, 3, 2, 1, 04) 4, 2, 3, 1, 05) 4, 2, 0, 3, 1 Example 3: 12345678910Input: Vertices=7, Edges=[6, 4], [6, 2], [5, 3], [5, 4], [3, 0], [3, 1], [3, 2], [4, 1]Output: Following are all valid topological sorts for the given graph:1) 5, 6, 3, 4, 0, 1, 22) 6, 5, 3, 4, 0, 1, 23) 5, 6, 4, 3, 0, 2, 14) 6, 5, 4, 3, 0, 1, 25) 5, 6, 3, 4, 0, 2, 16) 5, 6, 3, 4, 1, 2, 0 There are other valid topological ordering of the graph too. SolutionThe basic idea behind the topological sort is to provide a partial ordering among the vertices of the graph such that if there is an edge from U to V then U≤V i.e., U comes before V in the ordering. Here are a few fundamental concepts related to topological sort: Source: Any node that has no incoming edge and has only outgoing edges is called a source. Sink: Any node that has only incoming edges and no outgoing edge is called a sink. So, we can say that a topological ordering starts with one of the sources and ends at one of the sinks. A topological ordering is possible only when the graph has no directed cycles, i.e. if the graph is a Directed Acyclic Graph (DAG). If the graph has a cycle, some vertices will have cyclic dependencies which makes it impossible to find a linear ordering among vertices. To find the topological sort of a graph we can traverse the graph in a Breadth First Search (BFS) way. We will start with all the sources, and in a stepwise fashion, save all sources to a sorted list. We will then remove all sources and their edges from the graph. After the removal of the edges, we will have new sources, so we will repeat the above process until all vertices are visited. Here is the visual representation of this algorithm for Example-3: This is how we can implement this algorithm: a. Initialization We will store the graph in Adjacency Lists, which means each parent vertex will have a list containing all of its children. We will do this using a HashMap where the ‘key’ will be the parent vertex number and the value will be a List containing children vertices. To find the sources, we will keep a HashMap to count the in-degrees i.e., count of incoming edges of each vertex. Any vertex with ‘0’ in-degree will be a source. b. Build the graph and find in-degrees of all vertices We will build the graph from the input and populate the in-degrees HashMap. c. Find all sources All vertices with ‘0’ in-degrees will be our sources and we will store them in a Queue. d. Sort For each source, do the following things: Add it to the sorted list. Get all of its children from the graph. Decrement the in-degree of each child by 1. If a child’s in-degree becomes ‘0’, add it to the sources Queue. Repeat step 1, until the source Queue is empty. CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from collections import dequeclass Solution: def sort(self, vertices, edges): sortedOrder = [] if vertices &lt;= 0: return sortedOrder # a. Initialize the graph inDegree = &#123;i: 0 for i in range(vertices)&#125; # count of incoming edges graph = &#123;i: [] for i in range(vertices)&#125; # adjacency list graph # b. Build the graph for edge in edges: parent, child = edge[0], edge[1] graph[parent].append(child) # put the child into it&#x27;s parent&#x27;s list inDegree[child] += 1 # increment child&#x27;s inDegree # c. Find all sources i.e., all vertices with 0 in-degrees sources = deque() for key in inDegree: if inDegree[key] == 0: sources.append(key) # d. For each source, add it to the sortedOrder and subtract &#x27;1&#x27; from all of its # children&#x27;s in-degrees if a child&#x27;s in-degree becomes zero, add it to sources queue while sources: vertex = sources.popleft() sortedOrder.append(vertex) for child in graph[vertex]: # get the node&#x27;s children to decrement their in-degrees inDegree[child] -= 1 if inDegree[child] == 0: sources.append(child) # topological sort is not possible as the graph has a cycle if len(sortedOrder) != vertices: return [] return sortedOrderdef main(): sol = Solution() print(&quot;Topological sort: &quot; + str(sol.sort(4, [[3, 2], [3, 0], [2, 0], [2, 1]]))) print(&quot;Topological sort: &quot; + str(sol.sort(5, [[4, 2], [4, 3], [2, 0], [2, 1], [3, 1]]))) print(&quot;Topological sort: &quot; + str(sol.sort(7, [[6, 4], [6, 2], [5, 3], [5, 4], \\ [3, 0], [3, 1], [3, 2], [4, 1]])))main() Time ComplexityIn step ‘d’, each vertex will become a source only once and each edge will be accessed and removed once. Therefore, the time complexity of the above algorithm will be O(V+E), where ‘V’ is the total number of vertices and ‘E’ is the total number of edges in the graph. Space ComplexityThe space complexity will be O(V+E), since we are storing all of the edges for each vertex in an adjacency list. Similar ProblemsProblem 1: Find if a given Directed Graph has a cycle in it or not. Solution: If we can’t determine the topological ordering of all the vertices of a directed graph, the graph has a cycle in it. This was also referred to in the above code: 12if (sortedOrder.size() != vertices) // topological sort is not possible as the graph has a cycle return new ArrayList&lt;&gt;(); Tasks Scheduling (medium)Top Interview 150 | 207. Course Schedule Design Gurus Educative.io Problem StatementThere are ‘N’ tasks, labeled from ‘0’ to ‘N-1’. Each task can have some prerequisite tasks which need to be completed before it can be scheduled. Given the number of tasks and a list of prerequisite pairs, find out if it is possible to schedule all the tasks. Example 1: 1234Input: Tasks=3, Prerequisites=[0, 1], [1, 2]Output: trueExplanation: To execute task &#x27;1&#x27;, task &#x27;0&#x27; needs to finish first. Similarly, task &#x27;1&#x27; needs to finish before &#x27;2&#x27; can be scheduled. A possible sceduling of tasks is: [0, 1, 2] Example 2: 123Input: Tasks=3, Prerequisites=[0, 1], [1, 2], [2, 0]Output: falseExplanation: The tasks have cyclic dependency, therefore they cannot be sceduled. Example 3: 123Input: Tasks=6, Prerequisites=[2, 5], [0, 5], [0, 4], [1, 4], [3, 2], [1, 3]Output: trueExplanation: A possible sceduling of tasks is: [0 1 4 3 2 5] SolutionThis problem is asking us to find out if it is possible to find a topological ordering of the given tasks. The tasks are equivalent to the vertices and the prerequisites are the edges. We can use a similar algorithm as described in Topological Sort to find the topological ordering of the tasks. If the ordering does not include all the tasks, we will conclude that some tasks have cyclic dependencies. CodeHere is what our algorithm will look like (only the highlighted lines have changed): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# 和上一题一摸一样from collections import dequeclass Solution: def isSchedulingPossible(self, tasks, prerequisites): sortedOrder = [] if tasks &lt;= 0: return False # a. Initialize the graph inDegree = &#123;i: 0 for i in range(tasks)&#125; # count of incoming edges graph = &#123;i: [] for i in range(tasks)&#125; # adjacency list graph # b. Build the graph for prerequisite in prerequisites: parent, child = prerequisite[0], prerequisite[1] graph[parent].append(child) # put the child into it&#x27;s parent&#x27;s list inDegree[child] += 1 # increment child&#x27;s inDegree # c. Find all sources i.e., all vertices with 0 in-degrees sources = deque() for key in inDegree: if inDegree[key] == 0: sources.append(key) # d. For each source, add it to the sortedOrder and subtract one from all of its # children&#x27;s in-degrees if a child&#x27;s in-degree becomes zero, add it to sources queue while sources: vertex = sources.popleft() sortedOrder.append(vertex) for child in graph[vertex]: # get the node&#x27;s children to decrement their in-degrees inDegree[child] -= 1 if inDegree[child] == 0: sources.append(child) # if sortedOrder doesn&#x27;t contain all tasks, there is a cyclic dependency between # tasks, therefore, we will not be able to schedule all tasks return len(sortedOrder) == tasksdef main(): sol = Solution() print(&quot;Is scheduling possible: &quot; + str(sol.isSchedulingPossible(3, [[0, 1], [1, 2]]))) print(&quot;Is scheduling possible: &quot; + str(sol.isSchedulingPossible(3, [[0, 1], [1, 2], [2, 0]]))) print(&quot;Is scheduling possible: &quot; + str(sol.isSchedulingPossible(6, [[2, 5], [0, 5], [0, 4], [1, 4], [3, 2], [1, 3]])))main() Time complexityIn step ‘d’, each task can become a source only once and each edge (prerequisite) will be accessed and removed once. Therefore, the time complexity of the above algorithm will be O(V+E), where ‘V’ is the total number of tasks and ‘E’ is the total number of prerequisites. Space complexityThe space complexity will be O(V+E), since we are storing all of the prerequisites for each task in an adjacency list. Similar ProblemsCourse Schedule: There are ‘N’ courses, labeled from ‘0’ to ‘N-1’. Each course can have some prerequisite courses which need to be completed before it can be taken. Given the number of courses and a list of prerequisite pairs, find if it is possible for a student to take all the courses. Solution: This problem is exactly similar to our parent problem. In this problem, we have courses instead of tasks. Tasks Scheduling Order (medium)Top Interview 150 | 210. Course Schedule II Design Gurus Educative.io Problem StatementThere are ‘N’ tasks, labeled from ‘0’ to ‘N-1’. Each task can have some prerequisite tasks which need to be completed before it can be scheduled. Given the number of tasks and a list of prerequisite pairs, write a method to find the ordering of tasks we should pick to finish all tasks. Example 1: 1234Input: Tasks=3, Prerequisites=[0, 1], [1, 2]Output: [0, 1, 2]Explanation: To execute task &#x27;1&#x27;, task &#x27;0&#x27; needs to finish first. Similarly, task &#x27;1&#x27; needs to finish before &#x27;2&#x27; can be scheduled. A possible scheduling of tasks is: [0, 1, 2] Example 2: 123Input: Tasks=3, Prerequisites=[0, 1], [1, 2], [2, 0]Output: []Explanation: The tasks have cyclic dependency, therefore they cannot be scheduled. Example 3: 123Input: Tasks=6, Prerequisites=[2, 5], [0, 5], [0, 4], [1, 4], [3, 2], [1, 3]Output: [0 1 4 3 2 5] Explanation: A possible scheduling of tasks is: [0 1 4 3 2 5] SolutionThis problem is similar to Tasks Scheduling, the only difference being that we need to find the best ordering of tasks so that it is possible to schedule them all. CodeHere is what our algorithm will look like (only the highlighted lines have changed): 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from collections import dequeclass Solution: def findOrder(self, tasks, prerequisites): sortedOrder = [] if tasks &lt;= 0: return sortedOrder # a. Initialize the graph inDegree = &#123;i: 0 for i in range(tasks)&#125; # count of incoming edges graph = &#123;i: [] for i in range(tasks)&#125; # adjacency list graph # b. Build the graph for prerequisite in prerequisites: parent, child = prerequisite[0], prerequisite[1] graph[parent].append(child) # put the child into it&#x27;s parent&#x27;s list inDegree[child] += 1 # increment child&#x27;s inDegree # c. Find all sources i.e., all vertices with 0 in-degrees sources = deque() for key in inDegree: if inDegree[key] == 0: sources.append(key) # d. For each source, add it to the sortedOrder and subtract one from all of its # children&#x27;s in-degrees if a child&#x27;s in-degree becomes zero, add it to sources queue while sources: vertex = sources.popleft() sortedOrder.append(vertex) for child in graph[vertex]: # get the node&#x27;s children to decrement their in-degrees inDegree[child] -= 1 if inDegree[child] == 0: sources.append(child) # if sortedOrder doesn&#x27;t contain all tasks, there is a cyclic dependency between # tasks, therefore, we will not be able to schedule all tasks if len(sortedOrder) != tasks: return [] return sortedOrderdef main(): sol = Solution() print(&quot;Is scheduling possible: &quot; + str(sol.findOrder(3, [[0, 1], [1, 2]]))) print(&quot;Is scheduling possible: &quot; + str(sol.findOrder(3, [[0, 1], [1, 2], [2, 0]]))) print(&quot;Is scheduling possible: &quot; + str(sol.findOrder(6, [[2, 5], [0, 5], [0, 4], [1, 4], [3, 2], [1, 3]])))main() Time complexityIn step ‘d’, each task can become a source only once and each edge (prerequisite) will be accessed and removed once. Therefore, the time complexity of the above algorithm will be O(V+E), where ‘V’ is the total number of tasks and ‘E’ is the total number of prerequisites. Space complexityThe space complexity will be O(V+E), since we are storing all of the prerequisites for each task in an adjacency list. Similar ProblemsCourse Schedule: There are ‘N’ courses, labeled from ‘0’ to ‘N-1’. Each course has some prerequisite courses which need to be completed before it can be taken. Given the number of courses and a list of prerequisite pairs, write a method to find the best ordering of the courses that a student can take in order to finish all courses. Solution: This problem is exactly similar to our parent problem. In this problem, we have courses instead of tasks. *All Tasks Scheduling Orders (hard)Design Gurus Educative.io Problem StatementThere are ‘N’ tasks, labeled from ‘0’ to ‘N-1’. Each task can have some prerequisite tasks which need to be completed before it can be scheduled. Given the number of tasks and a list of prerequisite pairs, write a method to print all possible ordering of tasks meeting all prerequisites. Example 1: 123Input: Tasks=3, Prerequisites=[0, 1], [1, 2]Output: [0, 1, 2]Explanation: There is only possible ordering of the tasks. Example 2: 12345Input: Tasks=4, Prerequisites=[3, 2], [3, 0], [2, 0], [2, 1]Output: 1) [3, 2, 0, 1]2) [3, 2, 1, 0]Explanation: There are two possible orderings of the tasks meeting all prerequisites. Example 3: 123456789101112131415Input: Tasks=6, Prerequisites=[2, 5], [0, 5], [0, 4], [1, 4], [3, 2], [1, 3]Output: 1) [0, 1, 4, 3, 2, 5]2) [0, 1, 3, 4, 2, 5]3) [0, 1, 3, 2, 4, 5]4) [0, 1, 3, 2, 5, 4]5) [1, 0, 3, 4, 2, 5]6) [1, 0, 3, 2, 4, 5]7) [1, 0, 3, 2, 5, 4]8) [1, 0, 4, 3, 2, 5]9) [1, 3, 0, 2, 4, 5]10) [1, 3, 0, 2, 5, 4]11) [1, 3, 0, 4, 2, 5]12) [1, 3, 2, 0, 5, 4]13) [1, 3, 2, 0, 4, 5] SolutionThis problem is similar to Tasks Scheduling Order the only difference is that we need to find all the topological orderings of the tasks. At any stage, if we have more than one source available and since we can choose any source, therefore, in this case, we will have multiple orderings of the tasks. We can use a recursive approach with Backtracking to consider all sources at any step. CodeHere is what our algorithm will look like: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283from collections import dequeclass Solution: def __init__(self): self.orders = [] def printOrders(self, tasks, prerequisites): sortedOrder = [] if tasks &lt;= 0: return self.orders # a. Initialize the graph inDegree = &#123;i: 0 for i in range(tasks)&#125; # count of incoming edges graph = &#123;i: [] for i in range(tasks)&#125; # adjacency list graph # b. Build the graph for prerequisite in prerequisites: parent, child = prerequisite[0], prerequisite[1] graph[parent].append(child) # put the child into it&#x27;s parent&#x27;s list inDegree[child] += 1 # increment child&#x27;s inDegree # c. Find all sources i.e., all vertices with 0 in-degrees sources = deque() for key in inDegree: if inDegree[key] == 0: sources.append(key) self.print_all_topological_sorts(graph, inDegree, sources, sortedOrder) return self.orders def print_all_topological_sorts(self, graph, inDegree, sources, sortedOrder): if sources: for vertex in sources: sortedOrder.append(vertex) sourcesForNextCall = deque(sources) # make a copy of sources # only remove the current source, all other sources should remain in the queue for # the next call sourcesForNextCall.remove(vertex) # get the node&#x27;s children to decrement their in-degrees for child in graph[vertex]: inDegree[child] -= 1 if inDegree[child] == 0: sourcesForNextCall.append(child) # recursive call to print other orderings from the remaining (and new) sources self.print_all_topological_sorts( graph, inDegree, sourcesForNextCall, sortedOrder) # backtrack, remove the vertex from the sorted order and put all of its children # back to consider the next source instead of the current vertex sortedOrder.remove(vertex) for child in graph[vertex]: inDegree[child] += 1 # if sortedOrder doesn&#x27;t contain all tasks, either we&#x27;ve a cyclic dependency between # tasks, or we have not processed all the tasks in this recursive call if len(sortedOrder) == len(inDegree): self.orders.append(sortedOrder.copy())def main(): sol = Solution() print(&quot;Task Orders: &quot;) result1 = sol.printOrders(3, [[0, 1], [1, 2]]) for order in result1: print(order) print(&quot;Task Orders: &quot;) result2 = sol.printOrders(4, [[3, 2], [3, 0], [2, 0], [2, 1]]) for order in result2: print(order) print(&quot;Task Orders: &quot;) result3 = sol.printOrders(6, [[2, 5], [0, 5], [0, 4], [1, 4], [3, 2], [1, 3]]) for order in result3: print(order)if __name__ == &quot;__main__&quot;: main() Time and Space ComplexityIf we don’t have any prerequisites, all combinations of the tasks can represent a topological ordering. As we know, that there can be N!N! combinations for ‘N’ numbers, therefore the time and space complexity of our algorithm will be O(V! E)* where ‘V’ is the total number of tasks and ‘E’ is the total prerequisites. We need the ‘E’ part because in each recursive call, at max, we remove (and add back) all the edges. *Alien Dictionary (hard)没咋看懂题目：应该是对于给定的单词列表，相邻的单词对比，找出第一个不同的字符，这个字符的顺序将定义一条有向边。Leetcode 269 会员 Design Gurus Educative.io Problem StatementThere is a dictionary containing words from an alien language for which we don’t know the ordering of the letters. Write a method to find the correct order of the letters in the alien language. It is given that the input is a valid dictionary and there exists an ordering among its letters. Example 1: 123456789Input: Words: [&quot;ba&quot;, &quot;bc&quot;, &quot;ac&quot;, &quot;cab&quot;]Output: bacExplanation: Given that the words are sorted lexicographically by the rules of the alien language, sofrom the given words we can conclude the following ordering among its characters: 1. From &quot;ba&quot; and &quot;bc&quot;, we can conclude that &#x27;a&#x27; comes before &#x27;c&#x27;.2. From &quot;bc&quot; and &quot;ac&quot;, we can conclude that &#x27;b&#x27; comes before &#x27;a&#x27; From the above two points, we can conclude that the correct character order is: &quot;bac&quot; Example 2: 12345678Input: Words: [&quot;cab&quot;, &quot;aaa&quot;, &quot;aab&quot;]Output: cabExplanation: From the given words we can conclude the following ordering among its characters: 1. From &quot;cab&quot; and &quot;aaa&quot;, we can conclude that &#x27;c&#x27; comes before &#x27;a&#x27;.2. From &quot;aaa&quot; and &quot;aab&quot;, we can conclude that &#x27;a&#x27; comes before &#x27;b&#x27; From the above two points, we can conclude that the correct character order is: &quot;cab&quot; Example 3: 1234567891011Input: Words: [&quot;ywx&quot;, &quot;wz&quot;, &quot;xww&quot;, &quot;xz&quot;, &quot;zyy&quot;, &quot;zwz&quot;]Output: ywxzExplanation: From the given words we can conclude the following ordering among its characters: 1. From &quot;ywx&quot; and &quot;wz&quot;, we can conclude that &#x27;y&#x27; comes before &#x27;w&#x27;.2. From &quot;wz&quot; and &quot;xww&quot;, we can conclude that &#x27;w&#x27; comes before &#x27;x&#x27;.3. From &quot;xww&quot; and &quot;xz&quot;, we can conclude that &#x27;w&#x27; comes before &#x27;z&#x27;4. From &quot;xz&quot; and &quot;zyy&quot;, we can conclude that &#x27;x&#x27; comes before &#x27;z&#x27;5. From &quot;zyy&quot; and &quot;zwz&quot;, we can conclude that &#x27;y&#x27; comes before &#x27;w&#x27; From the above five points, we can conclude that the correct character order is: &quot;ywxz&quot; Constraints: 1 &lt;= words.length &lt;= 100 1 &lt;= words[i].length &lt;= 100 words[i] consists of only lowercase English letters. SolutionSince the given words are sorted lexicographically by the rules of the alien language, we can always compare two adjacent words to determine the ordering of the characters. Take Example-1 above: [“ba”, “bc”, “ac”, “cab”] Take the first two words “ba” and “bc”. Starting from the beginning of the words, find the first character that is different in both words: it would be ‘a’ from “ba” and ‘c’ from “bc”. Because of the sorted order of words (i.e. the dictionary!), we can conclude that ‘a’ comes before ‘c’ in the alien language. Similarly, from “bc” and “ac”, we can conclude that ‘b’ comes before ‘a’. These two points tell us that we are actually asked to find the topological ordering of the characters, and that the ordering rules should be inferred from adjacent words from the alien dictionary. This makes the current problem similar to Tasks Scheduling Order, the only difference being that we need to build the graph of the characters by comparing adjacent words first, and then perform the topological sort for the graph to determine the order of the characters. CodeHere is what our algorithm will look like (only the highlighted lines have changed): 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# 但是有一点不太懂就是为什么。只要选取相邻的两个就可以建立邻接表from collections import dequeclass Solution: def findOrder(self, words): if len(words) == 0: return &quot;&quot; # a. Initialize the graph inDegree = &#123;&#125; # count of incoming edges graph = &#123;&#125; # adjacency list graph for word in words: for character in word: inDegree[character] = 0 graph[character] = [] # b. Build the graph for i in range(0, len(words)-1): # find ordering of characters from adjacent words w1, w2 = words[i], words[i + 1] for j in range(0, min(len(w1), len(w2))): parent, child = w1[j], w2[j] if parent != child: # if the two characters are different # put the child into it&#x27;s parent&#x27;s list graph[parent].append(child) inDegree[child] += 1 # increment child&#x27;s inDegree break # only the first different character between the two words will help us # find the order # c. Find all sources i.e., all vertices with 0 in-degrees sources = deque() for key in inDegree: if inDegree[key] == 0: sources.append(key) # d. For each source, add it to the sortedOrder and subtract one from all of its # children&#x27;s in-degrees if a child&#x27;s in-degree becomes zero, add it to sources queue sortedOrder = [] while sources: vertex = sources.popleft() sortedOrder.append(vertex) for child in graph[vertex]: # get the node&#x27;s children to decrement their in-degrees inDegree[child] -= 1 if inDegree[child] == 0: sources.append(child) # if sortedOrder doesn&#x27;t contain all characters, there is a cyclic dependency between # characters, therefore, we&#x27;ll not be able to find the correct ordering of characters if len(sortedOrder) != len(inDegree): return &quot;&quot; return &#x27;&#x27;.join(sortedOrder)def main(): sol = Solution() print(&quot;Character order: &quot; + sol.findOrder([&quot;ba&quot;, &quot;bc&quot;, &quot;ac&quot;, &quot;cab&quot;])) print(&quot;Character order: &quot; + sol.findOrder([&quot;cab&quot;, &quot;aaa&quot;, &quot;aab&quot;])) print(&quot;Character order: &quot; + sol.findOrder([&quot;ywx&quot;, &quot;wz&quot;, &quot;xww&quot;, &quot;xz&quot;, &quot;zyy&quot;, &quot;zwz&quot;]))main() Time complexityIn step ‘d’, each task can become a source only once and each edge (a rule) will be accessed and removed once. Therefore, the time complexity of the above algorithm will be O(V+E), where ‘V’ is the total number of different characters and ‘E’ is the total number of the rules in the alien language. Since, at most, each pair of words can give us one rule, therefore, we can conclude that the upper bound for the rules is O(N) where ‘N’ is the number of words in the input. So, we can say that the time complexity of our algorithm is O(V+N). Space complexityThe space complexity will be O(V+N), since we are storing all of the rules for each character in an adjacency list. *Problem Challenge 1Leetcode 444 会员 Design Gurus Educative.io Reconstructing a Sequence (hard)Given a sequence originalSeq and an array of sequences, write a method to find if originalSeq can be uniquely reconstructed from the array of sequences. Unique reconstruction means that we need to find if originalSeq is the only sequence such that all sequences in the array are subsequences of it. Example 1: 12345Input: originalSeq: [1, 2, 3, 4], seqs: [[1, 2], [2, 3], [3, 4]]Output: trueExplanation: The sequences [1, 2], [2, 3], and [3, 4] can uniquely reconstruct [1, 2, 3, 4], in other words, all the given sequences uniquely define the order of numbers in the &#x27;originalSeq&#x27;. Example 2: 123456Input: originalSeq: [1, 2, 3, 4], seqs: [[1, 2], [2, 3], [2, 4]]Output: falseExplanation: The sequences [1, 2], [2, 3], and [2, 4] cannot uniquely reconstruct [1, 2, 3, 4]. There are two possible sequences we can construct from the given sequences:1) [1, 2, 3, 4]2) [1, 2, 4, 3] Example 3: 1234Input: originalSeq: [3, 1, 4, 2, 5], seqs: [[3, 1, 5], [1, 4, 2, 5]]Output: trueExplanation: The sequences [3, 1, 5] and [1, 4, 2, 5] can uniquely reconstruct [3, 1, 4, 2, 5]. Constraints: n == originalSeq.length 1 &lt;= n &lt;= 10^4 originalSeq is a permutation of all the integers in the range [1, n]. 1 &lt;= seqs.length &lt;= 10^4 1 &lt;= seqs[i].length &lt;= 10^4 `1 &lt;= sum(seqs[i].length) &lt;= 10^5 1 &lt;= seqs[i][j] &lt;= n All the arrays of sequences are unique. seqs[i] is a subsequence of nums. Try it yourselfTry solving this question here: 12# 我的想法：什么时候sources中的元素超过了1一个，那就是有有问题的，输出false# 漏了一种情况，就是可以构建出唯一的序列，但是和给的origin_seq不一样 SolutionSince each sequence in the given array defines the ordering of some numbers, we need to combine all these ordering rules to find two things: Is it possible to construct the originalSeq from all these rules? Are these ordering rules not sufficient enough to define the unique ordering of all the numbers in the originalSeq? In other words, can these rules result in more than one sequence? Take Example-1: 1originalSeq: [1, 2, 3, 4], seqs:[[1, 2], [2, 3], [3, 4]] The first sequence tells us that ‘1’ comes before ‘2’; the second sequence tells us that ‘2’ comes before ‘3’; the third sequence tells us that ‘3’ comes before ‘4’. Combining all these sequences will result in a unique sequence: [1, 2, 3, 4]. The above explanation tells us that we are actually asked to find the topological ordering of all the numbers and also to verify that there is only one topological ordering of the numbers possible from the given array of the sequences. This makes the current problem similar to Tasks Scheduling Order with two differences: We need to build the graph of the numbers by comparing each pair of numbers in the given array of sequences. We must perform the topological sort for the graph to determine two things: Can the topological ordering construct the originalSeq? That there is only one topological ordering of the numbers possible. This can be confirmed if we do not have more than one source at any time while finding the topological ordering of numbers. CodeHere is what our algorithm will look like (only the highlighted lines have changed): 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# 我的想法是：什么时候sources中的元素超过了1一个，那就是有有问题的，输出false# 漏了一种情况，就是可以构建出唯一的序列，但是和给的origin_seq不一样# 以下是官方solutionfrom collections import dequeclass Solution: def canConstruct(self, originalSeq, sequences): sortedOrder = [] if len(originalSeq) &lt;= 0: return False # a. Initialize the graph inDegree = &#123;&#125; # count of incoming edges graph = &#123;&#125; # adjacency list graph for sequence in sequences: for num in sequence: inDegree[num] = 0 graph[num] = [] # b. Build the graph for sequence in sequences: for i in range(1, len(sequence)): parent, child = sequence[i - 1], sequence[i] graph[parent].append(child) inDegree[child] += 1 # if we don&#x27;t have ordering rules for all the numbers we&#x27;ll not able to uniquely # construct the sequence if len(inDegree) != len(originalSeq): return False # c. Find all sources i.e., all vertices with 0 in-degrees sources = deque() for key in inDegree: if inDegree[key] == 0: sources.append(key) # d. For each source, add it to the sortedOrder and subtract one from all of its # children&#x27;s in-degrees if a child&#x27;s in-degree becomes zero, add it to sources queue while sources: if len(sources) &gt; 1: return False # more than one sources mean, there is more than one way to # reconstruct the sequence if originalSeq[len(sortedOrder)] != sources[0]: return False # the next source(or number) is different from the original sequence vertex = sources.popleft() sortedOrder.append(vertex) for child in graph[vertex]: # get the node&#x27;s children to decrement their in-degrees inDegree[child] -= 1 if inDegree[child] == 0: sources.append(child) # if sortedOrder&#x27;s size is not equal to original sequence&#x27;s size, there is no unique # way to construct return len(sortedOrder) == len(originalSeq)def main(): sol = Solution() print(&quot;Can construct: &quot; + str(sol.canConstruct([1, 2, 3, 4], [[1, 2], [2, 3], [3, 4]]))) print(&quot;Can construct: &quot; + str(sol.canConstruct([1, 2, 3, 4], [[1, 2], [2, 3], [2, 4]]))) print(&quot;Can construct: &quot; + str(sol.canConstruct([3, 1, 4, 2, 5], [[3, 1, 5], [1, 4, 2, 5]])))main() Time complexityIn step ‘d’, each number can become a source only once and each edge (a rule) will be accessed and removed once. Therefore, the time complexity of the above algorithm will be O(V+E), where ‘V’ is the count of distinct numbers and ‘E’ is the total number of the rules. Since, at most, each pair of numbers can give us one rule, we can conclude that the upper bound for the rules is O(N) where ‘N’ is the count of numbers in all sequences. So, we can say that the time complexity of our algorithm is O(V+N). Space complexityThe space complexity will be O(V+N), since we are storing all of the rules for each number in an adjacency list. *Problem Challenge 2310. Minimum Height Trees Design Gurus Educative.io Minimum Height Trees (hard)We are given an undirected graph that has characteristics of a k-ary tree. In such a graph, we can choose any node as the root to make a k-ary tree. The root (or the tree) with the minimum height will be called Minimum Height Tree (MHT). There can be multiple MHTs for a graph. In this problem, we need to find all those roots which give us MHTs. Write a method to find all MHTs of the given graph and return a list of their roots. Example 1: 1234Input: vertices: 5, Edges: [[0, 1], [1, 2], [1, 3], [2, 4]]Output:[1, 2]Explanation: Choosing &#x27;1&#x27; or &#x27;2&#x27; as roots give us MHTs. In the below diagram, we can see that the height of the trees with roots &#x27;1&#x27; or &#x27;2&#x27; is three which is minimum. Example 2: 1234Input: vertices: 4, Edges: [[0, 1], [0, 2], [2, 3]]Output:[0, 2]Explanation: Choosing &#x27;0&#x27; or &#x27;2&#x27; as roots give us MHTs. In the below diagram, we can see that the height of the trees with roots &#x27;0&#x27; or &#x27;2&#x27; is three which is minimum. Example 3: 12Input: vertices: 4, Edges: [[0, 1], [1, 2], [1, 3]]Output:[1] Constraints: 1 &lt;= vertices &lt;= 2 * 10^4 edges.length == n - 1 0 &lt;= ai, bi &lt; n ai != bi All the pairs (ai, bi) are distinct. The given input is guaranteed to be a tree and there will be no repeated edges. SolutionThe key intuition behind solving this problem is based on the definition of a tree’s height: the height of a tree is the number of edges on the longest path between the root and any leaf. So, an MHT is a tree that minimizes this longest path. Imagine we have a longest path P in the tree. The path P has two ends; let’s call them end A and end B. Now, let’s consider what the root of an MHT can be: If we select a root that is not on the path P, the height of the tree would at least be the length of P, because there would be a path from the root to either A or B that is longer than P (as it includes P plus some additional edges). Therefore, the root of the MHT must be on P. If the root is on P, but not in the middle of P, then the height of the tree will be larger than if we selected the root in the middle of P, because the longest path will be from the root to either end of P. Therefore, the root of the MHT must be in the middle of P. So, the problem of finding the MHT root(s) reduces to finding the middle node(s) of the longest path in the tree. We can find the middle node(s) of the longest path by using an algorithm called ‘leaf pruining’. Let’s look into this. From the above discussion, we can deduce that the leaves can’t give us MHT, hence, we can remove them from the graph and remove their edges too. Once we remove the leaves, we will have new leaves. Since these new leaves can’t give us MHT, we will repeat the process and remove them from the graph too. We will prune the leaves until we are left with one or two nodes which will be our answer and the roots for MHTs. The algorithm works because when you trim leaves, you’re essentially trimming the ends of all the longest paths in the tree. If there’s one longest path, you’re trimming it from both ends, and if there are multiple longest paths, you’re trimming them all. Eventually, you’re left with one or two nodes, which must be the middle of the longest path(s), and those are the roots of the MHTs. We can implement the above process using the topological sort. Any node with only one edge (i.e., a leaf) can be our source and, in a stepwise fashion, we can remove all sources from the graph to find new sources. We will repeat this process until we are left with one or two nodes in the graph, which will be our answer. This Java algorithm is used to find the root nodes of the Minimum Height Trees (MHTs) in a graph. An MHT is a tree rooted at a specific node that minimizes the tree’s height. In a graph with ‘n’ nodes, there can be one or two MHTs. Here’s a breakdown of the algorithm: It starts by checking if the number of nodes is less than or equal to 0, returning an empty list if true, as there would be no trees in the graph. If the graph contains only one node, it returns that single node as an MHT. Next, it initializes two HashMaps, inDegree to store the count of incoming edges for every vertex and graph as an adjacency list representation of the graph. It populates these HashMaps with initial values. The algorithm then constructs the graph. As it’s an undirected graph, each edge connects two nodes bi-directionally, meaning it adds a link for both nodes and increments the in-degrees of the two nodes. The algorithm finds all leaf nodes (nodes with only one in-degree) and adds them to a queue. Next, it iteratively removes the leaf nodes level by level, subtracting one from the in-degree of each leaf node’s children. If a child node becomes a leaf node as a result, it is added to the queue of leaf nodes. This process repeats until the graph has been reduced to one or two nodes, which represent the roots of the MHTs. Finally, the algorithm adds the remaining nodes in the leaves queue to minHeightTrees and returns this list. These nodes are the roots of the MHTs in the graph. CodeHere is what our algorithm will look like: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from collections import dequeclass Solution: def findTrees(self, nodes, edges): if nodes &lt;= 0: return [] # with only one node, since its in-degrees will be 0, therefore, we need to handle it # separately if nodes == 1: return [0] # a. Initialize the graph inDegree = &#123;i: 0 for i in range(nodes)&#125; # count of incoming edges graph = &#123;i: [] for i in range(nodes)&#125; # adjacency list graph # b. Build the graph for edge in edges: n1, n2 = edge[0], edge[1] # since this is an undirected graph, therefore, add a link for both the nodes graph[n1].append(n2) graph[n2].append(n1) # increment the in-degrees of both the nodes inDegree[n1] += 1 inDegree[n2] += 1 # c. Find all leaves i.e., all nodes with 1 in-degrees leaves = deque() for key in inDegree: if inDegree[key] == 1: leaves.append(key) # d. Remove leaves level by level and subtract each leave&#x27;s children&#x27;s in-degrees. # Repeat this until we are left with 1 or 2 nodes, which will be our answer. # Any node that has already been a leaf cannot be the root of a minimum height tree, # because its adjacent non-leaf node will always be a better candidate. totalNodes = nodes while totalNodes &gt; 2: leavesSize = len(leaves) totalNodes -= leavesSize for i in range(0, leavesSize): vertex = leaves.popleft() # get the node&#x27;s children to decrement their in-degrees for child in graph[vertex]: inDegree[child] -= 1 if inDegree[child] == 1: leaves.append(child) return list(leaves)def main(): sol = Solution() print(&quot;Roots of MHTs: &quot; + str(sol.findTrees(5, [[0, 1], [1, 2], [1, 3], [2, 4]]))) print(&quot;Roots of MHTs: &quot; + str(sol.findTrees(4, [[0, 1], [0, 2], [2, 3]]))) print(&quot;Roots of MHTs: &quot; + str(sol.findTrees(4, [[1, 2], [1, 3]])))main() Time complexityIn step ‘d’, each node can become a source only once and each edge will be accessed and removed once. Therefore, the time complexity of the above algorithm will be O(V+E), where ‘V’ is the total nodes and ‘E’ is the total number of the edges. Space complexityThe space complexity will be O(V+E), since we are storing all of the edges for each node in an adjacency list.","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://hasuer.github.io/categories/Algorithm/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hasuer.github.io/tags/Interview/"}]},{"title":"0.Introduction","slug":"0. Introduction","date":"2024-04-30T01:39:45.000Z","updated":"2024-04-30T01:41:37.199Z","comments":true,"path":"0-introduction/index.html","link":"","permalink":"https://hasuer.github.io/0-introduction/index.html","excerpt":"","text":"IntroductionWho should take this course?Thanks for choosing this course! We hope the techniques you learn here go a long way towards building solid algorithmic skills. Intended AudienceIf you want to work on your algorithms and problem-solving skills, this course is for you. Systematically, we will start with easier problems to develop an understanding of the underlying solution patterns and then apply these patterns to solve difficult ones. Every problem presented in this course has been solved in Java, Python, C++, and JavaScript. PrerequisitesYou need to have a basic understanding of common data-structures like Array, LinkedList, HashMap, Stack, Queue, Heap, and Graph. You should also be familiar with Recursion) and Big-O. Course OverviewThis course categorizes coding interview problems into a set of 16 patterns. Each pattern will be a complete tool - consisting of data structures, algorithms, and analysis techniques - to solve a specific category of problems. The goal is to develop an understanding of the underlying pattern, so that, we can apply that pattern to solve other problems. We have chosen each problem carefully such that it not only maps to the same pattern but also presents different constraints. Overall, the course has around 150 problems mapped to 16 patterns. The problems solved under these patterns use a varied set of algorithmic techniques. We will make use of Breadth-First Search and Depth-First Search to solve problems related to Trees and Graphs. Similarly, we will also cover Dynamic Programming, Backtracking, Recursion, Greedy algorithms, and Divide &amp; Conquer. We will start with a brief introduction of each pattern before jumping onto the problems. Under each pattern, the first problem will explain the underlying pattern in detail to build the concepts that can be applied to later problems. The later problems will focus on the different constraints each problem presents and how our algorithm needs to change to handle them. Let’s start with the Sliding Window pattern.","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://hasuer.github.io/categories/Algorithm/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hasuer.github.io/tags/Interview/"}]},{"title":"Ubuntu20.04安装配置MySQL8(详细)","slug":"Ubuntu20-04安装配置MySQL8","date":"2022-06-12T15:01:42.000Z","updated":"2022-06-12T17:59:52.398Z","comments":true,"path":"ubuntu20-04安装配置mysql8-详细/index.html","link":"","permalink":"https://hasuer.github.io/ubuntu20-04%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEmysql8-%E8%AF%A6%E7%BB%86/index.html","excerpt":"","text":"文章的第一节转载自原文连接 本文实现了服务器ubuntu18.04和虚拟机ubuntu20.04两个版本的MySQL8 的安装，和navicat的连接。其中ubuntu18.04对应第二节，ubuntu20.04是ubuntu focal的，对应第三节。 1. 彻底删除mysql5.71.1 查看mysql的依赖项1dpkg --list|grep mysql 1.2 卸载1sudo apt-get remove mysql-common 在卸载过程中输入yes 1.3 卸载（最后的版本数字根据自己具体的版本进行相应的修改）1sudo apt-get autoremove --purge mysql-server-5.7 1.4 清除残留数据1dpkg -l|grep ^rc|awk &#x27;&#123;print$2&#125;&#x27;|sudo xargs dpkg -P 出现下图界面，选择&lt;YES&gt; 1.5 再次查看依赖1dpkg --list|grep mysql 发现有如下残留 使用命令sudo apt-get autoremove --purge xxxx来卸载： 1sudo apt-get autoremove --purge php5.6-mysql 执行之后再次使用命令查看： 1dpkg --list|grep mysql 输入命令之后没有任何返回即成功，这里输入了两次： 2. 服务器（ubuntu18.04）安装MySQL82.1 使用命令下载存储库软件包1wget -c https://dev.mysql.com/get/mysql-apt-config_0.8.10-1_all.deb 2.2 使用命令安装上边下载的安装包1sudo dpkg -i mysql-apt-config_0.8.10-1_all.deb 安装过程中提示选择安装版本，默认安装的就是8.0版本，所以直接选择“OK”确认即可； 2.3 从所有已配置的存储库（包括新添加的 MySQL 8存储库）中下载最新的软件包信息：1sudo apt update 可能的报错： 解决： 查看签名列表： 1apt-key list 删除过期的签名；（del 后跟上条指令查到的pub） 1sudo apt-key del dsa1024 重新添加新的签名 GPG error: http://repo.mysql.com/apt/ubuntu focal InRelease: The following signatures couldn’t be verified because the public key is not available: NO_PUBKEY 467B942D3A79BD29 1sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 467B942D3A79BD29 之后继续执行更新命令: 1sudo apt update 2.4 安装MySQL81sudo apt install mysql-server 安装过程中会提示设置root密码。按照提示输入即可； 输入之后会出现选择加密方式的提示界面，我在网上的教程中看到默认的mysql8.0的加密方式与ubuntu18.04 及以上不兼容，所以选择5.x的加密方式；建议选择下边的那个： 2.5 验证1mysql -uroot -p [图片] 3. 在Ubuntu 20.04 LTS Focal Fossa上安装MySQL8在上一节中，执行命令sudo dpkg -i mysql-apt-config_0.8.10-1_all.deb的时候提示这是ubuntu focal系统，这里根据教程来安装。 Step 1: Update the system to the latest1sudo apt update Step 2: Install MySQL on Ubuntu 20.041sudo apt install mysql-server Step 3: Secure MySQL installation\\1sudo mysql_secure_installation 可能的问题： 设置完密码之后按照要求”Do you wish to continue with the password provided?”输入yes报错如下： [MySQL Failed! Error: SET PASSWORD has no significance for user ‘root’@’localhost’ as the authentication method used doesn’t store authentication data in the MySQL server. Please consider using ALTER USER](https://www.nixcraft.com/t/mysql-failed-error-set-password-has-no-significance-for-user-root-localhost-as-the-authentication-method-used-doesnt-store-authentication-data-in-the-mysql-server-please-consider-using-alter-user/4233) 解决： Open the terminal application. Terminate the mysql_secure_installation from another terminal using the killall command:sudo killall -9 mysql_secure_installation Start the mysql client:sudo mysql Run the following SQL query: 12ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;SetRootPasswordHere&#x27;;exit Then run the following command to secure it:sudo mysql_secure_installation When promoted for the password enter the SetRootPasswordHere (or whatever you set when you ran the above SQL query) That is all. 成功界面如下： Step 4: Test MySQL Community Server service1systemctl status mysql.service 1mysql -uroot -p 4. navicat 连接4.1 连接报错1103[图片] 原因:帐号不允许从远程登陆，只能在localhost。这个时候只要在localhost的那台电脑，登入mysql后，更改”mysql” 数据库里的 “user” 表里的 “host”项，从”localhost”改称”%” 在虚拟机/服务器上进入mysql: use mysql; select host, user from user; update user set host = &#39;%&#39; where user = &#39;root&#39;; flush privileges; service mysql restart 4.2 连接报错2003 在windows下，cmd 输入 1telnet 192.168.xxx.xxx 3306 在虚拟机下输入 1netstat -anp| grep 3306 修改/etc/mysql/mysql.conf.d/mysqld.cnf 需要root权限，sudo passwd root设置root密码， su进入root. 1vim /etc/mysql/mysql.conf.d/mysqld.cnf 把 bind-address = 127.0.0.1 改为 bind-address = 0.0.0.0 上面的意思是改为监听所有地址 重启MySQL 1service mysql restart","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://hasuer.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"Axios学习笔记","slug":"Axios学习笔记","date":"2022-02-25T07:03:16.000Z","updated":"2022-02-25T12:06:54.964Z","comments":true,"path":"axios学习笔记/index.html","link":"","permalink":"https://hasuer.github.io/axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html","excerpt":"","text":"此笔记转载自这里,对应的视频课程是尚硅谷Web前端axios入门与源码解析 预备工具 作为一个前端开发工程师，在后端还没有ready的时候，不可避免的要使用mock的数据。很多时候，我们并不想使用简单的静态数据，而是希望自己起一个本地的mock-server来完全模拟请求以及请求回来的过程。json-server是一个很好的可以替我们完成这一工作的工具。我们只需要提供一个json文件，或者写几行简单的js脚本就可以模拟出RESTful API的接口。 安装json-servernpm install -g json-server 创建db.json在一个文件夹下新建一个db.json文件 123456789&gt;&#123;&gt;&quot;posts&quot;: [ &#123; &quot;id&quot;: 1, &quot;title&quot;: &quot;json-server&quot;, &quot;author&quot;: &quot;typicode&quot; &#125;&gt;],&gt;&quot;comments&quot;: [ &#123; &quot;id&quot;: 1, &quot;body&quot;: &quot;some comment&quot;, &quot;postId&quot;: 1 &#125;&gt;],&gt;&quot;profile&quot;: &#123; &quot;name&quot;: &quot;typicode&quot; &#125;&gt;&#125; 启动json-server在当前文件夹下输入如下命令：json-server db.json 文档 一、Axios的理解与使用axios 是什么? 前端最流行的 ajax 请求库 react/vue 官方都推荐使用 axios 发 ajax 请求 文档: https://github.com/axios/axios axios 特点 基于 xhr + promise 的异步 ajax 请求库 浏览器端/node 端都可以使用 支持请求／响应拦截器 支持请求取消 请求/响应数据转换 批量发送多个请求 axios 常用语法 axios(config): 通用/最本质的发任意类型请求的方式 axios(url[, config]): 可以只指定 url 发 get 请求 axios.request(config): 等同于 axios(config) axios.get(url[, config]): 发 get 请求 axios.delete(url[, config]): 发 delete 请求 axios.post(url[, data, config]): 发 post 请求 axios.put(url[, data, config]): 发 put 请求 axios.defaults.xxx: 请求的默认全局配置 axios.interceptors.request.use(): 添加请求拦截器 axios.interceptors.response.use(): 添加响应拦截器 axios.create([config]): 创建一个新的 axios(它没有下面的功能) axios.Cancel(): 用于创建取消请求的错误对象 axios.CancelToken(): 用于创建取消请求的 token 对象 axios.isCancel(): 是否是一个取消请求的错误 axios.all(promises): 用于批量执行多个异步请求 axios.spread(): 用来指定接收所有成功数据的回调函数的方法 原理图 难点语法的理解和使用axios.create(config) 根据指定配置创建一个新的 axios, 也就就每个新 axios 都有自己的配置 新 axios 只是没有取消请求和批量发请求的方法, 其它所有语法都是一致的 为什么要设计这个语法? (1) 需求: 项目中有部分接口需要的配置与另一部分接口需要的配置不太一样, 如何处理 (2) 解决: 创建 2 个新 axios, 每个都有自己特有的配置, 分别应用到不同要 求的接口请求中 123456789101112131415161718//创建实例对象 /getJoke const duanzi = axios.create(&#123; baseURL: &#x27;https://api.apiopen.top&#x27;, timeout: 2000 &#125;); const onather = axios.create(&#123; baseURL: &#x27;https://b.com&#x27;, timeout: 2000 &#125;); //这里 duanzi 与 axios 对象的功能几近是一样的 // duanzi(&#123; // url: &#x27;/getJoke&#x27;, // &#125;).then(response =&gt; &#123; // console.log(response); // &#125;); duanzi.get(&#x27;/getJoke&#x27;).then(response =&gt; &#123; console.log(response.data) &#125;) 拦截器函数/ajax 请求/请求的回调函数的调用顺序 说明: 调用 axios()并不是立即发送 ajax 请求, 而是需要经历一个较长的流程 流程: 请求拦截器2 =&gt; 请求拦截器1 =&gt; 发ajax请求 =&gt; 响应拦截器1 =&gt; 响应拦截器 2 =&gt; 请求的回调 注意: 此流程是通过 promise 串连起来的, 请求拦截器传递的是 config, 响应 拦截器传递的是 response 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;script&gt; // Promise // 设置请求拦截器 config 配置对象 axios.interceptors.request.use(function (config) &#123; console.log(&#x27;请求拦截器 成功 - 1号&#x27;); //修改 config 中的参数 config.params = &#123; a: 100 &#125;; return config; &#125;, function (error) &#123; console.log(&#x27;请求拦截器 失败 - 1号&#x27;); return Promise.reject(error); &#125;); axios.interceptors.request.use(function (config) &#123; console.log(&#x27;请求拦截器 成功 - 2号&#x27;); //修改 config 中的参数 config.timeout = 2000; return config; &#125;, function (error) &#123; console.log(&#x27;请求拦截器 失败 - 2号&#x27;); return Promise.reject(error); &#125;); // 设置响应拦截器 axios.interceptors.response.use(function (response) &#123; console.log(&#x27;响应拦截器 成功 1号&#x27;); return response.data; // return response; &#125;, function (error) &#123; console.log(&#x27;响应拦截器 失败 1号&#x27;) return Promise.reject(error); &#125;); axios.interceptors.response.use(function (response) &#123; console.log(&#x27;响应拦截器 成功 2号&#x27;) return response; &#125;, function (error) &#123; console.log(&#x27;响应拦截器 失败 2号&#x27;) return Promise.reject(error); &#125;); //发送请求 axios(&#123; method: &#x27;GET&#x27;, url: &#x27;http://localhost:3000/posts&#x27; &#125;).then(response =&gt; &#123; console.log(&#x27;自定义回调处理成功的结果&#x27;); console.log(response); &#125;);&lt;/script&gt; 取消请求 基本流程 配置 cancelToken 对象 缓存用于取消请求的 cancel 函数 在后面特定时机调用 cancel 函数取消请求 在错误回调中判断如果 error 是 cancel, 做相应处理 实现功能 点击按钮, 取消某个正在请求中的请求, 实现功能 点击按钮, 取消某个正在请求中的请求 123456789101112131415161718192021222324252627282930&lt;script&gt; //获取按钮 const btns = document.querySelectorAll(&#x27;button&#x27;); //2.声明全局变量 let cancel = null; //发送请求 btns[0].onclick = function () &#123; //检测上一次的请求是否已经完成 if (cancel !== null) &#123; //取消上一次的请求 cancel(); &#125; axios(&#123; method: &#x27;GET&#x27;, url: &#x27;http://localhost:3000/posts&#x27;, //1. 添加配置对象的属性 cancelToken: new axios.CancelToken(function (c) &#123; //3. 将 c 的值赋值给 cancel cancel = c; &#125;) &#125;).then(response =&gt; &#123; console.log(response); //将 cancel 的值初始化 cancel = null; &#125;) &#125; //绑定第二个事件取消请求 btns[1].onclick = function () &#123;cancel(); &#125;&lt;/script&gt; 默认配置 12345678910111213&gt;//默认配置 axios.defaults.method = &#x27;GET&#x27;;//设置默认的请求类型为 GET axios.defaults.baseURL = &#x27;http://localhost:3000&#x27;;//设置基础 URL axios.defaults.params = &#123;id:100&#125;; axios.defaults.timeout = 3000;// btns[0].onclick = function()&#123; axios(&#123; url: &#x27;/posts&#x27; &#125;).then(response =&gt; &#123; console.log(response); &#125;) &#125; Axios的难点问题目录结构 ├── /dist/ # 项目输出目录├── /lib/ # 项目源码目录│ ├── /adapters/ # 定义请求的适配器 xhr、http│ │ ├── http.js # 实现 http 适配器(包装 http 包)│ │ └── xhr.js # 实现 xhr 适配器(包装 xhr 对象)│ ├── /cancel/ # 定义取消功能│ ├── /core/ # 一些核心功能│ │ ├── Axios.js # axios 的核心主类│ │ ├── dispatchRequest.js # 用来调用 http 请求适配器方法发送请求的函数│ │ ├── InterceptorManager.js # 拦截器的管理器│ │ └── settle.js # 根据 http 响应状态，改变 Promise 的状态│ ├── /helpers/ # 一些辅助方法│ ├── axios.js # 对外暴露接口│ ├── defaults.js # axios 的默认配置│ └── utils.js # 公用工具├── package.json # 项目信息├── index.d.ts # 配置 TypeScript 的声明文件└── index.js # 入口文件 axios 与 Axios 的关系 从语法上来说: axios 不是 Axios 的实例 从功能上来说: axios 是 Axios 的实例 axios 是 Axios.prototype.request 函数 bind()返回的函数 axios 作为对象有 Axios 原型对象上的所有方法, 有 Axios 对象上所有属性 instance 与 axios 的区别? 相同:(1) 都是一个能发任意请求的函数: request(config)(2) 都有发特定请求的各种方法: get()/post()/put()/delete()(3) 都有默认配置和拦截器的属性: defaults/interceptors 不同:(1) 默认配置很可能不一样(2) instance 没有 axios 后面添加的一些方法: create()/CancelToken()/all() axios运行的整体流程 整体流程:request(config) ==&gt; dispatchRequest(config) ==&gt; xhrAdapter(config) request(config):将请求拦截器 / dispatchRequest() / 响应拦截器 通过 promise 链串连起来, 返回 promise dispatchRequest(config):转换请求数据 ===&gt; 调用 xhrAdapter()发请求 ===&gt; 请求返回后转换响应数 据. 返回 promise xhrAdapter(config):创建 XHR 对象, 根据 config 进行相应设置, 发送特定请求, 并接收响应数据, 返回 promise 流程图: axios 的请求/响应拦截器是什么? 请求拦截器:Ⅰ- 在真正发送请求前执行的回调函数Ⅱ- 可以对请求进行检查或配置进行特定处理Ⅲ- 成功的回调函数, 传递的默认是 config(也必须是)Ⅳ- 失败的回调函数, 传递的默认是 error 响应拦截器Ⅰ- 在请求得到响应后执行的回调函数Ⅱ- 可以对响应数据进行特定处理Ⅲ- 成功的回调函数, 传递的默认是 responseⅣ- 失败的回调函数, 传递的默认是 error axios 的请求/响应数据转换器是什么? 请求转换器: 对请求头和请求体数据进行特定处理的函数 1234&gt;if (utils.isObject(data)) &#123;setContentTypeIfUnset(headers, &#x27;application/json;charset=utf-8&#x27;);return JSON.stringify(data);&gt;&#125; 响应转换器: 将响应体 json 字符串解析为 js 对象或数组的函数 1&gt;response.data = JSON.parse(response.data) response与error 的整体结构 response的整体结构 123&gt;&#123;&gt;data, status,statusText,headers,config,request&gt;&#125; error 的整体结构 123&gt;&#123;&gt;message,response,request,&gt;&#125; 如何取消未完成的请求? 当配置了 cancelToken 对象时, 保存 cancel 函数(1) 创建一个用于将来中断请求的 cancelPromise(2) 并定义了一个用于取消请求的 cancel 函数(3) 将 cancel 函数传递出来 调用 cancel()取消请求(1) 执行 cacel 函数, 传入错误信息 message(2) 内部会让 cancelPromise 变为成功, 且成功的值为一个 Cancel 对象(3) 在 cancelPromise 的成功回调中中断请求, 并让发请求的 proimse 失败,失败的 reason 为 Cancel 对象 Axios源码模拟实现axios 的创建过程模拟实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&gt;&lt;script&gt;&gt;//构造函数&gt;function Axios(config) &#123;//初始化this.defaults = config; //为了创建 default 默认属性this.intercepters = &#123; request: &#123;&#125;, response: &#123;&#125;&#125;&gt;&#125;&gt;//原型添加相关的方法&gt;Axios.prototype.request = function (config) &#123;console.log(&#x27;发送 AJAX 请求 请求的类型为 &#x27; + config.method);&gt;&#125;&gt;Axios.prototype.get = function (config) &#123;return this.request(&#123; method: &#x27;GET&#x27;&#125;);&gt;&#125;&gt;Axios.prototype.post = function (config) &#123;return this.request(&#123; method: &#x27;POST&#x27;&#125;);&gt;&#125;&gt;//声明函数&gt;function createInstance(config) &#123;//实例化一个对象let context = new Axios(config); // context.get() context.post() 但是不能当做函数使用 context() X//创建请求函数let instance = Axios.prototype.request.bind(context); // instance 是一个函数 并且可以 instance(&#123;&#125;) 此时 instance 不能 instance.get X//将 Axios.prototype 对象中的方法添加到instance函数对象中,才可以instance.get....Object.keys(Axios.prototype).forEach(key =&gt; &#123; instance[key] = Axios.prototype[key].bind(context); // this.default this.interceptors&#125;);//为 instance 函数对象添加属性 default 与 interceptorsObject.keys(context).forEach(key =&gt; &#123; instance[key] = context[key];&#125;);return instance;&gt;&#125;&gt;let axios = createInstance();&gt;//发送请求&gt;// axios(&#123;method:&#x27;POST&#x27;&#125;);&gt;axios.get(&#123;&#125;);&gt;axios.post(&#123;&#125;);&gt;&lt;/script&gt; axios发送请求过程详解 整体流程:request(config) ==&gt; dispatchRequest(config) ==&gt; xhrAdapter(config) request(config):将请求拦截器 / dispatchRequest() / 响应拦截器 通过 promise 链串连起来,返回 promise dispatchRequest(config):转换请求数据 ===&gt; 调用 xhrAdapter()发请求 ===&gt; 请求返回后转换响应数据. 返回 promise xhrAdapter(config):创建 XHR 对象, 根据 config 进行相应设置, 发送特定请求, 并接收响应数据,返回 promise 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&gt;&lt;script&gt; // axios 发送请求 axios Axios.prototype.request bind //1. 声明构造函数 function Axios(config) &#123; this.config = config; &#125; Axios.prototype.request = function (config) &#123; //发送请求 //创建一个 promise 对象 let promise = Promise.resolve(config); //声明一个数组 let chains = [dispatchRequest, undefined]; // undefined 占位 //调用 then 方法指定回调 let result = promise.then(chains[0], chains[1]); //返回 promise 的结果 return result; &#125; //2. dispatchRequest 函数 function dispatchRequest(config) &#123; //调用适配器发送请求 return xhrAdapter(config).then(response =&gt; &#123; //响应的结果进行转换处理 //.... return response; &#125;, error =&gt; &#123; throw error; &#125;); &#125; //3. adapter 适配器 function xhrAdapter(config) &#123; console.log(&#x27;xhrAdapter 函数执行&#x27;); return new Promise((resolve, reject) =&gt; &#123; //发送 AJAX 请求 let xhr = new XMLHttpRequest(); //初始化 xhr.open(config.method, config.url); //发送 xhr.send(); //绑定事件 xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; //判断成功的条件 if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123; //成功的状态 resolve(&#123; //配置对象 config: config, //响应体 data: xhr.response, //响应头 headers: xhr.getAllResponseHeaders(), //字符串 parseHeaders // xhr 请求对象 request: xhr, //响应状态码 status: xhr.status, //响应状态字符串 statusText: xhr.statusText &#125;); &#125; else &#123; //失败的状态 reject(new Error(&#x27;请求失败 失败的状态码为&#x27; + xhr.status)); &#125; &#125; &#125; &#125;); &#125; //4. 创建 axios 函数 let axios = Axios.prototype.request.bind(null); axios(&#123; method: &#x27;GET&#x27;, url: &#x27;http://localhost:3000/posts&#x27; &#125;).then(response =&gt; &#123; console.log(response); &#125;);&lt;/script&gt; 拦截器的模拟实现 array.shift()该方法用于把数组的第一个元素从其中删除，并返回第一个元素的值 思路为先将拦截器的响应回调与请求回调都压入一个数组中,之后进行遍历运行 promise = promise.then(chains.shift(), chains.shift()); 通过循环使用promise的then链条得到最终的结果—&gt;等式前面的promise将被最终的结果覆盖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&gt;&lt;!DOCTYPE html&gt;&gt;&lt;html lang=&quot;en&quot;&gt;&gt;&lt;head&gt;&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&gt;&lt;title&gt;拦截器&lt;/title&gt;&gt;&lt;!-- &lt;script src=&quot;./node_modules/axios/dist/mine-axios.js&quot;&gt;&lt;/script&gt; --&gt;&gt;&lt;/head&gt;&gt;&lt;body&gt;&gt;&lt;script&gt; //构造函数 function Axios(config)&#123; this.config = config; this.interceptors = &#123; request: new InterceptorManager(), response: new InterceptorManager(), &#125; &#125; //发送请求 难点与重点 Axios.prototype.request = function(config)&#123; //创建一个 promise 对象 let promise = Promise.resolve(config); //创建一个数组 const chains = [dispatchRequest, undefined]; //处理拦截器 //请求拦截器 将请求拦截器的回调 压入到 chains 的前面 request.handles = [] this.interceptors.request.handlers.forEach(item =&gt; &#123; chains.unshift(item.fulfilled, item.rejected); &#125;); //响应拦截器 this.interceptors.response.handlers.forEach(item =&gt; &#123; chains.push(item.fulfilled, item.rejected); &#125;); // console.log(chains); //遍历 while(chains.length &gt; 0)&#123; //array.shift() promise = promise.then(chains.shift(), chains.shift()); &#125; return promise; &#125; //发送请求 function dispatchRequest(config)&#123; //返回一个promise 队形 return new Promise((resolve, reject) =&gt; &#123; resolve(&#123; status: 200, statusText: &#x27;OK&#x27; &#125;); &#125;); &#125; //创建实例 let context = new Axios(&#123;&#125;); //创建axios函数 let axios = Axios.prototype.request.bind(context); //将 context 属性 config interceptors 添加至 axios 函数对象身上 Object.keys(context).forEach(key =&gt; &#123; axios[key] = context[key]; &#125;); //拦截器管理器构造函数 function InterceptorManager()&#123; this.handlers = []; &#125; InterceptorManager.prototype.use = function(fulfilled, rejected)&#123; this.handlers.push(&#123; fulfilled, rejected &#125;) &#125; //以下为功能测试代码 // 设置请求拦截器 config 配置对象 axios.interceptors.request.use(function one(config) &#123; console.log(&#x27;请求拦截器 成功 - 1号&#x27;); return config; &#125;, function one(error) &#123; console.log(&#x27;请求拦截器 失败 - 1号&#x27;); return Promise.reject(error); &#125;); axios.interceptors.request.use(function two(config) &#123; console.log(&#x27;请求拦截器 成功 - 2号&#x27;); return config; &#125;, function two(error) &#123; console.log(&#x27;请求拦截器 失败 - 2号&#x27;); return Promise.reject(error); &#125;); // 设置响应拦截器 axios.interceptors.response.use(function (response) &#123; console.log(&#x27;响应拦截器 成功 1号&#x27;); return response; &#125;, function (error) &#123; console.log(&#x27;响应拦截器 失败 1号&#x27;) return Promise.reject(error); &#125;); axios.interceptors.response.use(function (response) &#123; console.log(&#x27;响应拦截器 成功 2号&#x27;) return response; &#125;, function (error) &#123; console.log(&#x27;响应拦截器 失败 2号&#x27;) return Promise.reject(error); &#125;); //发送请求 axios(&#123; method: &#x27;GET&#x27;, url: &#x27;http://localhost:3000/posts&#x27; &#125;).then(response =&gt; &#123; console.log(response); &#125;);&gt;&lt;/script&gt;&gt;&lt;/body&gt;&gt;&lt;/html&gt; 请求取消功能模拟实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&gt;&lt;!DOCTYPE html&gt;&gt;&lt;html lang=&quot;en&quot;&gt;&gt;&lt;head&gt;&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&gt;&lt;title&gt;取消请求&lt;/title&gt;&gt;&lt;link crossorigin=&#x27;anonymous&#x27; href=&quot;https://cdn.bootcss.com/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;&gt;rel=&quot;stylesheet&quot;&gt;&gt;&lt;!-- &lt;script src=&quot;./node_modules/axios/dist/mine-axios.js&quot;&gt;&lt;/script&gt; --&gt;&gt;&lt;/head&gt;&gt;&lt;body&gt;&gt;&lt;div class=&quot;container&quot;&gt;&gt;&lt;h2 class=&quot;page-header&quot;&gt;axios取消请求&lt;/h2&gt;&gt;&lt;button class=&quot;btn btn-primary&quot;&gt; 发送请求 &lt;/button&gt;&gt;&lt;button class=&quot;btn btn-warning&quot;&gt; 取消请求 &lt;/button&gt;&gt;&lt;/div&gt;&gt;&lt;script&gt;&gt;//构造函数&gt;function Axios(config) &#123;this.config = config;&gt;&#125;&gt;//原型 request 方法&gt;Axios.prototype.request = function (config) &#123;return dispatchRequest(config);&gt;&#125;&gt;//dispatchRequest 函数&gt;function dispatchRequest(config) &#123;return xhrAdapter(config);&gt;&#125;&gt;//xhrAdapter&gt;function xhrAdapter(config) &#123;//发送 AJAX 请求return new Promise((resolve, reject) =&gt; &#123; //实例化对象 const xhr = new XMLHttpRequest(); //初始化 xhr.open(config.method, config.url); //发送 xhr.send(); //处理结果 xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; //判断结果 if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123; //设置为成功的状态 resolve(&#123; status: xhr.status, statusText: xhr.statusText &#125;); &#125; else &#123; reject(new Error(&#x27;请求失败&#x27;)); &#125; &#125; &#125; //关于取消请求的处理 if (config.cancelToken) &#123; //对 cancelToken 对象身上的 promise 对象指定成功的回调 config.cancelToken.promise.then(value =&gt; &#123; xhr.abort(); //将整体结果设置为失败 reject(new Error(&#x27;请求已经被取消&#x27;)) &#125;); &#125;&#125;)&gt;&#125;&gt;//创建 axios 函数&gt;const context = new Axios(&#123;&#125;);&gt;const axios = Axios.prototype.request.bind(context);&gt;//CancelToken 构造函数&gt;function CancelToken(executor) &#123;//声明一个变量var resolvePromise;//为实例对象添加属性this.promise = new Promise((resolve) =&gt; &#123; //将 resolve 赋值给 resolvePromise resolvePromise = resolve&#125;);//调用 executor 函数executor(function () &#123; //执行 resolvePromise 函数 resolvePromise();&#125;);&gt;&#125;&gt;//获取按钮 以上为模拟实现的代码&gt;const btns = document.querySelectorAll(&#x27;button&#x27;);&gt;//2.声明全局变量&gt;let cancel = null;&gt;//发送请求&gt;btns[0].onclick = function () &#123;//检测上一次的请求是否已经完成if (cancel !== null) &#123; //取消上一次的请求 cancel();&#125;//创建 cancelToken 的值let cancelToken = new CancelToken(function (c) &#123; cancel = c;&#125;);axios(&#123; method: &#x27;GET&#x27;, url: &#x27;http://localhost:3000/posts&#x27;, //1. 添加配置对象的属性 cancelToken: cancelToken&#125;).then(response =&gt; &#123; console.log(response); //将 cancel 的值初始化 cancel = null;&#125;)&gt;&#125;&gt;//绑定第二个事件取消请求&gt;btns[1].onclick = function () &#123;cancel();&gt;&#125;&gt;&lt;/script&gt;&gt;&lt;/body&gt;&gt;&lt;/html&gt; 原作者对于某些问题解答与理解axios同步与异步转换,在外部取值12345678910111213141516171819202122232425262728293031323334const axios = require (&#x27;axios&#x27;); //创建实例对象 const $http = axios.create(&#123; baseURL: &#x27;http://localhost:53000&#x27;, timeout: 11000 //请求超时时间&#125;);let resolveCommon = ()=&gt; &#123; let data=$http(&#123; url:&quot;/test&quot;&#125;) .then(v=&gt;v.data) //等于 `.then(v=&gt;&#123;return v&#125;)` console.log(data) //打印结果: Promise &#123; &lt;pending&gt; &#125; &#125;;let resolveAsync=async ()=&gt; &#123; let data=await $http(&#123; url:&quot;/test&quot;&#125;) .then(v=&gt;v.data) //等于 `.then(v=&gt;&#123;return v&#125;)`,我再then()中返回出去,让外部承接 console.log(data) //获得正确的值 /** * 打印结果&#123; id: 1000,course_name: &#x27;这是请求数据1&#x27;, autor: &#x27;袁明&#x27;, college: &#x27;金并即总变史&#x27;,category_Id: 2&#125; * */ //模拟新增数据,将上一步的结果简单加工一下 data.course_name=data.course_name+1 $http(&#123; url:&quot;/test&quot;, method:&quot;put&quot;, data &#125;).then(v=&gt;&#123; console.log(v) //直接打印了 需要再取出参照上一步 &#125;)&#125;;resolveCommon() //调用普通promise函数resolveAsync() //调用await+async","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://hasuer.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"Promise学习笔记","slug":"Promise学习笔记","date":"2022-02-23T13:58:50.000Z","updated":"2022-02-25T06:57:38.671Z","comments":true,"path":"promise学习笔记/index.html","link":"","permalink":"https://hasuer.github.io/promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html","excerpt":"","text":"笔记转载自这里，有适当改动。 视频教程是尚硅谷Web前端Promise教程从入门到精通 Promise的理解与使用 1、概念: ​ Promise是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。 通俗讲，Promise是一个许诺、承诺,是对未来事情的承诺，承诺不一定能完成，但是无论是否能完成都会有一个结果。 Pending 正在做。。。 Resolved 完成这个承诺 Rejected 这个承诺没有完成，失败了 ​ Promise 用来预定一个不一定能完成的任务，要么成功，要么失败 ​ 在具体的程序中具体的体现，通常用来封装一个异步任务，提供承诺结果 Promise 是异步编程的一种解决方案，主要用来解决回调地狱的问题，可以有效的减少回调嵌套。真正解决需要配合async/await 2、特点: ​ (1)对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。 ​ (2)一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。 3、缺点: ​ (1)无法取消Promise，一旦新建它就会立即执行，无法中途取消。和一般的对象不一样，无需调用。 ​ (2)如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。 ​ (3)当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成） Promise是什么?理解 抽象表达: ​ 1) Promise 是一门新的技术(ES6 规范) ​ 2)Promise 是 JS 中进行异步编程的新解决方案 备注：旧方案是单纯使用回调函数 具体表达: 1) 从语法上来说: Promise 是一个构造函数 2) 从功能上来说: promise 对象用来封装一个异步操作并可以获取其成功/ 失败的结果值 promise 的状态promise 的状态 实例对象中的一个属性 『PromiseState』 pending 未决定的 resolved / fullfilled 成功 rejected 失败 promise 的状态改变 pending 变为 resolved pending 变为 rejected 说明: 只有这 2 种, 且一个 promise 对象只能改变一次 无论变为成功还是失败, 都会有一个结果数据 成功的结果数据一般称为 value, 失败的结果数据一般称为 reason promise的基本流程 promise的基本使用使用 promise 封装基于定时器的异步1234567891011121314151617181920212223242526272829&lt;script &gt; function doDelay(time) &#123; // 1. 创建 promise 对象(pending 状态), 指定执行器函数 return new Promise((resolve, reject) =&gt; &#123; // 2. 在执行器函数中启动异步任务 console.log(&#x27;启动异步任务&#x27;) setTimeout(() =&gt; &#123; console.log(&#x27;延迟任务开始执行...&#x27;) const time = Date.now() // 假设: 时间为奇数代表成功, 为偶数代表失败 if (time % 2 === 1) &#123; // 成功了 // 3. 1. 如果成功了, 调用 resolve()并传入成功的 value resolve(&#x27;成功的数据 &#x27; + time) &#125; else &#123; // 失败了 // 3.2. 如果失败了, 调用 reject()并传入失败的 reason reject(&#x27;失败的数据 &#x27; + time) &#125; &#125;, time) &#125;) &#125;const promise = doDelay(2000)promise.then(// promise 指定成功或失败的回调函数来获取成功的 vlaue 或失败的 reason value =&gt; &#123;// 成功的回调函数 onResolved, 得到成功的 vlaue console.log(&#x27;成功的 value: &#x27;, value) &#125;, reason =&gt; &#123; // 失败的回调函数 onRejected, 得到失败的 reason console.log(&#x27;失败的 reason: &#x27;, reason) &#125;, ) &lt; /script&gt; 使用 promise 封装 ajax 异步请求12345678910111213141516171819202122232425262728293031323334&lt;script &gt; /* 可复用的发 ajax 请求的函数: xhr + promise */ function promiseAjax(url) &#123; return new Promise((resolve, reject) =&gt; &#123; const xhr = new XMLHttpRequest() xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState !== 4) return const &#123; status, response &#125; = xhr // 请求成功, 调用 resolve(value) if (status &gt;= 200 &amp;&amp; status &lt; 300) &#123; resolve(JSON.parse(response)) &#125; else &#123; // 请求失败, 调用 reject(reason) reject(new Error(&#x27;请求失败: status: &#x27; + status)) &#125; &#125; xhr.open(&quot;GET&quot;, url) xhr.send() &#125;) &#125;promiseAjax(&#x27;https://api.apiopen.top2/getJoke?page=1&amp;count=2&amp;type=vid eo &#x27;) .then( data =&gt; &#123; console.log(&#x27;显示成功数据&#x27;, data) &#125;, error =&gt; &#123; alert(error.message) &#125; ) &lt;/script&gt; fs模块使用Promise123456789101112131415161718192021222324252627282930313233343536const fs = require(&#x27;fs&#x27;);//回调函数 形式---------------------------------------------------- fs.readFile(&#x27;./resource/content.txt&#x27;, (err, data) =&gt; &#123; // 如果出错 则抛出错误 if(err) throw err; //输出文件内容 console.log(data.toString()); &#125;);//Promise 形式-----------------------------------------------------------/** * 封装一个函数 mineReadFile 读取文件内容 * 参数: path 文件路径 * 返回: promise 对象 */function mineReadFile(path)&#123; return new Promise((resolve, reject) =&gt; &#123; //读取文件 require(&#x27;fs&#x27;).readFile(path, (err, data) =&gt;&#123; //判断 if(err) reject(err); //成功 resolve(data); &#125;); &#125;);&#125;mineReadFile(&#x27;./resource/content.txt&#x27;).then(value=&gt;&#123; //输出文件内容 console.log(value.toString());&#125;, reason=&gt;&#123; console.log(reason);&#125;); 异常穿透 可以在每个then()的第二个回调函数中进行err处理,也可以利用异常穿透特性,到最后用catch去承接统一处理,两者一起用时,前者会生效(因为err已经将其处理,就不会再往下穿透)而走不到后面的catch 在每个.then()中我可以将数据再次传出给下一个then() 123456mineReadFile(&#x27;./11.txt&#x27;).then(result=&gt;&#123; console.log(result.toString()) return result&#125;,err=&gt;console.log(err)).then(data=&gt;console.log(data,&quot;2222222&quot;)).catch(err=&gt;console.log(&quot;这是catch的&quot;)) util.promisify方法 可以将函数直接变成promise的封装方式,不用再去手动封装 12345678910//引入 util 模块const util = require(&#x27;util&#x27;);//引入 fs 模块const fs = require(&#x27;fs&#x27;);//返回一个新的函数let mineReadFile = util.promisify(fs.readFile);mineReadFile(&#x27;./resource/content.txt&#x27;).then(value =&gt; &#123; console.log(value.toString());&#125;); 为什么要用Promise?指定回调函数的方式更加灵活 旧的: 必须在启动异步任务前指定 promise: 启动异步任务 =&gt; 返回promie对象 =&gt; 给promise对象绑定回调函 数(甚至可以在异步任务结束后指定/多个) 支持链式调用, 可以解决回调地狱问题什么是回调地狱 回调函数嵌套调用, 外部回调函数异步执行的结果是嵌套的回调执行的条件 回调地狱的缺点? 不便于阅读 不便于异常处理 解决方案? promise 链式调用, 用来解决回调地狱问题，但是只是简单的改变格式，并没有彻底解决上面的问题真正要解决上述问题，一定要利用promise再加上await和async关键字实现异步传同步 终极解决方案? promise +async/await Promise中的常用 API 概述 此处列举几个最常用的API的概述,如果想看详细描述的可以继续往下看下方的 Promise方法的具体使用 描述 Promise 构造函数: Promise (excutor) {} (1) executor 函数: 执行器 (resolve, reject) =&gt; {} (2) resolve 函数: 内部定义成功时我们调用的函数 value =&gt; {} (3) reject 函数: 内部定义失败时我们调用的函数 reason =&gt; {} 说明: executor 会在 Promise 内部立即**同步调用**,异步操作在执行器中执行,换话说Promise支持同步也支持异步操作 Promise.prototype.then 方法: (onResolved, onRejected) =&gt; {} (1) onResolved 函数: 成功的回调函数 (value) =&gt; {} (2) onRejected 函数: 失败的回调函数 (reason) =&gt; {} 说明: 指定用于得到成功 value 的成功回调和用于得到失败 reason 的失败回调 返回一个新的 promise 对象 Promise.prototype.catch 方法: (onRejected) =&gt; {} (1) onRejected 函数: 失败的回调函数 (reason) =&gt; {} 说明: then()的语法糖, 相当于: then(undefined, onRejected) (2) 异常穿透使用:当运行到最后,没被处理的所有异常错误都会进入这个方法的回调函数中 Promise.resolve 方法: (value) =&gt; {} (1) value: 成功的数据或 promise 对象 说明: 返回一个成功/失败的 promise 对象,直接改变promise状态 Promise.resolve(value) 用结果 value 创建一个 resolved 的 promise。 如同： 1&gt;let promise = new Promise(resolve =&gt; resolve(value)); 12&gt;let p3 = Promise.reject(new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;OK&#x27;); &#125;)); &gt;console.log(p3); Promise.reject 方法: (reason) =&gt; {} (1) reason: 失败的原因 说明: 返回一个失败的 promise 对象,直接改变promise状态,代码示例同上 Promise.reject(error) 用 error 创建一个 rejected 的 promise。 如同： 1&gt;let promise = new Promise((resolve, reject) =&gt; reject(error)); 实际上，这个方法几乎从未被使用过。 Promise.all 方法: (promises) =&gt; {} promises: 包含 n 个 promise 的数组 说明: 返回一个新的 promise, 只有所有的 promise 都成功才成功, 只要有一 个失败了就直接失败 12345&gt;let p1 = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;成功&#x27;); &#125;)&gt;let p2 = Promise.reject(&#x27;错误错误错误&#x27;);&gt;let p3 = Promise.resolve(&#x27;也是成功&#x27;)&gt;const result = Promise.all([p1, p2, p3]);&gt;console.log(result); Promise.race 方法: (promises) =&gt; {} (1) promises: 包含 n 个 promise 的数组 说明: 返回一个新的 promise, 第一个完成的 promise 的结果状态就是最终的结果状态, 如p1延时,开启了异步,内部正常是同步进行,所以p2&gt;p3&gt;p1,结果是P2 12345678910&gt;let p1 = new Promise((resolve, reject) =&gt; &#123;setTimeout(() =&gt; &#123; resolve(&#x27;OK&#x27;);&#125;, 1000);&gt;&#125;)&gt;let p2 = Promise.resolve(&#x27;Success&#x27;);&gt;let p3 = Promise.resolve(&#x27;Oh Yeah&#x27;);&gt;//调用&gt;const result = Promise.race([p1, p2, p3]);&gt;console.log(result); Promise的几个关键问题如何改变 promise 的状态? (1) resolve(value): 如果当前是 pending 就会变为 resolved (2) reject(reason): 如果当前是 pending 就会变为 rejected (3) 抛出异常: 如果当前是 pending 就会变为 rejected 一个 promise 指定多个成功/失败回调函数, 都会调用吗? 当 promise 改变为对应状态时都会调用,改变状态后,多个回调函数都会调用,并不会自动停止 12345&gt;let p = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;OK&#x27;);&#125;);&gt;///指定回调 - 1&gt;p.then(value =&gt; &#123; console.log(value); &#125;);&gt;//指定回调 - 2&gt;p.then(value =&gt; &#123; alert(value);&#125;); 改变 promise 状态和指定回调函数谁先谁后? (1) 都有可能, 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调 ​ 先指定回调再改变状态(异步):先指定回调—&gt; 再改变状态 —&gt;改变状态后才进入异步队列执行回调函数 ​ 先改状态再指定回调(同步):改变状态 —&gt;指定回调 并马上执行回调 (2) 如何先改状态再指定回调? —&gt;注意:指定并不是执行 ​ ① 在执行器中直接调用 resolve()/reject() —&gt;即,不使用定时器等方法,执行器内直接同步操作 ​ ② 延迟更长时间才调用 then() —&gt;即,在.then()这个方法外再包一层例如延时器这种方法 (3) 什么时候才能得到数据? ​ ① 如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据 ​ ② 如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据 1234567&gt;let p = new Promise((resolve, reject) =&gt; &#123;&gt;//异步写法,这样写会先指定回调,再改变状态&gt;setTimeout(() =&gt; &#123;resolve(&#x27;OK&#x27;); &#125;, 1000);&gt;//这是同步写法,这样写会先改变状态,再指定回调&gt;resolve(&#x27;OK&#x27;); &gt;&#125;);&gt;p.then(value =&gt; &#123;console.log(value);&#125;, reason =&gt; &#123;&#125;) (4) 个人理解—结合源码 ​ 源码中,promise的状态是通过一个默认为pending的变量进行判断,所以当你resolve/reject延时(异步导致当then加载时,状态还未修改)后,这时直接进行p.then()会发现,目前状态还是进行中,所以只是这样导致只有同步操作才能成功. ​ 所以promise将传入的回调函数拷贝到promise对象实例上,然后在resolve/reject的执行过程中再进行调用,达到异步的目的 ​ 具体代码实现看下方自定义promise Ⅳ-promise.then()返回的新 promise 的结果状态由什么决定? (1) 简单表达: 由 then()指定的回调函数执行的结果决定 (2) 详细表达: ​ ① 如果抛出异常, 新 promise 变为 rejected, reason 为抛出的异常 ​ ② 如果返回的是非 promise 的任意值, 新 promise 变为 resolved, value 为返回的值 ​ ③ 如果返回的是另一个新 promise, 此 promise 的结果就会成为新 promise 的结果 123456789101112131415161718&gt;let p = new Promise((resolve, reject) =&gt; &#123;&gt;resolve(&#x27;ok&#x27;);&gt;&#125;);&gt;//执行 then 方法&gt;let result = p.then(value =&gt; &#123;&gt;console.log(value);&gt;// 1. 抛出错误 ,变为 rejected&gt;throw &#x27;出了问题&#x27;;&gt;// 2. 返回结果是非 Promise 类型的对象,新 promise 变为 resolved&gt;return 521;&gt;// 3. 返回结果是 Promise 对象,此 promise 的结果就会成为新 promise 的结果&gt;return new Promise((resolve, reject) =&gt; &#123;&gt;// resolve(&#x27;success&#x27;);&gt;reject(&#x27;error&#x27;);&gt;&#125;);&gt;&#125;, reason =&gt; &#123;&gt;console.warn(reason);&gt;&#125;); promise 如何串连多个操作任务? (1) promise 的 then()返回一个新的 promise, 可以开成 then()的链式调用 (2) 通过 then 的链式调用串连多个同步/异步任务,这样就能用then()将多个同步或异步操作串联成一个同步队列 123456&gt;&lt;script&gt;&gt;let p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123;resolve(&#x27;OK&#x27;); &#125;, 1000); &#125;);&gt;p.then(value =&gt; &#123;return new Promise((resolve, reject) =&gt; &#123; resolve(&quot;success&quot;); &#125;);&#125;)&gt;.then(value =&gt; &#123;console.log(value);&#125;)&gt;.then(value =&gt; &#123; console.log(value);&#125;) // 输出undifined, 因为上面一个调用没有返回值&gt;&lt;/script&gt; promise 异常传透? 当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调 前面任何操作出了异常, 都会传到最后失败的回调中处理 1234567891011121314151617&gt;getJSON(&#x27;./hong.json&#x27;) .then(function(posts) &#123; throw new Error(&#x27;抛出异常&#x27;) &#125;).then(res=&gt;console.log(res),e=&gt;console.log(&#x27;被then的错误回调捕获&#x27;,e) ) .catch(function(error) &#123; // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log(&#x27;错误捕获: &#x27;, error);&#125;);&gt;//执行结果: 被then的错误回调捕获 Error: 抛出异常&gt;/******************** 利用异常穿透 ****************************************/&gt;getJSON(&#x27;./hong.json&#x27;) .then(function(posts) &#123; throw new Error(&#x27;抛出异常&#x27;) &#125;).then(res=&gt;console.log(res) ) //此处差异,不指定 reject 回调,利用异常穿透传到最后 .catch(function(error) &#123; console.log(&#x27;错误捕获: &#x27;, error);&#125;);&gt;//执行结果: 错误捕获: Error: 抛出异常 注:可以在每个then()的第二个回调函数中进行err处理,也可以利用异常穿透特性,到最后用catch去承接统一处理,两者一起用时,前者会生效(因为err已经将其处理,就不会再往下穿透)而走不到后面的catch 中断 promise 链? 在关键问题2中,可以得知,当promise状态改变时,他的链式调用都会生效,那如果我们有这个一个实际需求:我们有5个then(),但其中有条件判断,如当我符合或者不符合第三个then条件时,要直接中断链式调用,不再走下面的then,该如何? (1) 当使用 promise 的 then 链式调用时, 在中间中断, 不再调用后面的回调函数 (2) 办法: 在回调函数中返回一个 pendding 状态的promise 对象 1234567&gt;&lt;script&gt;&gt;let p = new Promise((resolve, reject) =&gt; &#123;setTimeout(() =&gt; &#123; resolve(&#x27;OK&#x27;);&#125;, 1000);&#125;);&gt;p.then(value =&gt; &#123;return new Promise(() =&gt; &#123;&#125;);&#125;)//有且只有这一个方式&gt;.then(value =&gt; &#123; console.log(222);&#125;)&gt;.then(value =&gt; &#123; console.log(333);&#125;)&gt;.catch(reason =&gt; &#123;console.warn(reason);&#125;);&gt;&lt;/script&gt; 5、 Promise的实际应用 举两个栗子 Ⅰ - 加载图片 我们可以将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化。 12345678&gt;const preloadImage = function (path) &#123; return new Promise(function (resolve, reject) &#123; const image = new Image(); image.onload = resolve; image.onerror = reject; image.src = path; &#125;);&gt;&#125;; Ⅱ - Generator 函数与 Promise 的结合 使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个Promise对象。 1234567891011121314151617181920212223242526272829303132&gt;function getFoo () &#123;&gt;return new Promise(function (resolve, reject)&#123;&gt;resolve(&#x27;foo&#x27;);&gt;&#125;);&gt;&#125;&gt;const g = function* () &#123;&gt;try &#123;&gt;const foo = yield getFoo();&gt;console.log(foo);&gt;&#125; catch (e) &#123;&gt;console.log(e);&gt;&#125;&gt;&#125;;&gt;function run (generator) &#123;&gt;const it = generator();&gt;function go(result) &#123;&gt;if (result.done) return result.value;&gt;return result.value.then(function (value) &#123;return go(it.next(value));&gt;&#125;, function (error) &#123;return go(it.throw(error));&gt;&#125;);&gt;&#125;&gt;go(it.next());&gt;&#125;&gt;run(g); 上面代码的 Generator 函数g之中，有一个异步操作getFoo，它返回的就是一个Promise对象。函数run用来处理这个Promise对象，并调用下一个next方法。 Promise API 用法详解 ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。 此部分是对于 Promise API 用法的详解 ,尽量详细地列举其常见用法,所以篇幅较长 基本用法举个创造 Promise 实例的栗子 下面代码创造了一个Promise实例。 1234const promise = new Promise(function(resolve, reject) &#123;if (/* 异步操作成功 */) resolve(value); //将该 Promise 修改为成功且返回else reject(error); //将该 Promise 修改为失败且返回&#125;); Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。 resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 使用 [ then ] 方法分别指定 成功/失败 的回调 Promise实例生成以后，可以用 [ then() ] 方法分别指定resolved状态和rejected状态的回调函数。 12345&gt;promise.then(function(value) &#123;&gt;// 当promise状态返回为resolve 时会执行的回调函数&gt;&#125;, function(error) &#123;&gt;// 当promise状态返回为rejected 时会执行的回调函数&gt;&#125;); [ then ] 方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。 举个 Promise 对象的简单栗子 下面是一个Promise对象的简单例子。 setTimeout的第三个参数是给第一个函数的参数，而且是先于第一个参数(即回调函数)执行的 123456789&gt;function timeout(ms) &#123; //声明一个方法, 传入的 参数ms 为延时器时间&gt;return new Promise((resolve, reject) =&gt; &#123; //这行代码实际效果: 当 [ms] 毫秒后 执行 resolve(&#x27;努力学习的汪&#x27;) setTimeout(resolve, ms, &#x27;努力学习的汪&#x27;); &gt;&#125;);&gt;&#125;&gt;timeout(1000).then((value) =&gt; &#123; console.log(value) &#125;);&gt;//打印结果 : 努力学习的汪 上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，Promise实例的状态变为resolved，就会触发then方法绑定的回调函数。 Promise 新建后就会立即执行 1234567891011121314&gt;let promise = new Promise(function(resolve, reject) &#123;&gt;console.log(&#x27;Promise&#x27;);&gt;resolve();&gt;&#125;);&gt;promise.then(function() &#123;&gt;console.log(&#x27;resolved.&#x27;);&gt;&#125;);&gt;console.log(&#x27;Hi!&#x27;);&gt;// Promise&gt;// Hi!&gt;// resolved //可以发现,明明then是在 Hi 前面,却最后打印 上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。 实际上,这个运行结果相关知识点是 [ 宏任务与微任务 ] ,单独梳理在下方.这里可以先初步理解为: JS是单线程的,至上往下运行,在声明 Promise 时实际上已经执行到了内部方法 为何 resolve() 运行后没有立即打印? JS中用来存储待执行回调函数的队列包含2个不同特定的列队 宏队列:用来保存待执行的宏任务(回调),比如:定时器回调/ajax回调/dom事件回调 微队列:用来保存待执行的微任务(回调),比如:Promise的回调/muntation回调 JS执行时会区别这2个队列: JS执行引擎首先必须执行所有的初始化同步任务代码 每次准备取出第一个宏任务执行前,都要将所有的微任务一个一个取出来执行 举个异步加载图片的栗子 123456789101112131415161718&gt;function loadImageAsync(url) &#123;&gt;return new Promise(function(resolve, reject) &#123;&gt;const image = new Image();&gt;image.onload = function() &#123;&gt;console.log(&#x27;图片加载成功&#x27;)&gt;resolve(image);&gt;&#125;;&gt;image.onerror = function() &#123;&gt;reject(new Error(`无法从 $&#123;url&#125; 中加载图片` ));&gt;&#125;;&gt;image.src = url;&gt;&#125;);&gt;&#125;&gt;loadImageAsync(&#x27;正确的url&#x27;) //打印图片加载成功&gt;loadImageAsync(&#x27;错误的url&#x27;) //抛出异常 上面代码中，使用Promise包装了一个图片加载的异步操作。如果加载成功，就调用resolve方法，否则就调用reject方法。 举个用Promise对象实现的 Ajax 操作的栗子 Ajax知识点不懂的同学要去补一下: 这里可以看原作者梳理的ajax笔记 —&gt; 点我跳转 12345678910111213141516171819202122&gt;const getJSON = function(url) &#123;&gt;const promise = new Promise(function(resolve, reject)&#123;&gt;const handler = function() &#123;&gt;if (this.readyState !== 4) return; //当readyState 为4 时直接返回,不修改 promise 状态&gt;if (this.status === 200) resolve(this.response); //返回状态为 200 时将状态修改为成功,且将响应内容返回&gt;else reject(new Error(this.statusText)); //失败时抛出异常&gt;&#125;;&gt;const client = new XMLHttpRequest(); //实例化xml实例&gt;client.open(&quot;GET&quot;, url); //下面这几行都是对xml实例进行配置,不懂的同学要去补一下ajax知识点&gt;client.onreadystatechange = handler;&gt;client.responseType = &quot;json&quot;;&gt;client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);&gt;client.send();&gt;&#125;);&gt;return promise;&gt;&#125;;&gt;getJSON(&quot;./hong.json&quot;).then(function(json) &#123;&gt;console.log(&#x27;Contents: &#x27; , json);&gt;&#125;, function(error) &#123;&gt;console.error(&#x27;出错了&#x27;, error);&gt;&#125;); 上面代码中，getJSON是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。 小贴士:此处可能有同学想尝试却发现读取本地文件会有跨域问题,这边教一下你们 resolve() 的参数可以是另一个 Promise 实例 如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。 123&gt;const p1 = new Promise(function (resolve, reject) &#123;&#125;);&gt;const p2 = new Promise(function (resolve, reject) &#123; resolve(p1) &#125;) 上面代码中，p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。 注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。 123456789101112&gt;const p1 = new Promise(function (resolve, reject) &#123;&gt;setTimeout(() =&gt; reject(new Error(&#x27;p1的状态改为错误&#x27;)), 0)&gt;&#125;)&gt;const p2 = new Promise(function (resolve, reject) &#123;&gt;setTimeout(() =&gt; resolve(p1), 3000) //将p1 传给p2&gt;&#125;)&gt;p2.then(result =&gt; console.log(result),result=&gt;console.log(&#x27;失败&#x27;))&gt;.catch(error =&gt; console.log(&#x27;catch异常捕获:&#x27;+error))&gt;//首先报错&gt;//运行三秒后打印: 失败 上面代码运行后执行效果: 首先马上会打印一个报错 : “Uncaught (in promise) Error: p1的状态改为错误” (红色报错) 然后等3秒后再打印: ‘失败’ 注意: 如果 p2.then() 中没有写 reject 回调函数(第二个参数),则会被 catch 捕获,变为catch异常捕获:Error: p1的状态改为错误 解释: 首先前面说过,promise定义时就会立即执行,所以刚开始就运行了 p1 的reject(),所以直接控制台报错了 resolve方法返回的是p1。由于p2返回的是另一个 Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态 总结来说,promise返回promise这种嵌套形式,将由最内层的promise决定外层的状态 调用resolve或reject并不会终结 Promise 的参数函数的执行 调用resolve或reject并不会终结 Promise 的参数函数的执行。 12345678&gt;new Promise((resolve, reject) =&gt; &#123;&gt;resolve(1);&gt;console.log(2);&gt;&#125;).then(r =&gt; &#123;&gt;console.log(r);&gt;&#125;);&gt;// 2&gt;// 1 上面代码中，调用resolve(1)以后，后面的console.log(2)还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。 建议在修改状态函数前加return 一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。 12345&gt;new Promise((resolve, reject) =&gt; &#123;&gt;return resolve(1);&gt;// 后面的语句不会执行&gt;console.log(2);&gt;&#125;) 有同学可能就会问了,不加感觉也没啥事啊,反正我在这个函数体内就是要做这些操作,放在 resolve/reject前后好像都不影响啊! 这里我给举个实际场景 不加 return 导致的错误场景举🌰 一般来说,错误发生在 Promise 内,是不会传到外部的,只会在 Promise 内部消化,详见下方API详解部分的 ②Promise.prototype.catch()) 1234567&gt;const promise = new Promise(function (resolve, reject) &#123;&gt;resolve(&#x27;成功了&#x27;); //如果你加了 return , 函数执行到此步就停止了&gt;setTimeout(function () &#123; throw new Error(&#x27;错误错误!!!!!&#x27;) &#125;, 0)&gt;&#125;);&gt;promise.then(function (value) &#123; console.log(value) &#125;);&gt;// ok&gt;// Uncaught Error: 错误错误!!!! 上面代码中，Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。 Ⅱ - API 用法详解 此处将对于所有API进行详细剖析,参照资料为 阮一峰的ES6日志(原作者这里没有给出链接） Promise.prototype.then() Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。 then方法返回的是一个新的Promise实例 then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。 12345&gt;getJSON(&quot;./hong.json&quot;).then(function(json) &#123;&gt;return json.name;&gt;&#125;).then(function(name) &#123;&gt;console.log(`My name is $&#123;name&#125;` )&gt;&#125;); 上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。 采用链式的then, 会等待前一个Promise状态发生改变才会被调用 采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。 123456&gt;getJSON(&quot;./hong.json&quot;)&gt;.then(function(json) &#123; return getJSON(json.name)&#125;)&gt;.then(&gt;function (name) &#123; console.log(&quot;resolved: My name is &quot;, name)&#125;, &gt;function (err)&#123; console.log(&quot;rejected: &quot;, err)&#125;&gt;); 上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为resolved，就调用第一个回调函数，如果状态变为rejected，就调用第二个回调函数。 使用箭头函数简写 如果采用箭头函数，上面的代码可以写得更简洁 (实际代码中基本都是这样写了) 123456&gt;getJSON(&quot;./hong.json&quot;)&gt;.then(json =&gt; getJSON(json.name) )&gt;.then( name =&gt; console.log(&quot;resolved: My name is &quot;, name), &gt;err =&gt; console.log(&quot;rejected: &quot;, err)&gt;); Promise.prototype.catch() Promise.prototype.catch()方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。 基本用法 123456&gt;getJSON(&#x27;./hong.json&#x27;)&gt;.then(function(posts) &#123;&#125;)&gt;.catch(function(error) &#123; // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log(&#x27;发生错误！&#x27;, error); &#125;); 上面代码中，getJSON()方法返回一个 Promise 对象 如果该对象状态变为resolved，则会调用then()方法指定的回调函数； 如果异步操作抛出错误，状态就会变为rejected，就会调用catch()方法指定的回调函数，处理这个错误 另外，then()方法指定的回调函数，如果运行中抛出错误，也会被catch()方法捕获。 被 catch 方法捕获的前提是前方的 then() 方法中没有对 rejected 进行捕获处理(即没有写reject回调函数) 12345&gt;p.then((val) =&gt; console.log(&#x27;指定成功回调:&#x27;, val))&gt;.catch((err) =&gt; console.log(&#x27;在catch中进行 rejected 的处理&#x27;, err));&gt;// 等同于&gt;p.then((val) =&gt; console.log(&#x27;指定成功回调:&#x27;, val))&gt;.then(null, (err) =&gt; console.log(&quot;等同于另起一个then,只指定 rejected 的处理&quot;, err)); reject()方法的作用，等同于抛出错误 1234567&gt;const promise = new Promise(function(resolve, reject) &#123;&gt;throw new Error(&#x27;直接抛出错误&#x27;);&gt;&#125;);&gt;promise.catch(function(error) &#123;&gt;console.log(&#x27;异常捕获: &#x27;,error);&gt;&#125;);&gt;//异常捕获: Error: 直接抛出错误 上面代码中，promise抛出一个错误，就被catch()方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。 1234567891011121314151617181920212223&gt;/****************** 写法一 ***************************************/&gt;const promise = new Promise(function(resolve, reject) &#123;&gt;try &#123;&gt;throw new Error(&#x27;直接抛出错误&#x27;);&gt;&#125; catch(e) &#123;&gt;console.log(&#x27;进入catch,然后再用 reject(e)抛出 &#x27;)&gt;reject(e) &gt;&#125;&gt;&#125;);&gt;promise.catch(function(error) &#123;&gt;console.log(error);&gt;&#125;);&gt;//进入catch,然后再用 reject(e)抛出 &gt;//Error: 直接抛出错误&gt;/****************** 写法二 ***************************************/&gt;const promise1 = new Promise(function(resolve, reject) &#123;&gt;reject(new Error(&#x27;使用 reject() 抛出错误&#x27;));&gt;&#125;);&gt;promise1.catch(function(error) &#123;&gt;console.log(error);&gt;&#125;);&gt;//Error: 使用 reject() 抛出错误 比较上面两种写法，可以发现reject()方法的作用，等同于抛出错误,所以不必用try..catch()去承接后再去抛出了 如果 Promise 状态已经被修改，再抛出错误是无效的 12345678&gt;const promise = new Promise(function(resolve, reject) &#123;&gt;resolve(&#x27;成功了&#x27;); //换成 reject(&#x27;成功了&#x27;) 结果也是一样的&gt;throw new Error(&#x27;成功后扔抛出异常&#x27;);&gt;&#125;);&gt;promise&gt;.then(function(value) &#123; console.log(value) &#125;)&gt;.catch(function(error) &#123; console.log(error) &#125;);&gt;// 成功了 上面代码中，Promise 在resolve/reject语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了(前面有说过) Promise 对象的错误具有 “冒泡” 性质 Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。 123456789&gt;getJSON(&#x27;./hong.json&#x27;) //第一个promise&gt;.then(function(post) &#123; //第二个promise return getJSON(post.commentURL)&#125;)&gt;.then(function(comments) &#123; //第三个promise&#125;)&gt;.catch(function(error) &#123; // 处理前面三个Promise产生的错误&#125;); 上面代码中，一共有三个 Promise 对象(then返回的仍可能是一个Promise对象)：一个由getJSON()产生，两个由then()产生。它们之中任何一个抛出的错误，都会被最后一个catch()捕获。 也是因为这个特性,有了 异常穿透问题 异常穿透问题 当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调 前面任何操作出了异常, 都会传到最后失败的回调中处理 1234567891011121314151617&gt;getJSON(&#x27;./hong.json&#x27;)&gt;.then(function(posts) &#123; throw new Error(&#x27;抛出异常&#x27;) &#125;).then(res=&gt;console.log(res),e=&gt;console.log(&#x27;被then的错误回调捕获&#x27;,e) )&gt;.catch(function(error) &#123; // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log(&#x27;错误捕获: &#x27;, error);&#125;);&gt;//执行结果: 被then的错误回调捕获 Error: 抛出异常&gt;/******************** 利用异常穿透 ****************************************/&gt;getJSON(&#x27;./hong.json&#x27;)&gt;.then(function(posts) &#123; throw new Error(&#x27;抛出异常&#x27;) &#125;).then(res=&gt;console.log(res) ) //此处差异,不指定 reject 回调,利用异常穿透传到最后&gt;.catch(function(error) &#123; console.log(&#x27;错误捕获: &#x27;, error);&#125;);&gt;//执行结果: 错误捕获: Error: 抛出异常 注:可以在每个then()的第二个回调函数中进行err处理,也可以利用异常穿透特性,到最后用catch去承接统一处理,两者一起用时,前者会生效(因为err已经将其处理,就不会再往下穿透)而走不到后面的catch 建议使用 catch() 进行异常处理 一般来说，不要在then()方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。 12345678910&gt;// bad&gt;promise&gt;.then(&gt;data=&gt; console.log(&#x27;成功&#x27;,data),&gt;err=&gt;console.log(&#x27;失败了&#x27;,err));&gt;/********* 好的写法 ********************/&gt;promise&gt;.then( data=&gt; console.log(&#x27;成功&#x27;,data)) //只指定成功回调&gt;.catch( err=&gt;console.log(&#x27;失败了&#x27;,err)); 上面代码中，第二种写法要好于第一种写法: 理由是第二种写法可以捕获前面then方法执行中的错误 也更接近同步的写法（try/catch） 因此, 建议总是使用catch()方法，而不使用then()方法的第二个参数。 与传统 try/catch 代码块的差异 跟传统的try/catch代码块不同的是，如果没有使用catch()方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。 123456789101112&gt;const someAsyncThing = function() &#123;&gt;return new Promise(function(resolve, reject) &#123;&gt;// 下面一行会报错，因为hong 没有声明&gt;resolve( hong );&gt;&#125;);&gt;&#125;;&gt;//Promise 的 then() 处理,但不处理异常&gt;someAsyncThing().then(function() &#123; console.log(&#x27;只指定成功回调,不处理异常错误&#x27;) &#125;);&gt;setTimeout(() =&gt; &#123; console.log(&#x27;努力学习的汪&#x27;) &#125;, 2000);&gt;// Uncaught (in promise) ReferenceError: hong is not defined&gt;// 努力学习的汪 上面代码中，someAsyncThing()函数产生的 Promise 对象，内部有语法错误。 浏览器运行到这一行，会打印出错误提示Uncaught (in promise) ReferenceError: hong is not defined 但是不会退出进程、终止脚本执行, 2 秒之后还是会输出努力学习的汪。 这就是说，Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。 catch()方法后还能跟 then() 方法 一般总是建议，Promise 对象后面要跟catch()方法，这样可以处理 Promise 内部发生的错误。catch()方法返回的还是一个 Promise 对象，因此后面还可以接着调用then()方法。 123456789101112&gt;const someAsyncThing = function() &#123;&gt;return new Promise(function(resolve, reject) &#123;&gt;// 下面一行会报错，因为 hong 没有声明&gt;resolve( hong );&gt;&#125;);&gt;&#125;;&gt;someAsyncThing()&gt;.catch(function(error) &#123; console.log(&#x27;捉到错误咯:&#x27;, error)&#125;)&gt;.then(function() &#123; console.log(&#x27;错误捕获后我还要浪&#x27;) &#125;);&gt;//捉到错误咯: ReferenceError: hong is not defined&gt;//错误捕获后我还要浪 上面代码运行完catch()方法指定的回调函数，会接着运行后面那个then()方法指定的回调函数。 如果没有报错，则会跳过catch()方法。 1234&gt;Promise.resolve(&#x27;硬是成功了&#x27;)&gt;.catch(function(error) &#123; console.log(&#x27;捉错误&#x27;, error) &#125;)&gt;.then(v =&gt; console.log(&#x27;catch后面的then: &#x27;,v) );&gt;//catch后面的then: 硬是成功了 上面的代码因为没有报错，跳过了catch()方法，直接执行后面的then()方法。此时，要是then()方法里面报错，就与前面的catch()无关了。 catch()方法之中，还能再抛出错误 catch()方法之中，还能再抛出错误。 123456789101112131415161718&gt;const someAsyncThing = function() &#123;&gt;return new Promise(function(resolve, reject) &#123;&gt;// 下面一行会报错，因为 hong 没有声明&gt;resolve( hong );&gt;&#125;);&gt;&#125;;&gt;someAsyncThing()&gt;.then(() =&gt; someOtherAsyncThing()) &gt;.catch(function(error) &#123; console.log(&#x27;ctach:&#x27;, error); // 下面一行会报错，因为 sum 没有声明 sum ++;&#125;)&gt;.then(function() &#123; console.log(&#x27;捕获后的then()&#x27;)&#125;);&gt;// ctach: [ReferenceError: hong is not defined]&gt;// Uncaught (in promise) ReferenceError: sum is not defined 上面代码中，catch()方法抛出一个错误，因为后面没有别的catch()方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。 1234567891011&gt;someAsyncThing().then(function() &#123;&gt;return someOtherAsyncThing();&gt;&#125;).catch(function(error) &#123;&gt;console.log(&#x27;catch: &#x27;, error);&gt;// 下面一行会报错，因为 sum 没有声明&gt;sum ++;&gt;&#125;).catch(function(error) &#123;&gt;console.log(&#x27;catch()后的catch: &#x27;, error);&gt;&#125;);&gt;//catch: ReferenceError: hong is not defined&gt;//catch()后的catch: ReferenceError: sum is not defined 上面代码中，第二个catch()方法用来捕获前一个catch()方法抛出的错误。 Promise.prototype.finally() finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。 1234&gt;promise&gt;.then(result =&gt; &#123;···&#125;)&gt;.catch(error =&gt; &#123;···&#125;)&gt;.finally(() =&gt; &#123;···&#125;); 上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。 finally方法的回调函数不接受任何参数， 这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。 这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。 a) finally本质上是then方法的特例 123456789&gt;promise&gt;.finally(() =&gt; &#123;&#125;);&gt;// 等同于&gt;promise&gt;.then(&gt;result =&gt; result ,&gt;error =&gt; throw error&gt;); 上面代码中，如果不使用finally方法，同样的语句需要为成功和失败两种情况各写一次。有了finally方法，则只需要写一次。 它的实现 它的实现也很简单。 1234567&gt;Promise.prototype.finally = function (callback) &#123;&gt;let P = this.constructor;&gt;return this.then(&gt;value =&gt; P.resolve(callback()).then(() =&gt; value),&gt;reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;)&gt;);&gt;&#125;; 上面代码中，不管前面的 Promise 是fulfilled还是rejected，都会执行回调函数callback。 从上面的实现还可以看到，finally方法总是会返回原来的值(传入什么即传出什么) 1234567891011&gt;// resolve 的值是 undefined&gt;Promise.resolve(2).then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;)&gt;// resolve 的值是 2&gt;Promise.resolve(2).finally(() =&gt; &#123;&#125;)&gt;// reject 的值是 undefined&gt;Promise.reject(3).then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;)&gt;// reject 的值是 3&gt;Promise.reject(3).finally(() =&gt; &#123;&#125;) Promise.all() Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 1&gt;const p = Promise.all([p1, p2, p3]); Promise.all()方法接受一个数组作为参数， p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。 另外，Promise.all()方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。 返回的状态由什么决定? p的状态由p1、p2、p3决定，分成两种情况。 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 下面是一个具体的例子。12345678910&gt;// 生成一个Promise对象的数组&gt;const promises = [&#x27;hong&#x27;, 1, 2, 3, 4, 5].map(item &#123;&gt;return getJSON( item+&#x27;.json&#x27;);&gt;&#125;);&gt;Promise.all(promises).then(function (posts) &#123;&gt;// ...&gt;&#125;).catch(function(reason)&#123;&gt;// ...&gt;&#125;); 上面代码中，promises是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态 都 变成fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数。 下面是另一个例子12345678910111213&gt;const databasePromise = connectDatabase(); //假设定义了一个异步方法,此方法能拿到你需要的所有数据&gt;const booksPromise = databasePromise //定义一个方法,在 databasePromise() 执行后寻找其内部书本信息&gt;.then(findAllBooks);&gt;const userPromise = databasePromise //定义一个方法,在 databasePromise() 执行后寻找其内部当前用户信息&gt;.then(getCurrentUser);&gt;Promise.all([&gt;booksPromise,&gt;userPromise&gt;])&gt;.then(([books, user]) =&gt; pickTopRecommendations(books, user)); 上面代码中，booksPromise和userPromise是两个异步操作，只有等到它们的结果都返回了，才会触发pickTopRecommendations这个回调函数。 如果参数中的Promise实例定义了自己的catch方法 ? 注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。 1234567891011121314151617181920&gt;//定义一个状态将为成功的的promise&gt;const p1 = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;hello&#x27;)&#125;)&gt;.then(result =&gt; result)&gt;.catch(e =&gt; e);&gt;//定义一个将抛出错误的promise&gt;const p2 = new Promise((resolve, reject) =&gt; &#123; throw new Error(&#x27;报错了&#x27;) &#125;)&gt;.then(result =&gt; result)&gt;.catch(e =&gt;&#123;&gt;console.log(&#x27;p2自己的catch捕获: &#x27;, e)&gt;return e; //异常获取后原样返回,不做修改&gt;&#125;);&gt;//调用 Promise.all 方法&gt;Promise.all([p1, p2])&gt;.then(result =&gt; console.log(&#x27; Promise.all 方法中的成功回调: &#x27;, result))&gt;.catch(e =&gt; console.log(&quot; Promise.all 方法中的catch&quot;, e));&gt;//p2自己的catch捕获: Error: 报错了&gt;// Promise.all 方法中的成功回调: (2) [&#x27;hello&#x27;, Error: 报错了] 上面代码中， p1会resolved，p2首先会rejected 但是p2有自己的catch方法，该方法返回的是一个新的 Promise 实例，p2指向的实际上是这个实例。 该实例执行完catch方法后，也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved 因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数 如果参数中的Promise实例 没有 定义自己的catch方法 ? 如果p2没有自己的catch方法，就会调用Promise.all()的catch方法。 1234567891011121314&gt;//定义一个状态将为成功的的promise&gt;const p1 = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;hello&#x27;)&#125;)&gt;.then(result =&gt; result)&gt;//定义一个将抛出错误的promise&gt;const p2 = new Promise((resolve, reject) =&gt; &#123; throw new Error(&#x27;报错了&#x27;) &#125;)&gt;.then(result =&gt; result)&gt;//调用 Promise.all 方法&gt;Promise.all([p1, p2])&gt;.then(result =&gt; console.log(&#x27; Promise.all 方法中的成功回调: &#x27;, result))&gt;.catch(e =&gt; console.log(&quot; Promise.all 方法中的catch&quot;, e));&gt;// Promise.all 方法中的catch Error: 报错了 Promise.race() Promise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。 1&gt;const p = Promise.race([p1, p2, p3]); 上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。 Promise.race()方法的参数与Promise.all()方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve()方法，将参数转为 Promise 实例，再进一步处理。 举个简单的🌰 如p1延时,开启了异步,内部正常是同步进行,所以p2&gt;p3&gt;p1,结果是P2 12345678910&gt;let p1 = new Promise((resolve, reject) =&gt; &#123;&gt;setTimeout(() =&gt; &#123;&gt;resolve(&#x27;OK&#x27;);&gt;&#125;, 1000);&gt;&#125;)&gt;let p2 = Promise.resolve(&#x27;Success&#x27;);&gt;let p3 = Promise.resolve(&#x27;Oh Yeah&#x27;);&gt;//调用&gt;const result = Promise.race([p1, p2, p3]);&gt;console.log(result); 举个应用实🌰 下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为reject，否则变为resolve。 12345678910&gt;const p = Promise.race([&gt;fetch(&#x27;https://gitee.com/hongjilin&#x27;),&gt;new Promise(function (resolve, reject) &#123;&gt;setTimeout(() =&gt; reject(new Error(&#x27;请求超时!!!!&#x27;)), 5000)&gt;&#125;)&gt;]);&gt;p&gt;.then(console.log)&gt;.catch(console.error); 上面代码中，如果 5 秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数。 是不是很好用又简单 Promise.allSettled() Promise.allSettled()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。 只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束。 该方法由 ES2020 引入。 举个简单的🌰 12345678&gt;const promises = [&gt;fetch(&#x27;https://gitee.com/hongjilin&#x27;),&gt;fetch(&#x27;https://github.com/Hongjilin&#x27;),&gt;fetch(&#x27;./hong.json&#x27;),&gt;];&gt;loading = true; //请求前将 loading 改为true ; 页面出现滚动加载图标蒙层&gt;await Promise.allSettled(promises);&gt;loading = false; 上面代码对服务器发出三个请求，等到三个请求都结束，不管请求成功还是失败，加载的滚动图标就会消失。 该方法返回的新的 Promise 实例，一旦结束，状态总是fulfilled，不会变成rejected 该方法返回的新的 Promise 实例，一旦结束，状态总是fulfilled，不会变成rejected。状态变成fulfilled后，Promise 的监听函数接收到的参数是一个数组，每个成员对应一个传入Promise.allSettled()的 Promise 实例。 1234567891011121314&gt;const resolved = Promise.resolve(&#x27;返回成功状态的promise&#x27;);&gt;const rejected = Promise.reject(&#x27;返回失败状态的promise&#x27;);&gt;const allSettledPromise = Promise.allSettled([resolved, rejected]);&gt;// Promise.allSettled 得到的新实例状态只会是 `fulfilled`&gt;allSettledPromise.then(function (results) &#123;&gt;console.log(results); //注意,这是 `fulfilled` 的回调函数,只有其状态为成功才能进到这里&gt;&#125;);&gt;/*&gt;[&#123; &quot;status&quot;: &quot;fulfilled&quot;, &quot;value&quot;: &quot;返回成功状态的promise&quot; &#125;,&#123; &quot;status&quot;: &quot;rejected&quot;, &quot;reason&quot;: &quot;返回失败状态的promise&quot; &#125;&gt;]&gt;*/ Promise.allSettled()的返回值allSettledPromise，状态只可能变成fulfilled(注意,是 allSettledPromise 的状态,而不是内部的promise实例) 它的监听函数接收到的参数是数组results。该数组的每个成员都是一个对象，对应的是传入Promise.allSettled()的 Promise 实例。 每个对象都有status属性，该属性的值只可能是字符串fulfilled或字符串rejected。 fulfilled时，对象有value属性，rejected时有reason属性，对应两种状态的返回值。 举个返回值用法的🌰 12345678910&gt;const promises = [ fetch(&#x27;./hong.json&#x27;), fetch(&#x27;https://gitee.com/hongjilin&#x27;) ];&gt;const results = await Promise.allSettled(promises);&gt;// 过滤出成功的请求&gt;const successfulPromises = results.filter(item =&gt; item.status === &#x27;fulfilled&#x27;);&gt;// 过滤出失败的请求，并取得它们的失败原因&gt;const errors = results&gt;.filter(p =&gt; p.status === &#x27;rejected&#x27;)&gt;.map(p =&gt; p.reason); 有时候，我们不关心异步操作的结果，只关心这些操作有没有结束。这时，Promise.allSettled()方法就很有用。如果没有这个方法，想要确保所有操作都结束，就很麻烦。Promise.all()方法无法做到这一点。 123456789&gt;const urls = [ &#x27;https://gitee.com/hongjilin&#x27; ,&#x27;https://github.com/Hongjilin&#x27;];&gt;const requests = urls.map(x =&gt; fetch(x));&gt;//举例用 Promise.all 尝试实现,很明显,难以实现&gt;try &#123;&gt;await Promise.all(requests);&gt;console.log(&#x27;所有请求都成功。&#x27;);&gt;&#125; catch &#123;&gt;console.log(&#x27;至少一个请求失败，其他请求可能还没结束。&#x27;);&gt;&#125; 上面代码中，Promise.all()无法确定所有请求都结束。想要达到这个目的，写起来很麻烦，有了Promise.allSettled()，这就很容易了 Promise.any() ES2021 引入了Promise.any()方法。该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。 与 Promise.race() 方法的区别 Promise.any()跟Promise.race()方法很像，只有一点不同，就是不会因为某个 Promise 变成rejected状态而结束。 1234567891011&gt;const promises = [&gt;fetch(&#x27;https://gitee.com/hongjilin&#x27;).then(() =&gt; &#x27;a&#x27;),&gt;fetch(&#x27;https://github.com/Hongjilin&#x27;).then(() =&gt; &#x27;b&#x27;),&gt;fetch(&#x27;./hong.json&#x27;).then(() =&gt; &#x27;c&#x27;),&gt;];&gt;try &#123;&gt;const first = await Promise.any(promises);&gt;console.log(first);&gt;&#125; catch (error) &#123;&gt;console.log(error);&gt;&#125; 上面代码中，Promise.any()方法的参数数组包含三个 Promise 操作。其中只要有一个变成fulfilled，Promise.any()返回的 Promise 对象就变成fulfilled。如果所有三个操作都变成rejected，那么await命令就会抛出错误。 Promise.any() 抛出的错误 Promise.any()抛出的错误，不是一个一般的错误，而是一个 AggregateError 实例。它相当于一个数组，每个成员对应一个被rejected的操作所抛出的错误。下面是 AggregateError 的实现示例。 123456&gt;new AggregateError() extends Array -&gt; AggregateError&gt;const err = new AggregateError();&gt;err.push(new Error(&quot;first error&quot;));&gt;err.push(new Error(&quot;second error&quot;));&gt;throw err; 捕捉错误时，如果不用try...catch结构和 await 命令，可以像下面这样写。 12345678&gt;Promise.any(promises).then(&gt;(first) =&gt; &#123;&gt;// Any of the promises was fulfilled.&gt;&#125;,&gt;(error) =&gt; &#123;&gt;// All of the promises were rejected.&gt;&#125;&gt;); 再举个🌰 下面是一个例子。 1234567891011&gt;const resolved = Promise.resolve(&#x27;成功&#x27;);&gt;const rejected = Promise.reject(&#x27;失败了&#x27;);&gt;const alsoRejected = Promise.reject(&#x27;太失败了&#x27;);&gt;Promise.any([resolved, rejected, alsoRejected]).then(function (result) &#123;&gt;console.log(result); // 成功&gt;&#125;);&gt;Promise.any([rejected, alsoRejected]).catch(function (results) &#123;&gt;console.log(results); //AggregateError: All promises were rejected&gt;&#125;); 三个Promise中有一个为成功,则总的结果就是成功,三个中全部失败,才会变成失败 Promise.resolve() 有时需要将现有对象转为 Promise 对象，Promise.resolve()方法就起到这个作用。 1&gt;const jsPromise = Promise.resolve($.ajax(&#x27;https://gitee.com/hongjilin&#x27;)); 上面代码将 jQuery 生成的deferred对象，转为一个新的 Promise 对象。 Promise.resolve()等价于下面的写法。 123&gt;Promise.resolve(&#x27;努力学习的汪&#x27;)&gt;// 等价于&gt;new Promise(resolve =&gt; resolve(&#x27;努力学习的汪&#x27;)) Promise.resolve()方法的参数分成四种情况 参数是一个 Promise 实例 如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。 参数是一个thenable对象 thenable对象指的是具有then方法的对象，比如下面这个对象。 12345&gt;let thenable = &#123;then: function(resolve, reject) &#123; resolve(&#x27;成功&#x27;);&#125;&gt;&#125;; Promise.resolve()方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then()方法。 12345678&gt;let thenable = &#123;then: function(resolve, reject) &#123; resolve(&#x27;成功&#x27;) &#125;&gt;&#125;;&gt;let p1 = Promise.resolve(thenable);&gt;p1.then(function (value) &#123;console.log(value); // &#x27;成功&#x27;&gt;&#125;); 上面代码中，thenable对象的then()方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then()方法指定的回调函数，输出 ‘成功’。 参数不是具有then()方法的对象，或根本就不是对象 如果参数是一个原始值，或者是一个不具有then()方法的对象，则Promise.resolve()方法返回一个新的 Promise 对象，状态为resolved。 123456&gt;const p = Promise.resolve(&#x27;努力学习的汪&#x27;);&gt;p.then(function (s) &#123;&gt;console.log(s)&gt;&#125;);&gt;// 努力学习的汪 上面代码生成一个新的 Promise 对象的实例p。 由于字符串 努力学习的汪 不属于异步操作（判断方法是字符串对象不具有 then 方法） 返回 Promise 实例的状态从一生成就是resolved，所以回调函数会立即执行 Promise.resolve()方法的参数会同时传给回调函数作为其参数 不带有任何参数 Promise.resolve()方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。 所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用Promise.resolve()方法。 123&gt;const p = Promise.resolve();&gt;p.then(function () &#123;&#125;); 上面代码的变量p就是一个 Promise 对象。 需要注意的是，立即resolve()的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时 —&gt; 不懂的同学请看 JavaScript笔记中的#4事件循环模型event-loop机制 ,本人在此有进行详细的解析 12345678910111213&gt;setTimeout(function () &#123;&gt;console.log(&#x27;three&#x27;); //这里是新的一轮事件循环&gt;&#125;, 0);&gt;Promise.resolve().then(function () &#123;&gt;console.log(&#x27;two&#x27;); //本轮同步代码结束后,新一轮事件循环前,就执行&gt;&#125;);&gt;console.log(&#x27;one&#x27;);&gt;// one&gt;// two&gt;// three 上面代码中，setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.resolve()在本轮“事件循环”结束时执行，console.log(&#39;one&#39;)则是立即执行，因此最先输出。 Promise.reject() Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。 12345678&gt;const p = Promise.reject(&#x27;出错了&#x27;);&gt;// 等同于&gt;const p = new Promise((resolve, reject) =&gt; reject(&#x27;出错了&#x27;))&gt;p.then(null, function (s) &#123;&gt;console.log(s)&gt;&#125;);&gt;// 出错了 上面代码生成一个 Promise 对象的实例p，状态为rejected，回调函数会立即执行。 Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。 12345&gt;Promise.reject(&#x27;出错了&#x27;)&gt;.catch(e =&gt; &#123;&gt;console.log(e === &#x27;出错了&#x27;)&gt;&#125;)&gt;// true 上面代码中，Promise.reject()方法的参数是一个字符串，后面catch()方法的参数e就是这个字符串。 Promise.try() 实际开发中，经常遇到一种情况：不知道或者不想区分，函数f是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管f是否包含异步操作，都用then方法指定下一步流程，用catch方法处理f抛出的错误。一般就会采用下面的写法。 1&gt;Promise.resolve().then(f) 上面的写法有一个缺点，就是如果f是同步函数，那么它会在本轮事件循环的末尾执行。 12345&gt;const f = () =&gt; console.log(&#x27;now&#x27;);&gt;Promise.resolve().then(f);&gt;console.log(&#x27;next&#x27;);&gt;// next&gt;// now 上面代码中，函数f是同步的，但是用 Promise 包装了以后，就变成异步执行了。 那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？ 写法一 : 用async函数来写 该知识点如果不懂的可以继续往下看,这是ES6的另外一块知识点内容 12345&gt;const f = () =&gt; console.log(&#x27;now&#x27;);&gt;(async () =&gt; f())();&gt;console.log(&#x27;next&#x27;);&gt;// now&gt;// next 上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的async函数，因此如果f是同步的，就会得到同步的结果；如果f是异步的，就可以用then指定下一步，就像下面的写法。 12&gt;(async () =&gt; f())()&gt;.then(...) 需要注意的是，async () =&gt; f()会吃掉f()抛出的错误。所以，如果想捕获错误，要使用promise.catch方法。 123&gt;(async () =&gt; f())()&gt;.then(...)&gt;.catch(...) 写法二 : 使用new Promise() 123456789&gt;const f = () =&gt; console.log(&#x27;now&#x27;);&gt;(&gt;() =&gt; new Promise(&gt;resolve =&gt; resolve(f())&gt;)&gt;)();&gt;console.log(&#x27;next&#x27;);&gt;// now&gt;// next 上面代码也是使用立即执行的匿名函数，执行new Promise()。这种情况下，同步函数也是同步执行的。 Promise.try的引出 鉴于这是一个很常见的需求，所以现在有一个提案，提供Promise.try方法替代上面的写法。 12345&gt;const f = () =&gt; console.log(&#x27;now&#x27;);&gt;Promise.try(f);&gt;console.log(&#x27;next&#x27;);&gt;// now&gt;// next 事实上，Promise.try存在已久，Promise 库Bluebird、Q和when，早就提供了这个方法。 由于Promise.try为所有操作提供了统一的处理机制，所以如果想用then方法管理流程，最好都用Promise.try包装一下。这样有许多好处，其中一点就是可以更好地管理异常。 123456&gt;function getUsername(userId) &#123;&gt;return database.users.get(&#123;id: userId&#125;)&gt;.then(function(user) &#123;&gt;return user.name;&gt;&#125;);&gt;&#125; 上面代码中，database.users.get()返回一个 Promise 对象，如果抛出异步错误，可以用catch方法捕获，就像下面这样写。 123&gt;database.users.get(&#123;id: userId&#125;)&gt;.then(...)&gt;.catch(...) 但是database.users.get()可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用try...catch去捕获。 1234567&gt;try &#123;&gt;database.users.get(&#123;id: userId&#125;)&gt;.then(...)&gt;.catch(...)&gt;&#125; catch (e) &#123;&gt;// ...&gt;&#125; 上面这样的写法就很笨拙了，这时就可以统一用promise.catch()捕获所有同步和异步的错误。 123&gt;Promise.try(() =&gt; database.users.get(&#123;id: userId&#125;))&gt;.then(...)&gt;.catch(...) 事实上，Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码块。 自定义Promise手写 下方的Promise.prototype.then与Promise.resolve为什么一个挂载在prototype而另一个挂载在实例对象上? 解:原因是分别为静态方法与实例方法 —&gt;上面的需要new实例化的时候自动继承实例prototype上的方法和属性,所以用实例对象.then()来调用,而下面的Promise.resolve是静态方法,不用new,是可以直接Promise.resolve()调用 此部分可以跳过不看,类似手撕源码 Promise的实例方法实现初始结构搭建 html引入,该章节后续html大部分重复 除非必要,否则不再放上来 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Promise-封装 | 1 - 初始结构搭建&lt;/title&gt; &lt;script src=&quot;./promise.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; let p = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;OK&#x27;); &#125;); p.then(value =&gt; &#123; console.log(value); &#125;, reason=&gt;&#123; console.warn(reason); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; promise.js —&gt;使用原生写法,最后会改为class写法 123function Promise(executor)&#123;&#125;//添加 then 方法Promise.prototype.then = function(onResolved, onRejected)&#123;&#125; resolve 与 reject构建与基础实现 使用const self = this;保存this执行,使function中可以取得当前实例 ps:可以不使用该方法保存,但是下方function需要改为箭头函数,否则function默认指向是window 之后代码默认使用self保存this,箭头函数方式将在最后改为class写法时使用 默认设置 PromiseState = &#39;pending&#39;以及 PromiseResult = null,这就是promise状态基础 123456789101112131415161718192021222324252627//声明构造函数function Promise(executor) &#123; //添加属性 this.PromiseState = &#x27;pending&#x27;; this.PromiseResult = null; //保存实例对象的 this 的值/* 此处可以不写,但是下面function方法需要改为箭头函数,否则function默认指向是window */ const self = this; //resolve 函数 function resolve(data) &#123;-------------------------------------------- //1. 修改对象的状态 (promiseState) self.PromiseState = &#x27;fulfilled&#x27;; // resolved //2. 设置对象结果值 (promiseResult) self.PromiseResult = data; &#125; //reject 函数 function reject(data) &#123;---------------------------------------------- //1. 修改对象的状态 (promiseState) self.PromiseState = &#x27;rejected&#x27;; // //2. 设置对象结果值 (promiseResult) self.PromiseResult = data; &#125; //同步调用『执行器函数』 executor(resolve, reject);&#125;//添加 then 方法Promise.prototype.then = function (onResolved, onRejected) &#123;&#125; throw 抛出异常改变状态 在2的基础上进行修改:将执行器放入try-catch()中 在catch中使用reject()修改 promise 对象状态为『失败』 1234567try &#123; //同步调用『执行器函数』 executor(resolve, reject); &#125; catch (e) &#123; //修改 promise 对象状态为『失败』 reject(e); &#125; 状态只能修改一次 基于2 3代码中resolve和reject方法进修改 在成功与失败函数中添加判断if(self.PromiseState !== &#39;pending&#39;) return;,如果进入函数时状态不为pending直接退出,这样就能做到状态只能从pending改至其他状态且做到只能改一次 12345678910111213141516171819202122232425262728html调用-------------------------------------------------------- let p = new Promise((resolve, reject) =&gt; &#123; reject(&quot;error&quot;); resolve(&#x27;OK&#x27;); //抛出异常 // throw &quot;error&quot;; &#125;); console.log(p);promise.js修改-------------------------------------------------------- //resolve 函数 function resolve(data)&#123; //判断状态 if(self.PromiseState !== &#x27;pending&#x27;) return; //1. 修改对象的状态 (promiseState) self.PromiseState = &#x27;fulfilled&#x27;;// resolved //2. 设置对象结果值 (promiseResult) self.PromiseResult = data; &#125; //reject 函数 function reject(data)&#123; //判断状态 if(self.PromiseState !== &#x27;pending&#x27;) return; //1. 修改对象的状态 (promiseState) self.PromiseState = &#x27;rejected&#x27;;// //2. 设置对象结果值 (promiseResult) self.PromiseResult = data; &#125; hen 方法执行回调基础实现 修改Promise.prototype.then方法 传入then(成功回调,失败回调),当调用then后,会判断当前this.PromiseState的状态,当其为成功时调用成功回调,失败时调用失败回调 12345678910111213141516html调用------------------------------------------------------------ let p = new Promise((resolve, reject) =&gt; &#123; // resolve(&#x27;OK&#x27;);// reject(&quot;Error&quot;); throw &quot;ERROR&quot;; &#125;); p.then( value =&gt; &#123;console.log(value); &#125;, reason =&gt; &#123;console.warn(reason);&#125; )promise.js修改与实现-----------------------------------------------------//添加 then 方法Promise.prototype.then = function (onResolved, onRejected) &#123; //调用回调函数 PromiseState if (this.PromiseState === &#x27;fulfilled&#x27;) &#123;onResolved(this.PromiseResult);&#125; if (this.PromiseState === &#x27;rejected&#x27;) &#123;onRejected(this.PromiseResult);&#125;&#125; 异步任务 then 方法实现 此处对于5有四处修改,下面上js代码 当我运行异步代码后,我的执行器内部代码还未返回(因为用了定时器,里面的代码进入了异步队列),所以当我下面的.then()运行时:我的p为pending状态,所以根本不会执行resolve与reject方法 解:添加判断pending状态,将当前回调函数保存到实例对象(存到实例上是为了更方便)中,这样后续改变状态时候才调用得到 为什么要将回调保存到实例上而不是直接调用? 理由:因为我的回调函数需要在我的promise状态改变后(成功或者失败),再根据状态选择运行哪个函数所以当你调用then()时却检测到状态为pending,说明这时候的promise在异步队列 不能直接运行成功或者失败函数 解决:因为resolve与reject方法与then()不在同一个作用域中,并不能共享then(成功回调,失败回调)的参数,所以在判断状态为pending时将回调保存到实例对象上.然后将回调函数的调用放在resolve()与reject()中 这样当我代码运行到异步队列的resolve()或reject()时,就可以在这个函数中运行回调函数,实现异步then 此处的then仍有瑕疵,需要继续完善 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849html调用------------------------------------------------------------ //实例化对象 let p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123;reject(&quot;error&quot;); /* resolve(&#x27;OK&#x27;);*/&#125;, 1000); &#125;); p.then(value =&gt; &#123;console.log(value);&#125;,reason =&gt; &#123; console.warn(reason);&#125;); console.log(p);promise.js修改与实现-----------------------------------------------------//声明构造函数function Promise(executor) &#123; this.PromiseState = &#x27;pending&#x27;; this.PromiseResult = null; // 声明属性 this.callback = &#123;&#125;; -----------新添加1 const self = this; //resolve 函数 function resolve(data) &#123; //判断状态 if (self.PromiseState !== &#x27;pending&#x27;) return; self.PromiseState = &#x27;fulfilled&#x27;; self.PromiseResult = data; //调用成功的回调函数 加判断的原因是防止无回调报错 if (self.callback.onResolved) &#123; self.callback.onResolved(data); &#125; ------------新添加2 最重要 &#125; //reject 函数 function reject(data) &#123; if (self.PromiseState !== &#x27;pending&#x27;) return; self.PromiseState = &#x27;rejected&#x27;; self.PromiseResult = data; //执行回调 if (self.callback.onResolved) &#123; self.callback.onResolved(data);&#125; ------------新添加3 &#125; try &#123;executor(resolve, reject);&#125; catch (e) &#123;reject(e);&#125;&#125;//添加 then 方法Promise.prototype.then = function (onResolved, onRejected) &#123; //调用回调函数 PromiseState if (this.PromiseState === &#x27;fulfilled&#x27;) &#123;onResolved(this.PromiseResult);&#125; if (this.PromiseState === &#x27;rejected&#x27;) &#123; onRejected(this.PromiseResult);&#125; //判断 pending 状态 if (this.PromiseState === &#x27;pending&#x27;) &#123; ------------新添加4 //保存回调函数 this.callback = &#123; onResolved: onResolved, onRejected: onRejected &#125; &#125;&#125; 指定多个回调 基于6代码进行修改 只展示修改部分代码 6中保存回调函数的方式有BUG,如果我有多个.then(),后面加载的回调函数会覆盖之前的回调函数,导致最后回调函数有且只有最后一个 解:使用数组的方式进行存储回调函数,调用时也是用数组循环取出 此处的then仍有瑕疵,需要继续完善 1234567891011121314151617181920212223242526272829303132333435363738394041html调用------------------------------------------------------------//实例化对象 let p = new Promise((resolve, reject) =&gt; &#123;setTimeout(() =&gt; &#123;reject(&#x27;No&#x27;);&#125;, 1000);&#125;); p.then(value =&gt; &#123; console.log(value);&#125;, reason=&gt;&#123;console.warn(reason);&#125;); p.then(value =&gt; &#123; alert(value);&#125;, reason=&gt;&#123; alert(reason);&#125;); console.log(p);promise.js修改与实现-----------------------------------------------------Promise.prototype.then = function (onResolved, onRejected) &#123; //resolve 函数 function resolve(data)&#123; ..... //调用成功的回调函数 // if (self.callback.onResolved) &#123; self.callback.onResolved(data); &#125; self.callbacks.forEach(item =&gt; &#123; --------修改1 item.onResolved(data); &#125;); &#125; //reject 函数 function reject(data)&#123; ...... //执行失败的回调 // if (self.callback.onResolved) &#123; self.callback.onResolved(data);&#125; self.callbacks.forEach(item =&gt; &#123; ------修改2 item.onRejected(data); &#125;); &#125; //添加 then 方法Promise.prototype.then = function(onResolved, onRejected)&#123; ........ //判断 pending 状态 if(this.PromiseState === &#x27;pending&#x27;)&#123; //保存回调函数 // this.callback = &#123; onResolved: onResolved, onRejected: onRejected &#125; this.callbacks.push(&#123; --------修改3 onResolved: onResolved, onRejected: onRejected &#125;); &#125;&#125; 同步任务 then 返回结果 在之前的then运行结果中得知,我们使用 [ then ] 后的返回结果是其回调函数的返回结果,而我们需要的返回结果是一个新的promise对象 解:所以我们在then中return new Promise(),使其得到的是一个新的promise对象 在为解决问题1后产生一个新问题:新的promise对象因为没有用rejerect与resolve方法,导致返回的状态一直是pending 解:在新的promise中判断运行回调函数后的返回值是什么,然后根据其不同类型给其赋予不同状态 ​ Ⅰ-if(result instanceof Promise):返回值一个新的②promise对象(因为是新的promise的回调函数返回值,称②promise对象),在返回值(因为是promise对象)的.then()回调函数中使用rejerect与resolve方法,将其自身的状态赋予外层的promise, ​ 即 回调函数中的promise 赋值 给then返回值 , 所以 最终返回状态==回调函数中的新promise状态 ​ Ⅱ-如果返回值是一个非promise对象,返回状态设置为成功 ​ Ⅲ-如果返回值是一个异常,返回状态设置为失败 12345678910111213141516171819202122232425262728293031323334html调用------------------------------------------------------------ //实例化对象 let p = new Promise((resolve, reject) =&gt; &#123;resolve(&#x27;OK&#x27;);&#125;); //执行 then 方法 const res = p.then( value =&gt; &#123; throw &quot;FAIL&quot;;&#125;, reason =&gt; &#123; console.warn(reason);&#125;); console.log(res);promise.js修改与实现-----------------------------------------------------//添加 then 方法Promise.prototype.then = function(onResolved, onRejected)&#123; return new Promise((resolve, reject) =&gt; &#123; //调用回调函数 PromiseState // if(this.PromiseState === &#x27;fulfilled&#x27;)&#123; onResolved(this.PromiseResult);&#125; 未修改时代码 if(this.PromiseState === &#x27;fulfilled&#x27;)&#123; -------修改1 try&#123; //获取回调函数的执行结果 let result = onResolved(this.PromiseResult); //判断 if(result instanceof Promise)&#123;//如果是 Promise 类型的对象,我就将下一个promise结果赋予外层 result.then(v =&gt; &#123; resolve(v); &#125;,r=&gt;&#123;reject(r);&#125;) &#125;else&#123;resolve(result);&#125; //如果返回的不是promise对象,都将其赋予成功状态 &#125;catch(e)&#123; rejerect(e); //如果出错了,则返回失败状态 &#125; &#125; if(this.PromiseState === &#x27;rejected&#x27;)&#123; onRejected(this.PromiseResult);&#125;------此部分修改与修改1一样 //判断 pending 状态 if(this.PromiseState === &#x27;pending&#x27;)&#123; this.callbacks.push(&#123; onResolved: onResolved, onRejected: onRejected&#125;); &#125; &#125;)&#125; 异步任务 then 返回结果 异步任务是修改if(this.PromiseState === &#39;pending&#39;)后面的值,原因参考6,下面代码只举例这部分修改 因为我们需要增加then状态修改,所以在我们保存回调函数这一步我们可以对于回调函数进行加工,添加判断其回调函数的返回值的代码块再存入实例的回调函数中 Ⅰ-声明一个新的函数:其内部功能-&gt;先运行onResolved回调函数,再将其返回值取出,进行判断其返回值(这个过程同8) Ⅱ-加工后存入实例回调函数数组,之后在resolve与reject方法中调用即可(同6) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950html调用------------------------------------------------------------ //实例化对象 let p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123;reject(&quot;Error&quot;);&#125;, 1000)&#125;); // resolve(&#x27;OK&#x27;); //执行 then 方法 const res = p.then(value =&gt; &#123; // return &#x27;oh Yeah&#x27;; //如果有返回,根据其返回值得到相应的状态:字符串为成功,抛出为错误 throw &#x27;error&#x27;; &#125;, reason =&gt; &#123; console.warn(reason, &quot;xx&quot;); //如果只是打印没返回,则实际上时返回一个undefined, //在我们封装js中,undefined会判定为非promise对象,所以状态为成功,结果为undefined return &quot;sss&quot; // throw &#x27;error&#x27;; &#125;); console.log(res);promise.js修改与实现----------------------------------------------------- //判断 pending 状态 if (this.PromiseState === &#x27;pending&#x27;) &#123; //保存回调函数 this.callbacks.push(&#123; onResolved: function () &#123; try &#123; //执行成功回调函数 let result = onResolved(self.PromiseResult); //判断 其结果 if (result instanceof Promise) &#123; result.then( v =&gt; &#123; resolve(v);&#125;, r =&gt; &#123;reject(r);&#125; ) &#125; else &#123;resolve(result);&#125; &#125; catch (e) &#123;reject(e);&#125; &#125;, onRejected: function () &#123; try &#123; //执行成功回调函数 let result = onRejected(self.PromiseResult); //判断 if (result instanceof Promise) &#123; result.then( v =&gt; &#123;resolve(v); &#125;, r =&gt; &#123;reject(r);&#125; ) &#125; else &#123;resolve(result);&#125; &#125; catch (e) &#123; reject(e); &#125; &#125; &#125;); &#125; then方法代码优化 在8、9、10中可以看出,其判断与改变返回结果状态的代码块是基本重复的,所以可以将其抽出 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//添加 then 方法Promise.prototype.then = function (onResolved, onRejected) &#123; const self = this; return new Promise((resolve, reject) =&gt; &#123; 封装函数---------------------------------------------------------------------------- function callback(type) &#123; try &#123; //获取回调函数的执行结果 let result = type(self.PromiseResult); //判断 if (result instanceof Promise) &#123; //如果是 Promise 类型的对象 result.then(v =&gt; &#123; resolve(v); &#125;, r =&gt; &#123; reject(r); &#125;) &#125; else &#123; //结果的对象状态为『成功』 resolve(result); &#125; &#125; catch (e) &#123; reject(e); &#125; &#125; ----------------------------------------------------------------------------------- //调用回调函数 PromiseState if (this.PromiseState === &#x27;fulfilled&#x27;) &#123; callback(onResolved); &#125; if (this.PromiseState === &#x27;rejected&#x27;) &#123; callback(onRejected); &#125; //判断 pending 状态 if (this.PromiseState === &#x27;pending&#x27;) &#123; //保存回调函数 this.callbacks.push(&#123; onResolved: function () &#123; callback(onResolved); &#125;, onRejected: function () &#123; callback(onRejected); &#125; &#125;); &#125; &#125;)&#125; catch 方法与异常穿透与值传递 异常穿透:添加catch 方法,并且需要进行回调函数为undefined的处理 当我then()中只传一个回调或者不传回调函数时,运行代码会报错,因为运行时调用的回调函数是undefined 解:进行回调函数判断,当其为空时,基于默认回调函数内容:直接往外抛出这样下方的then() or catch()就可以承接到异常或者值 12345678910111213141516171819202122html调用------------------------------------------------------------ //实例化对象 let p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123;resolve(&#x27;OK&#x27;); &#125;, 1000); &#125;); //值传递 p.then() .then(value =&gt; &#123;console.log(222);&#125;) .then(value =&gt; &#123;console.log(333);&#125;) .catch(reason =&gt; &#123;console.warn(reason);&#125;);promise.js修改与实现-----------------------------------------------------//添加 then 方法Promise.prototype.then = function (onResolved, onRejected) &#123; ... -----------修改1 if (typeof onRejected !== &#x27;function&#x27;) &#123;onRejected = reason =&gt; &#123; throw reason;&#125;&#125; if (typeof onResolved !== &#x27;function&#x27;) &#123; onResolved = value =&gt; value;&#125; ....&#125;//添加 catch 方法 Promise.prototype.catch = function(onRejected)&#123; ---------------异常穿透 修改2 return this.then(undefined, onRejected);&#125; Promise的静态方法实现Promise.resolve 封装 判断传入的参数是否为promise对象: Ⅰ-如果为promise:将其状态与结果赋值给外层promise对象 Ⅱ-如果为非promise:状态设置为成功 1234567891011121314151617181920html调用------------------------------------------------------------ const p = Promise.resolve(&#x27;OK&#x27;); const p2 = Promise.resolve(new Promise((resolve, reject) =&gt; &#123; reject(&quot;error&quot;);// resolve(&#x27;Success&#x27;); &#125;)); const p3 = Promise.resolve(Promise.resolve(&#x27;Oh Yeah&#x27;)); console.log(p3);promise.js修改与实现-----------------------------------------------------//添加 resolve 方法Promise.resolve = function(value)&#123; //返回promise对象 return new Promise((resolve, reject) =&gt; &#123; if(value instanceof Promise)&#123; value.then( v=&gt;&#123;resolve(v);&#125;, r=&gt;&#123;reject(r);&#125; )&#125;else&#123;resolve(value); &#125;//状态设置为成功 &#125;);&#125; Promise.resolve 封装 不同于resolve,这个方法只要把传入参数再次传出去,并将状态改为失败即可 12345678910111213141516html调用------------------------------------------------------------ //Promise.reject const p = Promise.reject(&#x27;Error&#x27;); const p2 = Promise.reject(new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;OK&#x27;); &#125;)); console.log(p); console.log(p2);promise.js修改与实现-----------------------------------------------------//添加 reject 方法Promise.reject = function (reason) &#123; return new Promise((resolve, reject) =&gt; &#123; reject(reason); &#125;);&#125; Promise.all 封装 遍历传入的promise数组,每当遍历结果是成功,则用计数器记录,当计数器等同于数组长度,则全部成功,这时候可以返回成功状态 如果当数组中任意一个promise的执行结果是reject,直接中断,返回状态为失败 12345678910111213141516171819202122232425262728293031323334html调用------------------------------------------------------------ let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123;resolve(&#x27;OK&#x27;); &#125;, 1000) &#125;) let p2 = Promise.reject(&#x27;Success&#x27;); let p3 = Promise.resolve(&#x27;Oh Yeah&#x27;); //调用 all 方法 let result = Promise.all([p1, p2, p3]); console.log(result);promise.js修改与实现-----------------------------------------------------//添加 all 方法Promise.all = function (promises) &#123; //返回结果为promise对象 return new Promise((resolve, reject) =&gt; &#123; //声明变量 let count = 0; let arr = []; //遍历 for (let i = 0; i &lt; promises.length; i++) &#123; promises[i].then(v =&gt; &#123; //得知对象的状态是成功 //每个promise对象 都成功 count++; //将当前promise对象成功的结果 存入到数组中 arr[i] = v; //判断 if (count === promises.length) &#123;resolve(arr);&#125;//修改状态 &#125;, r =&gt; &#123; reject(r); &#125;); &#125; &#125;);&#125; Promise.race 封装 直接谁先执行就返回谁的运行结果即可 12345678910111213141516171819202122232425html调用------------------------------------------------------------ let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123;resolve(&#x27;OK&#x27;);&#125;); &#125;); let p2 = Promise.reject(&#x27;Success&#x27;); let p3 = Promise.resolve(&#x27;Oh Yeah&#x27;); //调用 race 方法 let result = Promise.race([p1, p2, p3]); console.log(result);promise.js修改与实现-----------------------------------------------------//添加 race 方法Promise.race = function (promises) &#123; return new Promise((resolve, reject) =&gt; &#123; for (let i = 0; i &lt; promises.length; i++) &#123; promises[i].then(v =&gt; &#123; //修改返回对象的状态为 『成功』 resolve(v); &#125;, r =&gt; &#123; //修改返回对象的状态为 『失败』 reject(r); &#125;) &#125; &#125;);&#125; 其他优化回调函数『异步执行』 如果我们运行下面代码,正确顺序是: 111 —&gt; 333 —&gt;444 123456789101112let p1 = new Promise((resolve, reject) =&gt; &#123; reject(&#x27;OK&#x27;); console.log(111); &#125;); p1.then(value =&gt; &#123; console.log(222); &#125;, reason =&gt; &#123; console.log(444); &#125;); console.log(333); 但当我们运行之前封装的 Promise 代码时,结果却是:111 —&gt; 444 —&gt; 333 我们需要将我们的then方法变成异步方法 我们只要在以下四处地方的回调函数调用外层包裹一层定时器(不一定是定时器,开启异步即可),即可做到异步操作 123456789101112131415161718192021&gt;function resolve(data)&#123; setTimeout(() =&gt; &#123; self.callbacks.forEach(item =&gt; &#123; item.onResolved(data); &#125;); &#125;);--修改1 &#125; //reject 函数 function reject(data)&#123; setTimeout(() =&gt; &#123; self.callbacks.forEach(item =&gt; &#123; item.onRejected(data); &#125;); &#125;);---修改2 &#125;&gt;//添加 then 方法&gt;Promise.prototype.then = function(onResolved, onRejected)&#123; return new Promise((resolve, reject) =&gt; &#123; //调用回调函数 PromiseState /* 修改前代码 if (this.PromiseState === &#x27;fulfilled&#x27;) &#123; callback(onResolved); &#125; if (this.PromiseState === &#x27;rejected&#x27;) &#123; callback(onRejected); */ if(this.PromiseState === &#x27;fulfilled&#x27;)&#123;setTimeout(() =&gt; &#123; callback(onResolved);&#125;);&#125; -----修改3 if(this.PromiseState === &#x27;rejected&#x27;)&#123; setTimeout(() =&gt; &#123; callback(onRejected);&#125;); ---修改4 &#125; &#125; 相关原理参照js事件循环机制、宏任务与微任务 class改写promise 其中将self=this保存this指向方式改为箭头函数表示(在上面示例中也有效果) 将其改为class写法 下面为promisedemo.js代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180&gt;class Promise &#123;//构造方法constructor(executor) &#123; //添加属性 this.PromiseState = &#x27;pending&#x27;; this.PromiseResult = null; //声明属性 this.callbacks = []; //保存实例对象的 this 的值 //resolve 函数 let resolve = (data) =&gt; &#123; //判断状态 if (this.PromiseState !== &#x27;pending&#x27;) return; //1. 修改对象的状态 (promiseState) this.PromiseState = &#x27;fulfilled&#x27;; // resolved //2. 设置对象结果值 (promiseResult) this.PromiseResult = data; //调用成功的回调函数 setTimeout(() =&gt; &#123; this.callbacks.forEach(item =&gt; &#123; item.onResolved(data); &#125;); &#125;); &#125; //reject 函数 let reject = (data) =&gt; &#123; //判断状态 if (this.PromiseState !== &#x27;pending&#x27;) return; //1. 修改对象的状态 (promiseState) this.PromiseState = &#x27;rejected&#x27;; // //2. 设置对象结果值 (promiseResult) this.PromiseResult = data; //执行失败的回调 setTimeout(() =&gt; &#123; this.callbacks.forEach(item =&gt; &#123; item.onRejected(data); &#125;); &#125;); &#125; try &#123; //同步调用『执行器函数』 executor(resolve, reject); &#125; catch (e) &#123; //修改 promise 对象状态为『失败』 reject(e); &#125;&#125;//then 方法封装then(onResolved, onRejected) &#123; //判断回调函数参数 if (typeof onRejected !== &#x27;function&#x27;) &#123; onRejected = reason =&gt; &#123; throw reason; &#125; &#125; if (typeof onResolved !== &#x27;function&#x27;) &#123; onResolved = value =&gt; value; //value =&gt; &#123; return value&#125;; &#125; return new Promise((resolve, reject) =&gt; &#123; //封装函数 let callback = (type) =&gt; &#123; try &#123; //获取回调函数的执行结果 let result = type(this.PromiseResult); //判断 if (result instanceof Promise) &#123; //如果是 Promise 类型的对象 result.then(v =&gt; &#123; resolve(v); &#125;, r =&gt; &#123; reject(r); &#125;) &#125; else &#123; //结果的对象状态为『成功』 resolve(result); &#125; &#125; catch (e) &#123; reject(e); &#125; &#125; //调用回调函数 PromiseState if (this.PromiseState === &#x27;fulfilled&#x27;) &#123; setTimeout(() =&gt; &#123; callback(onResolved); &#125;); &#125; if (this.PromiseState === &#x27;rejected&#x27;) &#123; setTimeout(() =&gt; &#123; callback(onRejected); &#125;); &#125; //判断 pending 状态 if (this.PromiseState === &#x27;pending&#x27;) &#123; //保存回调函数 this.callbacks.push(&#123; onResolved: function () &#123; callback(onResolved); &#125;, onRejected: function () &#123; callback(onRejected); &#125; &#125;); &#125; &#125;)&#125;//catch 方法catch (onRejected) &#123; return this.then(undefined, onRejected);&#125;//添加 resolve 方法static resolve(value) &#123; //返回promise对象 return new Promise((resolve, reject) =&gt; &#123; if (value instanceof Promise) &#123; value.then(v =&gt; &#123; resolve(v); &#125;, r =&gt; &#123; reject(r); &#125;) &#125; else &#123; //状态设置为成功 resolve(value); &#125; &#125;);&#125;//添加 reject 方法static reject(reason) &#123; return new Promise((resolve, reject) =&gt; &#123; reject(reason); &#125;);&#125;//添加 all 方法static all(promises) &#123; //返回结果为promise对象 return new Promise((resolve, reject) =&gt; &#123; //声明变量 let count = 0; let arr = []; //遍历 for (let i = 0; i &lt; promises.length; i++) &#123; // promises[i].then(v =&gt; &#123; //得知对象的状态是成功 //每个promise对象 都成功 count++; //将当前promise对象成功的结果 存入到数组中 arr[i] = v; //判断 if (count === promises.length) &#123; //修改状态 resolve(arr); &#125; &#125;, r =&gt; &#123; reject(r); &#125;); &#125; &#125;);&#125;//添加 race 方法static race(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; for (let i = 0; i &lt; promises.length; i++) &#123; promises[i].then(v =&gt; &#123; //修改返回对象的状态为 『成功』 resolve(v); &#125;, r =&gt; &#123; //修改返回对象的状态为 『失败』 reject(r); &#125;) &#125; &#125;);&#125;&gt;&#125; html文件调用 123456789101112131415161718192021222324252627282930&gt;&lt;!DOCTYPE html&gt;&gt;&lt;html lang=&quot;en&quot;&gt;&gt;&lt;head&gt;&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&gt;&lt;title&gt;class版本封装&lt;/title&gt;&gt;&lt;script src=&quot;./promisedemo.js&quot;&gt;&lt;/script&gt;&gt;&lt;/head&gt;&gt;&lt;body&gt;&gt;&lt;script&gt;&gt;let p1 = new Promise((resolve, reject) =&gt; &#123;setTimeout(() =&gt; &#123; // resolve(&quot;OK&quot;); reject(&quot;Erosssr&quot;);&#125;)&gt;&#125;);&gt;p1.then(value =&gt; &#123;console.log(value);&gt;&#125;, reason =&gt; &#123;console.warn(reason);&gt;&#125;);&gt;console.log(Promise.resolve(&#x27;OK&#x27;));&gt;&lt;/script&gt;&gt;&lt;/body&gt;&gt;&lt;/html&gt; Promise+ async + await 1)Promise==&gt;异步2)await==&gt;异步转同步 await 可以理解为是 async wait 的简写。await 必须出现在 async 函数内部，不能单独使用。 await 后面可以跟任何的JS 表达式。虽然说 await 可以等很多类型的东西，但是它最主要的意图是用来等待 Promise 对象的状态被 resolved。如果await的是 promise对象会造成异步函数停止执行并且等待 promise 的解决,如果等的是正常的表达式则立即执行 3)async==&gt;同步转异步 方法体内部的某个表达式使用await修饰，那么这个方法体所属方法必须要用async修饰所以使用awit方法会自动升级为异步方法 4)mdn文档 async await async函数 函数的返回值为 promise 对象 promise 对象的结果由 async 函数执行的返回值决定 await表达式 await 右侧的表达式一般为 promise 对象, 但也可以是其它的值 如果表达式是 promise 对象, await 返回的是 promise 成功的值 如果表达式是其它值, 直接将此值作为 await 的返回值 注意 await 必须写在 async 函数中, 但 async 函数中可以没有 await 如果 await 的 promise 失败了, 就会抛出异常, 需要通过 try…catch 捕获处理 原作者对某些问题理解解答如何在Promise外部使用Promise的结果 用到的本章节知识: 1、axios本质上就是一个promise,所以下面用定时器+Promise模拟axios,效果一样,可以将new Promise(resolve =&gt; &#123;setTimeout(function() &#123; resolve(&quot;promise普通结果&quot;); &#125;, 1000); &#125;)等价于axios(&#123;&#125;) 2、resolve() 与reject()是修改Promise状态并往外抛出的,一个Promise只能改变一次状态,所以一个primise中只能调用一次 3、 上一步抛出后可以在下面 的.then()中获取到 Ⅰ-如果没有用.then(),则值会抛往Promise外部 Ⅱ-如果声明了.then(),则值会被.then()接住,放到里面处理,如果需要再次抛出—某些业务场景需要 ,然后在下一个then()或者外部使用, 则可以 .then(v=&gt;return v) —-前提这个链式调用前曾使用过resolve() 与reject()才用return,不然就用这两个resolve() 与reject() 123456789101112131415161718192021222324252627282930313233&gt;//讲解时写的简单demo&gt;let resolveCommon = ()=&gt; &#123;&gt;let result=&quot;普通promise初始值&quot;&gt;result=new Promise(resolve =&gt; &#123;setTimeout(function() &#123; resolve(&quot;promise普通结果&quot;); &#125;, 1000); &#125;)&gt;console.log(result)&gt;//打印结果: Promise &#123; &lt;pending&gt; &#125; &gt;&#125;;&gt;let resolveAsync=async ()=&gt; &#123;&gt;let result=&quot;await+async的promise初始值&quot;&gt;result=await new Promise(resolve =&gt; &#123; setTimeout(function() &#123; resolve(&quot;这是async+await结果&quot;); &#125;, 1000);&#125;)&gt;console.log(result)&gt;//打印结果: 这是async+await结果 这里就是正确的值,你可以在下一步进行正常使用,也可以用在下一步的promise中&gt;//------------------------------------------------------&gt;//在第二个promise中调用使用&gt;let result2=&quot;&quot;&gt;result2= await new Promise(resolve =&gt; &#123; setTimeout(function() &#123; resolve(result+&quot;+经过第二个promise加工&quot;); &#125;, 1000);&#125;)&gt;.then(v=&gt;&#123;&gt;console.log(&quot;第二个promise的then()中打印并返回:&quot;,v)&gt;return v+&quot;,经过then()加工返回&quot;&gt;&#125;)&gt;console.log(&quot;最终结果:第二个promise外部结果打印,&quot;,result2)&gt;//---------------------------------------------&gt;&#125;;&gt;resolveCommon() //调用普通promise函数&gt;resolveAsync() //调用await+async&gt;/**&gt;运行结果&gt;1.resolveCommon() 运行结果: Promise &#123; &lt;pending&gt; &#125;&gt;2.resolveAsync() 运行结果: &gt;这是async+await结果&gt;第二个promise的then()中打印并返回: 这是async+await结果+经过第二个promise加工&gt;最终结果:第二个promise外部结果打印, 这是async+await结果+经过第二个promise加工,经过then()加工返回&gt;*/ 原因解析: new Promise()是一个异步任务,会加到异步队列中,而正常运行比如console.log()是同步运行的(即从上往下运行),会加到同步队列 所以 Promise()通常是会在同一等级的同步任务之后才得到结果的 所以你得到的是一个挂起的 Promise { } 对象 而await则是让跟在后面的异步任务转为同步任务(效果如此,就通俗来讲,具体概念需要自学),所以result就能得到一个已经修改状态为成功或者失败的值 所以下面的任务就可以使用到这个值 为什么这些操作要放在同一个async fn()=&gt;{} 中? 1)Promise==&gt;异步 2)await==&gt;异步转同步 await 可以理解为是 async wait 的简写。await 必须出现在 async 函数内部，不能单独使用。 await 后面可以跟任何的JS 表达式。虽然说 await 可以等很多类型的东西，但是它最主要的意图是用来等待 Promise 对象的状态被 resolved。如果await的是 promise对象会造成异步函数停止执行并且等待 promise 的解决,如果等的是正常的表达式则立即执行 3)async==&gt;同步转异步 方法体内部的某个表达式使用await修饰，那么这个方法体所属方法必须要用async修饰所以使用awit方法会自动升级为异步方法 宏任务与微任务说明 原理图: 说明: JS中用来存储待执行回调函数的队列包含2个不同特定的列队 宏队列:用来保存待执行的宏任务(回调),比如:定时器回调/ajax回调/dom事件回调 微队列:用来保存待执行的微任务(回调),比如:Promise的回调/muntation回调 JS执行时会区别这2个队列: JS执行引擎首先必须执行所有的初始化同步任务代码 每次准备取出第一个宏任务执行前,都要将所有的微任务一个一个取出来执行 同步任务 —&gt; 微任务 —&gt; 宏任务 Ⅱ-代码与示例 你需要一些栗子来帮助验证自己的想法是否正确,尽量先不看结果去自己思考下打印结果顺序 1、代码示例:a) 首先给出注释的栗子举一个 此处会给出每个打印放入什么队列,加深你的印象 1234567891011121314151617181920212223setTimeout(() =&gt; &#123; console.log(&#x27;timeout callback1（）&#x27;) //立即放入宏队列 Promise.resolve(3).then((value) =&gt; &#123; console.log(&#x27;Promise onResolved3()&#x27;, value) //当这个宏任务执行后 立马放入微队列,所以这个微任务执行完后下个宏任务才能执行 &#125;) &#125;, 0) setTimeout(() =&gt; &#123; console.log(&#x27;timeout callback2（）&#x27;) //立即放入宏队列, &#125;, 0) Promise.resolve(1).then((value) =&gt; &#123; console.log(&#x27;Promise onResolved1()&#x27;, value) //立即放入微队列 setTimeout(() =&gt; &#123; console.log(&#x27;timeout callback3（）&#x27;, value) //立即放入宏任务 &#125;, 0) &#125;) Promise.resolve(2).then((value) =&gt; &#123; console.log(&#x27;Promise onResolved2()&#x27;, value) //立即放入微队列 &#125;)console.log(&#x27;同步代码&#x27;) //同步代码立即执行 结果放在下方,就怕你不小心瞄到 b) 尝试自己思考下 尝试自己脑海中用自己理解 ‘运行’ 一下, 然后把结果写下来,再去下面结果做对比 123456789&gt;setTimeout(() =&gt; console.log(&#x27;代码开始执行&#x27;), 0)&gt;new Promise((resolve, reject) =&gt; &#123; console.log(&#x27;开始for循环&#x27;) for (let i = 0; i &lt; 10000; i++) &#123; i == 99 &amp;&amp; resolve() &#125;&gt;&#125;).then(() =&gt; console.log(&#x27;执行then函数&#x27;))&gt;console.log(&#x27;代码执行结束&#x27;) 2、示例结果:a) 第一个栗子的结果 1234567&gt;&#x27;同步代码&#x27;,&gt;&#x27;Promise onResolved1()&#x27;,&gt;&#x27;Promise onResolved2()&#x27;,&gt;&#x27;timeout callback1（）&#x27;,&gt;&#x27;Promise onResolved3()&#x27;,&gt;&#x27;timeout callback2（）&#x27;,&gt;&#x27;timeout callback3（）&#x27; b) 第二个栗子的结果 PS: 可以忽略undefined这个打印结果, 因为这会加重我们对于宏任务与微任务的理解负担. 当然人都是会好奇的,没有打破砂锅问到底的精神呢也当不了一个好程序员,那我就在下方额外给出解释 五、对浏览器console控制台输出undefined的分析Ⅰ- 出现场景 Ⅱ - 尝试输入其他内容进行分析 那么做个合理推测: 应该是在控制台输入的内容,它的 返回值 会显示出来,这让我们不禁想到JS的 [ eval() ] Ⅲ - eval（string） 其作用是将 接收的 string 字符串作为参数，对其进行JavaScript 表达式或语句 计算，返回得到的值； 如果是没有返回值的表达式或语句，则会返回 undefined ； 如果没有合法的表达式和语句，则会抛出 SyntaxError 异常 。 于是我们可以猜测Console控制台的实质 就是 调用了eval（）函数 Ⅳ - 验证一下 大家都是聪明人,看到这个结果应该就不用我组织语言来解释了吧 Ⅴ - 分析其在宏任务与微任务的打印顺序 首先看图: 可以看到 [ undefined ] 实在微任务完成后,宏任务执行前 打印","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://hasuer.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"Nginx学习笔记","slug":"Nginx学习笔记","date":"2022-02-23T12:37:35.000Z","updated":"2022-02-25T06:01:54.829Z","comments":true,"path":"nginx学习笔记/index.html","link":"","permalink":"https://hasuer.github.io/nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html","excerpt":"","text":"Nginx 简介Nginx概述Nginx (“engine x”)是一个高性能的 HTTP 和反向代理服务器 特点是占有内存少，并发能力强，事实上 nginx 的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用 nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等 Nginx 作为 web 服务器Nginx可以作为静态页面的 web 服务器，同时还支持 CGI 协议的动态语言，比如 pe rl 、 php等。但是不支持 java 。 Java 程序只能通过与 tomcat 配合完成。 Nginx 专为性能优化而开发，性能是其最重要的考量 实现上非常注重效率 ，能经受高负载的考验 有报告表明能支持高达 50,000 个并发连接数。 https://lnmp.org/nginx.html 正向代理Nginx不仅可以做反向代理，实现负载均衡。还能用作正向代理来进行上网等功能。 正向代理：如果把局域网外的Internet 想象成一个巨大的资源库，则局域网中的客户端要访问 Internet ，则需要通过代理服务器来访问，这种代理服务就称为正向代理。 反向代理反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器 IP 地址。 负载均衡客户端发送多个请求到服务器，服务器处理请求，有一些可能要与数据库进行交互，服务器处理完毕后，再将结果返回给客户端。 这种架构模式对于早期的系统相对单一，并发请求相对较少的情况下是比较适合的，成本也低。但是随着信息数量的不断增长，访问量和数据量的飞速增长，以及系统业务的复杂度增加，这种架构会造成服务器相应客户端的请求日益缓慢，并发量特别大的时候，还容易造成服务器直接崩溃。很明显这是由于服务器性能的瓶颈造成的问题，那么如何解决这种情况呢？ 我们首先想到的可能是升级服务器的配置，比如提高CPU执行频率，加大内存等提高机器的物理性能来解决此问题，但是我们知道摩尔定律的日益失效，硬件的性能提升已经不能满足日益提升的需求了。最明显的一个例子，天猫双十一当天，某个热销商品的瞬时访问量是极其庞大的，那么类似上面的系统架构，将机器都增加到现有的顶级物理配置，都是不能够满足需求的。那么怎么办呢？ 上面的分析我们去掉了增加服务器物理配置来解决问题的办法，也就是说纵向解决问题的办法行不通了，那么横向增加服务器的数量呢？这时候集群的概念产生了，单个服务器解决不了，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡 动静分离为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。 Nginx 安装进入 nginx 官网，下载http://nginx.org/ 安装 nginx第一步，安装 pcrewget http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre8.37.tar.gz 解压文件，./configure完成后，回到 pcre 目录下执行 make再执行make install 第二步，安装 openssl第三步，安装 zlibyum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel 第四步,安装 nginx 解压缩 nginx xx.tar.gz 包。 进入解压缩目录 执行 ./configure 。 make &amp;&amp; make install 查看开放的端口号firewall-cmd --list all设置开放的端口号firewall-cmd --add-service=http --permanentsudo firewall-cmd --add -port=80/tcp --permanent重启防火墙firewall-cmd --reload nginx 常用的命令和配置文件nginx 常用的命令 启动命令 在/usr/local/nginx/sbin 目录下执行 ./nginx 关闭命令在/usr/local/nginx/sbin 目录下执行 ./nginx -s stop 重新加载命令在/usr/local/nginx/sbin 目录下执行 ./nginx -s reload nginx.conf 配置文件nginx 安装目录下，其默认的配置文件都放在这个目录的 conf 目录下，而 主配置文件 nginx.conf 也在其中，后续对 nginx 的使用基本上都是对此配置文件进行相应的修改 配置文件中有很多 开头的表示注释内容，我们去掉所有以 # 开头的段落，精简之后的内容如下： 根据上述文件，我们可以很明显的将 nginx.conf 配置文件分为三部分： 第一部分：全局块从配置文件开始到 events 块之间的内容，主要会设置一些影响nginx 服务器整体运行的配置指令，主要包括配置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以及配置文件的引入等。 比如上面第一行配置的： 这是 Nginx 服务器并发处理服务的关键配置，worker_processes 值越大，可以支持的并发处理量也越多，但是会受到硬件、软件等设备的制约 第二部分：events块比如上面的配置： events 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word process 可以同时支持的最大连接数等。 上述例子就表示每个 work process 支持的最大连接数为 1024. 这部分的配置对 Nginx 的性能影响较大，在实际中应该灵活配置。 第三部分：http块 这算是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。 需要注意的是：http 块也可以包括 http全局块、server 块。 http 全局块http全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。 server 块这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。 每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。 而每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。 全局 server 块 最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或IP配置。 location 块 一个 server 块可以配置多个 location 块。 这块的主要作用是基于 Nginx 服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟主机名称（也可以是IP别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。 nginx 配置实例 反向代理反向代理实例一实现效果：使用 n ginx 反向代理，访问 www 123 com 直接跳转到 127.0.0.1:8080 实验代码 启动一个 tomcat ，浏览器地址栏输入 127.0.0.1:8080 ，出现如下界面 通过修改本地 host 文件，将 www. 123 .com 映射到 127.0.0.1 配置完成之后，我们便可以通过www.123.com:8080 访问到第一步出现的 Tomcat初始界面。那么如何只需要输入www.123.com便可以跳转到 Tomcat初始界面呢？便用到 nginx的反向代理。 在 nginx.conf配置文件中增加如下配置 如上配置，我们监听80端口，访问域名为www.123.com，不加端口号时默认为80端口，故访问该域名时会跳转到127.0.0.1:8080路径上。在浏览器端输入 www.123.com 结果如下： 反向代理实例二实现效果：使用 nginx 反向代理， 根据访问的路径跳转到不同端口的服务中nginx 监听端口为 9001访问 http://127.0.0.1:9001/edu/ 直接跳转到 127.0.0.1:8081访问 http://127.0.0.1:9001/vod/ 直接跳转到 127.0.0.1:8082 实验代码第一步，准备两个 tomcat ，一个 8001 端口，一个 8002 端口，并准备好测试的页面第二步，修改 nginx 的配置文件在http 块中添加 server{} location 指令说明该指令用于匹配 URL。 语法如下： 1、= ：用于不含正则表达式的 uri 前，要求请求字符串与 uri 严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求。 2、~：用于表示 uri 包含正则表达式，并且区分大小写。 3、~*：用于表示 uri 包含正则表达式，并且不区分大小写。 4、^~：用于不含正则表达式的 uri 前，要求 Nginx 服务器找到标识 uri 和请求字符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location 块中的正则 uri 和请求字符串做匹配。 注意：如果 url 包含正则表达式，则必须要有 ~ 或者 ~\\ 标识。 nginx 配置实例 负载均衡实现效果： 配置负载均衡 实验代码 首先准备两个同时启动的 Tomcat 在 nginx.conf 中进行配置 随着互联网信息的爆炸性增长，负载均衡（load balance ）已经不再是一个很陌生的话题顾名思义，负载均衡即是将负载分摊到不同的服务单元，既保证服务的可用性，又保证响应足够快，给用户很好的体验。快速增长的访问量和数据流量催生了各式各样的负载均衡产品，很多专业的负载均衡硬件提供了很好的功能，但却价格不菲，这使得负载均衡软件大受欢迎，nginx 就是其中的一个，在 linux 下有 Nginx 、 LVS 、 Haproxy 等等服务可以提供负载均衡服务，而且 Nginx 提供了几种分配方式 策略: 1、轮询（默认）每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。2、weightweight代表权 重默认为 1, 权重越高被分配的客户端越多。指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 例如： 1234upstream server_pool&#123; server 192.168.5.21 weight=10; server 192.168.5.22 weight=10; &#125; 3、ip_hash每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 例如： 12345upstream server_pool&#123; ip_hash; server 192.168.5.21:80; server 192.168.5.22:80; &#125; 4、fair（第三方） 按后端服务器的响应时间来分配请求，响应时间短的优先分配。 12345upstream server_pool&#123; server 192.168.5.21:80; server 192.168.5.22:80; fair; &#125; nginx 配置实例 动静分离Nginx 动静分离简单来说就是把动态跟静态请求分开，不能理解成只是单纯的把动态页面和静态页面物理分离。严格意义上说应该是动态请求跟静态请求分开，可以理解成使用Nginx 处理静态页面，Tomcat处理动态页面。 动静分离从目前实现角度来讲大致分为两种， 一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案； 另外一种方法就是动态跟静态文件混合在一起发布，通过 nginx 来分开。 通过 location 指定不同的后缀名实现不同的请求转发。通过 expires 参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量。具体 Expires 定义：是给一个资源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。此种方法非常适合不经常变动的资源。（如果经常更新的文件，不建议使用 Expires 来缓存），我这里设置 3d，表示在这 3 天之内访问这个 URL，发送一个请求，比对服务器该文件最后更新时间没有变化，则不会从服务器抓取，返回状态码 304，如果有修改，则直接从服务器重新下载，返回状态码 200。 实验代码 项目资源准备 进行 nginx 配置找到 nginx 安装目录，打开 /conf/nginx.conf 配置文件， 添加监听端口、访问名字重点是添加location,最后检查 Nginx 配置是否正确即可，然后测试动静分离是否成功，之需要删除后端 tomcat服务器上的某个静态文件，查看是否能访问，如果可以访问说明静态资源 nginx 直接返回了，不走后端 tomcat 服务器.","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://hasuer.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"AJAX学习笔记","slug":"AJAX学习笔记","date":"2022-02-23T06:53:23.000Z","updated":"2022-02-23T10:33:09.519Z","comments":true,"path":"ajax学习笔记/index.html","link":"","permalink":"https://hasuer.github.io/ajax%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html","excerpt":"","text":"本笔记是视频课程的笔记。【尚硅谷】3小时AJAX入门到精通 笔记转载自这里,做了适当改动。 此部分知识为学习axios预备知识,预备知识链:ajax —&gt; promise —&gt; axios —&gt; react/vue Ajax简介 AJAX 简介 AJAX 全称为 Asynchronous JavaScript And XML，就是异步的 JS 和 XML。 通过 AJAX 可以在浏览器中向服务器发送异步请求，最大的优势：无刷新获取数据。 AJAX 不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式。 XML简介 XML 可扩展标记语言。 XML 被设计用来传输和存储数据。 XML 和 HTML 类似，不同的是 HTML 中都是预定义标签，而 XML 中没有预定义标签， 全都是自定义标签，用来表示一些数据。 比如说我有一个学生数据： name = “孙悟空” ; age = 18 ; gender = “男” ; 123456用 XML 表示：&lt;student&gt; &lt;name&gt;孙悟空&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;gender&gt;男&lt;/gender&gt;&lt;/student&gt; 现在已经被 JSON 取代了。 1&#123;&quot;name&quot;:&quot;孙悟空&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;&#125; Ajax的特点AJAX 的优点 可以无需刷新页面而与服务器端进行通信。 允许你根据用户事件来更新部分页面内容。 Ajax的缺点 没有浏览历史，不能回退 存在跨域问题(同源) SEO (搜索引擎优化）不友好，爬虫无法爬到 HTTP简介 HTTP（hypertext transport protocol）协议『超文本传输协议』，协议详细规定了浏览器和万维网服务器之间互相通信的规则、约定,、规则 请求报文 123456789重点是格式与参数行 POST /s?ie=utf-8 HTTP/1.1 头 Host: atguigu.com Cookie: name=guigu Content-type: application/x-www-form-urlencoded User-Agent: chrome 83空行体 username=admin&amp;password=admin 响应报文 12345678910111213行 HTTP/1.1 200 OK头 Content-Type: text/html;charset=utf-8 Content-length: 2048 Content-encoding: gzip空行 体 &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;尚硅谷&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; Chrome网络控制台查看通信报文 1、Network —&gt; Hearders 请求头 2、Network —&gt; Response 响应体:通常返回的是html 原生Ajax 1、XMLHttpRequest，AJAX 的所有操作都是通过该对象进行的。 2、当你前端想设置自定义的请求头时,需要如此后端设置响应头 123//表示接收任意类型的请求 app.all(&#x27;/server&#x27;, (request, response) =&gt; &#123; //响应头 允许跨域 运行自定义响应头 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;*&#x27;);&#125; 3、ajax请求状态:xhr.readyState 0：请求未初始化，还没有调用 open()。 1：请求已经建立，但是还没有发送，还没有调用 send()。 2：请求已发送，正在处理中（通常现在可以从响应中获取内容头）。 3：请求在处理中；通常响应中已有部分数据可用了，没有全部完成。 4：响应已完成；您可以获取并使用服务器的响应了 Ajax的使用 使用步骤: 1234567891011121314151617181920212223241) 创建 XMLHttpRequest 对象var xhr = new XMLHttpRequest();2) 设置请求信息xhr.open(method, url);//可以设置请求头，一般不设置xhr.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;);3) 发送请求xhr.send(body) //get 请求不传 body 参数，只有 post 请求使用4) 接收响应//xhr.responseXML 接收 xml 格式的响应数据//xhr.responseText 接收文本格式的响应数据xhr.onreadystatechange = function ()&#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; var text = xhr.responseText; console.log(text); &#125;&#125;/*0: 请求未初始化1: 服务器连接已建立2: 请求已接收3: 请求处理中4: 请求已完成，且响应已就绪*/ Get方式12345678910111213141516171819202122232425262728293031//绑定事件btn.onclick = function () &#123; //1. 创建对象 const xhr = new XMLHttpRequest(); //2. 初始化 设置请求方法和 url // 使用&amp;分割参数 xhr.open(&#x27;GET&#x27;, &#x27;http://127.0.0.1:8000/server?a=100&amp;b=200&amp;c=300&#x27;); //3. 发送 xhr.send(); //4. 事件绑定 处理服务端返回的结果 // on when 当....时候 // readystate 是 xhr 对象中的属性, 表示状态 0 1 2 3 4 // change 改变 xhr.onreadystatechange = function () &#123; //判断 (服务端返回了所有的结果) if (xhr.readyState === 4) &#123; //判断响应状态码 200 404 403 401 500 // 2xx 成功 if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123; //处理结果 行 头 空行 体 //响应 // console.log(xhr.status);//状态码 // console.log(xhr.statusText);//状态字符串 // console.log(xhr.getAllResponseHeaders());//所有响应头 // console.log(xhr.response);//响应体 //设置 result 的文本 result.innerHTML = xhr.response; &#125; else &#123;&#125; &#125; &#125;&#125; Post方式12345678910111213141516171819202122232425//绑定事件 result.addEventListener(&quot;mouseover&quot;, function()&#123; //1. 创建对象 const xhr = new XMLHttpRequest(); //2. 初始化 设置类型与 URL xhr.open(&#x27;POST&#x27;, &#x27;http://127.0.0.1:8000/server&#x27;); //设置请求头 xhr.setRequestHeader(&#x27;Content-Type&#x27;,&#x27;application/x-www-form-urlencoded&#x27;) // 下面这个是自定义的头信息，在后端代码中要设置允许所有的请求头，否则失败 xhr.setRequestHeader(&#x27;name&#x27;,&#x27;atguigu&#x27;); //3. 发送 xhr.send(&#x27;a=100&amp;b=200&amp;c=300&#x27;); // xhr.send(&#x27;a:100&amp;b:200&amp;c:300&#x27;); // xhr.send(&#x27;1233211234567&#x27;); //4. 事件绑定 xhr.onreadystatechange = function()&#123; //判断 if(xhr.readyState === 4)&#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123; //处理服务端返回的结果 result.innerHTML = xhr.response; &#125; &#125; &#125; &#125;); 解决ie缓存问题 问题：在一些浏览器中(IE),由于缓存机制的存在，ajax 只会发送的第一次请求，剩余多次请求不会再发送给浏览器而是直接加载缓存中的数据。 解决方式：浏览器的缓存是根据 url地址来记录的，所以我们只需要修改 url 地址 即可避免缓存问题 xhr.open(&quot;get&quot;,&quot;/testAJAX?t=&quot;+Date.now()); 请求超时与网络异常 当你的请求时间过长,或者无网络时,进行的相应处理 1234567891011121314151617181920212223btn.addEventListener(&#x27;click&#x27;, function()&#123; const xhr = new XMLHttpRequest(); //超时设置 2s 设置 xhr.timeout = 2000; //超时回调 xhr.ontimeout = function()&#123; alert(&quot;网络异常, 请稍后重试!!&quot;); &#125; //网络异常回调 xhr.onerror = function()&#123; alert(&quot;你的网络似乎出了一些问题!&quot;); &#125; xhr.open(&quot;GET&quot;,&#x27;http://127.0.0.1:8000/delay&#x27;); xhr.send(); xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4)&#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status&lt; 300)&#123; result.innerHTML = xhr.response; &#125; &#125; &#125; &#125;) 取消请求 在请求发出去后但是未响应完成时可以进行取消请求操作 1234567891011const btns = document.querySelectorAll(&#x27;button&#x27;);let x = null;btns[0].onclick = function()&#123; x = new XMLHttpRequest(); x.open(&quot;GET&quot;,&#x27;http://127.0.0.1:8000/delay&#x27;); x.send();&#125;// abortbtns[1].onclick = function()&#123; x.abort();&#125; 重复请求问题 利用之前取消请求知识点,当我点击时判断之前请求是否在发送中,如果是,则停止请求 123456789101112131415btns[0].onclick = function()&#123; //判断标识变量 if(isSending) x.abort();// 如果正在发送, 则取消该请求, 创建一个新的请求 x = new XMLHttpRequest(); //修改 标识变量的值 isSending = true; x.open(&quot;GET&quot;,&#x27;http://127.0.0.1:8000/delay&#x27;); x.send(); x.onreadystatechange = function()&#123; if(x.readyState === 4)&#123; //修改标识变量 isSending = false; &#125; &#125; &#125; 常见三种Ajax请求方式jQuery发送AJAX请求 jQuery有三种发送请求方法: 当你只是简单的请求数据,可以直接使用前两种方式请求,当你需要设置的东西较多的时候,可以使用$.ajax()方法 $.get()12345$(&#x27;button&#x27;).eq(0).click(function()&#123; $.get(&#x27;http://127.0.0.1:8000/jquery-server&#x27;, &#123;a:100, b:200&#125;, function(data)&#123; console.log(data); &#125;,&#x27;json&#x27;); &#125;); $.post()12345$(&#x27;button&#x27;).eq(1).click(function()&#123; $.post(&#x27;http://127.0.0.1:8000/jquery-server&#x27;, &#123;a:100, b:200&#125;, function(data)&#123; console.log(data); &#125;); &#125;); $.ajax123456789101112131415161718192021222324252627$(&#x27;button&#x27;).eq(2).click(function()&#123; $.ajax(&#123; //url url: &#x27;http://127.0.0.1:8000/jquery-server&#x27;, //参数 data: &#123;a:100, b:200&#125;, //请求类型 type: &#x27;GET&#x27;, //响应体结果 dataType: &#x27;json&#x27;, //成功的回调 success: function(data)&#123; console.log(data); &#125;, //超时时间 timeout: 2000, //失败的回调 error: function()&#123; console.log(&#x27;出错啦!!&#x27;); &#125;, //头信息 headers: &#123; c:300, d:400 &#125; &#125;); &#125;); Axios发送AJAX请求axios.get() axios.get(url,data,params) 1234567891011121314151617181920//配置 baseURL axios.defaults.baseURL = &#x27;http://127.0.0.1:8000&#x27;; btns[0].onclick = function () &#123; //GET 请求 axios.get(&#x27;/axios-server&#x27;, &#123; //url 参数 params: &#123; id: 100, vip: 7 &#125;, //请求头信息 headers: &#123; name: &#x27;atguigu&#x27;, age: 20 &#125; &#125;).then(value =&gt; &#123; console.log(value); &#125;); &#125; axios.post() axios.post(url,data,params) 12345678910111213141516171819 //配置 baseURL axios.defaults.baseURL = &#x27;http://127.0.0.1:8000&#x27;; btns[1].onclick = function () &#123; axios.post(&#x27;/axios-server&#x27;, &#123; username: &#x27;admin&#x27;, password: &#x27;admin&#x27; &#125;, &#123; //url params: &#123; id: 200, vip: 9 &#125;, //请求头参数 headers: &#123; height: 180, weight: 180, &#125; &#125;); &#125; axios() 常用 axios({}) 12345678910111213141516171819202122232425262728293031323334 //配置 baseURL axios.defaults.baseURL = &#x27;http://127.0.0.1:8000&#x27;;btns[2].onclick = function () &#123; axios(&#123; //请求方法 method: &#x27;POST&#x27;, //url url: &#x27;/axios-server&#x27;, //url参数 params: &#123; vip: 10, level: 30 &#125;, //头信息,此部分如果使用自定义的头信息,需要服务端进行相应修改,正常不设置 headers: &#123; a: 100, b: 200 &#125;, //请求体参数 data: &#123; username: &#x27;admin&#x27;, password: &#x27;admin&#x27; &#125; &#125;).then(response =&gt; &#123; //响应状态码 console.log(response.status); //响应状态字符串 console.log(response.statusText); //响应头信息 console.log(response.headers); //响应体 console.log(response.data); &#125;) &#125; Fetch发送AJAX请求 代码示例 1234567891011121314151617btn.onclick = function () &#123; fetch(&#x27;http://127.0.0.1:8000/fetch-server?vip=10&#x27;, &#123; //请求方法 method: &#x27;POST&#x27;, //请求头 headers: &#123; name: &#x27;atguigu&#x27; &#125;, //请求体 body: &#x27;username=admin&amp;password=admin&#x27; &#125;).then(response =&gt; &#123; // return response.text(); return response.json(); &#125;).then(response =&gt; &#123; console.log(response); &#125;); &#125; 跨域与解决 1、什么是跨越？ 一个网页向另一个不同域名/不同协议/不同端口的网页请求资源，这就是跨域。 跨域原因产生：在当前域名请求网站中，默认不允许通过ajax请求发送其他域名。 2、为什么会产生跨域请求？ 因为浏览器使用了同源策略 3、什么是同源策略？ 同源策略是Netscape提出的一个著名的安全策略，现在所有支持JavaScript的浏览器都会使用这个策略。同源策略是浏览器最核心也最基本的安全功能，如果缺少同源策略，浏览器的正常功能可能受到影响。可以说web是构建在同源策略的基础之上的，浏览器只是针对同源策略的一种实现。 同源： 协议、域名、端口号 必须完全相同。 违背同源策略就是跨域。 4、为什么浏览器要使用同源策略？ 是为了保证用户的信息安全，防止恶意网站窃取数据，如果网页之间不满足同源要求，将不能: 1、共享Cookie、LocalStorage、IndexDB 2、获取DOM 3、AJAX请求不能发送 5、跨域的五个解决方式: 1、前端使用jsonp （不推荐使用） 2、后台Http请求转发 3、后台配置同源Cors （推荐） 4、使用SpringCloud网关 5、使用nginx做转发 (推荐) 本课程提到了其中的两种: jsonP 1)JSONP 是什么? JSONP(JSON with Padding)，是一个非官方的跨域解决方案，纯粹凭借程序员的聪明 才智开发出来，只支持 get 请求。 2)JSONP 怎么工作的？ 在网页有一些标签天生具有跨域能力，比如：img link iframe script。 JSONP 就是利用 script 标签的跨域能力来发送请求的。 jsonP的使用1234567891011121314151617181920 // 1. 动态的创建一个 script 标签------------------------------------------------------------ var script = document.createElement(&quot;script&quot;);//2. 设置 script 的 src， 设置回调函数 script.src = &quot;http://localhost:3000/testAJAX?callback=abc&quot;; function abc(data) &#123; alert(data.name); &#125;; // 3. 将 script 添加到 body 中 document.body.appendChild(script); // 4. 服务器中路由的处理------------------------------------------------------ router.get(&quot;/testAJAX&quot;, function (req, res) &#123; console.log(&quot;收到请求&quot;); var callback = req.query.callback; var obj = &#123; ame: &quot;孙悟空&quot;, age: 18 &#125; res.send(callback + &quot;(&quot; + JSON.stringify(obj) + &quot;)&quot;); &#125;); jQuery发送jsonP请求1234567891011121314151617181920212223242526//前端代码-----------------------------------------------------------------------------------$(&#x27;button&#x27;).eq(0).click(function () &#123; $.getJSON(&#x27;http://127.0.0.1:8000/jquery-jsonp-server?callback=?&#x27;, function (data) &#123; $(&#x27;#result&#x27;).html(` 名称: $&#123;data.name&#125;&lt;br&gt; 校区: $&#123;data.city&#125; `) &#125;);&#125;);//服务端代码-----------------------------------------------------------app.all(&#x27;/jquery-jsonp-server&#x27;, (request, response) =&gt; &#123; // response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;); const data = &#123; name: &#x27;尚硅谷&#x27;, city: [&#x27;北京&#x27;, &#x27;上海&#x27;, &#x27;深圳&#x27;] &#125;; //将数据转化为字符串 let str = JSON.stringify(data); //接收 callback 参数 let cb = request.query.callback; //返回结果 // $&#123;&#125; 可以将str转变成对象 response.end(`$&#123;cb&#125;($&#123;str&#125;)`);&#125;); 原作者开发封装的jsonP插件 1、代价:需要前后端联动 2、精髓:自动的由插件生成方法名,并在当前的页面动态的生成函数,然后再生成的函数里头调用用户预留的回调函数 3、插件：自动化的去模拟基于script去实现跨域请求的过程（对用户来说是黑盒子） 4、参数拼接：url已经是带参的。和不带参的 5、id优化 额可以添加一个容器来管理id 1、前端调用测试封装好的jsonP代码 123456789101112//测试调用函数 let test=function () &#123; jsonP.req(&#123; url:&quot;http://localhost:3000/jsonpx&quot;, data:&#123; a:&quot;111&quot; &#125;, callback:function (result) &#123; alert(&quot;成功&quot;+result) &#125; &#125;) &#125; 2、服务端测试代码 12345678router.get(&#x27;/jsonpx&#x27;, async function (req, resp, next) &#123; let callback=req.query.callback; let data=req.query.a; if (!data)&#123; resp.send(`$&#123;callback&#125;(&#x27;洪jl:我是服务端代码&#x27;)`) &#125; resp.send(`$&#123;callback&#125;(&#x27;洪jl:我是服务端代码`+data+`&#x27;)`)&#125;) 3、封装原生代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;script&gt; /**author:@hongjilin * 1.声明一个jsonP插件对象 * 作用：隔开作用域 */ let jsonP = &#123;&#125;; /** *2.在插件对象中创建两个名字备用符数组 */ jsonP.char = &#123; Number: &#x27;0123456789&#x27;, Letter: &#x27;qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM&#x27; &#125; /** * 通过随机数抽取备用字符数组库拼凑函数id * @param charLen * @param numLen */ jsonP.newFunId = function (charLen, numLen) &#123; let id = &#x27;&#x27;; for (let i = 0; i &lt; charLen; i++) &#123; id += this.char.Letter.charAt(Math.random() * 52) &#125; for (let j = 0; j &lt; numLen; j++) &#123; id += Math.floor(Math.random() * 10); &#125; return id; &#125; /** * 拼接路径 * @param url * @param key * @param value */ jsonP.jointUrl = function (url, key, value) &#123; if (url &amp;&amp; key &amp;&amp; value) &#123; let sign = &quot;&amp;&quot; //如果是第一次 if (url.indexOf(&#x27;?&#x27;) == -1) &#123; sign = &#x27;?&#x27; &#125; url += sign + key + &quot;=&quot; + value &#125; return url; &#125; /** 封装err属性方便 */ jsonP.err = function (msg) &#123; console.error(msg) &#125; /** * 发送请求函数 * @param options */ jsonP.req = function (options) &#123; let jsonId=&#123;&#125;; //1.生成方法名 jsonId.funId = this.newFunId(4,8); let Userurl = options.url; let Userdata = options.data; if (!options) &#123; this.err(&quot;输入不能空&quot;) return; &#125; else if (!Userurl) &#123; this.err(&quot;url不能空&quot;) return; &#125; else if (!Userdata) &#123; //如果没有data,初始化 Userdata = &#123;&#125;; &#125; //将函数名赋值给userdata的回调函数属性中 Userdata.callback = jsonId.funId; for (let key in Userdata) &#123; Userurl = this.jointUrl(Userurl, key, Userdata[key]) &#125; let script = document.createElement(&#x27;script&#x27;); script.setAttribute(&quot;id&quot; , jsonId.funId); script.setAttribute(&quot;src&quot; , Userurl); //动态生成函数 let callback=function (result) &#123; console.log(&quot;xxxxxxx&quot;) //业务逻辑回调 if (options.callback)&#123; try &#123; options.callback(result) &#125;catch (e) &#123; this.err(e.message) &#125; &#125; //善后 let tmp=document.getElementById(jsonId.funId) tmp.parentNode.removeChild(tmp); eval(jsonId.funId+&#x27;=null&#x27;) &#125; eval(&quot;window.&quot;+jsonId.funId+&quot;=function(result)&#123; callback(result) &#125;&quot;) document.head.appendChild(script) &#125;&lt;/script&gt; CORS 1、CORS文档链接 2、CORS是什么? CORS（Cross-Origin Resource Sharing），跨域资源共享。CORS 是官方的跨域解决方 案，它的特点是不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持 get 和 post 请求。跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些 源站通过浏览器有权限访问哪些资源 3、CORS是怎么工作的? CORS 是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应 以后就会对响应放行。 代码示例1234567891011app.all(&#x27;/cors-server&#x27;, (request, response) =&gt; &#123; //设置响应头 //响应首部中可以携带一个 Access-Control-Allow-Origin 字段 response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); //Access-Control-Allow-Headers 首部字段用于预检请求的响应。其指明了实际请求中允许携带的首部字 response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &#x27;*&#x27;); //Access-Control-Allow-Methods 首部字段用于预检请求的响应。其指明了实际请求所允许使用的 HTTP response.setHeader(&quot;Access-Control-Allow-Method&quot;, &#x27;*&#x27;); // response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://127.0.0.1:5500&quot;); response.send(&#x27;hello CORS&#x27;);&#125;); HTTP 响应首部字段 本节列出了规范所定义的响应首部字段。上一小节中，我们已经看到了这些首部字段在实际场景中是如何工作的。 Access-Control-Allow-Origin 响应首部中可以携带一个 Access-Control-Allow-Origin 字段，其语法如下: 1Access-Control-Allow-Origin: &lt;origin&gt; | * 其中，origin 参数的值指定了允许访问该资源的外域 URI。对于不需要携带身份凭证的请求，服务器可以指定该字段的值为通配符，表示允许来自所有域的请求。 例如，下面的字段值将允许来自 http://mozilla.com 的请求： 1Access-Control-Allow-Origin: http://mozilla.com 如果服务端指定了具体的域名而非“*”，那么响应首部中的 Vary 字段的值必须包含 Origin。这将告诉客户端：服务器对不同的源站返回不同的内容。 Access-Control-Expose-Headers 译者注：在跨源访问时，XMLHttpRequest对象的getResponseHeader()方法只能拿到一些最基本的响应头，Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。 Access-Control-Expose-Headers 头让服务器把允许浏览器访问的头放入白名单，例如： 1Access-Control-Expose-Headers: X-My-Custom-Header, X-Another-Custom-Header 这样浏览器就能够通过getResponseHeader访问X-My-Custom-Header和 X-Another-Custom-Header 响应头了。 Access-Control-Max-Age Access-Control-Max-Age 头指定了preflight请求的结果能够被缓存多久，请参考本文在前面提到的preflight例子。 1Access-Control-Max-Age: &lt;delta-seconds&gt; delta-seconds 参数表示preflight请求的结果在多少秒内有效。 Access-Control-Allow-Credentials Access-Control-Allow-Credentials 头指定了当浏览器的credentials设置为true时是否允许浏览器读取response的内容。当用在对preflight预检测请求的响应中时，它指定了实际的请求是否可以使用credentials。请注意：简单 GET 请求不会被预检；如果对此类请求的响应中不包含该字段，这个响应将被忽略掉，并且浏览器也不会将相应内容返回给网页。 1Access-Control-Allow-Credentials: true Access-Control-Allow-Methods Access-Control-Allow-Methods 首部字段用于预检请求的响应。其指明了实际请求所允许使用的 HTTP 方法。 1Access-Control-Allow-Methods: &lt;method&gt;[, &lt;method&gt;]* Access-Control-Allow-Headers Access-Control-Allow-Headers 首部字段用于预检请求的响应。其指明了实际请求中允许携带的首部字段。 1Access-Control-Allow-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]* HTTP 请求首部字段 本节列出了可用于发起跨源请求的首部字段。请注意，这些首部字段无须手动设置。 当开发者使用 XMLHttpRequest 对象发起跨源请求时，它们已经被设置就绪。 Origin Origin 首部字段表明预检请求或实际请求的源站。 1Origin: &lt;origin&gt; origin 参数的值为源站 URI。它不包含任何路径信息，只是服务器名称。 Note: 有时候将该字段的值设置为空字符串是有用的，例如，当源站是一个 data URL 时。 注意，在所有访问控制请求（Access control request）中，Origin 首部字段总是被发送 Access-Control-Request-Method Access-Control-Request-Method 首部字段用于预检请求。其作用是，将实际请求所使用的 HTTP 方法告诉服务器。 1Access-Control-Request-Method: &lt;method&gt; Access-Control-Request-Headers Access-Control-Request-Headers 首部字段用于预检请求。其作用是，将实际请求所携带的首部字段告诉服务器。 1Access-Control-Request-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]* 服务端代码示例 配合以上前端代码的服务端代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153//1. 引入expressconst express = require(&#x27;express&#x27;);//2. 创建应用对象const app = express();//3. 创建路由规则// request 是对请求报文的封装// response 是对响应报文的封装app.get(&#x27;/server&#x27;, (request, response) =&gt; &#123; //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); //设置响应体 response.send(&#x27;HELLO AJAX - 2&#x27;);&#125;);//可以接收任意类型的请求 app.all(&#x27;/server&#x27;, (request, response) =&gt; &#123; //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); //响应头 response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;*&#x27;); //设置响应体 response.send(&#x27;HELLO AJAX POST&#x27;);&#125;);//JSON 响应app.all(&#x27;/json-server&#x27;, (request, response) =&gt; &#123; //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;*&#x27;); //响应一个数据 const data = &#123; name: &#x27;atguigu&#x27; &#125;; //对对象进行字符串转换 let str = JSON.stringify(data); //设置响应体 response.send(str);&#125;);//针对 IE 缓存app.get(&#x27;/ie&#x27;, (request, response) =&gt; &#123; //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); //设置响应体 response.send(&#x27;HELLO IE - 5&#x27;);&#125;);//延时响应app.all(&#x27;/delay&#x27;, (request, response) =&gt; &#123; //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;*&#x27;); setTimeout(() =&gt; &#123; //设置响应体 response.send(&#x27;延时响应&#x27;); &#125;, 1000)&#125;);//jQuery 服务app.all(&#x27;/jquery-server&#x27;, (request, response) =&gt; &#123; //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;*&#x27;); // response.send(&#x27;Hello jQuery AJAX&#x27;); const data = &#123; name: &#x27;尚硅谷&#x27; &#125;; // 只能send字符串数据，不能直接发送data，所以这里使用了JSON.stringfy()方法 response.send(JSON.stringify(data));&#125;);//axios 服务app.all(&#x27;/axios-server&#x27;, (request, response) =&gt; &#123; //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;*&#x27;); // response.send(&#x27;Hello jQuery AJAX&#x27;); const data = &#123; name: &#x27;尚硅谷&#x27; &#125;; // 只能send字符串数据，不能直接发送data，所以这里使用了JSON.stringfy()方法 response.send(JSON.stringify(data));&#125;);//fetch 服务app.all(&#x27;/fetch-server&#x27;, (request, response) =&gt; &#123; //设置响应头 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;*&#x27;); // response.send(&#x27;Hello jQuery AJAX&#x27;); const data = &#123; name: &#x27;尚硅谷&#x27; &#125;; // 只能send字符串数据，不能直接发送data，所以这里使用了JSON.stringfy()方法 response.send(JSON.stringify(data));&#125;);//jsonp服务app.all(&#x27;/jsonp-server&#x27;, (request, response) =&gt; &#123; // response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;); const data = &#123; name: &#x27;尚硅谷atguigu&#x27; &#125;; //将数据转化为字符串 let str = JSON.stringify(data); //返回结果 response.end(`handle($&#123;str&#125;)`);&#125;);//用户名检测是否存在app.all(&#x27;/check-username&#x27;, (request, response) =&gt; &#123; // response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;); const data = &#123; exist: 1, msg: &#x27;用户名已经存在&#x27; &#125;; //将数据转化为字符串 let str = JSON.stringify(data); //返回结果 response.end(`handle($&#123;str&#125;)`);&#125;);//app.all(&#x27;/jquery-jsonp-server&#x27;, (request, response) =&gt; &#123; // response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;); const data = &#123; name: &#x27;尚硅谷&#x27;, city: [&#x27;北京&#x27;, &#x27;上海&#x27;, &#x27;深圳&#x27;] &#125;; //将数据转化为字符串 let str = JSON.stringify(data); //接收 callback 参数 let cb = request.query.callback; //返回结果 response.end(`$&#123;cb&#125;($&#123;str&#125;)`);&#125;);app.all(&#x27;/cors-server&#x27;, (request, response) =&gt; &#123; //设置响应头 response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &#x27;*&#x27;); response.setHeader(&quot;Access-Control-Allow-Method&quot;, &#x27;*&#x27;); // response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://127.0.0.1:5500&quot;); response.send(&#x27;hello CORS&#x27;);&#125;);//4. 监听端口启动服务app.listen(8000, () =&gt; &#123; console.log(&quot;服务已经启动, 8000 端口监听中....&quot;);&#125;);","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://hasuer.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"Git学习笔记","slug":"Git学习笔记","date":"2021-07-07T12:59:22.000Z","updated":"2022-02-23T12:42:59.056Z","comments":true,"path":"git学习笔记/index.html","link":"","permalink":"https://hasuer.github.io/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html","excerpt":"","text":"Git命令行操作本地库初始化进入文件夹 12git init注意：生成的 .git 目录中存放的是本地库相关文件，不要删除 设置签名这里设置的签名和GitHub中的用户，密码没有关系。 项目(仓库)级别仅在当前本地库有效 12git config user.name tom #设置用户名tomgit config user.email liu@qq.com #设置用户邮箱 系统用户级别仅在当前登录的操作系统用户有效 12git config --global user.name tomgit config --global user.email liu@qq.com 仅仅加了一个 --global 优先级别：项目级别 &gt; 系统级别 项目级别的作用范围更小，类似于局部变量 &gt; 全局变量。二者必须要有其一。 信息保存位置：~/.gitconfig 文件 查看方式：cat .git/config 查看当前用户（global）配置 git config --global --list查看当前仓库配置信息 git config --local --list 基本操作状态查看1git status #查看工作区、暂存区状态 添加1234git add fileName #指定文件git add . #所有说明：将工作区的文件添加到暂存区git rm --cached filename #将暂存区的文件撤销 提交12git commit -m &#x27;commit message&#x27; fileName说明：将暂存区内容提交到本地库 查看历史记录12345git log git reflog #常用，说明：HEAD@&#123;移动到当前版本需要多少步&#125;git log --greph #图形显示,更直观git log --pretty=oneline #漂亮一行显示git log --oneline #简洁显示 前进后退 基于索引值推荐 12git reset --hard 指针位置例子：git reset --hard a6ace91 #回到这个状态 使用 ^ 符号只能后退 1git reset --hard HEAD^例子：git reset --hard HEAD^^注意：几个 ^ 表示后退几步 使用 ~ 符号只能后退 1git reset --hard HEAD~n例子：git reset --hard HEAD~3 reset的三个参数比较123456soft: - 仅本地库移动HEAD 指针mixed： - 在本地库移动HEAD指针 - 重置暂存区hard： - 在本地库移动HEAD指针 - 重置暂存区 - 重置工作区 删除文件并找回 相当于建立一个快照，虽然删除了，但只要添加到暂存区，就能找回 如果文件删除之后已经commit了，那么在log里就有有一条记录，这时，使用git reset --hard 指针位置来还原。 如果删除文件之后只是add,没有commit，那么log中没有新的记录，使用git reset --hard HEAD来刷新工作区。 文件差异比较123git diff 文件名 #工作区文件和暂存区比较git diff 哈希值 文件名 #工作区文件和本地库历史记录比较git diff #不带文件名，则比较多个文件 分支管理什么是分支管理 在版本控制中，使用推进多个任务 分支的好处 同时并行推进多个功能开发，提高开发效率 某一分支开发失败，不会对其它分支有任何影响 分支操作 创建分支 1git branch 分支名 查看分支 12git branchgit branch -v 切换分支 12git checkout 分支名git checkout -b 分支名 #创建分支并直接切换到该分支 合并分支相当于把修改了的文件拉过来 第一步：切换到接收修改的分支名上 git checkout [分支名] 第二步：执行merge命令 git merge [分支名] 删除分支 1git branch -d 分支名 解决冲突 冲突的表现 冲突的解决 第一步：编辑，删除特殊标记&lt;&lt;&lt; === 第二步：修改到满意位置，保存退出 第三步：添加到缓存区 git add 文件名 第四步：提交到本地库git commit -m &#39;日志信息&#39; 注意：后面一定不能带文件名 Git 结合Github创建远程库地址别名1234git remote -v #查看远程地址别名git remote add 别名 远程地址 例子：git remote add origin https://xx 这里的 origin 是别名的意思 推送开发修改完把本地库的文件推送到远程仓库 前提是提交到了本地库才可以推送 123git push 别名 分支名git push -u 别名 分支名 #-u指定默认主机 例子：git push origin master 克隆完整的把远程库克隆到本地`克隆下来后不要在主分支里面做开发 `clone进行一次，从无到有的过程，更新用pull 12git clone 远程地址 例子：git clone https://xx 常见建立仓库方式 建立仓库 —&gt; 打开空文件夹（还没有项目） —&gt; 克隆下来 建立仓库 —&gt; 打开项目文件夹（已经有项目）—&gt; 初始化仓库 —&gt; 设置remote仓库链接 拉取pull = fetch + merge 把远程库中的内容拉取到本地库，但是在本地库没有 被更新，这个时候当前分支（本地库）是看不到变化的，只有进入origin/分支名才能看到变化。这个时候在本地的分支执行merge命令之后才能在本地的分支看到变化。 本地存在clone下来的文件 就用pull更新 1234pull = fetch + merge git fetch [远程地址别名] [分支名] git merge [远程地址别名] [分支名] git pull [远程地址别名] [分支名] 解决冲突注意：解决冲突后的提交是不能带文件名的 如果不是基于GitHub 远程库的最新版所做的修改，不能推送，必须先拉取。 拉取下来后如果进入冲突状态，则按照“分支冲突解决”操作解决即可。 rebase提交记录简洁不分叉 没学懂，感觉有点鸡肋 混眼熟 1git rebase -i 索引号git rebase -i HEAD~3 #合并最近三条记录说明：在vim编辑里面改成s beyond compare用软件解决冲突 11.安装 ： beyond compare 2.配置： git config --local merge.tool bc3 #合并名称 git config --local mergetool.path &#x27;/usr/local/bin/bcomp&#x27; #软件路径 git config --local mergetool.keepBackup false #False不用保存备份3.应用： git mergetool说明：--local指只在当前操作系统有效 跨团队合作代码review之后合并 适用于个人 邀请成员:Settings —&gt; Collaborators —&gt;填写用户名 —&gt;打开链接接受邀请 企业 创建一个组织 方便管理 review 组织做review 通过Pull request 给开源社区共享代码 点击别人仓库的fork 到自己的仓库 — &gt; 然后clone下来 修改后推送到远程库 —&gt; 点击Pull Request请求 —&gt; Create pull request发消息 Tag标签为了清晰的版本管理，公司一般不会直接使用commit提交 1git tag -a v1.0 -m &#x27;版本介绍&#x27; #创建本地tag信息git tag -d v1.0 #删除taggit push origin --tags #将本地tag信息推送到远程库git pull origin --tags #拉取到本地git checkout v.10 #切换taggit clone -b v0.1 地址 #指定tag下载代码 SSH 免密登录 进入当前的家目录 1$ cd ~ 删除.ssh目录 1$ rm -rvf .ssh 运行命令生成SSH密钥目录 123$ ssh-keygen -t rsa -C [Github邮箱]或者 $ ssh-keygen (会让你设置SSH的登录密码，可以不输入，一直Enter) 进入.ssh目录查看文件列表 12$ cd .ssh$ ls -la 查看id_rsa.pub的内容 1$ cat id_rsa.pub 在GitHub上建立SSH Key, 把刚刚生成的ssh密钥填进去。 保证本地库对应的远程库是SSH方式的。 如果没有： 1git add remote origin_ssh[(这是别名) [SSH地址] 然后就可以愉快的push啦~~ 123git push [别名] [分支名]# 这里要注意，如果你在本地库只建立了一个远程地址，# 那么不用使用[别名]和[分支名]。如果有多个才要使用。 Git工作流概念1在项目开发过程中使用Git的方式 分类集中式工作流像SVN一样，集中式工作流有一个中央仓库，所有的修改都提交到了Master分支上 GitFlow工作流 *主干分支master 开发分支develop 修复分支hotfix 预发布分支release 功能分支feature GitFlow 有独立的分支，让发布迭代过程更流畅。 Forking 工作流在 GitFlow 基础上， 充分利用了 Git 的 Fork 和 pull request 的功能以达到代码审核的目的。 安全可靠地管理大团队的开发者","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://hasuer.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[]}],"categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://hasuer.github.io/categories/Algorithm/"},{"name":"技术笔记","slug":"技术笔记","permalink":"https://hasuer.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://hasuer.github.io/tags/Interview/"}]}