<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Ubuntu20.04安装配置MySQL8(详细)</title>
      <link href="/ubuntu20-04%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEmysql8-%E8%AF%A6%E7%BB%86/index.html"/>
      <url>/ubuntu20-04%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEmysql8-%E8%AF%A6%E7%BB%86/index.html</url>
      
        <content type="html"><![CDATA[<p>文章的第一节转载自<a href="https://blog.csdn.net/qq_42468130/article/details/88595418">原文连接</a></p><p>本文实现了服务器ubuntu18.04和虚拟机ubuntu20.04两个版本的MySQL8 的安装，和navicat的连接。其中ubuntu18.04对应第二节，ubuntu20.04是ubuntu focal的，对应第三节。</p><h2 id="1-彻底删除mysql5-7"><a href="#1-彻底删除mysql5-7" class="headerlink" title="1. 彻底删除mysql5.7"></a>1. 彻底删除mysql5.7</h2><h3 id="1-1-查看mysql的依赖项"><a href="#1-1-查看mysql的依赖项" class="headerlink" title="1.1 查看mysql的依赖项"></a>1.1 查看mysql的依赖项</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg --list<span class="string">|grep mysql</span></span><br></pre></td></tr></table></figure><p><img src="/ubuntu20-04%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEmysql8-%E8%AF%A6%E7%BB%86/index/1.1.png"></p><h3 id="1-2-卸载"><a href="#1-2-卸载" class="headerlink" title="1.2 卸载"></a>1.2 卸载</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> <span class="builtin-name">remove</span> mysql-common</span><br></pre></td></tr></table></figure><p>在卸载过程中输入<code>yes</code></p><h3 id="1-3-卸载（最后的版本数字根据自己具体的版本进行相应的修改）"><a href="#1-3-卸载（最后的版本数字根据自己具体的版本进行相应的修改）" class="headerlink" title="1.3 卸载（最后的版本数字根据自己具体的版本进行相应的修改）"></a>1.3 卸载（最后的版本数字根据自己具体的版本进行相应的修改）</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo</span> apt-get autoremove --purge mysql-server-<span class="number">5</span>.<span class="number">7</span></span><br></pre></td></tr></table></figure><h3 id="1-4-清除残留数据"><a href="#1-4-清除残留数据" class="headerlink" title="1.4 清除残留数据"></a>1.4 清除残留数据</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">dpkg</span> -l|grep<span class="regexp"> ^rc|awk</span> <span class="string">&#x27;&#123;print<span class="variable">$2</span>&#125;&#x27;</span>|sudo xargs dpkg -P</span><br></pre></td></tr></table></figure><p>出现下图界面，选择<code>&lt;YES&gt;</code></p><p><img src="/ubuntu20-04%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEmysql8-%E8%AF%A6%E7%BB%86/index/1.2.png"></p><h3 id="1-5-再次查看依赖"><a href="#1-5-再次查看依赖" class="headerlink" title="1.5 再次查看依赖"></a>1.5 再次查看依赖</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg --list<span class="string">|grep mysql</span></span><br></pre></td></tr></table></figure><p>发现有如下残留</p><p><img src="/ubuntu20-04%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEmysql8-%E8%AF%A6%E7%BB%86/index/1.3.png"></p><p>使用命令<code>sudo apt-get autoremove --purge xxxx</code>来卸载：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo</span> apt-get autoremove --purge php<span class="number">5</span>.<span class="number">6</span>-mysql</span><br></pre></td></tr></table></figure><p>执行之后再次使用命令查看：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg --list<span class="string">|grep mysql</span></span><br></pre></td></tr></table></figure><p>输入命令之后没有任何返回即成功，这里输入了两次：</p><p><img src="/ubuntu20-04%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEmysql8-%E8%AF%A6%E7%BB%86/index/1.4.png"></p><h2 id="2-服务器（ubuntu18-04）安装MySQL8"><a href="#2-服务器（ubuntu18-04）安装MySQL8" class="headerlink" title="2. 服务器（ubuntu18.04）安装MySQL8"></a>2. 服务器（ubuntu18.04）安装MySQL8</h2><h3 id="2-1-使用命令下载存储库软件包"><a href="#2-1-使用命令下载存储库软件包" class="headerlink" title="2.1  使用命令下载存储库软件包"></a>2.1  使用命令下载存储库软件包</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">wget</span> -c https://dev.mysql.com/get/mysql-apt-config_<span class="number">0</span>.<span class="number">8</span>.<span class="number">10</span>-<span class="number">1</span>_all.deb</span><br></pre></td></tr></table></figure><h3 id="2-2-使用命令安装上边下载的安装包"><a href="#2-2-使用命令安装上边下载的安装包" class="headerlink" title="2.2  使用命令安装上边下载的安装包"></a>2.2  <strong>使用命令安装上边下载的安装包</strong></h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo</span> dpkg -i mysql-apt-config_<span class="number">0</span>.<span class="number">8</span>.<span class="number">10</span>-<span class="number">1</span>_all.deb</span><br></pre></td></tr></table></figure><blockquote><p>安装过程中提示选择安装版本，默认安装的就是8.0版本，所以直接选择“OK”确认即可；</p></blockquote><p><img src="/ubuntu20-04%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEmysql8-%E8%AF%A6%E7%BB%86/index/1.10.png"></p><h3 id="2-3-从所有已配置的存储库（包括新添加的-MySQL-8存储库）中下载最新的软件包信息："><a href="#2-3-从所有已配置的存储库（包括新添加的-MySQL-8存储库）中下载最新的软件包信息：" class="headerlink" title="2.3 从所有已配置的存储库（包括新添加的 MySQL 8存储库）中下载最新的软件包信息："></a>2.3 <strong>从所有已配置的存储库（包括新添加的 MySQL 8存储库）中下载最新的软件包信息：</strong></h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo apt update</span></span><br></pre></td></tr></table></figure><blockquote><p>可能的报错：</p><p><img src="/ubuntu20-04%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEmysql8-%E8%AF%A6%E7%BB%86/index/1.6.png"></p><p><strong>解决：</strong></p><ol><li><p>查看签名列表：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="type">key</span> <span class="type">list</span></span><br></pre></td></tr></table></figure><p><img src="/ubuntu20-04%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEmysql8-%E8%AF%A6%E7%BB%86/index/1.7.png"></p></li><li><p>删除过期的签名；（del 后跟上条指令查到的pub）</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">key</span> <span class="built_in">del</span> dsa1024</span><br></pre></td></tr></table></figure></li><li><p>重新添加新的签名</p><blockquote><p>GPG error: <a href="http://repo.mysql.com/apt/ubuntu">http://repo.mysql.com/apt/ubuntu</a> focal InRelease: The following signatures couldn’t be verified because the public key is not available: NO_PUBKEY 467B942D3A79BD29</p></blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo</span> apt-key adv --keyserver keyserver.ubuntu.com --recv-keys <span class="number">467</span>B<span class="number">942</span>D<span class="number">3</span>A<span class="number">79</span>BD<span class="number">29</span></span><br></pre></td></tr></table></figure><p><img src="/ubuntu20-04%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEmysql8-%E8%AF%A6%E7%BB%86/index/1.8.png"></p></li><li><p>之后继续执行更新命令:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo apt update</span></span><br></pre></td></tr></table></figure><p><img src="/ubuntu20-04%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEmysql8-%E8%AF%A6%E7%BB%86/index/1.9.png"></p></li></ol></blockquote><h3 id="2-4-安装MySQL8"><a href="#2-4-安装MySQL8" class="headerlink" title="2.4  安装MySQL8"></a>2.4  安装MySQL8</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install mysql-<span class="keyword">server</span></span><br></pre></td></tr></table></figure><p>安装过程中会提示设置root密码。按照提示输入即可；</p><p><strong>输入之后会出现选择加密方式的提示界面，我在网上的教程中看到默认的mysql8.0的加密方式与ubuntu18.04 及以上不兼容，所以选择5.x的加密方式；建议选择下边的那个：</strong></p><h3 id="2-5-验证"><a href="#2-5-验证" class="headerlink" title="2.5 验证"></a>2.5 验证</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -<span class="selector-tag">p</span></span><br></pre></td></tr></table></figure><p>[图片]</p><h2 id="3-在Ubuntu-20-04-LTS-Focal-Fossa上安装MySQL8"><a href="#3-在Ubuntu-20-04-LTS-Focal-Fossa上安装MySQL8" class="headerlink" title="3. 在Ubuntu 20.04 LTS Focal Fossa上安装MySQL8"></a>3. 在Ubuntu 20.04 LTS Focal Fossa上安装MySQL8</h2><p>在上一节中，执行命令<code>sudo dpkg -i mysql-apt-config_0.8.10-1_all.deb</code>的时候提示这是ubuntu focal系统，这里根据<a href="https://www.how2shout.com/how-to/how-to-install-mysql-on-ubuntu-20-04-lts-focal-fossa.html">教程</a>来安装。</p><p><img src="/ubuntu20-04%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEmysql8-%E8%AF%A6%E7%BB%86/index/1.11.png"></p><h3 id="Step-1-Update-the-system-to-the-latest"><a href="#Step-1-Update-the-system-to-the-latest" class="headerlink" title="Step 1: Update the system to the latest"></a><strong>Step 1: Update the system to the latest</strong></h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo apt update</span></span><br></pre></td></tr></table></figure><h3 id="Step-2-Install-MySQL-on-Ubuntu-20-04"><a href="#Step-2-Install-MySQL-on-Ubuntu-20-04" class="headerlink" title="Step 2: Install MySQL on Ubuntu 20.04"></a><strong>Step 2: Install MySQL on Ubuntu 20.04</strong></h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install mysql-<span class="keyword">server</span></span><br></pre></td></tr></table></figure><h3 id="Step-3-Secure-MySQL-installation"><a href="#Step-3-Secure-MySQL-installation" class="headerlink" title="Step 3: Secure MySQL installation\"></a><strong>Step 3: Secure MySQL installation</strong>\</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo mysql_secure_installation</span></span><br></pre></td></tr></table></figure><p><img src="/ubuntu20-04%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEmysql8-%E8%AF%A6%E7%BB%86/index/1.12.png"></p><blockquote><p>可能的问题：</p><p>设置完密码之后按照要求”Do you wish to continue with the password provided?”输入yes报错如下：</p><p><code>[MySQL Failed! Error: SET PASSWORD has no significance for user ‘root’@’localhost’ as the authentication method used doesn’t store authentication data in the MySQL server. Please consider using ALTER USER](https://www.nixcraft.com/t/mysql-failed-error-set-password-has-no-significance-for-user-root-localhost-as-the-authentication-method-used-doesnt-store-authentication-data-in-the-mysql-server-please-consider-using-alter-user/4233)</code></p><p><strong><a href="https://www.nixcraft.com/t/mysql-failed-error-set-password-has-no-significance-for-user-root-localhost-as-the-authentication-method-used-doesnt-store-authentication-data-in-the-mysql-server-please-consider-using-alter-user/4233">解决</a>：</strong></p><ol><li>Open the terminal application.</li><li>Terminate the <code>mysql_secure_installation</code> from another terminal using the <code>killall command</code>:<br><code>sudo killall -9 mysql_secure_installation</code></li><li>Start the mysql client:<br><code>sudo mysql</code></li><li>Run the following SQL query:</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED WITH mysql_native_password BY <span class="string">&#x27;SetRootPasswordHere&#x27;</span>;</span><br><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure><ol><li><p>Then run the following command to secure it:<br><code>sudo mysql_secure_installation</code></p></li><li><p>When promoted for the password enter the <code>SetRootPasswordHere</code> (or whatever you set when you ran the above SQL query)</p></li><li><p>That is all.</p></li></ol></blockquote><p>成功界面如下：</p><p><img src="/ubuntu20-04%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEmysql8-%E8%AF%A6%E7%BB%86/index/1.13.png"></p><h3 id="Step-4-Test-MySQL-Community-Server-service"><a href="#Step-4-Test-MySQL-Community-Server-service" class="headerlink" title="Step 4: Test MySQL Community Server service"></a><strong>Step 4: Test MySQL Community Server service</strong></h3><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="keyword">status</span> mysql.service</span><br></pre></td></tr></table></figure><p><img src="/ubuntu20-04%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEmysql8-%E8%AF%A6%E7%BB%86/index/1.14.png"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -<span class="selector-tag">p</span></span><br></pre></td></tr></table></figure><p><img src="/ubuntu20-04%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEmysql8-%E8%AF%A6%E7%BB%86/index/1.15.png"></p><h2 id="4-navicat-连接"><a href="#4-navicat-连接" class="headerlink" title="4. navicat 连接"></a>4. navicat 连接</h2><h3 id="4-1-连接报错1103"><a href="#4-1-连接报错1103" class="headerlink" title="4.1 连接报错1103"></a>4.1 连接报错1103</h3><p>[图片]</p><p><strong>原因:</strong>帐号不允许从远程登陆，只能在localhost。这个时候只要在localhost的那台电脑，登入mysql后，更改”mysql” 数据库里的 “user” 表里的 “host”项，从”localhost”改称”%”</p><p>在虚拟机/服务器上进入mysql:</p><ol><li><code>use mysql;</code></li><li><code>select host, user from user;</code></li><li><code>update user set host = &#39;%&#39; where user = &#39;root&#39;;</code></li><li><code>flush   privileges;</code></li><li><code>service mysql restart</code></li></ol><h3 id="4-2-连接报错2003"><a href="#4-2-连接报错2003" class="headerlink" title="4.2 连接报错2003"></a>4.2 连接报错2003</h3><ol><li>在windows下，cmd 输入</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">telnet</span>  <span class="number">192</span>.<span class="number">168</span>.xxx.xxx <span class="number">3306</span></span><br></pre></td></tr></table></figure><ol><li>在虚拟机下输入</li></ol><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -anp<span class="string">| grep 3306</span></span><br></pre></td></tr></table></figure><p><img src="/ubuntu20-04%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEmysql8-%E8%AF%A6%E7%BB%86/index/1.16.png"></p><ol><li>修改<code>/etc/mysql/mysql.conf.d/mysqld.cnf</code></li></ol><p><strong>需要root权限，<code>sudo passwd root</code>设置root密码， <code>su</code>进入root.</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim <span class="regexp">/etc/my</span>sql<span class="regexp">/mysql.conf.d/my</span>sqld.cnf</span><br></pre></td></tr></table></figure><p>把 bind-address = 127.0.0.1 改为 bind-address = 0.0.0.0</p><p><strong>上面的意思是改为监听所有地址</strong></p><ol><li>重启MySQL</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">service mysql restart</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>新英文杂志</title>
      <link href="/%E6%96%B0%E8%8B%B1%E6%96%87%E6%9D%82%E5%BF%97/index.html"/>
      <url>/%E6%96%B0%E8%8B%B1%E6%96%87%E6%9D%82%E5%BF%97/index.html</url>
      
        <content type="html"><![CDATA[<ul><li>in light of  考虑到</li><li>nuanced adj. 有细微差别的<ul><li>a much more nuanced picture 一个更加细致的局面/情况</li></ul></li><li>wind up doing/ in sth. 以…告终<ul><li>I always said he would wiind up in prison.</li></ul></li><li>quintessential adj. 典型的，范例的</li><li><p>take hold 产生影响后受欢迎</p><ul><li>as the idea took hold that …</li></ul></li><li><p>sobering 令人警醒的，使人冷静的</p></li><li>a/the silver lining 困境中的一丝希望</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Axios学习笔记</title>
      <link href="/axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"/>
      <url>/axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html</url>
      
        <content type="html"><![CDATA[<p>此笔记转载自<a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Ajax%E3%80%81Axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">这里</a>,对应的视频课程是<a href="https://www.bilibili.com/video/av756328321?from=search&amp;seid=3894592914109668754&amp;spm_id_from=333.337.0.0">尚硅谷Web前端axios入门与源码解析</a></p><h2 id="预备工具"><a href="#预备工具" class="headerlink" title="预备工具"></a>预备工具</h2><blockquote><ol><li>作为一个前端开发工程师，在后端还没有ready的时候，不可避免的要使用mock的数据。很多时候，我们并不想使用简单的静态数据，而是希望自己起一个本地的mock-server来完全模拟请求以及请求回来的过程。json-server是一个很好的可以替我们完成这一工作的工具。我们只需要提供一个json文件，或者写几行简单的js脚本就可以模拟出RESTful API的接口。</li><li>安装json-server<br><code>npm install -g json-server</code></li><li>创建db.json<br>在一个文件夹下新建一个db.json文件</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="attr">&quot;posts&quot;</span>: [</span><br><span class="line"> &#123; <span class="attr">&quot;id&quot;</span>: <span class="number">1</span>, <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;json-server&quot;</span>, <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;typicode&quot;</span> &#125;</span><br><span class="line">&gt;],</span><br><span class="line">&gt;<span class="attr">&quot;comments&quot;</span>: [</span><br><span class="line"> &#123; <span class="attr">&quot;id&quot;</span>: <span class="number">1</span>, <span class="attr">&quot;body&quot;</span>: <span class="string">&quot;some comment&quot;</span>, <span class="attr">&quot;postId&quot;</span>: <span class="number">1</span> &#125;</span><br><span class="line">&gt;],</span><br><span class="line">&gt;<span class="attr">&quot;profile&quot;</span>: &#123; <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;typicode&quot;</span> &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><ol><li>启动json-server<br>在当前文件夹下输入如下命令：<code>json-server db.json</code></li><li><a href="https://github.com/typicode/json-server">文档</a></li></ol></blockquote><h1 id="一、Axios的理解与使用"><a href="#一、Axios的理解与使用" class="headerlink" title="一、Axios的理解与使用"></a>一、Axios的理解与使用</h1><h2 id="axios-是什么"><a href="#axios-是什么" class="headerlink" title="axios 是什么?"></a>axios 是什么?</h2><blockquote><ol><li>前端最流行的 ajax 请求库 </li><li>react/vue 官方都推荐使用 axios 发 ajax 请求 </li><li>文档: <a href="https://github.com/axios/axios">https://github.com/axios/axios</a></li></ol></blockquote><h2 id="axios-特点"><a href="#axios-特点" class="headerlink" title="axios 特点"></a>axios 特点</h2><blockquote><ol><li>基于 xhr + promise 的异步 ajax 请求库 </li><li>浏览器端/node 端都可以使用 </li><li>支持请求／响应拦截器 </li><li>支持请求取消 </li><li>请求/响应数据转换 </li><li>批量发送多个请求</li></ol></blockquote><h2 id="axios-常用语法"><a href="#axios-常用语法" class="headerlink" title="axios 常用语法"></a>axios 常用语法</h2><blockquote><ol><li>axios(config): <code>通用/最本质</code>的发任意类型请求的方式 </li><li>axios(url[, config]): 可以只指定 url 发 get 请求 </li><li>axios.request(config): 等同于 axios(config) </li><li>axios.get(url[, config]): 发 get 请求 </li><li>axios.delete(url[, config]): 发 delete 请求 </li><li>axios.post(url[, data, config]): 发 post 请求</li><li>axios.put(url[, data, config]): 发 put 请求 </li><li>axios.defaults.xxx: 请求的默认全局配置 </li><li>axios.interceptors.request.use(): 添加请求拦截器 </li><li>axios.interceptors.response.use(): 添加响应拦截器 </li><li>axios.create([config]): 创建一个新的 axios(它没有下面的功能) </li><li>axios.Cancel(): 用于创建取消请求的错误对象 </li><li>axios.CancelToken(): 用于创建取消请求的 token 对象 </li><li>axios.isCancel(): 是否是一个取消请求的错误 </li><li>axios.all(promises): 用于批量执行多个异步请求 </li><li>axios.spread(): 用来指定接收所有成功数据的回调函数的方法</li></ol></blockquote><h2 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h2><p><img src="/axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index/Axios系统学习笔记原理图.png"></p><h2 id="难点语法的理解和使用"><a href="#难点语法的理解和使用" class="headerlink" title="难点语法的理解和使用"></a>难点语法的理解和使用</h2><h3 id="axios-create-config"><a href="#axios-create-config" class="headerlink" title="axios.create(config)"></a>axios.create(config)</h3><blockquote><ol><li><p>根据指定配置创建一个新的 axios, 也就就每个新 axios 都有自己的配置 </p></li><li><p>新 axios 只是没有取消请求和批量发请求的方法, 其它所有语法都是一致的 </p></li><li><p>为什么要设计这个语法?</p><p>(1) 需求: 项目中有部分接口需要的配置与另一部分接口需要的配置不太一样, 如何处理 </p><p>(2) 解决: 创建 2 个新 axios, 每个都有自己特有的配置, 分别应用到不同要 求的接口请求中</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建实例对象  /getJoke</span></span><br><span class="line">  <span class="keyword">const</span> duanzi = axios.create(&#123;</span><br><span class="line">    <span class="attr">baseURL</span>: <span class="string">&#x27;https://api.apiopen.top&#x27;</span>,</span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">2000</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> onather = axios.create(&#123;</span><br><span class="line">    <span class="attr">baseURL</span>: <span class="string">&#x27;https://b.com&#x27;</span>,</span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">2000</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">//这里  duanzi 与 axios 对象的功能几近是一样的</span></span><br><span class="line">  <span class="comment">// duanzi(&#123;</span></span><br><span class="line">  <span class="comment">//     url: &#x27;/getJoke&#x27;,</span></span><br><span class="line">  <span class="comment">// &#125;).then(response =&gt; &#123;</span></span><br><span class="line">  <span class="comment">//     console.log(response);</span></span><br><span class="line">  <span class="comment">// &#125;);</span></span><br><span class="line">  duanzi.get(<span class="string">&#x27;/getJoke&#x27;</span>).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response.data)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></blockquote><h3 id="拦截器函数-ajax-请求-请求的回调函数的调用顺序"><a href="#拦截器函数-ajax-请求-请求的回调函数的调用顺序" class="headerlink" title="拦截器函数/ajax 请求/请求的回调函数的调用顺序"></a>拦截器函数/ajax 请求/请求的回调函数的调用顺序</h3><blockquote><ol><li>说明: 调用 axios()并不是立即发送 ajax 请求, 而是需要经历一个较长的流程 </li><li>流程: 请求拦截器2 =&gt; 请求拦截器1 =&gt; 发ajax请求 =&gt; 响应拦截器1 =&gt; 响应拦截器 2 =&gt; 请求的回调 </li><li>注意: 此流程是通过 promise 串连起来的, 请求拦截器传递的是 config, 响应 拦截器传递的是 response</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="comment">// Promise</span></span><br><span class="line">  <span class="comment">// 设置请求拦截器  config 配置对象</span></span><br><span class="line">  axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;请求拦截器 成功 - 1号&#x27;</span>);</span><br><span class="line">    <span class="comment">//修改 config 中的参数</span></span><br><span class="line">    config.params = &#123;</span><br><span class="line">      <span class="attr">a</span>: <span class="number">100</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;请求拦截器 失败 - 1号&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;请求拦截器 成功 - 2号&#x27;</span>);</span><br><span class="line">    <span class="comment">//修改 config 中的参数</span></span><br><span class="line">    config.timeout = <span class="number">2000</span>;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;请求拦截器 失败 - 2号&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置响应拦截器</span></span><br><span class="line">  axios.interceptors.response.use(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;响应拦截器 成功 1号&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> response.data;</span><br><span class="line">    <span class="comment">// return response;</span></span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;响应拦截器 失败 1号&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  axios.interceptors.response.use(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;响应拦截器 成功 2号&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;响应拦截器 失败 2号&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//发送请求</span></span><br><span class="line">  axios(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts&#x27;</span></span><br><span class="line">  &#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;自定义回调处理成功的结果&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h3><blockquote><ol><li>基本流程 配置 cancelToken 对象 <ol><li>缓存用于取消请求的 cancel 函数 </li><li>在后面特定时机调用 cancel 函数取消请求 </li><li>在错误回调中判断如果 error 是 cancel, 做相应处理</li></ol></li><li>实现功能 点击按钮, 取消某个正在请求中的请求,<ol><li>实现功能 点击按钮, 取消某个正在请求中的请求</li></ol></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="comment">//获取按钮</span></span><br><span class="line">  <span class="keyword">const</span> btns = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">  <span class="comment">//2.声明全局变量</span></span><br><span class="line">  <span class="keyword">let</span> cancel = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">//发送请求</span></span><br><span class="line">  btns[<span class="number">0</span>].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//检测上一次的请求是否已经完成</span></span><br><span class="line">    <span class="keyword">if</span> (cancel !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//取消上一次的请求</span></span><br><span class="line">      cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    axios(&#123;</span><br><span class="line">      <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts&#x27;</span>,</span><br><span class="line">      <span class="comment">//1. 添加配置对象的属性</span></span><br><span class="line">      <span class="attr">cancelToken</span>: <span class="keyword">new</span> axios.CancelToken(<span class="function"><span class="keyword">function</span> (<span class="params">c</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//3. 将 c 的值赋值给 cancel</span></span><br><span class="line">        cancel = c;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(response);</span><br><span class="line">      <span class="comment">//将 cancel 的值初始化</span></span><br><span class="line">      cancel = <span class="literal">null</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//绑定第二个事件取消请求</span></span><br><span class="line">  btns[<span class="number">1</span>].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;cancel(); &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h2><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//默认配置</span></span><br><span class="line">  axios.defaults.method = <span class="string">&#x27;GET&#x27;</span>;<span class="comment">//设置默认的请求类型为 GET</span></span><br><span class="line">  axios.defaults.baseURL = <span class="string">&#x27;http://localhost:3000&#x27;</span>;<span class="comment">//设置基础 URL</span></span><br><span class="line">  axios.defaults.params = &#123;<span class="attr">id</span>:<span class="number">100</span>&#125;;</span><br><span class="line">  axios.defaults.timeout = <span class="number">3000</span>;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">  btns[<span class="number">0</span>].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      axios(&#123;</span><br><span class="line">          <span class="attr">url</span>: <span class="string">&#x27;/posts&#x27;</span></span><br><span class="line">      &#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(response);</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="Axios的难点问题"><a href="#Axios的难点问题" class="headerlink" title="Axios的难点问题"></a>Axios的难点问题</h1><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><blockquote><p>├── /dist/ # 项目输出目录<br>├── /lib/ # 项目源码目录<br>│ ├── /adapters/ # 定义请求的适配器 xhr、http<br>│ │ ├── http.js # 实现 http 适配器(包装 http 包)<br>│ │ └── xhr.js # 实现 xhr 适配器(包装 xhr 对象)<br>│ ├── /cancel/ # 定义取消功能<br>│ ├── /core/ # 一些核心功能<br>│ │ ├── Axios.js # axios 的核心主类<br>│ │ ├── dispatchRequest.js # 用来调用 http 请求适配器方法发送请求的函数<br>│ │ ├── InterceptorManager.js # 拦截器的管理器<br>│ │ └── settle.js # 根据 http 响应状态，改变 Promise 的状态<br>│ ├── /helpers/ # 一些辅助方法<br>│ ├── axios.js # 对外暴露接口<br>│ ├── defaults.js # axios 的默认配置<br>│ └── utils.js # 公用工具<br>├── package.json # 项目信息<br>├── index.d.ts # 配置 TypeScript 的声明文件<br>└── index.js # 入口文件</p></blockquote><h2 id="axios-与-Axios-的关系"><a href="#axios-与-Axios-的关系" class="headerlink" title="axios 与 Axios 的关系"></a>axios 与 Axios 的关系</h2><blockquote><ol><li>从<code>语法</code>上来说: axios 不是 Axios 的实例</li><li>从<code>功能</code>上来说: axios 是 Axios 的实例</li><li>axios 是 <code>Axios.prototype.request</code> 函数 bind()返回的函数</li><li>axios 作为对象有 Axios 原型对象上的所有方法, 有 Axios 对象上所有属性</li></ol></blockquote><h2 id="instance-与-axios-的区别"><a href="#instance-与-axios-的区别" class="headerlink" title="instance 与 axios 的区别?"></a>instance 与 axios 的区别?</h2><blockquote><ol><li>相同:<br>(1) 都是一个能发任意请求的函数: request(config)<br>(2) 都有发特定请求的各种方法: get()/post()/put()/delete()<br>(3) 都有默认配置和拦截器的属性: defaults/interceptors</li><li>不同:<br>(1) 默认配置很可能不一样<br>(2) instance 没有 axios 后面添加的一些方法: create()/CancelToken()/all()</li></ol></blockquote><h2 id="axios运行的整体流程"><a href="#axios运行的整体流程" class="headerlink" title="axios运行的整体流程"></a>axios运行的整体流程</h2><blockquote><ol><li><p>整体流程:<br>request(config) ==&gt; dispatchRequest(config) ==&gt; xhrAdapter(config)</p></li><li><p>request(config):<br>将请求拦截器 / dispatchRequest() / 响应拦截器 通过 promise 链串连起来,<br> 返回 promise</p></li><li><p>dispatchRequest(config):<br>转换请求数据 ===&gt; 调用 xhrAdapter()发请求 ===&gt; 请求返回后转换响应数<br> 据. 返回 promise</p></li><li><p>xhrAdapter(config):<br>创建 XHR 对象, 根据 config 进行相应设置, 发送特定请求, 并接收响应数据,<br> 返回 promise </p></li><li><p>流程图:</p></li></ol><p><img src="/axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index/Users\Hasuer\AppData\Local\Temp\BNZ.62187fc84e0baf70\Axios入门与源码解析笔记中的图片\Axios系统学习流程图.png" alt="Axios系统学习流程图"></p></blockquote><h2 id="axios-的请求-响应拦截器是什么"><a href="#axios-的请求-响应拦截器是什么" class="headerlink" title="axios 的请求/响应拦截器是什么?"></a>axios 的请求/响应拦截器是什么?</h2><blockquote><ol><li>请求拦截器:<br>Ⅰ- 在真正发送请求前执行的回调函数<br>Ⅱ- 可以对请求进行检查或配置进行特定处理<br>Ⅲ- 成功的回调函数, 传递的默认是 config(也必须是)<br>Ⅳ- 失败的回调函数, 传递的默认是 error</li><li>响应拦截器<br>Ⅰ- 在请求得到响应后执行的回调函数<br>Ⅱ- 可以对响应数据进行特定处理<br>Ⅲ- 成功的回调函数, 传递的默认是 response<br>Ⅳ- 失败的回调函数, 传递的默认是 error</li></ol></blockquote><h2 id="axios-的请求-响应数据转换器是什么"><a href="#axios-的请求-响应数据转换器是什么" class="headerlink" title="axios 的请求/响应数据转换器是什么?"></a>axios 的请求/响应数据转换器是什么?</h2><blockquote><ol><li>请求转换器: 对请求头和请求体数据进行特定处理的函数</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">if</span> (utils.isObject(data)) &#123;</span><br><span class="line">setContentTypeIfUnset(headers, <span class="string">&#x27;application/json;charset=utf-8&#x27;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(data);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><ol><li>响应转换器: 将响应体 json 字符串解析为 js 对象或数组的函数</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;response.data = <span class="built_in">JSON</span>.parse(response.data)</span><br></pre></td></tr></table></figure></blockquote><h2 id="response与error-的整体结构"><a href="#response与error-的整体结构" class="headerlink" title="response与error  的整体结构"></a>response与error  的整体结构</h2><blockquote><ol><li>response的整体结构</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&#123;</span><br><span class="line">&gt;data, status,statusText,headers,config,request</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><ol><li>error  的整体结构</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&#123;</span><br><span class="line">&gt;message,response,request,</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="如何取消未完成的请求"><a href="#如何取消未完成的请求" class="headerlink" title="如何取消未完成的请求?"></a>如何取消未完成的请求?</h2><blockquote><ol><li>当配置了 cancelToken 对象时, 保存 cancel 函数<br>(1) 创建一个用于将来中断请求的 cancelPromise<br>(2) 并定义了一个用于取消请求的 cancel 函数<br>(3) 将 cancel 函数传递出来</li><li>调用 cancel()取消请求<br>(1) 执行 cacel 函数, 传入错误信息 message<br>(2) 内部会让 cancelPromise 变为成功, 且成功的值为一个 Cancel 对象<br>(3) 在 cancelPromise 的成功回调中中断请求, 并让发请求的 proimse 失败,<br>失败的 reason 为 Cancel 对象</li></ol></blockquote><h1 id="Axios源码模拟实现"><a href="#Axios源码模拟实现" class="headerlink" title="Axios源码模拟实现"></a>Axios源码模拟实现</h1><h2 id="axios-的创建过程模拟实现"><a href="#axios-的创建过程模拟实现" class="headerlink" title="axios 的创建过程模拟实现"></a>axios 的创建过程模拟实现</h2><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="comment">//构造函数</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="function"><span class="keyword">function</span> <span class="title">Axios</span>(<span class="params">config</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">//初始化</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="built_in">this</span>.defaults = config; <span class="comment">//为了创建 default 默认属性</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="built_in">this</span>.intercepters = &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">request</span>: &#123;&#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">response</span>: &#123;&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="comment">//原型添加相关的方法</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;Axios.prototype.request = <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="built_in">console</span>.log(<span class="string">&#x27;发送 AJAX 请求 请求的类型为 &#x27;</span> + config.method);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;Axios.prototype.get = <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">return</span> <span class="built_in">this</span>.request(&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;Axios.prototype.post = <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">return</span> <span class="built_in">this</span>.request(&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="comment">//声明函数</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="function"><span class="keyword">function</span> <span class="title">createInstance</span>(<span class="params">config</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">//实例化一个对象</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">let</span> context = <span class="keyword">new</span> Axios(config); <span class="comment">// context.get()  context.post()  但是不能当做函数使用 context() X</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">//创建请求函数</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">let</span> instance = Axios.prototype.request.bind(</span></span></span><br><span class="line"><span class="javascript"><span class="xml">context); <span class="comment">// instance 是一个函数 并且可以 instance(&#123;&#125;)  此时 instance 不能 instance.get X</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">//将 Axios.prototype 对象中的方法添加到instance函数对象中,才可以instance.get....</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="built_in">Object</span>.keys(Axios.prototype).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  instance[key] = Axios.prototype[key].bind(context); <span class="comment">// this.default  this.interceptors</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">//为 instance 函数对象添加属性 default 与 interceptors</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="built_in">Object</span>.keys(context).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  instance[key] = context[key];</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">return</span> instance;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="keyword">let</span> axios = createInstance();</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="comment">//发送请求</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="comment">// axios(&#123;method:&#x27;POST&#x27;&#125;);</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;axios.get(&#123;&#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;axios.post(&#123;&#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></blockquote><h2 id="axios发送请求过程详解"><a href="#axios发送请求过程详解" class="headerlink" title="axios发送请求过程详解"></a>axios发送请求过程详解</h2><blockquote><ol><li>整体流程:<br>request(config) ==&gt; dispatchRequest(config) ==&gt; xhrAdapter(config)</li><li>request(config):<br>将请求拦截器 / dispatchRequest() / 响应拦截器 通过 promise 链串连起来,<br>返回 promise</li><li>dispatchRequest(config):<br>转换请求数据 ===&gt; 调用 xhrAdapter()发请求 ===&gt; 请求返回后转换响应数<br>据. 返回 promise</li><li>xhrAdapter(config):<br>创建 XHR 对象, 根据 config 进行相应设置, 发送特定请求, 并接收响应数据,<br>返回 promise </li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="comment">// axios 发送请求   axios  Axios.prototype.request  bind</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="comment">//1. 声明构造函数</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="keyword">function</span> <span class="title">Axios</span>(<span class="params">config</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="built_in">this</span>.config = config;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  Axios.prototype.request = <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//发送请求</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//创建一个 promise 对象</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve(config);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//声明一个数组</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">let</span> chains = [dispatchRequest, <span class="literal">undefined</span>]; <span class="comment">// undefined 占位</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//调用 then 方法指定回调</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">let</span> result = promise.then(chains[<span class="number">0</span>], chains[<span class="number">1</span>]);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//返回 promise 的结果</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">return</span> result;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="comment">//2. dispatchRequest 函数</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="keyword">function</span> <span class="title">dispatchRequest</span>(<span class="params">config</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//调用适配器发送请求</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">return</span> xhrAdapter(config).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">//响应的结果进行转换处理</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">//....</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">return</span> response;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">throw</span> error;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="comment">//3. adapter 适配器</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="keyword">function</span> <span class="title">xhrAdapter</span>(<span class="params">config</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="built_in">console</span>.log(<span class="string">&#x27;xhrAdapter 函数执行&#x27;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">//发送 AJAX 请求</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">//初始化</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      xhr.open(config.method, config.url);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">//发送</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      xhr.send();</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">//绑定事件</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="comment">//判断成功的条件</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="comment">//成功的状态</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            resolve(&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">              <span class="comment">//配置对象</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">              <span class="attr">config</span>: config,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">              <span class="comment">//响应体</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">              <span class="attr">data</span>: xhr.response,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">              <span class="comment">//响应头</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">              <span class="attr">headers</span>: xhr.getAllResponseHeaders(), <span class="comment">//字符串  parseHeaders</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">              <span class="comment">// xhr 请求对象</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">              <span class="attr">request</span>: xhr,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">              <span class="comment">//响应状态码</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">              <span class="attr">status</span>: xhr.status,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">              <span class="comment">//响应状态字符串</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">              <span class="attr">statusText</span>: xhr.statusText</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            &#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          &#125; <span class="keyword">else</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="comment">//失败的状态</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;请求失败 失败的状态码为&#x27;</span> + xhr.status));</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="comment">//4. 创建 axios 函数</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">let</span> axios = Axios.prototype.request.bind(<span class="literal">null</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  axios(&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="built_in">console</span>.log(response);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></blockquote><h2 id="拦截器的模拟实现"><a href="#拦截器的模拟实现" class="headerlink" title="拦截器的模拟实现"></a>拦截器的模拟实现</h2><blockquote><ol><li>array.shift()该方法用于把数组的第一个元素从其中删除，并返回第一个元素的值</li><li>思路为先将拦截器的响应回调与请求回调都压入一个数组中,之后进行遍历运行</li><li><code>promise = promise.then(chains.shift(), chains.shift());</code> 通过循环使用promise的then链条得到最终的结果—&gt;等式前面的<code>promise</code>将被最终的结果覆盖</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">title</span>&gt;</span>拦截器<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">&gt;<span class="comment">&lt;!-- &lt;script src=&quot;./node_modules/axios/dist/mine-axios.js&quot;&gt;&lt;/script&gt; --&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">//构造函数</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">Axios</span>(<span class="params">config</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.config = config;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.interceptors = &#123;</span></span><br><span class="line"><span class="javascript">          <span class="attr">request</span>: <span class="keyword">new</span> InterceptorManager(),</span></span><br><span class="line"><span class="javascript">          <span class="attr">response</span>: <span class="keyword">new</span> InterceptorManager(),</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">  <span class="comment">//发送请求  难点与重点</span></span></span><br><span class="line"><span class="javascript">  Axios.prototype.request = <span class="function"><span class="keyword">function</span>(<span class="params">config</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">//创建一个 promise 对象</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve(config);</span></span><br><span class="line"><span class="javascript">      <span class="comment">//创建一个数组</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> chains = [dispatchRequest, <span class="literal">undefined</span>];</span></span><br><span class="line"><span class="javascript">      <span class="comment">//处理拦截器</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//请求拦截器 将请求拦截器的回调 压入到 chains 的前面  request.handles = []</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.interceptors.request.handlers.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">          chains.unshift(item.fulfilled, item.rejected);</span></span><br><span class="line"><span class="javascript">      &#125;);</span></span><br><span class="line"><span class="javascript">      <span class="comment">//响应拦截器</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.interceptors.response.handlers.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">          chains.push(item.fulfilled, item.rejected);</span></span><br><span class="line"><span class="javascript">      &#125;);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="comment">// console.log(chains);</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//遍历</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">while</span>(chains.length &gt; <span class="number">0</span>)&#123; </span></span><br><span class="line"><span class="javascript">          <span class="comment">//array.shift()</span></span></span><br><span class="line"><span class="javascript">          promise = promise.then(chains.shift(), chains.shift());</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> promise;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">//发送请求</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">dispatchRequest</span>(<span class="params">config</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">//返回一个promise 队形</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">          resolve(&#123;</span></span><br><span class="line"><span class="javascript">              <span class="attr">status</span>: <span class="number">200</span>,</span></span><br><span class="line"><span class="javascript">              <span class="attr">statusText</span>: <span class="string">&#x27;OK&#x27;</span></span></span><br><span class="line"><span class="javascript">          &#125;);</span></span><br><span class="line"><span class="javascript">      &#125;);</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">//创建实例</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> context = <span class="keyword">new</span> Axios(&#123;&#125;);</span></span><br><span class="line"><span class="javascript">  <span class="comment">//创建axios函数</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> axios = Axios.prototype.request.bind(context);</span></span><br><span class="line"><span class="javascript">  <span class="comment">//将 context 属性 config interceptors 添加至 axios 函数对象身上</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">Object</span>.keys(context).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      axios[key] = context[key];</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">//拦截器管理器构造函数</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">InterceptorManager</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.handlers = [];</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">  InterceptorManager.prototype.use = <span class="function"><span class="keyword">function</span>(<span class="params">fulfilled, rejected</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.handlers.push(&#123;</span></span><br><span class="line"><span class="javascript">          fulfilled,</span></span><br><span class="line"><span class="javascript">          rejected</span></span><br><span class="line"><span class="javascript">      &#125;)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">//以下为功能测试代码</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 设置请求拦截器  config 配置对象</span></span></span><br><span class="line"><span class="javascript">  axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> <span class="title">one</span>(<span class="params">config</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;请求拦截器 成功 - 1号&#x27;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> config;</span></span><br><span class="line"><span class="javascript">  &#125;, <span class="function"><span class="keyword">function</span> <span class="title">one</span>(<span class="params">error</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;请求拦截器 失败 - 1号&#x27;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> <span class="title">two</span>(<span class="params">config</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;请求拦截器 成功 - 2号&#x27;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> config;</span></span><br><span class="line"><span class="javascript">  &#125;, <span class="function"><span class="keyword">function</span> <span class="title">two</span>(<span class="params">error</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;请求拦截器 失败 - 2号&#x27;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 设置响应拦截器</span></span></span><br><span class="line"><span class="javascript">  axios.interceptors.response.use(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;响应拦截器 成功 1号&#x27;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> response;</span></span><br><span class="line"><span class="javascript">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;响应拦截器 失败 1号&#x27;</span>)</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  axios.interceptors.response.use(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;响应拦截器 成功 2号&#x27;</span>)</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> response;</span></span><br><span class="line"><span class="javascript">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;响应拦截器 失败 2号&#x27;</span>)</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">//发送请求</span></span></span><br><span class="line"><span class="javascript">  axios(&#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts&#x27;</span></span></span><br><span class="line"><span class="javascript">  &#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(response);</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="请求取消功能模拟实现"><a href="#请求取消功能模拟实现" class="headerlink" title="请求取消功能模拟实现"></a>请求取消功能模拟实现</h2><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">title</span>&gt;</span>取消请求<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">link</span> <span class="attr">crossorigin</span>=<span class="string">&#x27;anonymous&#x27;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcss.com/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span>rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">&gt;<span class="comment">&lt;!-- &lt;script src=&quot;./node_modules/axios/dist/mine-axios.js&quot;&gt;&lt;/script&gt; --&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;page-header&quot;</span>&gt;</span>axios取消请求<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span>&gt;</span> 发送请求 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-warning&quot;</span>&gt;</span> 取消请求 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">&gt;<span class="comment">//构造函数</span></span></span><br><span class="line"><span class="javascript">&gt;<span class="function"><span class="keyword">function</span> <span class="title">Axios</span>(<span class="params">config</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">this</span>.config = config;</span></span><br><span class="line"><span class="javascript">&gt;&#125;</span></span><br><span class="line"><span class="javascript">&gt;<span class="comment">//原型 request 方法</span></span></span><br><span class="line"><span class="javascript">&gt;Axios.prototype.request = <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">return</span> dispatchRequest(config);</span></span><br><span class="line"><span class="javascript">&gt;&#125;</span></span><br><span class="line"><span class="javascript">&gt;<span class="comment">//dispatchRequest 函数</span></span></span><br><span class="line"><span class="javascript">&gt;<span class="function"><span class="keyword">function</span> <span class="title">dispatchRequest</span>(<span class="params">config</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">return</span> xhrAdapter(config);</span></span><br><span class="line"><span class="javascript">&gt;&#125;</span></span><br><span class="line"><span class="javascript">&gt;<span class="comment">//xhrAdapter</span></span></span><br><span class="line"><span class="javascript">&gt;<span class="function"><span class="keyword">function</span> <span class="title">xhrAdapter</span>(<span class="params">config</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="comment">//发送 AJAX 请求</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">//实例化对象</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="javascript">  <span class="comment">//初始化</span></span></span><br><span class="line"><span class="javascript">  xhr.open(config.method, config.url);</span></span><br><span class="line"><span class="javascript">  <span class="comment">//发送</span></span></span><br><span class="line"><span class="javascript">  xhr.send();</span></span><br><span class="line"><span class="javascript">  <span class="comment">//处理结果</span></span></span><br><span class="line"><span class="javascript">  xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">//判断结果</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//设置为成功的状态</span></span></span><br><span class="line"><span class="javascript">        resolve(&#123;</span></span><br><span class="line"><span class="javascript">          <span class="attr">status</span>: xhr.status,</span></span><br><span class="line"><span class="javascript">          <span class="attr">statusText</span>: xhr.statusText</span></span><br><span class="line"><span class="javascript">        &#125;);</span></span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;请求失败&#x27;</span>));</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">  <span class="comment">//关于取消请求的处理</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">if</span> (config.cancelToken) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//对 cancelToken 对象身上的 promise 对象指定成功的回调</span></span></span><br><span class="line"><span class="javascript">    config.cancelToken.promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      xhr.abort();</span></span><br><span class="line"><span class="javascript">      <span class="comment">//将整体结果设置为失败</span></span></span><br><span class="line"><span class="javascript">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;请求已经被取消&#x27;</span>))</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript">&gt;&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">&gt;<span class="comment">//创建 axios 函数</span></span></span><br><span class="line"><span class="javascript">&gt;<span class="keyword">const</span> context = <span class="keyword">new</span> Axios(&#123;&#125;);</span></span><br><span class="line"><span class="javascript">&gt;<span class="keyword">const</span> axios = Axios.prototype.request.bind(context);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">&gt;<span class="comment">//CancelToken 构造函数</span></span></span><br><span class="line"><span class="javascript">&gt;<span class="function"><span class="keyword">function</span> <span class="title">CancelToken</span>(<span class="params">executor</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="comment">//声明一个变量</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> resolvePromise;</span></span><br><span class="line"><span class="javascript"><span class="comment">//为实例对象添加属性</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">this</span>.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">//将 resolve 赋值给 resolvePromise</span></span></span><br><span class="line"><span class="javascript">  resolvePromise = resolve</span></span><br><span class="line"><span class="javascript">&#125;);</span></span><br><span class="line"><span class="javascript"><span class="comment">//调用 executor 函数</span></span></span><br><span class="line"><span class="javascript">executor(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">//执行 resolvePromise 函数</span></span></span><br><span class="line"><span class="javascript">  resolvePromise();</span></span><br><span class="line"><span class="javascript">&#125;);</span></span><br><span class="line"><span class="javascript">&gt;&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">&gt;<span class="comment">//获取按钮 以上为模拟实现的代码</span></span></span><br><span class="line"><span class="javascript">&gt;<span class="keyword">const</span> btns = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;button&#x27;</span>);</span></span><br><span class="line"><span class="javascript">&gt;<span class="comment">//2.声明全局变量</span></span></span><br><span class="line"><span class="javascript">&gt;<span class="keyword">let</span> cancel = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">&gt;<span class="comment">//发送请求</span></span></span><br><span class="line"><span class="javascript">&gt;btns[<span class="number">0</span>].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="comment">//检测上一次的请求是否已经完成</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (cancel !== <span class="literal">null</span>) &#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">//取消上一次的请求</span></span></span><br><span class="line"><span class="javascript">  cancel();</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">//创建 cancelToken 的值</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> cancelToken = <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span> (<span class="params">c</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  cancel = c;</span></span><br><span class="line"><span class="javascript">&#125;);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">axios(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts&#x27;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="comment">//1. 添加配置对象的属性</span></span></span><br><span class="line"><span class="javascript">  <span class="attr">cancelToken</span>: cancelToken</span></span><br><span class="line"><span class="javascript">&#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(response);</span></span><br><span class="line"><span class="javascript">  <span class="comment">//将 cancel 的值初始化</span></span></span><br><span class="line"><span class="javascript">  cancel = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript">&gt;&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">&gt;<span class="comment">//绑定第二个事件取消请求</span></span></span><br><span class="line"><span class="javascript">&gt;btns[<span class="number">1</span>].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">cancel();</span></span><br><span class="line"><span class="javascript">&gt;&#125;</span></span><br><span class="line"><span class="javascript">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h1 id="原作者对于某些问题解答与理解"><a href="#原作者对于某些问题解答与理解" class="headerlink" title="原作者对于某些问题解答与理解"></a>原作者对于某些问题解答与理解</h1><h2 id="axios同步与异步转换-在外部取值"><a href="#axios同步与异步转换-在外部取值" class="headerlink" title="axios同步与异步转换,在外部取值"></a>axios同步与异步转换,在外部取值</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>  axios  =  <span class="built_in">require</span> (<span class="string">&#x27;axios&#x27;</span>);</span><br><span class="line"> <span class="comment">//创建实例对象 </span></span><br><span class="line"> <span class="keyword">const</span> $http = axios.create(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;http://localhost:53000&#x27;</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">11000</span>  <span class="comment">//请求超时时间</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> resolveCommon = <span class="function">()=&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> data=$http(&#123; <span class="attr">url</span>:<span class="string">&quot;/test&quot;</span>&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">v</span>=&gt;</span>v.data)  <span class="comment">//等于 `.then(v=&gt;&#123;return v&#125;)`</span></span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">  <span class="comment">//打印结果: Promise &#123; &lt;pending&gt; &#125; </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> resolveAsync=<span class="keyword">async</span> ()=&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> data=<span class="keyword">await</span> $http(&#123; <span class="attr">url</span>:<span class="string">&quot;/test&quot;</span>&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">v</span>=&gt;</span>v.data)  <span class="comment">//等于 `.then(v=&gt;&#123;return v&#125;)`,我再then()中返回出去,让外部承接</span></span><br><span class="line">  <span class="built_in">console</span>.log(data)  <span class="comment">//获得正确的值</span></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 打印结果&#123; id: 1000,course_name: &#x27;这是请求数据1&#x27;, autor: &#x27;袁明&#x27;, college: &#x27;金并即总变史&#x27;,category_Id: 2&#125;</span></span><br><span class="line"><span class="comment">    *  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//模拟新增数据,将上一步的结果简单加工一下</span></span><br><span class="line">   data.course_name=data.course_name+<span class="number">1</span></span><br><span class="line"> $http(&#123;</span><br><span class="line">   <span class="attr">url</span>:<span class="string">&quot;/test&quot;</span>,</span><br><span class="line">   <span class="attr">method</span>:<span class="string">&quot;put&quot;</span>,</span><br><span class="line">   data</span><br><span class="line"> &#125;).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(v)  <span class="comment">//直接打印了 需要再取出参照上一步</span></span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">resolveCommon()  <span class="comment">//调用普通promise函数</span></span><br><span class="line">resolveAsync()    <span class="comment">//调用await+async</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Promise学习笔记</title>
      <link href="/promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"/>
      <url>/promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>笔记转载自<a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">这里</a>，有适当改动。</p><p>视频教程是<a href="https://www.bilibili.com/video/BV1GA411x7z1?from=search&amp;seid=7941337224331251655&amp;spm_id_from=333.337.0.0"><code>尚硅谷Web前端Promise教程从入门到精通</code></a></p></blockquote><h1 id="Promise的理解与使用"><a href="#Promise的理解与使用" class="headerlink" title="Promise的理解与使用"></a>Promise的理解与使用</h1><blockquote><p>1、概念:</p><p>​    Promise是<code>异步编程的一种解决方案</code>，比传统的解决方案——回调函数和事件——更合理和更强大。所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。</p><p>通俗讲，<code>Promise是一个许诺、承诺</code>,是对未来事情的承诺，承诺不一定能完成，但是无论是否能完成都会有一个结果。</p><ul><li>Pending  正在做。。。</li><li>Resolved 完成这个承诺</li><li>Rejected 这个承诺没有完成，失败了</li></ul><p>​    Promise 用来预定一个不一定能完成的任务，要么成功，要么失败</p><p>​    在具体的程序中具体的体现，通常用来封装一个异步任务，提供承诺结果</p><p>Promise 是异步编程的一种解决方案，<code>主要用来解决回调地狱的问题，可以有效的减少回调嵌套</code>。真正解决需要<code>配合async/await</code></p><p>2、特点:</p><p>​    (1)对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</p><p>​    (2)一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。</p><p>3、缺点:</p><p>​    (1)无法取消Promise，一旦新建它就会立即执行，无法中途取消。和一般的对象不一样，无需调用。</p><p>​    (2)如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</p><p>​    (3)当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）</p></blockquote><hr><h2 id="Promise是什么"><a href="#Promise是什么" class="headerlink" title="Promise是什么?"></a>Promise是什么?</h2><h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><blockquote><ol><li>抽象表达:  </li></ol><p>​    1) Promise 是一门新的技术(ES6 规范) </p><p>​    2)Promise 是 JS 中<code>进行异步编程</code>的新解决方案 备注：旧方案是单纯使用回调函数</p><ol><li><p>具体表达: </p><p>1) 从语法上来说: Promise 是一个<code>构造函数</code></p><p>2) 从功能上来说: promise 对象用来封装一个异步操作并可以获取其成功/ 失败的结果值</p></li></ol></blockquote><h4 id="promise-的状态"><a href="#promise-的状态" class="headerlink" title="promise 的状态"></a>promise 的状态</h4><h5 id="promise-的状态-1"><a href="#promise-的状态-1" class="headerlink" title="promise 的状态"></a>promise 的状态</h5><blockquote><p>实例对象中的一个属性 『PromiseState』</p><ul><li>pending  未决定的</li><li>resolved / fullfilled  成功</li><li>rejected  失败</li></ul></blockquote><h5 id="promise-的状态改变"><a href="#promise-的状态改变" class="headerlink" title="promise 的状态改变"></a>promise 的状态改变</h5><blockquote><ol><li><p>pending 变为 resolved </p></li><li><p>pending 变为 rejected</p><p>说明: <code>只有这 2 种</code>, 且一个 promise 对象<code>只能改变一次</code> 无论变为成功还是失败, 都会有一个结果数据 成功的结果数据一般称为 value, 失败的结果数据一般称为 reason</p></li></ol></blockquote><h4 id="promise的基本流程"><a href="#promise的基本流程" class="headerlink" title="promise的基本流程"></a>promise的基本流程</h4><p><img src="/promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index/1.jpg"></p><h4 id="promise的基本使用"><a href="#promise的基本使用" class="headerlink" title="promise的基本使用"></a>promise的基本使用</h4><h6 id="使用-promise-封装基于定时器的异步"><a href="#使用-promise-封装基于定时器的异步" class="headerlink" title="使用 promise 封装基于定时器的异步"></a>使用 promise 封装基于定时器的异步</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;script &gt;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doDelay</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建 promise 对象(pending 状态), 指定执行器函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 2. 在执行器函数中启动异步任务</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;启动异步任务&#x27;</span>)</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;延迟任务开始执行...&#x27;</span>)</span><br><span class="line">        <span class="keyword">const</span> time = <span class="built_in">Date</span>.now() <span class="comment">// 假设: 时间为奇数代表成功, 为偶数代表失败</span></span><br><span class="line">        <span class="keyword">if</span> (time % <span class="number">2</span> === <span class="number">1</span>) &#123; <span class="comment">// 成功了</span></span><br><span class="line">          <span class="comment">// 3. 1. 如果成功了, 调用 resolve()并传入成功的 value</span></span><br><span class="line">          resolve(<span class="string">&#x27;成功的数据 &#x27;</span> + time)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 失败了</span></span><br><span class="line">          <span class="comment">// 3.2. 如果失败了, 调用 reject()并传入失败的 reason</span></span><br><span class="line">          reject(<span class="string">&#x27;失败的数据 &#x27;</span> + time)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, time)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">const</span> promise = doDelay(<span class="number">2000</span>)</span><br><span class="line">promise.then(<span class="comment">// promise 指定成功或失败的回调函数来获取成功的 vlaue 或失败的 reason</span></span><br><span class="line">    <span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="comment">// 成功的回调函数 onResolved, 得到成功的 vlaue</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;成功的 value: &#x27;</span>, value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> &#123; <span class="comment">// 失败的回调函数 onRejected, 得到失败的 reason</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;失败的 reason: &#x27;</span>, reason)</span><br><span class="line">    &#125;,</span><br><span class="line">  ) &lt;</span><br><span class="line">  /script&gt;</span><br></pre></td></tr></table></figure><h6 id="使用-promise-封装-ajax-异步请求"><a href="#使用-promise-封装-ajax-异步请求" class="headerlink" title="使用 promise 封装 ajax 异步请求"></a>使用 promise 封装 ajax 异步请求</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;script &gt;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  可复用的发 ajax 请求的函数: xhr + promise</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">promiseAjax</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">      xhr.onreadystatechange = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.readyState !== <span class="number">4</span>) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">const</span> &#123;</span><br><span class="line">          status,</span><br><span class="line">          response</span><br><span class="line">        &#125; = xhr</span><br><span class="line">        <span class="comment">// 请求成功, 调用 resolve(value)</span></span><br><span class="line">        <span class="keyword">if</span> (status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">          resolve(<span class="built_in">JSON</span>.parse(response))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 请求失败, 调用 reject(reason)</span></span><br><span class="line">          reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;请求失败: status: &#x27;</span> + status))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      xhr.open(<span class="string">&quot;GET&quot;</span>, url)</span><br><span class="line">      xhr.send()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">promiseAjax(<span class="string">&#x27;https://api.apiopen.top2/getJoke?page=1&amp;count=2&amp;type=vid</span></span><br><span class="line"><span class="string">    eo &#x27;</span>)</span><br><span class="line">    .then(</span><br><span class="line">      <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;显示成功数据&#x27;</span>, data)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        alert(error.message)</span><br><span class="line">      &#125;</span><br><span class="line">    ) &lt;/script&gt;</span><br></pre></td></tr></table></figure><h6 id="fs模块使用Promise"><a href="#fs模块使用Promise" class="headerlink" title="fs模块使用Promise"></a>fs模块使用Promise</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//回调函数 形式----------------------------------------------------</span></span><br><span class="line"> fs.readFile(<span class="string">&#x27;./resource/content.txt&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="comment">// 如果出错 则抛出错误</span></span><br><span class="line">     <span class="keyword">if</span>(err)  <span class="keyword">throw</span> err;</span><br><span class="line">     <span class="comment">//输出文件内容</span></span><br><span class="line">     <span class="built_in">console</span>.log(data.toString());</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Promise 形式-----------------------------------------------------------</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 封装一个函数 mineReadFile 读取文件内容</span></span><br><span class="line"><span class="comment"> * 参数:  path  文件路径</span></span><br><span class="line"><span class="comment"> * 返回:  promise 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mineReadFile</span>(<span class="params">path</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//读取文件</span></span><br><span class="line">        <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>).readFile(path, <span class="function">(<span class="params">err, data</span>) =&gt;</span>&#123;</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">if</span>(err) reject(err);</span><br><span class="line">            <span class="comment">//成功</span></span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mineReadFile(<span class="string">&#x27;./resource/content.txt&#x27;</span>)</span><br><span class="line">.then(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//输出文件内容</span></span><br><span class="line">    <span class="built_in">console</span>.log(value.toString());</span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="异常穿透"><a href="#异常穿透" class="headerlink" title="异常穿透"></a>异常穿透</h6><blockquote><p>可以在每个then()的第二个回调函数中进行err处理,也可以利用异常穿透特性,到最后用<code>catch</code>去承接统一处理,两者一起用时,前者会生效(因为err已经将其处理,就不会再往下穿透)而走不到后面的catch</p><p>在每个.then()中我可以将数据再次传出给下一个then()</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mineReadFile(<span class="string">&#x27;./11.txt&#x27;</span>).then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result.toString())</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;,<span class="function"><span class="params">err</span>=&gt;</span><span class="built_in">console</span>.log(err))</span><br><span class="line">.then(<span class="function"><span class="params">data</span>=&gt;</span><span class="built_in">console</span>.log(data,<span class="string">&quot;2222222&quot;</span>))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">&quot;这是catch的&quot;</span>))</span><br></pre></td></tr></table></figure><h6 id="util-promisify方法"><a href="#util-promisify方法" class="headerlink" title="util.promisify方法"></a><code>util.promisify方法</code></h6><blockquote><p>可以将函数直接变成promise的封装方式,不用再去手动封装</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入 util 模块</span></span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>);</span><br><span class="line"><span class="comment">//引入 fs 模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="comment">//返回一个新的函数</span></span><br><span class="line"><span class="keyword">let</span> mineReadFile = util.promisify(fs.readFile);</span><br><span class="line"></span><br><span class="line">mineReadFile(<span class="string">&#x27;./resource/content.txt&#x27;</span>).then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value.toString());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h2 id="为什么要用Promise"><a href="#为什么要用Promise" class="headerlink" title="为什么要用Promise?"></a>为什么要用Promise?</h2><h3 id="指定回调函数的方式更加灵活"><a href="#指定回调函数的方式更加灵活" class="headerlink" title="指定回调函数的方式更加灵活"></a>指定回调函数的方式更加灵活</h3><blockquote><ol><li>旧的: 必须在启动异步任务前指定 </li><li>promise: 启动异步任务 =&gt; 返回promie对象 =&gt; 给promise对象绑定回调函 数(甚至可以在异步任务结束后指定/多个)</li></ol></blockquote><h3 id="支持链式调用-可以解决回调地狱问题"><a href="#支持链式调用-可以解决回调地狱问题" class="headerlink" title="支持链式调用, 可以解决回调地狱问题"></a>支持链式调用, 可以解决回调地狱问题</h3><h5 id="什么是回调地狱"><a href="#什么是回调地狱" class="headerlink" title="什么是回调地狱"></a>什么是回调地狱</h5><blockquote><p>回调函数嵌套调用, 外部回调函数异步执行的结果是嵌套的回调执行的条件</p></blockquote><p><img src="/promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index/2.jpg"></p><h5 id="回调地狱的缺点"><a href="#回调地狱的缺点" class="headerlink" title="回调地狱的缺点?"></a>回调地狱的缺点?</h5><blockquote><p>不便于阅读 不便于异常处理</p></blockquote><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案?"></a>解决方案?</h5><blockquote><p>promise <code>链式调用</code>,</p><p>用来解决回调地狱问题，但是<code>只是简单的改变格式</code>，并没有彻底解决上面的问题真正要解决上述问题，一定要利用promise再加上await和async关键字实现异步传同步</p></blockquote><h5 id="终极解决方案"><a href="#终极解决方案" class="headerlink" title="终极解决方案?"></a>终极解决方案?</h5><blockquote><p>promise +async/await</p></blockquote><hr><h2 id="Promise中的常用-API-概述"><a href="#Promise中的常用-API-概述" class="headerlink" title="Promise中的常用 API 概述"></a>Promise中的常用 API 概述</h2><blockquote><p>此处列举几个最常用的API的概述,如果想看详细描述的可以继续往下看下方的  <strong>Promise方法的具体使用</strong> 描述</p></blockquote><h4 id="Promise-构造函数-Promise-excutor"><a href="#Promise-构造函数-Promise-excutor" class="headerlink" title="Promise 构造函数: Promise (excutor) {}"></a>Promise 构造函数: Promise (excutor) {}</h4><blockquote><p>(1) executor 函数: 执行器 (resolve, reject) =&gt; {}</p><p>(2) resolve 函数: 内部定义成功时我们调用的函数 value =&gt; {} </p><p>(3) reject 函数: 内部定义失败时我们调用的函数 reason =&gt; {} </p><p>说明: executor 会在 Promise 内部立即<code>**同步调用**</code>,异步操作在执行器中执行,换话说Promise支持同步也支持异步操作</p></blockquote><h4 id="Promise-prototype-then-方法-onResolved-onRejected-gt"><a href="#Promise-prototype-then-方法-onResolved-onRejected-gt" class="headerlink" title="Promise.prototype.then 方法: (onResolved, onRejected) =&gt; {}"></a>Promise.prototype.then 方法: (onResolved, onRejected) =&gt; {}</h4><blockquote><p>(1) onResolved 函数: 成功的回调函数 (value) =&gt; {} </p><p>(2) onRejected 函数: 失败的回调函数 (reason) =&gt; {} </p><p>说明: 指定用于得到成功 value 的成功回调和用于得到失败 reason 的失败回调 返回一个新的 promise 对象</p></blockquote><h4 id="Promise-prototype-catch-方法-onRejected-gt"><a href="#Promise-prototype-catch-方法-onRejected-gt" class="headerlink" title="Promise.prototype.catch 方法: (onRejected) =&gt; {}"></a>Promise.prototype.catch 方法: (onRejected) =&gt; {}</h4><blockquote><p>(1) onRejected 函数: 失败的回调函数 (reason) =&gt; {}</p><p>说明: then()的语法糖, 相当于: then(undefined, onRejected)</p><p>(2) 异常穿透使用:当运行到最后,没被处理的所有异常错误都会进入这个方法的回调函数中    </p></blockquote><h4 id="Promise-resolve-方法-value-gt"><a href="#Promise-resolve-方法-value-gt" class="headerlink" title="Promise.resolve 方法: (value) =&gt; {}"></a>Promise.resolve 方法: (value) =&gt; {}</h4><blockquote><p>(1) value: 成功的数据或 promise 对象 </p><p>说明: 返回一个成功/失败的 promise 对象,直接改变promise状态</p><p><code>Promise.resolve(value)</code> 用结果 <code>value</code> 创建一个 resolved 的 promise。</p><p>如同：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(value));</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;  resolve(<span class="string">&#x27;OK&#x27;</span>); &#125;));      </span><br><span class="line">&gt;<span class="built_in">console</span>.log(p3);</span><br></pre></td></tr></table></figure></blockquote><h4 id="Promise-reject-方法-reason-gt"><a href="#Promise-reject-方法-reason-gt" class="headerlink" title="Promise.reject 方法: (reason) =&gt; {}"></a>Promise.reject 方法: (reason) =&gt; {}</h4><blockquote><p>(1) reason: 失败的原因 </p><p>说明: 返回一个失败的 promise 对象,直接改变promise状态,<code>代码示例同上</code></p><p><code>Promise.reject(error)</code> 用 <code>error</code> 创建一个 rejected 的 promise。</p><p>如同：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(error));</span><br></pre></td></tr></table></figure><p>实际上，这个方法几乎从未被使用过。</p></blockquote><h4 id="Promise-all-方法-promises-gt"><a href="#Promise-all-方法-promises-gt" class="headerlink" title="Promise.all 方法: (promises) =&gt; {}"></a>Promise.all 方法: (promises) =&gt; {}</h4><blockquote><p>promises: 包含 n 个 promise 的数组 </p><p>说明: 返回一个新的 promise, 只有所有的 promise <code>都成功才成功</code>, 只要有一 个失败了就直接失败</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; resolve(<span class="string">&#x27;成功&#x27;</span>);  &#125;)</span><br><span class="line">&gt;<span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.reject(<span class="string">&#x27;错误错误错误&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;也是成功&#x27;</span>)</span><br><span class="line">&gt;<span class="keyword">const</span> result = <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br><span class="line">&gt;<span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure></blockquote><h4 id="Promise-race-方法-promises-gt"><a href="#Promise-race-方法-promises-gt" class="headerlink" title="Promise.race 方法: (promises) =&gt; {}"></a>Promise.race 方法: (promises) =&gt; {}</h4><blockquote><p>(1) promises: 包含 n 个 promise 的数组 </p><p>说明: 返回一个新的 promise, <code>第一个完成</code>的 promise 的结果状态就是最终的结果状态,</p><p>如p1延时,开启了异步,内部正常是同步进行,所以<code>p2&gt;p3&gt;p1</code>,结果是<code>P2</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">&gt;&#125;)</span><br><span class="line">&gt;<span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;Success&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;Oh Yeah&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">//调用</span></span><br><span class="line">&gt;<span class="keyword">const</span> result = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br><span class="line">&gt;<span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure></blockquote><hr><h2 id="Promise的几个关键问题"><a href="#Promise的几个关键问题" class="headerlink" title="Promise的几个关键问题"></a>Promise的几个关键问题</h2><h4 id="如何改变-promise-的状态"><a href="#如何改变-promise-的状态" class="headerlink" title="如何改变 promise 的状态?"></a>如何改变 promise 的状态?</h4><blockquote><p>(1) resolve(value): 如果当前是 pending 就会变为 resolved </p><p>(2) reject(reason): 如果当前是 pending 就会变为 rejected </p><p>(3) 抛出异常: 如果当前是 pending 就会变为 rejected</p></blockquote><h4 id="一个-promise-指定多个成功-失败回调函数-都会调用吗"><a href="#一个-promise-指定多个成功-失败回调函数-都会调用吗" class="headerlink" title="一个 promise 指定多个成功/失败回调函数, 都会调用吗?"></a>一个 promise 指定多个成功/失败回调函数, 都会调用吗?</h4><blockquote><p>当 promise <code>改变为对应状态时</code>都会调用,改变状态后,多个回调函数都会调用,并不会自动停止</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;  resolve(<span class="string">&#x27;OK&#x27;</span>);&#125;);</span><br><span class="line">&gt;<span class="comment">///指定回调 - 1</span></span><br><span class="line">&gt;p.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;  <span class="built_in">console</span>.log(value); &#125;);</span><br><span class="line">&gt;<span class="comment">//指定回调 - 2</span></span><br><span class="line">&gt;p.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123; alert(value);&#125;);</span><br></pre></td></tr></table></figure></blockquote><h4 id="改变-promise-状态和指定回调函数谁先谁后"><a href="#改变-promise-状态和指定回调函数谁先谁后" class="headerlink" title="改变 promise 状态和指定回调函数谁先谁后?"></a>改变 promise 状态和指定回调函数谁先谁后?</h4><blockquote><p>(1) 都有可能, 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调 </p><p>​    先指定回调再改变状态(<code>异步</code>):先指定回调—&gt; 再改变状态 —&gt;改变状态后才进入异步队列执行回调函数</p><p>​    先改状态再指定回调(<code>同步</code>):改变状态 —&gt;指定回调 <code>并马上执行</code>回调</p><p>(2) 如何先改状态再<code>指定</code>回调?   —&gt;注意:指定并不是执行</p><p>​    ① 在执行器中直接调用 resolve()/reject() —&gt;即,不使用定时器等方法,执行器内直接同步操作 </p><p>​    ② 延迟更长时间才调用 then()     —&gt;即,在<code>.then()</code>这个方法外再包一层例如延时器这种方法</p><p>(3) 什么时候才能得到数据? </p><p>​    ① 如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据 </p><p>​    ② 如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="comment">//异步写法,这样写会先指定回调,再改变状态</span></span><br><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;resolve(<span class="string">&#x27;OK&#x27;</span>); &#125;, <span class="number">1000</span>);</span><br><span class="line">&gt;<span class="comment">//这是同步写法,这样写会先改变状态,再指定回调</span></span><br><span class="line">&gt;resolve(<span class="string">&#x27;OK&#x27;</span>); </span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;p.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(value);&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><p>(4) 个人理解—结合源码</p><p>​    源码中,promise的状态是通过一个<code>默认为pending</code>的变量进行判断,所以当你<code>resolve/reject</code>延时(异步导致当then加载时,状态还未修改)后,这时直接进行p.then()会发现,目前状态还是<code>进行中</code>,所以只是这样导致只有同步操作才能成功.</p><p>​    所以promise将传入的<code>回调函数</code>拷贝到promise对象实例上,然后在<code>resolve/reject</code>的执行过程中再进行调用,达到异步的目的</p><p>​    具体代码实现看下方自定义promise</p></blockquote><h4 id="Ⅳ-promise-then-返回的新-promise-的结果状态由什么决定"><a href="#Ⅳ-promise-then-返回的新-promise-的结果状态由什么决定" class="headerlink" title="Ⅳ-promise.then()返回的新 promise 的结果状态由什么决定?"></a>Ⅳ-promise.then()返回的新 promise 的结果状态由什么决定?</h4><blockquote><p>(1) 简单表达: 由 then()指定的回调函数执行的结果决定 </p><p>(2) 详细表达: </p><p>​    ① 如果抛出异常, 新 promise 变为 rejected, reason 为抛出的异常 </p><p>​    ② 如果返回的是非 promise 的任意值, 新 promise 变为 resolved, value 为返回的值 </p><p>​    ③ 如果返回的是另一个新 promise, 此 promise 的结果就会成为新 promise 的结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;resolve(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">//执行 then 方法</span></span><br><span class="line">&gt;<span class="keyword">let</span> result = p.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="built_in">console</span>.log(value);</span><br><span class="line">&gt;<span class="comment">// 1. 抛出错误 ,变为 rejected</span></span><br><span class="line">&gt;<span class="keyword">throw</span> <span class="string">&#x27;出了问题&#x27;</span>;</span><br><span class="line">&gt;<span class="comment">// 2. 返回结果是非 Promise 类型的对象,新 promise 变为 resolved</span></span><br><span class="line">&gt;<span class="keyword">return</span> <span class="number">521</span>;</span><br><span class="line">&gt;<span class="comment">// 3. 返回结果是 Promise 对象,此 promise 的结果就会成为新 promise 的结果</span></span><br><span class="line">&gt;<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="comment">// resolve(&#x27;success&#x27;);</span></span><br><span class="line">&gt;reject(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="built_in">console</span>.warn(reason);</span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure></blockquote><h4 id="promise-如何串连多个操作任务"><a href="#promise-如何串连多个操作任务" class="headerlink" title="promise 如何串连多个操作任务?"></a>promise 如何串连多个操作任务?</h4><blockquote><p>(1) promise 的 then()返回一个新的 promise, 可以开成 then()的链式调用 </p><p>(2) 通过 then 的链式调用串连多个同步/异步任务,这样就能用<code>then()</code>将多个同步或异步操作串联成一个同步队列</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;resolve(<span class="string">&#x27;OK&#x27;</span>); &#125;, <span class="number">1000</span>); &#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;p.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; resolve(<span class="string">&quot;success&quot;</span>); &#125;);&#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(value);&#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(value);&#125;) <span class="comment">// 输出undifined, 因为上面一个调用没有返回值</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></blockquote><h4 id="promise-异常传透"><a href="#promise-异常传透" class="headerlink" title="promise 异常传透?"></a>promise 异常传透?</h4><blockquote><ul><li>当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调</li><li>前面任何操作出了异常, 都会传到最后失败的回调中处理</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;getJSON(<span class="string">&#x27;./hong.json&#x27;</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">posts</span>) </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抛出异常&#x27;</span>) &#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res</span>=&gt;</span><span class="built_in">console</span>.log(res),<span class="function"><span class="params">e</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">&#x27;被then的错误回调捕获&#x27;</span>,e) )</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;错误捕获: &#x27;</span>, error);</span><br><span class="line">&#125;);</span><br><span class="line">&gt;<span class="comment">//执行结果: 被then的错误回调捕获 Error: 抛出异常</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">/******************** 利用异常穿透 ****************************************/</span></span><br><span class="line">&gt;getJSON(<span class="string">&#x27;./hong.json&#x27;</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">posts</span>) </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抛出异常&#x27;</span>) &#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res</span>=&gt;</span><span class="built_in">console</span>.log(res) ) <span class="comment">//此处差异,不指定 reject 回调,利用异常穿透传到最后</span></span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;错误捕获: &#x27;</span>, error);</span><br><span class="line">&#125;);</span><br><span class="line">&gt;<span class="comment">//执行结果:  错误捕获:  Error: 抛出异常</span></span><br></pre></td></tr></table></figure><p>注:可以在每个then()的第二个回调函数中进行err处理,也可以利用异常穿透特性,到最后用<code>catch</code>去承接统一处理,两者一起用时,前者会生效(因为err已经将其处理,就不会再往下穿透)而走不到后面的catch<img src="/promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index/Users/Hasuer/AppData/Local/Temp/BNZ.62163f8245409555/A_Promise系统学习笔记中的图片/image-20210927105504988.png" alt="image-20210927105504988"></p></blockquote><h4 id="中断-promise-链"><a href="#中断-promise-链" class="headerlink" title="中断 promise 链?"></a>中断 promise 链?</h4><blockquote><p>在<code>关键问题2</code>中,可以得知,当promise状态改变时,他的链式调用都会生效,那如果我们有这个一个实际需求:我们有5个then(),但其中有条件判断,如当我符合或者不符合第三个then条件时,要直接中断链式调用,不再走下面的then,该如何?</p><p>(1) 当使用 promise 的 then 链式调用时, 在中间中断, 不再调用后面的回调函数 </p><p>(2) 办法: 在回调函数中返回一个 <code>pendding</code> 状态的<code>promise 对象</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;<span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; resolve(<span class="string">&#x27;OK&#x27;</span>);&#125;, <span class="number">1000</span>);&#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;p.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;);&#125;)<span class="comment">//有且只有这一个方式</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="number">222</span>);&#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="number">333</span>);&#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;.catch(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="built_in">console</span>.warn(reason);&#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></blockquote><hr><h2 id="5、-Promise的实际应用"><a href="#5、-Promise的实际应用" class="headerlink" title="5、 Promise的实际应用"></a>5、 Promise的实际应用</h2><blockquote><p>举两个栗子</p></blockquote><h3 id="Ⅰ-加载图片"><a href="#Ⅰ-加载图片" class="headerlink" title="Ⅰ - 加载图片"></a>Ⅰ - 加载图片</h3><blockquote><p>我们可以将图片的加载写成一个<code>Promise</code>，一旦加载完成，<code>Promise</code>的状态就发生变化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> preloadImage = <span class="function"><span class="keyword">function</span> (<span class="params">path</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">const</span> image = <span class="keyword">new</span> Image();</span><br><span class="line">       image.onload  = resolve;</span><br><span class="line">       image.onerror = reject;</span><br><span class="line">       image.src = path;</span><br><span class="line">   &#125;);</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅱ-Generator-函数与-Promise-的结合"><a href="#Ⅱ-Generator-函数与-Promise-的结合" class="headerlink" title="Ⅱ - Generator 函数与 Promise 的结合"></a>Ⅱ - Generator 函数与 Promise 的结合</h3><blockquote><p>使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个<code>Promise</code>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">function</span> <span class="title">getFoo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">&gt;resolve(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">&gt;<span class="keyword">try</span> &#123;</span><br><span class="line">&gt;<span class="keyword">const</span> foo = <span class="keyword">yield</span> getFoo();</span><br><span class="line">&gt;<span class="built_in">console</span>.log(foo);</span><br><span class="line">&gt;&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">&gt;<span class="built_in">console</span>.log(e);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="keyword">function</span> <span class="title">run</span> (<span class="params">generator</span>) </span>&#123;</span><br><span class="line">&gt;<span class="keyword">const</span> it = generator();</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">&gt;<span class="keyword">if</span> (result.done) <span class="keyword">return</span> result.value;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">return</span> result.value.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> go(it.next(value));</span><br><span class="line">&gt;&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> go(it.throw(error));</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;go(it.next());</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;run(g);</span><br></pre></td></tr></table></figure><p>上面代码的 Generator 函数<code>g</code>之中，有一个异步操作<code>getFoo</code>，它返回的就是一个<code>Promise</code>对象。函数<code>run</code>用来处理这个<code>Promise</code>对象，并调用下一个<code>next</code>方法。</p></blockquote><hr><h1 id="Promise-API-用法详解"><a href="#Promise-API-用法详解" class="headerlink" title="Promise API 用法详解"></a>Promise API 用法详解</h1><blockquote><p>ES6 规定，<code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例。</p><p>此部分是对于 <strong>Promise API 用法的详解</strong> ,尽量详细地列举其常见用法,所以篇幅较长</p></blockquote><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h4 id="举个创造-Promise-实例的栗子"><a href="#举个创造-Promise-实例的栗子" class="headerlink" title="举个创造 Promise 实例的栗子"></a>举个创造 Promise 实例的栗子</h4><blockquote><p>下面代码创造了一个<code>Promise</code>实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)  resolve(value); <span class="comment">//将该 Promise 修改为成功且返回</span></span><br><span class="line"><span class="keyword">else</span>  reject(error); <span class="comment">//将该 Promise 修改为失败且返回</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p><p><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p></blockquote><h4 id="使用-then-方法分别指定-成功-失败-的回调"><a href="#使用-then-方法分别指定-成功-失败-的回调" class="headerlink" title="使用 [ then ] 方法分别指定 成功/失败 的回调"></a>使用 [ then ] 方法分别指定 成功/失败 的回调</h4><blockquote><p><code>Promise</code>实例生成以后，可以用 [ then() ] 方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">&gt;<span class="comment">// 当promise状态返回为resolve 时会执行的回调函数</span></span><br><span class="line">&gt;&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">&gt;<span class="comment">// 当promise状态返回为rejected 时会执行的回调函数</span></span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p>[ then ] 方法可以接受两个回调函数作为参数。第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用，第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。其中，<strong>第二个函数是可选的，不一定要提供</strong>。这两个函数都接受<code>Promise</code>对象传出的值作为参数。</p></blockquote><h4 id="举个-Promise-对象的简单栗子"><a href="#举个-Promise-对象的简单栗子" class="headerlink" title="举个 Promise 对象的简单栗子"></a>举个 Promise 对象的简单栗子</h4><blockquote><p>下面是一个<code>Promise</code>对象的简单例子。</p><blockquote><p>setTimeout的第三个参数是给第一个函数的参数，而且是先于第一个参数(即回调函数)执行的 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123; <span class="comment">//声明一个方法, 传入的 参数ms 为延时器时间</span></span><br><span class="line">&gt;<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="comment">//这行代码实际效果: 当 [ms] 毫秒后 执行 resolve(&#x27;努力学习的汪&#x27;)</span></span><br><span class="line"> <span class="built_in">setTimeout</span>(resolve, ms, <span class="string">&#x27;努力学习的汪&#x27;</span>); </span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;timeout(<span class="number">1000</span>).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;  <span class="built_in">console</span>.log(value) &#125;);</span><br><span class="line">&gt;<span class="comment">//打印结果 : 努力学习的汪</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>timeout</code>方法返回一个<code>Promise</code>实例，表示一段时间以后才会发生的结果。过了指定的时间（<code>ms</code>参数）以后，<code>Promise</code>实例的状态变为<code>resolved</code>，就会触发<code>then</code>方法绑定的回调函数。</p></blockquote><h4 id="Promise-新建后就会立即执行"><a href="#Promise-新建后就会立即执行" class="headerlink" title="Promise 新建后就会立即执行"></a>Promise 新建后就会立即执行</h4><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">&gt;<span class="built_in">console</span>.log(<span class="string">&#x27;Promise&#x27;</span>);</span><br><span class="line">&gt;resolve();</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&gt;<span class="built_in">console</span>.log(<span class="string">&#x27;resolved.&#x27;</span>);</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="built_in">console</span>.log(<span class="string">&#x27;Hi!&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// Promise</span></span><br><span class="line">&gt;<span class="comment">// Hi!</span></span><br><span class="line">&gt;<span class="comment">// resolved //可以发现,明明then是在 Hi 前面,却最后打印</span></span><br></pre></td></tr></table></figure><p>上面代码中，Promise 新建后立即执行，所以首先输出的是<code>Promise</code>。然后，<code>then</code>方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以<code>resolved</code>最后输出。</p><p>实际上,这个运行结果相关知识点是 [ <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0#%E5%9B%9B%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%BE%AE%E4%BB%BB%E5%8A%A1">宏任务与微任务</a> ] ,单独梳理在下方.这里可以先初步理解为: </p><ol><li><p>JS是单线程的,至上往下运行,在声明 <strong>Promise</strong> 时实际上已经执行到了内部方法</p></li><li><p>为何 resolve() 运行后没有立即打印?</p></li></ol><ul><li><p>JS中用来存储待执行回调函数的队列包含2个不同特定的列队</p><blockquote><p><code>宏队列</code>:用来保存待执行的宏任务(回调),比如:<code>定时器</code>回调/ajax回调/dom事件回调</p><p><code>微队列</code>:用来保存待执行的微任务(回调),比如:<code>Promise</code>的回调/muntation回调</p></blockquote></li><li><p>JS执行时会区别这2个队列:</p><blockquote><p>JS执行引擎首先必须执行所有的<code>初始化同步任务</code>代码</p><p>每次准备取出第一个<code>宏任务执行前</code>,都要将所有的<code>微任务</code>一个一个取出来执行</p></blockquote></li></ul></blockquote><h4 id="举个异步加载图片的栗子"><a href="#举个异步加载图片的栗子" class="headerlink" title="举个异步加载图片的栗子"></a>举个异步加载图片的栗子</h4><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">function</span> <span class="title">loadImageAsync</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">&gt;<span class="keyword">const</span> image = <span class="keyword">new</span> Image();</span><br><span class="line"></span><br><span class="line">&gt;image.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&gt;<span class="built_in">console</span>.log(<span class="string">&#x27;图片加载成功&#x27;</span>)</span><br><span class="line">&gt;resolve(image);</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;image.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&gt;reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`无法从 <span class="subst">$&#123;url&#125;</span> 中加载图片`</span> ));</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;image.src = url;</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;loadImageAsync(<span class="string">&#x27;正确的url&#x27;</span>) <span class="comment">//打印图片加载成功</span></span><br><span class="line">&gt;loadImageAsync(<span class="string">&#x27;错误的url&#x27;</span>) <span class="comment">//抛出异常</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面代码中，使用<code>Promise</code>包装了一个图片加载的异步操作。如果加载成功，就调用<code>resolve</code>方法，否则就调用<code>reject</code>方法。</p><p><img src="/promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index/11.png"></p></blockquote><h4 id="举个用Promise对象实现的-Ajax-操作的栗子"><a href="#举个用Promise对象实现的-Ajax-操作的栗子" class="headerlink" title="举个用Promise对象实现的 Ajax 操作的栗子"></a>举个用<code>Promise</code>对象实现的 Ajax 操作的栗子</h4><blockquote><p>Ajax知识点不懂的同学要去补一下: 这里可以看原作者梳理的ajax笔记 —&gt; <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Ajax%E3%80%81Axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">点我跳转</a> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> getJSON = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">&gt;<span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">&gt;<span class="keyword">const</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&gt;<span class="keyword">if</span> (<span class="built_in">this</span>.readyState !== <span class="number">4</span>)  <span class="keyword">return</span>; <span class="comment">//当readyState 为4 时直接返回,不修改 promise 状态</span></span><br><span class="line">&gt;<span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="number">200</span>) resolve(<span class="built_in">this</span>.response); <span class="comment">//返回状态为 200 时将状态修改为成功,且将响应内容返回</span></span><br><span class="line">&gt;<span class="keyword">else</span>  reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="built_in">this</span>.statusText)); <span class="comment">//失败时抛出异常</span></span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> client = <span class="keyword">new</span> XMLHttpRequest(); <span class="comment">//实例化xml实例</span></span><br><span class="line">&gt;client.open(<span class="string">&quot;GET&quot;</span>, url); <span class="comment">//下面这几行都是对xml实例进行配置,不懂的同学要去补一下ajax知识点</span></span><br><span class="line">&gt;client.onreadystatechange = handler;</span><br><span class="line">&gt;client.responseType = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">&gt;client.setRequestHeader(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">&gt;client.send();</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="keyword">return</span> promise;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;getJSON(<span class="string">&quot;./hong.json&quot;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">&gt;<span class="built_in">console</span>.log(<span class="string">&#x27;Contents: &#x27;</span> , json);</span><br><span class="line">&gt;&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">&gt;<span class="built_in">console</span>.error(<span class="string">&#x27;出错了&#x27;</span>, error);</span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>getJSON</code>是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个<code>Promise</code>对象。需要注意的是，在<code>getJSON</code>内部，<code>resolve</code>函数和<code>reject</code>函数调用时，都带有参数。</p><p><img src="/promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index/3.png"></p><blockquote><p>小贴士:此处可能有同学想尝试却发现读取本地文件会有跨域问题,这边教一下你们</p><p><img src="/promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index/4.png"></p></blockquote></blockquote><h4 id="resolve-的参数可以是另一个-Promise-实例"><a href="#resolve-的参数可以是另一个-Promise-实例" class="headerlink" title="resolve()  的参数可以是另一个 Promise 实例"></a>resolve()  的参数可以是另一个 Promise 实例</h4><blockquote><p>如果调用<code>resolve</code>函数和<code>reject</code>函数时带有参数，那么它们的参数会被传递给回调函数。<code>reject</code>函数的参数通常是<code>Error</code>对象的实例，表示抛出的错误；<code>resolve</code>函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123; resolve(p1) &#125;)</span><br></pre></td></tr></table></figure><p>上面代码中，<code>p1</code>和<code>p2</code>都是 Promise 的实例，但是<code>p2</code>的<code>resolve</code>方法将<code>p1</code>作为参数，即一个异步操作的结果是返回另一个异步操作。</p><p>注意，这时<code>p1</code>的状态就会传递给<code>p2</code>，也就是说，<code>p1</code>的状态决定了<code>p2</code>的状态。如果<code>p1</code>的状态是<code>pending</code>，那么<code>p2</code>的回调函数就会等待<code>p1</code>的状态改变；如果<code>p1</code>的状态已经是<code>resolved</code>或者<code>rejected</code>，那么<code>p2</code>的回调函数将会立刻执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;p1的状态改为错误&#x27;</span>)), <span class="number">0</span>)</span><br><span class="line">&gt;&#125;)</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(p1), <span class="number">3000</span>) <span class="comment">//将p1 传给p2</span></span><br><span class="line">&gt;&#125;)</span><br><span class="line"></span><br><span class="line">&gt;p2.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result),<span class="function"><span class="params">result</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">&#x27;失败&#x27;</span>))</span><br><span class="line">&gt;.catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;catch异常捕获:&#x27;</span>+error))</span><br><span class="line">&gt;<span class="comment">//首先报错</span></span><br><span class="line">&gt;<span class="comment">//运行三秒后打印: 失败</span></span><br></pre></td></tr></table></figure><h5 id="上面代码运行后执行效果"><a href="#上面代码运行后执行效果" class="headerlink" title="上面代码运行后执行效果:"></a>上面代码运行后执行效果:</h5><ul><li>首先马上会打印一个报错 : “Uncaught (in promise) Error: p1的状态改为错误” (红色报错)</li><li>然后等3秒后再打印:  ‘失败’</li><li>注意: 如果 <strong>p2.then()</strong> 中没有写 <strong>reject</strong> 回调函数(第二个参数),则会被 <strong>catch</strong> 捕获,变为<code>catch异常捕获:Error: p1的状态改为错误</code></li></ul><h5 id="解释"><a href="#解释" class="headerlink" title="解释:"></a>解释:</h5><blockquote><ul><li>首先前面说过,promise定义时就会立即执行,所以刚开始就运行了 <strong>p1 的reject()</strong>,所以直接控制台报错了</li><li><code>resolve</code>方法返回的是<code>p1</code>。由于<code>p2</code>返回的是另一个 Promise，导致<code>p2</code>自己的状态无效了，由<code>p1</code>的状态决定<code>p2</code>的状态</li><li>总结来说,promise返回promise这种嵌套形式,将由最内层的promise决定外层的状态</li></ul></blockquote></blockquote><h4 id="调用resolve或reject并不会终结-Promise-的参数函数的执行"><a href="#调用resolve或reject并不会终结-Promise-的参数函数的执行" class="headerlink" title="调用resolve或reject并不会终结 Promise 的参数函数的执行"></a>调用<code>resolve</code>或<code>reject</code>并不会终结 Promise 的参数函数的执行</h4><blockquote><p>调用<code>resolve</code>或<code>reject</code>并不会终结 Promise 的参数函数的执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;resolve(<span class="number">1</span>);</span><br><span class="line">&gt;<span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&gt;&#125;).then(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="built_in">console</span>.log(r);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">// 2</span></span><br><span class="line">&gt;<span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面代码中，调用<code>resolve(1)</code>以后，后面的<code>console.log(2)</code>还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</p></blockquote><h4 id="建议在修改状态函数前加return"><a href="#建议在修改状态函数前加return" class="headerlink" title="建议在修改状态函数前加return"></a>建议在修改状态函数前加return</h4><blockquote><p>一般来说，调用<code>resolve</code>或<code>reject</code>以后，Promise 的使命就完成了，后继操作应该放到<code>then</code>方法里面，而不应该直接写在<code>resolve</code>或<code>reject</code>的后面。所以，最好在它们前面加上<code>return</code>语句，这样就不会有意外。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> resolve(<span class="number">1</span>);</span><br><span class="line">&gt;<span class="comment">// 后面的语句不会执行</span></span><br><span class="line">&gt;<span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&gt;&#125;)</span><br></pre></td></tr></table></figure><p>有同学可能就会问了,不加感觉也没啥事啊,反正我在这个函数体内就是要做这些操作,放在 <code>resolve/reject</code>前后好像都不影响啊! 这里我给举个实际场景</p></blockquote><h5 id="不加-return-导致的错误场景举🌰"><a href="#不加-return-导致的错误场景举🌰" class="headerlink" title="不加 return 导致的错误场景举🌰"></a>不加 return 导致的错误场景举🌰</h5><blockquote><p>一般来说,错误发生在 Promise 内,是不会传到外部的,只会在 Promise 内部消化,详见下方API详解部分的 <a href="#② Promise.prototype.catch(">②Promise.prototype.catch()</a>)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">&gt;resolve(<span class="string">&#x27;成功了&#x27;</span>); <span class="comment">//如果你加了 return , 函数执行到此步就停止了</span></span><br><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;错误错误!!!!!&#x27;</span>) &#125;, <span class="number">0</span>)</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; <span class="built_in">console</span>.log(value) &#125;);</span><br><span class="line">&gt;<span class="comment">// ok</span></span><br><span class="line">&gt;<span class="comment">// Uncaught Error: 错误错误!!!!</span></span><br></pre></td></tr></table></figure><p>上面代码中，Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。</p></blockquote><h2 id="Ⅱ-API-用法详解"><a href="#Ⅱ-API-用法详解" class="headerlink" title="Ⅱ -  API 用法详解"></a>Ⅱ -  API 用法详解</h2><blockquote><p>此处将对于所有API进行详细剖析,参照资料为 <a href>阮一峰的ES6日志</a>(原作者这里没有给出链接）</p></blockquote><h4 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h4><blockquote><p>Promise 实例具有<code>then</code>方法，也就是说，<code>then</code>方法是定义在原型对象<code>Promise.prototype</code>上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，<code>then</code>方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数（可选）是<code>rejected</code>状态的回调函数。</p></blockquote><h5 id="then方法返回的是一个新的Promise实例"><a href="#then方法返回的是一个新的Promise实例" class="headerlink" title="then方法返回的是一个新的Promise实例"></a><code>then</code>方法返回的是一个新的<code>Promise</code>实例</h5><blockquote><p><code>then</code>方法返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;getJSON(<span class="string">&quot;./hong.json&quot;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">&gt;<span class="keyword">return</span> json.name;</span><br><span class="line">&gt;&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">&gt;<span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;name&#125;</span>`</span> )</span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码使用<code>then</code>方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p></blockquote><h5 id="采用链式的then-会等待前一个Promise状态发生改变才会被调用"><a href="#采用链式的then-会等待前一个Promise状态发生改变才会被调用" class="headerlink" title="采用链式的then, 会等待前一个Promise状态发生改变才会被调用"></a>采用链式的<code>then</code>, 会等待前一个Promise状态发生改变才会被调用</h5><blockquote><p>采用链式的<code>then</code>，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个<code>Promise</code>对象（即有异步操作），这时后一个回调函数，就会等待该<code>Promise</code>对象的状态发生变化，才会被调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;getJSON(<span class="string">&quot;./hong.json&quot;</span>)</span><br><span class="line">&gt;.then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;  <span class="keyword">return</span> getJSON(json.name)&#125;)</span><br><span class="line">&gt;.then(</span><br><span class="line">&gt;<span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&quot;resolved: My name is &quot;</span>, name)&#125;, </span><br><span class="line">&gt;<span class="function"><span class="keyword">function</span> (<span class="params">err</span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">&quot;rejected: &quot;</span>, err)&#125;</span><br><span class="line">&gt;);</span><br></pre></td></tr></table></figure><p>上面代码中，第一个<code>then</code>方法指定的回调函数，返回的是另一个<code>Promise</code>对象。这时，第二个<code>then</code>方法指定的回调函数，就会等待这个新的<code>Promise</code>对象状态发生变化。如果变为<code>resolved</code>，就调用第一个回调函数，如果状态变为<code>rejected</code>，就调用第二个回调函数。</p></blockquote><h5 id="使用箭头函数简写"><a href="#使用箭头函数简写" class="headerlink" title="使用箭头函数简写"></a>使用箭头函数简写</h5><blockquote><p>如果采用箭头函数，上面的代码可以写得更简洁 (实际代码中基本都是这样写了)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;getJSON(<span class="string">&quot;./hong.json&quot;</span>)</span><br><span class="line">&gt;.then(<span class="function"><span class="params">json</span> =&gt;</span> getJSON(json.name) )</span><br><span class="line">&gt;.then(</span><br><span class="line">  <span class="function"><span class="params">name</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;resolved: My name is &quot;</span>, name), </span><br><span class="line">&gt;<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;rejected: &quot;</span>, err)</span><br><span class="line">&gt;);</span><br></pre></td></tr></table></figure></blockquote><h4 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h4><blockquote><p><code>Promise.prototype.catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数。</p></blockquote><h5 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;getJSON(<span class="string">&#x27;./hong.json&#x27;</span>)</span><br><span class="line">&gt;.then(<span class="function"><span class="keyword">function</span>(<span class="params">posts</span>) </span>&#123;&#125;)</span><br><span class="line">&gt;.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;发生错误！&#x27;</span>, error);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>getJSON()</code>方法返回一个 Promise 对象</p><blockquote><ul><li>如果该对象状态变为<code>resolved</code>，则会调用<code>then()</code>方法指定的回调函数；</li><li>如果异步操作抛出错误，状态就会变为<code>rejected</code>，就会调用<code>catch()</code>方法指定的回调函数，处理这个错误</li><li>另外，<code>then()</code>方法指定的回调函数，如果运行中抛出错误，也会被<code>catch()</code>方法捕获。</li><li>被 catch 方法捕获的前提是前方的 then() 方法中没有对 <code>rejected</code> 进行捕获处理(即没有写reject回调函数)</li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;p.then(<span class="function">(<span class="params">val</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;指定成功回调:&#x27;</span>, val))</span><br><span class="line">&gt;.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;在catch中进行 rejected 的处理&#x27;</span>, err));</span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;p.then(<span class="function">(<span class="params">val</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;指定成功回调:&#x27;</span>, val))</span><br><span class="line">&gt;.then(<span class="literal">null</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;等同于另起一个then,只指定 rejected 的处理&quot;</span>, err));</span><br></pre></td></tr></table></figure></blockquote><h5 id="reject-方法的作用，等同于抛出错误"><a href="#reject-方法的作用，等同于抛出错误" class="headerlink" title="reject()方法的作用，等同于抛出错误"></a><code>reject()</code>方法的作用，等同于抛出错误</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">&gt;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;直接抛出错误&#x27;</span>);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">&gt;<span class="built_in">console</span>.log(<span class="string">&#x27;异常捕获: &#x27;</span>,error);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">//异常捕获:  Error: 直接抛出错误</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>promise</code>抛出一个错误，就被<code>catch()</code>方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">/******************  写法一 ***************************************/</span></span><br><span class="line">&gt;<span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">&gt;<span class="keyword">try</span> &#123;</span><br><span class="line">&gt;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;直接抛出错误&#x27;</span>);</span><br><span class="line">&gt;&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">&gt;<span class="built_in">console</span>.log(<span class="string">&#x27;进入catch,然后再用 reject(e)抛出 &#x27;</span>)</span><br><span class="line">&gt;reject(e) </span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">&gt;<span class="built_in">console</span>.log(error);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">//进入catch,然后再用 reject(e)抛出 </span></span><br><span class="line">&gt;<span class="comment">//Error: 直接抛出错误</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">/******************  写法二 ***************************************/</span></span><br><span class="line">&gt;<span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">&gt;reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;使用 reject() 抛出错误&#x27;</span>));</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;promise1.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">&gt;<span class="built_in">console</span>.log(error);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">//Error: 使用 reject() 抛出错误</span></span><br></pre></td></tr></table></figure><p>比较上面两种写法，可以发现<code>reject()</code>方法的作用，等同于抛出错误,所以不必用try..catch()去承接后再去抛出了</p></blockquote><h5 id="如果-Promise-状态已经被修改，再抛出错误是无效的"><a href="#如果-Promise-状态已经被修改，再抛出错误是无效的" class="headerlink" title="如果 Promise 状态已经被修改，再抛出错误是无效的"></a>如果 Promise 状态已经被修改，再抛出错误是无效的</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">&gt;resolve(<span class="string">&#x27;成功了&#x27;</span>); <span class="comment">//换成 reject(&#x27;成功了&#x27;) 结果也是一样的</span></span><br><span class="line">&gt;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;成功后扔抛出异常&#x27;</span>);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;promise</span><br><span class="line">&gt;.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; <span class="built_in">console</span>.log(value) &#125;)</span><br><span class="line">&gt;.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123; <span class="built_in">console</span>.log(error) &#125;);</span><br><span class="line">&gt;<span class="comment">// 成功了</span></span><br></pre></td></tr></table></figure><p>上面代码中，Promise 在<code>resolve/reject</code>语句后面，再抛出错误，不会被捕获，等于没有抛出。<strong>因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了(前面有说过)</strong></p></blockquote><h5 id="Promise-对象的错误具有-“冒泡”-性质"><a href="#Promise-对象的错误具有-“冒泡”-性质" class="headerlink" title="Promise 对象的错误具有 “冒泡” 性质"></a>Promise 对象的错误具有 “冒泡” 性质</h5><blockquote><p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个<code>catch</code>语句捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;getJSON(<span class="string">&#x27;./hong.json&#x27;</span>) <span class="comment">//第一个promise</span></span><br><span class="line">&gt;.then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123; <span class="comment">//第二个promise</span></span><br><span class="line"> <span class="keyword">return</span> getJSON(post.commentURL)</span><br><span class="line">&#125;)</span><br><span class="line">&gt;.then(<span class="function"><span class="keyword">function</span>(<span class="params">comments</span>) </span>&#123; <span class="comment">//第三个promise</span></span><br><span class="line">&#125;)</span><br><span class="line">&gt;.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 处理前面三个Promise产生的错误</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，一共有三个 Promise 对象(<strong>then返回的仍可能是一个Promise对象</strong>)：一个由<code>getJSON()</code>产生，两个由<code>then()</code>产生。它们之中任何一个抛出的错误，都会被最后一个<code>catch()</code>捕获。</p><p>也是因为这个特性,有了 <strong>异常穿透问题</strong> </p></blockquote><h5 id="异常穿透问题"><a href="#异常穿透问题" class="headerlink" title="异常穿透问题"></a>异常穿透问题</h5><blockquote><ul><li>当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调</li><li>前面任何操作出了异常, 都会传到最后失败的回调中处理</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;getJSON(<span class="string">&#x27;./hong.json&#x27;</span>)</span><br><span class="line">&gt;.then(<span class="function"><span class="keyword">function</span>(<span class="params">posts</span>) </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抛出异常&#x27;</span>) &#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res</span>=&gt;</span><span class="built_in">console</span>.log(res),<span class="function"><span class="params">e</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">&#x27;被then的错误回调捕获&#x27;</span>,e) )</span><br><span class="line">&gt;.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;错误捕获: &#x27;</span>, error);</span><br><span class="line">&#125;);</span><br><span class="line">&gt;<span class="comment">//执行结果: 被then的错误回调捕获 Error: 抛出异常</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">/******************** 利用异常穿透 ****************************************/</span></span><br><span class="line">&gt;getJSON(<span class="string">&#x27;./hong.json&#x27;</span>)</span><br><span class="line">&gt;.then(<span class="function"><span class="keyword">function</span>(<span class="params">posts</span>) </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抛出异常&#x27;</span>) &#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res</span>=&gt;</span><span class="built_in">console</span>.log(res) ) <span class="comment">//此处差异,不指定 reject 回调,利用异常穿透传到最后</span></span><br><span class="line">&gt;.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;错误捕获: &#x27;</span>, error);</span><br><span class="line">&#125;);</span><br><span class="line">&gt;<span class="comment">//执行结果:  错误捕获:  Error: 抛出异常</span></span><br></pre></td></tr></table></figure><p>注:可以在每个then()的第二个回调函数中进行err处理,也可以利用异常穿透特性,到最后用<code>catch</code>去承接统一处理,两者一起用时,前者会生效(因为err已经将其处理,就不会再往下穿透)而走不到后面的catch</p><p><img src="/promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index/5.png"></p></blockquote><h5 id="建议使用-catch-进行异常处理"><a href="#建议使用-catch-进行异常处理" class="headerlink" title="建议使用 catch() 进行异常处理"></a>建议使用 catch() 进行异常处理</h5><blockquote><p>一般来说，不要在<code>then()</code>方法里面定义 Reject 状态的回调函数（即<code>then</code>的第二个参数），总是使用<code>catch</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// bad</span></span><br><span class="line">&gt;promise</span><br><span class="line">&gt;.then(</span><br><span class="line">&gt;<span class="function"><span class="params">data</span>=&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;成功&#x27;</span>,data),</span><br><span class="line">&gt;<span class="function"><span class="params">err</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">&#x27;失败了&#x27;</span>,err)</span><br><span class="line">);</span><br><span class="line">&gt;<span class="comment">/********* 好的写法 ********************/</span></span><br><span class="line">&gt;promise</span><br><span class="line">&gt;.then( <span class="function"><span class="params">data</span>=&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;成功&#x27;</span>,data)) <span class="comment">//只指定成功回调</span></span><br><span class="line">&gt;.catch( <span class="function"><span class="params">err</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">&#x27;失败了&#x27;</span>,err));</span><br></pre></td></tr></table></figure><p>上面代码中，第二种写法要好于第一种写法:</p><ul><li>理由是第二种写法可以捕获前面<code>then</code>方法执行中的错误</li><li>也更接近同步的写法（<code>try/catch</code>）</li><li>因此, 建议总是使用<code>catch()</code>方法，而不使用<code>then()</code>方法的第二个参数。</li></ul></blockquote><h5 id="与传统-try-catch-代码块的差异"><a href="#与传统-try-catch-代码块的差异" class="headerlink" title="与传统 try/catch 代码块的差异"></a>与传统 <code>try/catch</code> 代码块的差异</h5><blockquote><p>跟传统的<code>try/catch</code>代码块不同的是，如果没有使用<code>catch()</code>方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> someAsyncThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">&gt;<span class="comment">// 下面一行会报错，因为hong 没有声明</span></span><br><span class="line">&gt;resolve( hong );</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="comment">//Promise 的 then() 处理,但不处理异常</span></span><br><span class="line">&gt;someAsyncThing().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;只指定成功回调,不处理异常错误&#x27;</span>) &#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;努力学习的汪&#x27;</span>) &#125;, <span class="number">2000</span>);</span><br><span class="line">&gt;<span class="comment">// Uncaught (in promise) ReferenceError: hong is not defined</span></span><br><span class="line">&gt;<span class="comment">// 努力学习的汪</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>someAsyncThing()</code>函数产生的 Promise 对象，内部有语法错误。</p><blockquote><ul><li>浏览器运行到这一行，会打印出错误提示<code>Uncaught (in promise) ReferenceError: hong is not defined</code></li><li>但是不会退出进程、终止脚本执行, 2 秒之后还是会输出<code>努力学习的汪</code>。</li><li>这就是说，Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。</li></ul></blockquote></blockquote><h5 id="catch-方法后还能跟-then-方法"><a href="#catch-方法后还能跟-then-方法" class="headerlink" title="catch()方法后还能跟 then() 方法"></a>catch()方法后还能跟 then() 方法</h5><blockquote><p>一般总是建议，Promise 对象后面要跟<code>catch()</code>方法，这样可以处理 Promise 内部发生的错误。<code>catch()</code>方法返回的还是一个 Promise 对象，因此后面还可以接着调用<code>then()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> someAsyncThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">&gt;<span class="comment">// 下面一行会报错，因为 hong 没有声明</span></span><br><span class="line">&gt;resolve( hong );</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;someAsyncThing()</span><br><span class="line">&gt;.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;  <span class="built_in">console</span>.log(<span class="string">&#x27;捉到错误咯:&#x27;</span>, error)&#125;)</span><br><span class="line">&gt;.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;错误捕获后我还要浪&#x27;</span>) &#125;);</span><br><span class="line">&gt;<span class="comment">//捉到错误咯: ReferenceError: hong is not defined</span></span><br><span class="line">&gt;<span class="comment">//错误捕获后我还要浪</span></span><br></pre></td></tr></table></figure><p>上面代码运行完<code>catch()</code>方法指定的回调函数，会接着运行后面那个<code>then()</code>方法指定的回调函数。</p><p>如果没有报错，则会跳过<code>catch()</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">Promise</span>.resolve(<span class="string">&#x27;硬是成功了&#x27;</span>)</span><br><span class="line">&gt;.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;捉错误&#x27;</span>, error) &#125;)</span><br><span class="line">&gt;.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;catch后面的then: &#x27;</span>,v) );</span><br><span class="line">&gt;<span class="comment">//catch后面的then:  硬是成功了</span></span><br></pre></td></tr></table></figure><p>上面的代码因为没有报错，跳过了<code>catch()</code>方法，直接执行后面的<code>then()</code>方法。此时，要是<code>then()</code>方法里面报错，就与前面的<code>catch()</code>无关了。</p></blockquote><h5 id="catch-方法之中，还能再抛出错误"><a href="#catch-方法之中，还能再抛出错误" class="headerlink" title="catch()方法之中，还能再抛出错误"></a><code>catch()</code>方法之中，还能再抛出错误</h5><blockquote><p><code>catch()</code>方法之中，还能再抛出错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> someAsyncThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">&gt;<span class="comment">// 下面一行会报错，因为 hong 没有声明</span></span><br><span class="line">&gt;resolve( hong );</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;someAsyncThing()</span><br><span class="line">&gt;.then(<span class="function">() =&gt;</span>  someOtherAsyncThing()) </span><br><span class="line">&gt;.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;ctach:&#x27;</span>, error);</span><br><span class="line"> <span class="comment">// 下面一行会报错，因为 sum 没有声明</span></span><br><span class="line">  sum ++;</span><br><span class="line">&#125;)</span><br><span class="line">&gt;.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;捕获后的then()&#x27;</span>)&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// ctach: [ReferenceError: hong is not defined]</span></span><br><span class="line">&gt;<span class="comment">// Uncaught (in promise) ReferenceError: sum is not defined</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>catch()</code>方法抛出一个错误，因为后面没有别的<code>catch()</code>方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;someAsyncThing().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&gt;<span class="keyword">return</span> someOtherAsyncThing();</span><br><span class="line">&gt;&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">&gt;<span class="built_in">console</span>.log(<span class="string">&#x27;catch: &#x27;</span>, error);</span><br><span class="line">&gt;<span class="comment">// 下面一行会报错，因为 sum 没有声明</span></span><br><span class="line">&gt;sum ++;</span><br><span class="line">&gt;&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">&gt;<span class="built_in">console</span>.log(<span class="string">&#x27;catch()后的catch: &#x27;</span>, error);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">//catch:  ReferenceError: hong is not defined</span></span><br><span class="line">&gt;<span class="comment">//catch()后的catch:  ReferenceError: sum is not defined</span></span><br></pre></td></tr></table></figure><p>上面代码中，第二个<code>catch()</code>方法用来捕获前一个<code>catch()</code>方法抛出的错误。</p></blockquote><h4 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h4><blockquote><p><code>finally()</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 <code>ES2018</code> 引入标准的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;promise</span><br><span class="line">&gt;.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">&gt;.catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">&gt;.finally(<span class="function">() =&gt;</span> &#123;···&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。</p><blockquote><ul><li><code>finally</code>方法的回调函数不接受任何参数，</li><li>这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。</li><li>这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</li></ul></blockquote></blockquote><h5 id="a-finally本质上是then方法的特例"><a href="#a-finally本质上是then方法的特例" class="headerlink" title="a) finally本质上是then方法的特例"></a>a) <code>finally</code>本质上是<code>then</code>方法的特例</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;promise</span><br><span class="line">&gt;.finally(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;promise</span><br><span class="line">&gt;.then(</span><br><span class="line">&gt;<span class="function"><span class="params">result</span> =&gt;</span>  result ,</span><br><span class="line">&gt;<span class="function"><span class="params">error</span> =&gt;</span>  <span class="keyword">throw</span> error</span><br><span class="line">&gt;);</span><br></pre></td></tr></table></figure><p>上面代码中，如果不使用<code>finally</code>方法，同样的语句需要为成功和失败两种情况各写一次。有了<code>finally</code>方法，则只需要写一次。</p></blockquote><h5 id="它的实现"><a href="#它的实现" class="headerlink" title="它的实现"></a>它的实现</h5><blockquote><p>它的实现也很简单。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">&gt;<span class="keyword">let</span> P = <span class="built_in">this</span>.constructor;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="built_in">this</span>.then(</span><br><span class="line">&gt;<span class="function"><span class="params">value</span>  =&gt;</span> P.resolve(callback()).then(<span class="function">() =&gt;</span> value),</span><br><span class="line">&gt;<span class="function"><span class="params">reason</span> =&gt;</span> P.resolve(callback()).then(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)</span><br><span class="line">&gt;);</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，不管前面的 Promise 是<code>fulfilled</code>还是<code>rejected</code>，都会执行回调函数<code>callback</code>。</p><p>从上面的实现还可以看到，<code>finally</code>方法总是会返回原来的值(传入什么即传出什么)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// resolve 的值是 undefined</span></span><br><span class="line">&gt;<span class="built_in">Promise</span>.resolve(<span class="number">2</span>).then(<span class="function">() =&gt;</span> &#123;&#125;, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// resolve 的值是 2</span></span><br><span class="line">&gt;<span class="built_in">Promise</span>.resolve(<span class="number">2</span>).finally(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// reject 的值是 undefined</span></span><br><span class="line">&gt;<span class="built_in">Promise</span>.reject(<span class="number">3</span>).then(<span class="function">() =&gt;</span> &#123;&#125;, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// reject 的值是 3</span></span><br><span class="line">&gt;<span class="built_in">Promise</span>.reject(<span class="number">3</span>).finally(<span class="function">() =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><p><img src="/promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index/12.png"></p></blockquote><h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h4><blockquote><p><code>Promise.all()</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>Promise.all()</code>方法接受一个数组作为参数，</li><li><code>p1</code>、<code>p2</code>、<code>p3</code>都是 Promise 实例，如果不是，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为 Promise 实例，再进一步处理。</li><li>另外，<code>Promise.all()</code>方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。</li></ul></blockquote></blockquote><h5 id="返回的状态由什么决定"><a href="#返回的状态由什么决定" class="headerlink" title="返回的状态由什么决定?"></a>返回的状态由什么决定?</h5><blockquote><p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p><blockquote><ol><li>只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</li><li>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</li></ol></blockquote><h6 id="下面是一个具体的例子。"><a href="#下面是一个具体的例子。" class="headerlink" title="下面是一个具体的例子。"></a>下面是一个具体的例子。</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 生成一个Promise对象的数组</span></span><br><span class="line">&gt;<span class="keyword">const</span> promises = [<span class="string">&#x27;hong&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].map(item &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> getJSON( item+<span class="string">&#x27;.json&#x27;</span>);</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="built_in">Promise</span>.all(promises).then(<span class="function"><span class="keyword">function</span> (<span class="params">posts</span>) </span>&#123;</span><br><span class="line">&gt;<span class="comment">// ...</span></span><br><span class="line">&gt;&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">&gt;<span class="comment">// ...</span></span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>promises</code>是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态 <strong>都</strong> 变成<code>fulfilled</code>，或者<strong>其中有一个变为<code>rejected</code></strong>，才会调用<code>Promise.all</code>方法后面的回调函数。</p><h6 id="下面是另一个例子"><a href="#下面是另一个例子" class="headerlink" title="下面是另一个例子"></a>下面是另一个例子</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> databasePromise = connectDatabase(); <span class="comment">//假设定义了一个异步方法,此方法能拿到你需要的所有数据</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> booksPromise = databasePromise     <span class="comment">//定义一个方法,在 databasePromise() 执行后寻找其内部书本信息</span></span><br><span class="line">&gt;.then(findAllBooks);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> userPromise = databasePromise    <span class="comment">//定义一个方法,在 databasePromise() 执行后寻找其内部当前用户信息</span></span><br><span class="line">&gt;.then(getCurrentUser);</span><br><span class="line"></span><br><span class="line">&gt;<span class="built_in">Promise</span>.all([</span><br><span class="line">&gt;booksPromise,</span><br><span class="line">&gt;userPromise</span><br><span class="line">&gt;])</span><br><span class="line">&gt;.then(<span class="function">(<span class="params">[books, user]</span>) =&gt;</span> pickTopRecommendations(books, user));</span><br></pre></td></tr></table></figure><p>上面代码中，<code>booksPromise</code>和<code>userPromise</code>是两个异步操作，只有等到它们的结果都返回了，才会触发<code>pickTopRecommendations</code>这个回调函数。</p></blockquote><h5 id="如果参数中的Promise实例定义了自己的catch方法"><a href="#如果参数中的Promise实例定义了自己的catch方法" class="headerlink" title="如果参数中的Promise实例定义了自己的catch方法 ?"></a>如果参数中的Promise实例定义了自己的catch方法 ?</h5><blockquote><p>注意，如果作为参数的 Promise 实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//定义一个状态将为成功的的promise</span></span><br><span class="line">&gt;<span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; resolve(<span class="string">&#x27;hello&#x27;</span>)&#125;)</span><br><span class="line">&gt;.then(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">&gt;.catch(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//定义一个将抛出错误的promise</span></span><br><span class="line">&gt;<span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;报错了&#x27;</span>) &#125;)</span><br><span class="line">&gt;.then(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">&gt;.catch(<span class="function"><span class="params">e</span> =&gt;</span>&#123;</span><br><span class="line">&gt;<span class="built_in">console</span>.log(<span class="string">&#x27;p2自己的catch捕获: &#x27;</span>, e)</span><br><span class="line">&gt;<span class="keyword">return</span> e; <span class="comment">//异常获取后原样返回,不做修改</span></span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//调用 Promise.all 方法</span></span><br><span class="line">&gt;<span class="built_in">Promise</span>.all([p1, p2])</span><br><span class="line">&gt;.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27; Promise.all 方法中的成功回调: &#x27;</span>, result))</span><br><span class="line">&gt;.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot; Promise.all 方法中的catch&quot;</span>, e));</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//p2自己的catch捕获:  Error: 报错了</span></span><br><span class="line">&gt;<span class="comment">// Promise.all 方法中的成功回调:  (2) [&#x27;hello&#x27;, Error: 报错了]</span></span><br></pre></td></tr></table></figure><p>上面代码中，</p><blockquote><ul><li><code>p1</code>会<code>resolved</code>，<code>p2</code>首先会<code>rejected</code></li><li>但是<code>p2</code>有自己的<code>catch</code>方法，该方法返回的是一个新的 Promise 实例，<code>p2</code>指向的实际上是这个实例。</li><li>该实例执行完<code>catch</code>方法后，也会变成<code>resolved</code>，导致<code>Promise.all()</code>方法参数里面的两个实例都会<code>resolved</code></li><li>因此会调用<code>then</code>方法指定的回调函数，而不会调用<code>catch</code>方法指定的回调函数</li></ul></blockquote></blockquote><h5 id="如果参数中的Promise实例-没有-定义自己的catch方法"><a href="#如果参数中的Promise实例-没有-定义自己的catch方法" class="headerlink" title="如果参数中的Promise实例 没有 定义自己的catch方法 ?"></a>如果参数中的Promise实例 <code>没有</code> 定义自己的catch方法 ?</h5><blockquote><p>如果<code>p2</code>没有自己的<code>catch</code>方法，就会调用<code>Promise.all()</code>的<code>catch</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//定义一个状态将为成功的的promise</span></span><br><span class="line">&gt;<span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; resolve(<span class="string">&#x27;hello&#x27;</span>)&#125;)</span><br><span class="line">&gt;.then(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//定义一个将抛出错误的promise</span></span><br><span class="line">&gt;<span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;报错了&#x27;</span>) &#125;)</span><br><span class="line">&gt;.then(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//调用 Promise.all 方法</span></span><br><span class="line">&gt;<span class="built_in">Promise</span>.all([p1, p2])</span><br><span class="line">&gt;.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27; Promise.all 方法中的成功回调: &#x27;</span>, result))</span><br><span class="line">&gt;.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot; Promise.all 方法中的catch&quot;</span>, e));</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// Promise.all 方法中的catch Error: 报错了</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h4><blockquote><p><code>Promise.race()</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p><p><code>Promise.race()</code>方法的参数与<code>Promise.all()</code>方法一样，如果不是 Promise 实例，就会先调用下面讲到的<code>Promise.resolve()</code>方法，将参数转为 Promise 实例，再进一步处理。</p></blockquote><h5 id="举个简单的🌰"><a href="#举个简单的🌰" class="headerlink" title="举个简单的🌰"></a>举个简单的🌰</h5><blockquote><p>如p1延时,开启了异步,内部正常是同步进行,所以<code>p2&gt;p3&gt;p1</code>,结果是<code>P2</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">&gt;resolve(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">&gt;&#125;, <span class="number">1000</span>);</span><br><span class="line">&gt;&#125;)</span><br><span class="line">&gt;<span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;Success&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;Oh Yeah&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">//调用</span></span><br><span class="line">&gt;<span class="keyword">const</span> result = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br><span class="line">&gt;<span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure></blockquote><h5 id="举个应用实🌰"><a href="#举个应用实🌰" class="headerlink" title="举个应用实🌰"></a>举个应用实🌰</h5><blockquote><p>下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为<code>reject</code>，否则变为<code>resolve</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([</span><br><span class="line">&gt;fetch(<span class="string">&#x27;https://gitee.com/hongjilin&#x27;</span>),</span><br><span class="line">&gt;<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;请求超时!!!!&#x27;</span>)), <span class="number">5000</span>)</span><br><span class="line">&gt;&#125;)</span><br><span class="line">&gt;]);</span><br><span class="line"></span><br><span class="line">&gt;p</span><br><span class="line">&gt;.then(<span class="built_in">console</span>.log)</span><br><span class="line">&gt;.catch(<span class="built_in">console</span>.error);</span><br></pre></td></tr></table></figure><p>上面代码中，如果 5 秒之内<code>fetch</code>方法无法返回结果，变量<code>p</code>的状态就会变为<code>rejected</code>，从而触发<code>catch</code>方法指定的回调函数。</p><p>是不是很好用又简单</p></blockquote><h4 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled()"></a>Promise.allSettled()</h4><blockquote><p><code>Promise.allSettled()</code>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。</p><p><strong>只有等到所有这些参数实例都返回结果</strong>，不管是<code>fulfilled</code>还是<code>rejected</code>，包装实例才会结束。</p><p>该方法由 <a href="https://github.com/tc39/proposal-promise-allSettled">ES2020</a> 引入。</p></blockquote><h5 id="举个简单的🌰-1"><a href="#举个简单的🌰-1" class="headerlink" title="举个简单的🌰"></a>举个简单的🌰</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> promises = [</span><br><span class="line">&gt;fetch(<span class="string">&#x27;https://gitee.com/hongjilin&#x27;</span>),</span><br><span class="line">&gt;fetch(<span class="string">&#x27;https://github.com/Hongjilin&#x27;</span>),</span><br><span class="line">&gt;fetch(<span class="string">&#x27;./hong.json&#x27;</span>),</span><br><span class="line">&gt;];</span><br><span class="line">&gt;loading = <span class="literal">true</span>; <span class="comment">//请求前将 loading 改为true ; 页面出现滚动加载图标蒙层</span></span><br><span class="line">&gt;<span class="keyword">await</span> <span class="built_in">Promise</span>.allSettled(promises);</span><br><span class="line">&gt;loading = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>上面代码对服务器发出三个请求，等到三个请求都结束，不管请求成功还是失败，加载的滚动图标就会消失。</p></blockquote><h5 id="该方法返回的新的-Promise-实例，一旦结束，状态总是fulfilled，不会变成rejected"><a href="#该方法返回的新的-Promise-实例，一旦结束，状态总是fulfilled，不会变成rejected" class="headerlink" title="该方法返回的新的 Promise 实例，一旦结束，状态总是fulfilled，不会变成rejected"></a>该方法返回的新的 Promise 实例，一旦结束，状态总是<code>fulfilled</code>，不会变成<code>rejected</code></h5><blockquote><p>该方法返回的新的 Promise 实例，一旦结束，状态总是<code>fulfilled</code>，不会变成<code>rejected</code>。状态变成<code>fulfilled</code>后，Promise 的监听函数接收到的参数是一个数组，每个成员对应一个传入<code>Promise.allSettled()</code>的 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> resolved = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;返回成功状态的promise&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">const</span> rejected = <span class="built_in">Promise</span>.reject(<span class="string">&#x27;返回失败状态的promise&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> allSettledPromise = <span class="built_in">Promise</span>.allSettled([resolved, rejected]);</span><br><span class="line">&gt;<span class="comment">// Promise.allSettled 得到的新实例状态只会是 `fulfilled`</span></span><br><span class="line">&gt;allSettledPromise.then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">&gt;<span class="built_in">console</span>.log(results); <span class="comment">//注意,这是 `fulfilled` 的回调函数,只有其状态为成功才能进到这里</span></span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">/*</span></span><br><span class="line"><span class="comment">&gt;[</span></span><br><span class="line"><span class="comment">&#123; &quot;status&quot;: &quot;fulfilled&quot;, &quot;value&quot;: &quot;返回成功状态的promise&quot; &#125;,</span></span><br><span class="line"><span class="comment">&#123; &quot;status&quot;: &quot;rejected&quot;, &quot;reason&quot;: &quot;返回失败状态的promise&quot; &#125;</span></span><br><span class="line"><span class="comment">&gt;]</span></span><br><span class="line"><span class="comment">&gt;*/</span></span><br></pre></td></tr></table></figure><blockquote><ul><li><code>Promise.allSettled()</code>的返回值<code>allSettledPromise</code>，状态只可能变成<code>fulfilled</code>(注意,是 <strong>allSettledPromise</strong> 的状态,而不是内部的promise实例)</li><li>它的监听函数接收到的参数是数组<code>results</code>。该数组的每个成员都是一个对象，对应的是传入<code>Promise.allSettled()</code>的 Promise 实例。</li><li>每个对象都有<code>status</code>属性，该属性的值只可能是字符串<code>fulfilled</code>或字符串<code>rejected</code>。</li><li><code>fulfilled</code>时，对象有<code>value</code>属性，<code>rejected</code>时有<code>reason</code>属性，对应两种状态的返回值。</li></ul></blockquote></blockquote><h5 id="举个返回值用法的🌰"><a href="#举个返回值用法的🌰" class="headerlink" title="举个返回值用法的🌰"></a>举个返回值用法的🌰</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> promises = [ fetch(<span class="string">&#x27;./hong.json&#x27;</span>), fetch(<span class="string">&#x27;https://gitee.com/hongjilin&#x27;</span>) ];</span><br><span class="line">&gt;<span class="keyword">const</span> results = <span class="keyword">await</span> <span class="built_in">Promise</span>.allSettled(promises);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 过滤出成功的请求</span></span><br><span class="line">&gt;<span class="keyword">const</span> successfulPromises = results.filter(<span class="function"><span class="params">item</span> =&gt;</span> item.status === <span class="string">&#x27;fulfilled&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 过滤出失败的请求，并取得它们的失败原因</span></span><br><span class="line">&gt;<span class="keyword">const</span> errors = results</span><br><span class="line">&gt;.filter(<span class="function"><span class="params">p</span> =&gt;</span> p.status === <span class="string">&#x27;rejected&#x27;</span>)</span><br><span class="line">&gt;.map(<span class="function"><span class="params">p</span> =&gt;</span> p.reason);</span><br></pre></td></tr></table></figure><p>有时候，我们不关心异步操作的结果，只关心这些操作有没有结束。这时，<code>Promise.allSettled()</code>方法就很有用。如果没有这个方法，想要确保所有操作都结束，就很麻烦。<code>Promise.all()</code>方法无法做到这一点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> urls = [ <span class="string">&#x27;https://gitee.com/hongjilin&#x27;</span> ,<span class="string">&#x27;https://github.com/Hongjilin&#x27;</span>];</span><br><span class="line">&gt;<span class="keyword">const</span> requests = urls.map(<span class="function"><span class="params">x</span> =&gt;</span> fetch(x));</span><br><span class="line">&gt;<span class="comment">//举例用 Promise.all 尝试实现,很明显,难以实现</span></span><br><span class="line">&gt;<span class="keyword">try</span> &#123;</span><br><span class="line">&gt;<span class="keyword">await</span> <span class="built_in">Promise</span>.all(requests);</span><br><span class="line">&gt;<span class="built_in">console</span>.log(<span class="string">&#x27;所有请求都成功。&#x27;</span>);</span><br><span class="line">&gt;&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">&gt;<span class="built_in">console</span>.log(<span class="string">&#x27;至少一个请求失败，其他请求可能还没结束。&#x27;</span>);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise.all()</code>无法确定所有请求都结束。想要达到这个目的，写起来很麻烦，有了<code>Promise.allSettled()</code>，这就很容易了</p></blockquote><h4 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any()"></a>Promise.any()</h4><blockquote><p>ES2021 引入了<a href="https://github.com/tc39/proposal-promise-any"><code>Promise.any()</code>方法</a>。该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。只要参数实例有一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态；如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态。</p></blockquote><h5 id="与-Promise-race-方法的区别"><a href="#与-Promise-race-方法的区别" class="headerlink" title="与 Promise.race() 方法的区别"></a>与 <code>Promise.race()</code> 方法的区别</h5><blockquote><p><code>Promise.any()</code>跟<code>Promise.race()</code>方法很像，只有一点不同，就是不会因为某个 Promise 变成<code>rejected</code>状态而结束。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> promises = [</span><br><span class="line">&gt;fetch(<span class="string">&#x27;https://gitee.com/hongjilin&#x27;</span>).then(<span class="function">() =&gt;</span> <span class="string">&#x27;a&#x27;</span>),</span><br><span class="line">&gt;fetch(<span class="string">&#x27;https://github.com/Hongjilin&#x27;</span>).then(<span class="function">() =&gt;</span> <span class="string">&#x27;b&#x27;</span>),</span><br><span class="line">&gt;fetch(<span class="string">&#x27;./hong.json&#x27;</span>).then(<span class="function">() =&gt;</span> <span class="string">&#x27;c&#x27;</span>),</span><br><span class="line">&gt;];</span><br><span class="line">&gt;<span class="keyword">try</span> &#123;</span><br><span class="line">&gt;<span class="keyword">const</span> first = <span class="keyword">await</span> <span class="built_in">Promise</span>.any(promises);</span><br><span class="line">&gt;<span class="built_in">console</span>.log(first);</span><br><span class="line">&gt;&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">&gt;<span class="built_in">console</span>.log(error);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise.any()</code>方法的参数数组包含三个 Promise 操作。其中只要有一个变成<code>fulfilled</code>，<code>Promise.any()</code>返回的 Promise 对象就变成<code>fulfilled</code>。如果所有三个操作都变成<code>rejected</code>，那么<code>await</code>命令就会抛出错误。</p></blockquote><h5 id="Promise-any-抛出的错误"><a href="#Promise-any-抛出的错误" class="headerlink" title="Promise.any() 抛出的错误"></a>Promise.any() 抛出的错误</h5><blockquote><p><code>Promise.any()</code>抛出的错误，不是一个一般的错误，而是一个 AggregateError 实例。它相当于一个数组，每个成员对应一个被<code>rejected</code>的操作所抛出的错误。下面是 AggregateError 的实现示例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">new</span> AggregateError() <span class="keyword">extends</span> <span class="built_in">Array</span> -&gt; AggregateError</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> err = <span class="keyword">new</span> AggregateError();</span><br><span class="line">&gt;err.push(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;first error&quot;</span>));</span><br><span class="line">&gt;err.push(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;second error&quot;</span>));</span><br><span class="line">&gt;<span class="keyword">throw</span> err;</span><br></pre></td></tr></table></figure><p>捕捉错误时，如果不用<code>try...catch</code>结构和 await 命令，可以像下面这样写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">Promise</span>.any(promises).then(</span><br><span class="line">&gt;<span class="function">(<span class="params">first</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="comment">// Any of the promises was fulfilled.</span></span><br><span class="line">&gt;&#125;,</span><br><span class="line">&gt;<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="comment">// All of the promises were rejected.</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;);</span><br></pre></td></tr></table></figure></blockquote><h5 id="再举个🌰"><a href="#再举个🌰" class="headerlink" title="再举个🌰"></a>再举个🌰</h5><blockquote><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> resolved = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;成功&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">const</span> rejected = <span class="built_in">Promise</span>.reject(<span class="string">&#x27;失败了&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">const</span> alsoRejected = <span class="built_in">Promise</span>.reject(<span class="string">&#x27;太失败了&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="built_in">Promise</span>.any([resolved, rejected, alsoRejected]).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">&gt;<span class="built_in">console</span>.log(result); <span class="comment">// 成功</span></span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="built_in">Promise</span>.any([rejected, alsoRejected]).catch(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">&gt;<span class="built_in">console</span>.log(results);  <span class="comment">//AggregateError: All promises were rejected</span></span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p>三个Promise中有一个为成功,则总的结果就是成功,三个中全部失败,才会变成失败</p></blockquote><h4 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h4><blockquote><p>有时需要将现有对象转为 Promise 对象，<code>Promise.resolve()</code>方法就起到这个作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> jsPromise = <span class="built_in">Promise</span>.resolve($.ajax(<span class="string">&#x27;https://gitee.com/hongjilin&#x27;</span>));</span><br></pre></td></tr></table></figure><p>上面代码将 jQuery 生成的<code>deferred</code>对象，转为一个新的 Promise 对象。</p><p><code>Promise.resolve()</code>等价于下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">Promise</span>.resolve(<span class="string">&#x27;努力学习的汪&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// 等价于</span></span><br><span class="line">&gt;<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="string">&#x27;努力学习的汪&#x27;</span>))</span><br></pre></td></tr></table></figure><p><code>Promise.resolve()</code>方法的参数分成四种情况</p></blockquote><h5 id="参数是一个-Promise-实例"><a href="#参数是一个-Promise-实例" class="headerlink" title="参数是一个 Promise 实例"></a>参数是一个 Promise 实例</h5><blockquote><p>如果参数是 Promise 实例，那么<code>Promise.resolve</code>将不做任何修改、原封不动地返回这个实例。</p></blockquote><h5 id="参数是一个thenable对象"><a href="#参数是一个thenable对象" class="headerlink" title="参数是一个thenable对象"></a><strong>参数是一个<code>thenable</code>对象</strong></h5><blockquote><p><code>thenable</code>对象指的是具有<code>then</code>方法的对象，比如下面这个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> thenable = &#123;</span><br><span class="line"><span class="attr">then</span>: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">resolve(<span class="string">&#x27;成功&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><p><code>Promise.resolve()</code>方法会将这个对象转为 Promise 对象，然后就立即执行<code>thenable</code>对象的<code>then()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> thenable = &#123;</span><br><span class="line"><span class="attr">then</span>: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123; resolve(<span class="string">&#x27;成功&#x27;</span>) &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(thenable);</span><br><span class="line">&gt;p1.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(value);  <span class="comment">// &#x27;成功&#x27;</span></span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>thenable</code>对象的<code>then()</code>方法执行后，对象<code>p1</code>的状态就变为<code>resolved</code>，从而立即执行最后那个<code>then()</code>方法指定的回调函数，输出 <strong>‘成功’</strong>。 </p></blockquote><h5 id="参数不是具有then-方法的对象，或根本就不是对象"><a href="#参数不是具有then-方法的对象，或根本就不是对象" class="headerlink" title="参数不是具有then()方法的对象，或根本就不是对象"></a>参数不是具有<code>then()</code>方法的对象，或根本就不是对象</h5><blockquote><p>如果参数是一个原始值，或者是一个不具有<code>then()</code>方法的对象，则<code>Promise.resolve()</code>方法返回一个新的 Promise 对象，状态为<code>resolved</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;努力学习的汪&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;p.then(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">&gt;<span class="built_in">console</span>.log(s)</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">// 努力学习的汪</span></span><br></pre></td></tr></table></figure><p>上面代码生成一个新的 Promise 对象的实例<code>p</code>。</p><blockquote><ul><li>由于字符串 <code>努力学习的汪</code> 不属于异步操作（判断方法是字符串对象不具有 then 方法）</li><li>返回 Promise 实例的状态从一生成就是<code>resolved</code>，所以回调函数会立即执行</li><li><code>Promise.resolve()</code>方法的参数会同时传给回调函数作为其参数</li></ul></blockquote></blockquote><h5 id="不带有任何参数"><a href="#不带有任何参数" class="headerlink" title="不带有任何参数"></a>不带有任何参数</h5><blockquote><p><code>Promise.resolve()</code>方法允许调用时不带参数，直接返回一个<code>resolved</code>状态的 Promise 对象。</p><p>所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用<code>Promise.resolve()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line"></span><br><span class="line">&gt;p.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure><p>上面代码的变量<code>p</code>就是一个 Promise 对象。</p><p>需要注意的是，立即<code>resolve()</code>的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时 —&gt; 不懂的同学请看 <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/编程_前端开发学习笔记/HTML+CSS+JS基础笔记/JavaScript笔记#4事件循环模型event-loop机制">JavaScript笔记中的#4事件循环模型event-loop机制</a> ,本人在此有进行详细的解析</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">&gt;<span class="built_in">console</span>.log(<span class="string">&#x27;three&#x27;</span>); <span class="comment">//这里是新的一轮事件循环</span></span><br><span class="line">&gt;&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">&gt;<span class="built_in">console</span>.log(<span class="string">&#x27;two&#x27;</span>); <span class="comment">//本轮同步代码结束后,新一轮事件循环前,就执行</span></span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="built_in">console</span>.log(<span class="string">&#x27;one&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// one</span></span><br><span class="line">&gt;<span class="comment">// two</span></span><br><span class="line">&gt;<span class="comment">// three</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>setTimeout(fn, 0)</code>在下一轮“事件循环”开始时执行，<code>Promise.resolve()</code>在本轮“事件循环”结束时执行，<code>console.log(&#39;one&#39;)</code>则是立即执行，因此最先输出。</p></blockquote><h4 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h4><blockquote><p><code>Promise.reject(reason)</code>方法也会返回一个新的 Promise 实例，该实例的状态为<code>rejected</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p = <span class="built_in">Promise</span>.reject(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(<span class="string">&#x27;出错了&#x27;</span>))</span><br><span class="line"></span><br><span class="line">&gt;p.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">&gt;<span class="built_in">console</span>.log(s)</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><p>上面代码生成一个 Promise 对象的实例<code>p</code>，状态为<code>rejected</code>，回调函数会立即执行。</p><p><code>Promise.reject()</code>方法的参数，会原封不动地作为<code>reject</code>的理由，变成后续方法的参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">Promise</span>.reject(<span class="string">&#x27;出错了&#x27;</span>)</span><br><span class="line">&gt;.catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="built_in">console</span>.log(e === <span class="string">&#x27;出错了&#x27;</span>)</span><br><span class="line">&gt;&#125;)</span><br><span class="line">&gt;<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise.reject()</code>方法的参数是一个字符串，后面<code>catch()</code>方法的参数<code>e</code>就是这个字符串。</p></blockquote><h4 id="Promise-try"><a href="#Promise-try" class="headerlink" title="Promise.try()"></a>Promise.try()</h4><blockquote><p>实际开发中，经常遇到一种情况：不知道或者不想区分，函数<code>f</code>是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管<code>f</code>是否包含异步操作，都用<code>then</code>方法指定下一步流程，用<code>catch</code>方法处理<code>f</code>抛出的错误。一般就会采用下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">Promise</span>.resolve().then(f)</span><br></pre></td></tr></table></figure><p>上面的写法有一个缺点，就是如果<code>f</code>是同步函数，那么它会在本轮事件循环的末尾执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> f = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;now&#x27;</span>);</span><br><span class="line">&gt;<span class="built_in">Promise</span>.resolve().then(f);</span><br><span class="line">&gt;<span class="built_in">console</span>.log(<span class="string">&#x27;next&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">// next</span></span><br><span class="line">&gt;<span class="comment">// now</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>f</code>是同步的，但是用 Promise 包装了以后，就变成异步执行了。</p><h6 id="那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的-API-呢？"><a href="#那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的-API-呢？" class="headerlink" title="那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？"></a>那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？</h6></blockquote><h5 id="写法一-用async函数来写"><a href="#写法一-用async函数来写" class="headerlink" title="写法一 : 用async函数来写"></a>写法一 : 用<code>async</code>函数来写</h5><blockquote><p>该知识点如果不懂的可以继续往下看,这是ES6的另外一块知识点内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> f = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;now&#x27;</span>);</span><br><span class="line">&gt;(<span class="keyword">async</span> () =&gt; f())();</span><br><span class="line">&gt;<span class="built_in">console</span>.log(<span class="string">&#x27;next&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">// now</span></span><br><span class="line">&gt;<span class="comment">// next</span></span><br></pre></td></tr></table></figure><p>上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的<code>async</code>函数，因此如果<code>f</code>是同步的，就会得到同步的结果；如果<code>f</code>是异步的，就可以用<code>then</code>指定下一步，就像下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;(<span class="keyword">async</span> () =&gt; f())()</span><br><span class="line">&gt;.then(...)</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>async () =&gt; f()</code>会吃掉<code>f()</code>抛出的错误。所以，如果想捕获错误，要使用<code>promise.catch</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;(<span class="keyword">async</span> () =&gt; f())()</span><br><span class="line">&gt;.then(...)</span><br><span class="line">&gt;.catch(...)</span><br></pre></td></tr></table></figure></blockquote><h5 id="写法二-使用new-Promise"><a href="#写法二-使用new-Promise" class="headerlink" title="写法二 : 使用new Promise()"></a>写法二 : 使用<code>new Promise()</code></h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> f = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;now&#x27;</span>);</span><br><span class="line">&gt;(</span><br><span class="line">&gt;<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(</span><br><span class="line">&gt;<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(f())</span><br><span class="line">&gt;)</span><br><span class="line">&gt;)();</span><br><span class="line">&gt;<span class="built_in">console</span>.log(<span class="string">&#x27;next&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">// now</span></span><br><span class="line">&gt;<span class="comment">// next</span></span><br></pre></td></tr></table></figure><p>上面代码也是使用立即执行的匿名函数，执行<code>new Promise()</code>。这种情况下，同步函数也是同步执行的。</p></blockquote><h5 id="Promise-try的引出"><a href="#Promise-try的引出" class="headerlink" title="Promise.try的引出"></a>Promise.try的引出</h5><blockquote><p>鉴于这是一个很常见的需求，所以现在有一个<a href="https://github.com/ljharb/proposal-promise-try">提案</a>，提供<code>Promise.try</code>方法替代上面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> f = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;now&#x27;</span>);</span><br><span class="line">&gt;<span class="built_in">Promise</span>.try(f);</span><br><span class="line">&gt;<span class="built_in">console</span>.log(<span class="string">&#x27;next&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">// now</span></span><br><span class="line">&gt;<span class="comment">// next</span></span><br></pre></td></tr></table></figure><p>事实上，<code>Promise.try</code>存在已久，Promise 库<a href="http://bluebirdjs.com/docs/api/promise.try.html"><code>Bluebird</code></a>、<a href="https://github.com/kriskowal/q/wiki/API-Reference#promisefcallargs"><code>Q</code></a>和<a href="https://github.com/cujojs/when/blob/master/docs/api.md#whentry"><code>when</code></a>，早就提供了这个方法。</p><p>由于<code>Promise.try</code>为所有操作提供了统一的处理机制，所以如果想用<code>then</code>方法管理流程，最好都用<code>Promise.try</code>包装一下。这样有<a href="http://cryto.net/~joepie91/blog/2016/05/11/what-is-promise-try-and-why-does-it-matter/">许多好处</a>，其中一点就是可以更好地管理异常。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">function</span> <span class="title">getUsername</span>(<span class="params">userId</span>) </span>&#123;</span><br><span class="line">&gt;<span class="keyword">return</span> database.users.get(&#123;<span class="attr">id</span>: userId&#125;)</span><br><span class="line">&gt;.then(<span class="function"><span class="keyword">function</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">&gt;<span class="keyword">return</span> user.name;</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>database.users.get()</code>返回一个 Promise 对象，如果抛出异步错误，可以用<code>catch</code>方法捕获，就像下面这样写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;database.users.get(&#123;<span class="attr">id</span>: userId&#125;)</span><br><span class="line">&gt;.then(...)</span><br><span class="line">&gt;.catch(...)</span><br></pre></td></tr></table></figure><p>但是<code>database.users.get()</code>可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用<code>try...catch</code>去捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">try</span> &#123;</span><br><span class="line">&gt;database.users.get(&#123;<span class="attr">id</span>: userId&#125;)</span><br><span class="line">&gt;.then(...)</span><br><span class="line">&gt;.catch(...)</span><br><span class="line">&gt;&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">&gt;<span class="comment">// ...</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面这样的写法就很笨拙了，这时就可以统一用<code>promise.catch()</code>捕获所有同步和异步的错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">Promise</span>.try(<span class="function">() =&gt;</span> database.users.get(&#123;<span class="attr">id</span>: userId&#125;))</span><br><span class="line">&gt;.then(...)</span><br><span class="line">&gt;.catch(...)</span><br></pre></td></tr></table></figure><p>事实上，<code>Promise.try</code>就是模拟<code>try</code>代码块，就像<code>promise.catch</code>模拟的是<code>catch</code>代码块。</p></blockquote><hr><h1 id="自定义Promise手写"><a href="#自定义Promise手写" class="headerlink" title="自定义Promise手写"></a>自定义Promise手写</h1><blockquote><ol><li>下方的<code>Promise.prototype.then</code>与<code>Promise.resolve</code>为什么一个挂载在<code>prototype</code>而另一个挂载在实例对象上?</li></ol><p>解:原因是分别为静态方法与实例方法 </p><p>—&gt;上面的需要new实例化的时候自动继承实例<code>prototype</code>上的方法和属性,所以用<code>实例对象.then()</code>来调用,而下面的Promise.resolve是静态方法,不用new,是可以直接Promise.resolve()调用</p><h2 id="此部分可以跳过不看-类似手撕源码"><a href="#此部分可以跳过不看-类似手撕源码" class="headerlink" title="此部分可以跳过不看,类似手撕源码"></a><strong>此部分可以跳过不看,类似手撕源码</strong></h2></blockquote><h2 id="Promise的实例方法实现"><a href="#Promise的实例方法实现" class="headerlink" title="Promise的实例方法实现"></a>Promise的实例方法实现</h2><h3 id="初始结构搭建"><a href="#初始结构搭建" class="headerlink" title="初始结构搭建"></a>初始结构搭建</h3><blockquote><p>html引入,该章节后续html大部分重复 除非必要,否则不再放上来</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Promise-封装 | 1 - 初始结构搭建<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./promise.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            resolve(<span class="string">&#x27;OK&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        &#125;);</span></span><br><span class="line"><span class="javascript">        p.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(value);</span></span><br><span class="line"><span class="javascript">        &#125;, <span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.warn(reason);</span></span><br><span class="line"><span class="javascript">        &#125;)</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>promise.js  —&gt;使用原生写法,最后会改为class写法</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>)</span>&#123;&#125;</span><br><span class="line"><span class="comment">//添加 then 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onResolved, onRejected</span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="resolve-与-reject构建与基础实现"><a href="#resolve-与-reject构建与基础实现" class="headerlink" title="resolve 与 reject构建与基础实现"></a>resolve 与 reject构建与基础实现</h3><blockquote><ol><li><p>使用<code>const self = this;</code>保存this执行,使function中可以取得当前实例</p><p>ps:可以不使用该方法保存,但是下方function需要<code>改为箭头函数</code>,否则<code>function默认指向是window</code></p><p>之后代码默认使用<code>self</code>保存this,箭头函数方式将在最后改为class写法时使用</p></li><li><p>默认设置 <code>PromiseState = &#39;pending&#39;以及 PromiseResult = null</code>,这就是promise状态基础</p></li></ol></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//添加属性</span></span><br><span class="line">  <span class="built_in">this</span>.PromiseState = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.PromiseResult = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">//保存实例对象的 this 的值</span></span><br><span class="line"><span class="comment">/*  此处可以不写,但是下面function方法需要改为箭头函数,否则function默认指向是window */</span></span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>; </span><br><span class="line">  <span class="comment">//resolve 函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">data</span>) </span>&#123;--------------------------------------------</span><br><span class="line">    <span class="comment">//1. 修改对象的状态 (promiseState)</span></span><br><span class="line">    self.PromiseState = <span class="string">&#x27;fulfilled&#x27;</span>; <span class="comment">// resolved</span></span><br><span class="line">    <span class="comment">//2. 设置对象结果值 (promiseResult)</span></span><br><span class="line">    self.PromiseResult = data;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//reject 函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">data</span>) </span>&#123;----------------------------------------------</span><br><span class="line">    <span class="comment">//1. 修改对象的状态 (promiseState)</span></span><br><span class="line">    self.PromiseState = <span class="string">&#x27;rejected&#x27;</span>; <span class="comment">// </span></span><br><span class="line">    <span class="comment">//2. 设置对象结果值 (promiseResult)</span></span><br><span class="line">    self.PromiseResult = data;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//同步调用『执行器函数』</span></span><br><span class="line">  executor(resolve, reject);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加 then 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="throw-抛出异常改变状态"><a href="#throw-抛出异常改变状态" class="headerlink" title="throw 抛出异常改变状态"></a>throw 抛出异常改变状态</h3><blockquote><ol><li>在2的基础上进行修改:将执行器放入<code>try-catch()</code>中</li><li>在catch中使用<code>reject()</code>修改 promise 对象状态为『<code>失败</code>』</li></ol></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">//同步调用『执行器函数』</span></span><br><span class="line">   executor(resolve, reject);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">   <span class="comment">//修改 promise 对象状态为『失败』</span></span><br><span class="line">   reject(e);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="状态只能修改一次"><a href="#状态只能修改一次" class="headerlink" title="状态只能修改一次"></a>状态只能修改一次</h3><blockquote><ol><li><p>基于2 3代码中resolve和reject方法进修改</p></li><li><p>在成功与失败函数中添加判断<code>if(self.PromiseState !== &#39;pending&#39;) return;</code>,如果进入函数时状态不为<code>pending</code>直接退出,这样就能做到状态只能从<code>pending</code>改至其他状态且做到只能改一次</p></li></ol></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">html调用--------------------------------------------------------</span><br><span class="line"> <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      reject(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">      resolve(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">      <span class="comment">//抛出异常</span></span><br><span class="line">      <span class="comment">// throw &quot;error&quot;;</span></span><br><span class="line">    &#125;);</span><br><span class="line"> <span class="built_in">console</span>.log(p);</span><br><span class="line">promise.js修改--------------------------------------------------------</span><br><span class="line"></span><br><span class="line">  <span class="comment">//resolve 函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//判断状态</span></span><br><span class="line">        <span class="keyword">if</span>(self.PromiseState !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//1. 修改对象的状态 (promiseState)</span></span><br><span class="line">        self.PromiseState = <span class="string">&#x27;fulfilled&#x27;</span>;<span class="comment">// resolved</span></span><br><span class="line">        <span class="comment">//2. 设置对象结果值 (promiseResult)</span></span><br><span class="line">        self.PromiseResult = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//reject 函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//判断状态</span></span><br><span class="line">        <span class="keyword">if</span>(self.PromiseState !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//1. 修改对象的状态 (promiseState)</span></span><br><span class="line">        self.PromiseState = <span class="string">&#x27;rejected&#x27;</span>;<span class="comment">// </span></span><br><span class="line">        <span class="comment">//2. 设置对象结果值 (promiseResult)</span></span><br><span class="line">        self.PromiseResult = data;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="hen-方法执行回调基础实现"><a href="#hen-方法执行回调基础实现" class="headerlink" title="hen 方法执行回调基础实现"></a>hen 方法执行回调基础实现</h3><blockquote><ol><li>修改<code>Promise.prototype.then</code>方法</li><li>传入<code>then(成功回调,失败回调)</code>,当调用then后,会判断当前<code>this.PromiseState</code>的状态,当其为成功时调用<code>成功回调</code>,失败时调用<code>失败回调</code></li></ol></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">html调用------------------------------------------------------------</span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// resolve(&#x27;OK&#x27;);// reject(&quot;Error&quot;);</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&quot;ERROR&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    p.then(</span><br><span class="line">        <span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(value); &#125;, </span><br><span class="line">        <span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="built_in">console</span>.warn(reason);&#125;</span><br><span class="line">    )</span><br><span class="line">promise.js修改与实现-----------------------------------------------------</span><br><span class="line"><span class="comment">//添加 then 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//调用回调函数  PromiseState</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === <span class="string">&#x27;fulfilled&#x27;</span>) &#123;onResolved(<span class="built_in">this</span>.PromiseResult);&#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === <span class="string">&#x27;rejected&#x27;</span>) &#123;onRejected(<span class="built_in">this</span>.PromiseResult);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步任务-then-方法实现"><a href="#异步任务-then-方法实现" class="headerlink" title="异步任务 then 方法实现"></a>异步任务 then 方法实现</h3><blockquote><ol><li><p>此处对于5有四处修改,下面上<code>js代码</code></p></li><li><p>当我运行<code>异步代码</code>后,我的执行器内部代码还未返回(因为用了定时器,里面的代码进入了异步队列),所以当我下面的.then()运行时:我的<code>p</code>为<code>pending</code>状态,所以根本不会执行resolve与reject方法</p><p>解:添加判断<code>pending</code>状态,将当前回调函数保存到实例对象(存到实例上是为了更方便)中,这样后续改变状态时候才调用得到</p></li><li><p>为什么要将回调保存到实例上而不是直接调用?</p><p><code>理由</code>:因为我的回调函数需要在我的promise状态改变后(成功或者失败),再根据状态选择运行哪个函数<br>所以当你调用<code>then()</code>时却检测到状态为<code>pending</code>,说明这时候的promise在异步队列 不能直接运行成功或者失败函数</p><p><code>解决</code>:因为<code>resolve与reject</code>方法与<code>then()</code>不在同一个作用域中,并不能共享<code>then(成功回调,失败回调)</code>的参数,所以在判断状态为<code>pending</code>时将回调保存到实例对象上.然后将回调函数的调用放在<code>resolve()与reject()</code>中</p><p>这样当我代码运行到异步队列的<code>resolve()或reject()</code>时,就可以在这个函数中运行回调函数,实现异步then</p></li><li><p>此处的then<code>仍有瑕疵</code>,需要继续完善</p></li></ol></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">html调用------------------------------------------------------------</span><br><span class="line"> <span class="comment">//实例化对象</span></span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;reject(<span class="string">&quot;error&quot;</span>); <span class="comment">/* resolve(&#x27;OK&#x27;);*/</span>&#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    p.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(value);&#125;,<span class="function"><span class="params">reason</span> =&gt;</span> &#123; <span class="built_in">console</span>.warn(reason);&#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(p);</span><br><span class="line"></span><br><span class="line">promise.js修改与实现-----------------------------------------------------</span><br><span class="line"><span class="comment">//声明构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.PromiseState = <span class="string">&#x27;pending&#x27;</span>; <span class="built_in">this</span>.PromiseResult = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 声明属性     </span></span><br><span class="line">  <span class="built_in">this</span>.callback = &#123;&#125;;-----------新添加<span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>; </span><br><span class="line">    </span><br><span class="line">  <span class="comment">//resolve 函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//判断状态</span></span><br><span class="line">    <span class="keyword">if</span> (self.PromiseState !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    self.PromiseState = <span class="string">&#x27;fulfilled&#x27;</span>; self.PromiseResult = data;</span><br><span class="line">    <span class="comment">//调用成功的回调函数  加判断的原因是防止无回调报错</span></span><br><span class="line">    <span class="keyword">if</span> (self.callback.onResolved) &#123; self.callback.onResolved(data); &#125;  ------------新添加<span class="number">2</span> 最重要 </span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//reject 函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (self.PromiseState !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    self.PromiseState = <span class="string">&#x27;rejected&#x27;</span>; self.PromiseResult = data;</span><br><span class="line">    <span class="comment">//执行回调</span></span><br><span class="line">    <span class="keyword">if</span> (self.callback.onResolved) &#123; self.callback.onResolved(data);&#125;  ------------新添加<span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;executor(resolve, reject);&#125; <span class="keyword">catch</span> (e) &#123;reject(e);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加 then 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//调用回调函数  PromiseState</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === <span class="string">&#x27;fulfilled&#x27;</span>) &#123;onResolved(<span class="built_in">this</span>.PromiseResult);&#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === <span class="string">&#x27;rejected&#x27;</span>) &#123; onRejected(<span class="built_in">this</span>.PromiseResult);&#125;</span><br><span class="line">  <span class="comment">//判断 pending 状态</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === <span class="string">&#x27;pending&#x27;</span>) &#123;  ------------新添加<span class="number">4</span></span><br><span class="line">    <span class="comment">//保存回调函数</span></span><br><span class="line">    <span class="built_in">this</span>.callback = &#123;</span><br><span class="line">      <span class="attr">onResolved</span>: onResolved,</span><br><span class="line">      <span class="attr">onRejected</span>: onRejected</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指定多个回调"><a href="#指定多个回调" class="headerlink" title="指定多个回调"></a>指定多个回调</h3><blockquote><ol><li><p>基于6代码进行修改 只展示修改部分代码</p></li><li><p><code>6</code>中保存回调函数的方式有BUG,如果我有多个<code>.then()</code>,后面加载的回调函数会覆盖之前的回调函数,导致最后回调函数<code>有且只有</code>最后一个</p><p>解:使用<code>数组</code>的方式进行存储回调函数,调用时也是用数组循环取出</p></li><li><p>此处的then<code>仍有瑕疵</code>,需要继续完善</p></li></ol></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">html调用------------------------------------------------------------</span><br><span class="line"><span class="comment">//实例化对象</span></span><br><span class="line">   <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;reject(<span class="string">&#x27;No&#x27;</span>);&#125;, <span class="number">1000</span>);&#125;);</span><br><span class="line">   p.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(value);&#125;, <span class="function"><span class="params">reason</span>=&gt;</span>&#123;<span class="built_in">console</span>.warn(reason);&#125;);</span><br><span class="line">   p.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123; alert(value);&#125;, <span class="function"><span class="params">reason</span>=&gt;</span>&#123; alert(reason);&#125;);</span><br><span class="line">   <span class="built_in">console</span>.log(p);</span><br><span class="line"></span><br><span class="line">promise.js修改与实现-----------------------------------------------------</span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">       <span class="comment">//resolve 函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  .....</span><br><span class="line">        <span class="comment">//调用成功的回调函数</span></span><br><span class="line">        <span class="comment">// if (self.callback.onResolved) &#123; self.callback.onResolved(data); &#125; </span></span><br><span class="line">        self.callbacks.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;   --------修改<span class="number">1</span></span><br><span class="line">            item.onResolved(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//reject 函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">      ......</span><br><span class="line">        <span class="comment">//执行失败的回调</span></span><br><span class="line">        <span class="comment">// if (self.callback.onResolved) &#123; self.callback.onResolved(data);&#125;</span></span><br><span class="line">        self.callbacks.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;------修改<span class="number">2</span></span><br><span class="line">            item.onRejected(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//添加 then 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onResolved, onRejected</span>)</span>&#123;</span><br><span class="line">    ........</span><br><span class="line">    <span class="comment">//判断 pending 状态</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.PromiseState === <span class="string">&#x27;pending&#x27;</span>)&#123;</span><br><span class="line">        <span class="comment">//保存回调函数</span></span><br><span class="line">        <span class="comment">//  this.callback = &#123; onResolved: onResolved, onRejected: onRejected &#125;</span></span><br><span class="line">        <span class="built_in">this</span>.callbacks.push(&#123;--------修改<span class="number">3</span></span><br><span class="line">            <span class="attr">onResolved</span>: onResolved,</span><br><span class="line">            <span class="attr">onRejected</span>: onRejected</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同步任务-then-返回结果"><a href="#同步任务-then-返回结果" class="headerlink" title="同步任务 then 返回结果"></a>同步任务 then 返回结果</h3><blockquote><ol><li><p>在之前的then运行结果中得知,我们使用  [ then ] 后的返回结果是其回调函数的返回结果,而我们需要的返回结果是一个新的promise对象</p><p>解:所以我们在then中<code>return new Promise()</code>,使其得到的是一个新的promise对象</p></li><li><p>在为<code>解决问题1</code>后产生一个新问题:新的promise对象因为没有用<code>rejerect与resolve</code>方法,导致返回的状态一直是<code>pending</code></p><p>解:在新的promise中判断<code>运行回调函数</code>后的返回值是什么,然后根据其不同类型给其赋予不同状态</p><p>​    Ⅰ-<code>if(result instanceof Promise)</code>:返回值一个新的②promise对象(因为是新的promise的回调函数返回值,称<code>②promise对象</code>),在返回值(因为是promise对象)的<code>.then()</code>回调函数中使用rejerect与resolve方法,将其<code>自身的状态</code>赋予外层的promise,</p><p>​    即 回调函数中的promise 赋值 给then返回值 ,  所以 <code>最终返回状态==回调函数中的新promise状态</code></p><p>​    Ⅱ-如果返回值是一个<code>非promise</code>对象,返回状态设置为成功</p><p>​    Ⅲ-如果返回值是一个异常,返回状态设置为失败</p></li></ol></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">html调用------------------------------------------------------------</span><br><span class="line">  <span class="comment">//实例化对象</span></span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;resolve(<span class="string">&#x27;OK&#x27;</span>);&#125;);</span><br><span class="line">    <span class="comment">//执行 then 方法</span></span><br><span class="line">    <span class="keyword">const</span> res = p.then(</span><br><span class="line">     <span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="keyword">throw</span> <span class="string">&quot;FAIL&quot;</span>;&#125;,</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> &#123; <span class="built_in">console</span>.warn(reason);&#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line"></span><br><span class="line">promise.js修改与实现-----------------------------------------------------</span><br><span class="line"><span class="comment">//添加 then 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onResolved, onRejected</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//调用回调函数  PromiseState</span></span><br><span class="line"> <span class="comment">//  if(this.PromiseState === &#x27;fulfilled&#x27;)&#123; onResolved(this.PromiseResult);&#125; 未修改时代码</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.PromiseState === <span class="string">&#x27;fulfilled&#x27;</span>)&#123;    -------修改<span class="number">1</span> </span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//获取回调函数的执行结果</span></span><br><span class="line">                <span class="keyword">let</span> result = onResolved(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">                <span class="comment">//判断</span></span><br><span class="line">                <span class="keyword">if</span>(result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)&#123;<span class="comment">//如果是 Promise 类型的对象,我就将下一个promise结果赋予外层</span></span><br><span class="line">                    result.then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;  resolve(v); &#125;,<span class="function"><span class="params">r</span>=&gt;</span>&#123;reject(r);&#125;)</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;resolve(result);&#125;  <span class="comment">//如果返回的不是promise对象,都将其赋予成功状态</span></span><br><span class="line">            &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">                rejerect(e);<span class="comment">//如果出错了,则返回失败状态</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.PromiseState === <span class="string">&#x27;rejected&#x27;</span>)&#123; onRejected(<span class="built_in">this</span>.PromiseResult);&#125;------此部分修改与修改<span class="number">1</span>一样</span><br><span class="line">        <span class="comment">//判断 pending 状态</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.PromiseState === <span class="string">&#x27;pending&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.callbacks.push(&#123; <span class="attr">onResolved</span>: onResolved, <span class="attr">onRejected</span>: onRejected&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步任务-then-返回结果"><a href="#异步任务-then-返回结果" class="headerlink" title="异步任务 then 返回结果"></a>异步任务 then 返回结果</h3><blockquote><ol><li><p>异步任务是修改<code>if(this.PromiseState === &#39;pending&#39;)</code>后面的值,原因参考<code>6</code>,下面代码只举例这部分修改</p></li><li><p>因为我们需要增加then状态修改,所以在我们保存回调函数这一步我们可以对于回调函数进行<code>加工</code>,<code>添加判断其回调函数的返回值</code>的代码块再存入实例的回调函数中</p><p>Ⅰ-声明一个新的函数:其内部功能-&gt;先运行<code>onResolved回调函数</code>,再将其返回值取出,进行判断其返回值(这个过程同<code>8</code>)</p><p>Ⅱ-加工后存入实例回调函数数组,之后在<code>resolve与reject</code>方法中调用即可(同<code>6</code>)</p></li></ol></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">html调用------------------------------------------------------------</span><br><span class="line">   <span class="comment">//实例化对象</span></span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;reject(<span class="string">&quot;Error&quot;</span>);&#125;, <span class="number">1000</span>)&#125;); <span class="comment">// resolve(&#x27;OK&#x27;);</span></span><br><span class="line">    <span class="comment">//执行 then 方法</span></span><br><span class="line">    <span class="keyword">const</span> res = p.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// return &#x27;oh Yeah&#x27;;  //如果有返回,根据其返回值得到相应的状态:字符串为成功,抛出为错误</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&#x27;error&#x27;</span>;</span><br><span class="line">    &#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.warn(reason, <span class="string">&quot;xx&quot;</span>); <span class="comment">//如果只是打印没返回,则实际上时返回一个undefined,</span></span><br><span class="line">      <span class="comment">//在我们封装js中,undefined会判定为非promise对象,所以状态为成功,结果为undefined</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;sss&quot;</span>   <span class="comment">// throw &#x27;error&#x27;;</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line"></span><br><span class="line">promise.js修改与实现-----------------------------------------------------</span><br><span class="line">    <span class="comment">//判断 pending 状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">//保存回调函数</span></span><br><span class="line">      <span class="built_in">this</span>.callbacks.push(&#123;</span><br><span class="line">          </span><br><span class="line">        <span class="attr">onResolved</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//执行成功回调函数</span></span><br><span class="line">            <span class="keyword">let</span> result = onResolved(self.PromiseResult);</span><br><span class="line">            <span class="comment">//判断 其结果</span></span><br><span class="line">            <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">              result.then(</span><br><span class="line">                  <span class="function"><span class="params">v</span> =&gt;</span> &#123; resolve(v);&#125;,</span><br><span class="line">                  <span class="function"><span class="params">r</span> =&gt;</span> &#123;reject(r);&#125;</span><br><span class="line">                 )</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;resolve(result);&#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;reject(e);&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">          </span><br><span class="line">        <span class="attr">onRejected</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//执行成功回调函数</span></span><br><span class="line">            <span class="keyword">let</span> result = onRejected(self.PromiseResult);</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">              result.then(</span><br><span class="line">                  <span class="function"><span class="params">v</span> =&gt;</span> &#123;resolve(v); &#125;,</span><br><span class="line">                  <span class="function"><span class="params">r</span> =&gt;</span> &#123;reject(r);&#125;</span><br><span class="line">                 )</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;resolve(result);&#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123; reject(e); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="then方法代码优化"><a href="#then方法代码优化" class="headerlink" title="then方法代码优化"></a>then方法代码优化</h3><blockquote><ol><li>在8、9、10中可以看出,其判断与改变返回结果状态的代码块是基本重复的,所以可以将其抽出</li></ol></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加 then 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    封装函数----------------------------------------------------------------------------</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取回调函数的执行结果</span></span><br><span class="line">        <span class="keyword">let</span> result = type(self.PromiseResult);</span><br><span class="line">        <span class="comment">//判断</span></span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">          <span class="comment">//如果是 Promise 类型的对象</span></span><br><span class="line">          result.then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(v);</span><br><span class="line">          &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">            reject(r);</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//结果的对象状态为『成功』</span></span><br><span class="line">          resolve(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  -----------------------------------------------------------------------------------    </span><br><span class="line">    <span class="comment">//调用回调函数  PromiseState</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === <span class="string">&#x27;fulfilled&#x27;</span>) &#123;</span><br><span class="line">      callback(onResolved);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">      callback(onRejected);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断 pending 状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">//保存回调函数</span></span><br><span class="line">      <span class="built_in">this</span>.callbacks.push(&#123;</span><br><span class="line">        <span class="attr">onResolved</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          callback(onResolved);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onRejected</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          callback(onRejected);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="catch-方法与异常穿透与值传递"><a href="#catch-方法与异常穿透与值传递" class="headerlink" title="catch 方法与异常穿透与值传递"></a>catch 方法与异常穿透与值传递</h3><blockquote><ol><li><p>异常穿透:添加<code>catch 方法</code>,并且需要进行回调函数为<code>undefined的</code>处理</p></li><li><p>当我<code>then()</code>中只传一个回调或者不传回调函数时,运行代码会报错,因为运行时调用的回调函数是<code>undefined</code></p><p>解:进行回调函数判断,当其为空时,基于默认回调函数内容:<code>直接往外抛出</code>这样下方的<code>then() or catch()</code>就可以承接到异常或者值</p></li></ol></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">html调用------------------------------------------------------------  </span><br><span class="line"><span class="comment">//实例化对象</span></span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;resolve(<span class="string">&#x27;OK&#x27;</span>); &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//值传递</span></span><br><span class="line">    p.then()</span><br><span class="line">    .then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="number">222</span>);&#125;)</span><br><span class="line">      .then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="number">333</span>);&#125;)</span><br><span class="line">        .catch(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="built_in">console</span>.warn(reason);&#125;);</span><br><span class="line">promise.js修改与实现-----------------------------------------------------</span><br><span class="line"><span class="comment">//添加 then 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">...-----------修改<span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected !== <span class="string">&#x27;function&#x27;</span>) &#123;onRejected = <span class="function"><span class="params">reason</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason;&#125;&#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> onResolved !== <span class="string">&#x27;function&#x27;</span>) &#123; onResolved = <span class="function"><span class="params">value</span> =&gt;</span> value;&#125;</span><br><span class="line"> ....</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加 catch 方法  </span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.catch = <span class="function"><span class="keyword">function</span>(<span class="params">onRejected</span>)</span>&#123;  ---------------异常穿透 修改<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, onRejected);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise的静态方法实现"><a href="#Promise的静态方法实现" class="headerlink" title="Promise的静态方法实现"></a>Promise的静态方法实现</h2><h3 id="Promise-resolve-封装"><a href="#Promise-resolve-封装" class="headerlink" title="Promise.resolve 封装"></a>Promise.resolve 封装</h3><blockquote><ol><li><p>判断传入的参数是否为<code>promise对象</code>:</p><p>Ⅰ-如果为<code>promise</code>:将其状态与结果赋值给外层promise对象</p><p>Ⅱ-如果为<code>非promise</code>:状态设置为成功</p></li></ol></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">html调用------------------------------------------------------------  </span><br><span class="line"> <span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line"> <span class="keyword">const</span> p2 = <span class="built_in">Promise</span>.resolve(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;     </span><br><span class="line">      reject(<span class="string">&quot;error&quot;</span>);<span class="comment">// resolve(&#x27;Success&#x27;);</span></span><br><span class="line">    &#125;));</span><br><span class="line"> <span class="keyword">const</span> p3 = <span class="built_in">Promise</span>.resolve(<span class="built_in">Promise</span>.resolve(<span class="string">&#x27;Oh Yeah&#x27;</span>));</span><br><span class="line"> <span class="built_in">console</span>.log(p3);</span><br><span class="line"></span><br><span class="line">promise.js修改与实现-----------------------------------------------------</span><br><span class="line"><span class="comment">//添加 resolve 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//返回promise对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)&#123;</span><br><span class="line">            value.then(</span><br><span class="line">                <span class="function"><span class="params">v</span>=&gt;</span>&#123;resolve(v);&#125;,</span><br><span class="line">                <span class="function"><span class="params">r</span>=&gt;</span>&#123;reject(r);&#125;</span><br><span class="line">            )&#125;<span class="keyword">else</span>&#123;resolve(value); &#125;<span class="comment">//状态设置为成功</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-resolve-封装-1"><a href="#Promise-resolve-封装-1" class="headerlink" title="Promise.resolve 封装"></a>Promise.resolve 封装</h3><blockquote><p>不同于resolve,这个方法只要把传入参数再次传出去,并将状态改为<code>失败</code>即可</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">html调用------------------------------------------------------------  </span><br><span class="line">   <span class="comment">//Promise.reject</span></span><br><span class="line">    <span class="keyword">const</span> p = <span class="built_in">Promise</span>.reject(<span class="string">&#x27;Error&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> p2 = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">    &#125;));</span><br><span class="line">    <span class="built_in">console</span>.log(p);</span><br><span class="line">    <span class="built_in">console</span>.log(p2);</span><br><span class="line"></span><br><span class="line">promise.js修改与实现-----------------------------------------------------</span><br><span class="line"><span class="comment">//添加 reject 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(reason);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-all-封装"><a href="#Promise-all-封装" class="headerlink" title="Promise.all 封装"></a>Promise.all 封装</h3><blockquote><ol><li>遍历传入的promise数组,每当遍历结果是成功,则用计数器记录,当计数器等同于数组长度,则全部成功,这时候可以返回<code>成功</code>状态</li><li>如果当数组中任意一个promise的执行结果是<code>reject</code>,直接中断,返回状态为<code>失败</code></li></ol></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">html调用------------------------------------------------------------  </span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;resolve(<span class="string">&#x27;OK&#x27;</span>); &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.reject(<span class="string">&#x27;Success&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;Oh Yeah&#x27;</span>);</span><br><span class="line">    <span class="comment">//调用 all 方法</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line"></span><br><span class="line">promise.js修改与实现-----------------------------------------------------</span><br><span class="line"><span class="comment">//添加 all 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//返回结果为promise对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//声明变量</span></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">      promises[i].then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//得知对象的状态是成功</span></span><br><span class="line">        <span class="comment">//每个promise对象 都成功</span></span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">//将当前promise对象成功的结果 存入到数组中</span></span><br><span class="line">        arr[i] = v;</span><br><span class="line">        <span class="comment">//判断</span></span><br><span class="line">        <span class="keyword">if</span> (count === promises.length) &#123;resolve(arr);&#125;<span class="comment">//修改状态</span></span><br><span class="line">      &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">        reject(r);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-race-封装"><a href="#Promise-race-封装" class="headerlink" title="Promise.race 封装"></a>Promise.race 封装</h3><blockquote><p>直接谁先执行就返回谁的运行结果即可</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">html调用------------------------------------------------------------  </span><br><span class="line"> <span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;resolve(<span class="string">&#x27;OK&#x27;</span>);&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.reject(<span class="string">&#x27;Success&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;Oh Yeah&#x27;</span>);</span><br><span class="line">    <span class="comment">//调用 race 方法</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line"></span><br><span class="line">promise.js修改与实现-----------------------------------------------------</span><br><span class="line"><span class="comment">//添加 race 方法</span></span><br><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">      promises[i].then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//修改返回对象的状态为 『成功』</span></span><br><span class="line">        resolve(v);</span><br><span class="line">      &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//修改返回对象的状态为 『失败』</span></span><br><span class="line">        reject(r);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h2><h3 id="回调函数『异步执行』"><a href="#回调函数『异步执行』" class="headerlink" title="回调函数『异步执行』"></a>回调函数『异步执行』</h3><blockquote><ol><li>如果我们运行下面代码,正确顺序是: 111 —&gt; 333 —&gt;444</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">111</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  p1.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">222</span>);</span><br><span class="line">  &#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">444</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">333</span>);</span><br></pre></td></tr></table></figure><ol><li><p>但当我们运行之前封装的 <strong>Promise</strong> 代码时,结果却是:111 —&gt; 444 —&gt; 333</p><p>我们需要将我们的then方法变成<code>异步方法</code></p></li><li><p>我们只要在以下四处地方的<code>回调函数调用</code>外层包裹一层定时器(不一定是定时器,开启异步即可),即可做到异步操作</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; self.callbacks.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123; item.onResolved(data); &#125;); &#125;);--修改<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">//reject 函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; self.callbacks.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123; item.onRejected(data); &#125;); &#125;);---修改<span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//添加 then 方法</span></span><br><span class="line">&gt;<span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onResolved, onRejected</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//调用回调函数  PromiseState</span></span><br><span class="line">     <span class="comment">/*  修改前代码</span></span><br><span class="line"><span class="comment">     if (this.PromiseState === &#x27;fulfilled&#x27;) &#123; callback(onResolved); &#125;</span></span><br><span class="line"><span class="comment"> if (this.PromiseState === &#x27;rejected&#x27;) &#123; callback(onRejected);</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">this</span>.PromiseState === <span class="string">&#x27;fulfilled&#x27;</span>)&#123;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; callback(onResolved);&#125;);&#125;  -----修改<span class="number">3</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">this</span>.PromiseState === <span class="string">&#x27;rejected&#x27;</span>)&#123; <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; callback(onRejected);&#125;);   ---修改<span class="number">4</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><code>相关原理参照js事件循环机制、宏任务与微任务</code></li></ol></blockquote><h3 id="class改写promise"><a href="#class改写promise" class="headerlink" title="class改写promise"></a>class改写promise</h3><blockquote><ol><li>其中将<code>self=this</code>保存this指向方式改为箭头函数表示(在上面示例中也有效果)</li><li>将其改为class写法</li><li>下面为promisedemo.js代码</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">  <span class="comment">//添加属性</span></span><br><span class="line">  <span class="built_in">this</span>.PromiseState = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.PromiseResult = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">//声明属性</span></span><br><span class="line">  <span class="built_in">this</span>.callbacks = [];</span><br><span class="line">  <span class="comment">//保存实例对象的 this 的值</span></span><br><span class="line">  <span class="comment">//resolve 函数</span></span><br><span class="line">  <span class="keyword">let</span> resolve = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//判断状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//1. 修改对象的状态 (promiseState)</span></span><br><span class="line">    <span class="built_in">this</span>.PromiseState = <span class="string">&#x27;fulfilled&#x27;</span>; <span class="comment">// resolved</span></span><br><span class="line">    <span class="comment">//2. 设置对象结果值 (promiseResult)</span></span><br><span class="line">    <span class="built_in">this</span>.PromiseResult = data;</span><br><span class="line">    <span class="comment">//调用成功的回调函数</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.callbacks.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        item.onResolved(data);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//reject 函数</span></span><br><span class="line">  <span class="keyword">let</span> reject = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//判断状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//1. 修改对象的状态 (promiseState)</span></span><br><span class="line">    <span class="built_in">this</span>.PromiseState = <span class="string">&#x27;rejected&#x27;</span>; <span class="comment">// </span></span><br><span class="line">    <span class="comment">//2. 设置对象结果值 (promiseResult)</span></span><br><span class="line">    <span class="built_in">this</span>.PromiseResult = data;</span><br><span class="line">    <span class="comment">//执行失败的回调</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.callbacks.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        item.onRejected(data);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//同步调用『执行器函数』</span></span><br><span class="line">    executor(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">//修改 promise 对象状态为『失败』</span></span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//then 方法封装</span></span><br><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onResolved, onRejected</span>)</span> &#123;</span><br><span class="line">  <span class="comment">//判断回调函数参数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    onRejected = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> reason;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> onResolved !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    onResolved = <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">    <span class="comment">//value =&gt; &#123; return value&#125;;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//封装函数</span></span><br><span class="line">    <span class="keyword">let</span> callback = <span class="function">(<span class="params">type</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取回调函数的执行结果</span></span><br><span class="line">        <span class="keyword">let</span> result = type(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">        <span class="comment">//判断</span></span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">          <span class="comment">//如果是 Promise 类型的对象</span></span><br><span class="line">          result.then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(v);</span><br><span class="line">          &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">            reject(r);</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//结果的对象状态为『成功』</span></span><br><span class="line">          resolve(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用回调函数  PromiseState</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === <span class="string">&#x27;fulfilled&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        callback(onResolved);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        callback(onRejected);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断 pending 状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">//保存回调函数</span></span><br><span class="line">      <span class="built_in">this</span>.callbacks.push(&#123;</span><br><span class="line">        <span class="attr">onResolved</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          callback(onResolved);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onRejected</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          callback(onRejected);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//catch 方法</span></span><br><span class="line"><span class="keyword">catch</span> (onRejected) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, onRejected);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加 resolve 方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">  <span class="comment">//返回promise对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">      value.then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(v);</span><br><span class="line">      &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">        reject(r);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//状态设置为成功</span></span><br><span class="line">      resolve(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加 reject 方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(reason);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加 all 方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">all</span>(<span class="params">promises</span>)</span> &#123;</span><br><span class="line">  <span class="comment">//返回结果为promise对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//声明变量</span></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      promises[i].then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//得知对象的状态是成功</span></span><br><span class="line">        <span class="comment">//每个promise对象 都成功</span></span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">//将当前promise对象成功的结果 存入到数组中</span></span><br><span class="line">        arr[i] = v;</span><br><span class="line">        <span class="comment">//判断</span></span><br><span class="line">        <span class="keyword">if</span> (count === promises.length) &#123;</span><br><span class="line">          <span class="comment">//修改状态</span></span><br><span class="line">          resolve(arr);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">        reject(r);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加 race 方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">race</span>(<span class="params">promises</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">      promises[i].then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//修改返回对象的状态为 『成功』</span></span><br><span class="line">        resolve(v);</span><br><span class="line">      &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//修改返回对象的状态为 『失败』</span></span><br><span class="line">        reject(r);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>html文件调用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">title</span>&gt;</span>class版本封装<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./promisedemo.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">&gt;<span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// resolve(&quot;OK&quot;);</span></span></span><br><span class="line"><span class="javascript">  reject(<span class="string">&quot;Erosssr&quot;</span>);</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript">&gt;&#125;);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">&gt;p1.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(value);</span></span><br><span class="line"><span class="javascript">&gt;&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.warn(reason);</span></span><br><span class="line"><span class="javascript">&gt;&#125;);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">&gt;<span class="built_in">console</span>.log(<span class="built_in">Promise</span>.resolve(<span class="string">&#x27;OK&#x27;</span>));</span></span><br><span class="line"><span class="javascript">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h1 id="Promise-async-await"><a href="#Promise-async-await" class="headerlink" title="Promise+ async + await"></a>Promise+ async + await</h1><blockquote><h5 id="1-Promise-gt-异步"><a href="#1-Promise-gt-异步" class="headerlink" title="1)Promise==&gt;异步"></a>1)Promise==&gt;异步</h5><h5 id="2-await-gt-异步转同步"><a href="#2-await-gt-异步转同步" class="headerlink" title="2)await==&gt;异步转同步"></a>2)await==&gt;异步转同步</h5><ol><li>await 可以理解为是 async wait 的简写。await 必须出现在 async 函数内部，不能单独使用。</li><li>await 后面可以跟任何的JS 表达式。虽然说 await 可以等很多类型的东西，但是它最主要的意图是用来等待 Promise 对象的状态被 resolved。如果await的是 promise对象会造成异步函数停止执行并且等待 promise 的解决,如果等的是正常的表达式则立即执行        </li></ol><h5 id="3-async-gt-同步转异步"><a href="#3-async-gt-同步转异步" class="headerlink" title="3)async==&gt;同步转异步"></a>3)async==&gt;同步转异步</h5><ol><li>方法体内部的某个表达式使用await修饰，那么这个方法体所属方法必须要用async修饰所以使用awit方法会自动升级为异步方法</li></ol><h6 id="4-mdn文档"><a href="#4-mdn文档" class="headerlink" title="4)mdn文档"></a>4)mdn文档</h6><ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function">async</a> </li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await">await</a></li></ol></blockquote><h2 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h2><blockquote><ol><li>函数的返回值为 promise 对象 </li><li>promise 对象的结果由 async 函数执行的返回值决定</li></ol></blockquote><h2 id="await表达式"><a href="#await表达式" class="headerlink" title="await表达式"></a>await表达式</h2><blockquote><ol><li><p>await 右侧的表达式<strong>一般为 promise 对象</strong>, 但也可以是其它的值 </p></li><li><p>如果表达式是 promise 对象, await 返回的是 promise <strong>成功</strong>的值 </p></li><li>如果表达式是其它值, 直接将此值作为 await 的返回值</li></ol></blockquote><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><blockquote><ol><li>await 必须写在 async 函数中, 但 async 函数中可以没有 await </li><li><strong>如果 await 的 promise 失败了, 就会抛出异常, 需要通过 try…catch 捕获处理</strong></li></ol></blockquote><h2 id="原作者对某些问题理解解答"><a href="#原作者对某些问题理解解答" class="headerlink" title="原作者对某些问题理解解答"></a>原作者对某些问题理解解答</h2><h3 id="如何在Promise外部使用Promise的结果"><a href="#如何在Promise外部使用Promise的结果" class="headerlink" title="如何在Promise外部使用Promise的结果"></a>如何在Promise外部使用Promise的结果</h3><blockquote><p>用到的本章节知识:</p><p>1、axios本质上就是一个promise,所以下面用定时器+Promise模拟axios,效果一样,可以将<code>new Promise(resolve =&gt; &#123;setTimeout(function() &#123; resolve(&quot;promise普通结果&quot;); &#125;, 1000); &#125;)</code>等价于<code>axios(&#123;&#125;)</code></p><p>2、resolve() 与reject()是修改Promise状态并往外抛出的,一个Promise只能改变一次状态,所以一个primise中只能调用一次</p><p>3、 上一步抛出后可以在下面 的.then()中获取到</p><p>Ⅰ-如果没有用.then(),则值会抛往Promise外部</p><p>Ⅱ-如果声明了.then(),则值会被.then()接住,放到里面处理,如果需要再次抛出—<code>某些业务场景需要</code> ,然后在下一个then()或者外部使用, 则可以 .then(v=&gt;return v) —-前提这个链式调用前曾使用过resolve() 与reject()才用return,不然就用这两个resolve() 与reject()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//讲解时写的简单demo</span></span><br><span class="line">&gt;<span class="keyword">let</span> resolveCommon = <span class="function">()=&gt;</span> &#123;</span><br><span class="line">&gt;<span class="keyword">let</span> result=<span class="string">&quot;普通promise初始值&quot;</span></span><br><span class="line">&gt;result=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; resolve(<span class="string">&quot;promise普通结果&quot;</span>); &#125;, <span class="number">1000</span>); &#125;)</span><br><span class="line">&gt;<span class="built_in">console</span>.log(result)</span><br><span class="line">&gt;<span class="comment">//打印结果: Promise &#123; &lt;pending&gt; &#125; </span></span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> resolveAsync=<span class="keyword">async</span> ()=&gt; &#123;</span><br><span class="line">&gt;<span class="keyword">let</span> result=<span class="string">&quot;await+async的promise初始值&quot;</span></span><br><span class="line">&gt;result=<span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123; <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; resolve(<span class="string">&quot;这是async+await结果&quot;</span>); &#125;, <span class="number">1000</span>);&#125;)</span><br><span class="line">&gt;<span class="built_in">console</span>.log(result)</span><br><span class="line">&gt;<span class="comment">//打印结果: 这是async+await结果  这里就是正确的值,你可以在下一步进行正常使用,也可以用在下一步的promise中</span></span><br><span class="line">&gt;<span class="comment">//------------------------------------------------------</span></span><br><span class="line">&gt;<span class="comment">//在第二个promise中调用使用</span></span><br><span class="line">&gt;<span class="keyword">let</span> result2=<span class="string">&quot;&quot;</span></span><br><span class="line">&gt;result2= <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123; <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; resolve(result+<span class="string">&quot;+经过第二个promise加工&quot;</span>); &#125;, <span class="number">1000</span>);&#125;)</span><br><span class="line">&gt;.then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">&gt;<span class="built_in">console</span>.log(<span class="string">&quot;第二个promise的then()中打印并返回:&quot;</span>,v)</span><br><span class="line">&gt;<span class="keyword">return</span> v+<span class="string">&quot;,经过then()加工返回&quot;</span></span><br><span class="line">&gt;&#125;)</span><br><span class="line">&gt;<span class="built_in">console</span>.log(<span class="string">&quot;最终结果:第二个promise外部结果打印,&quot;</span>,result2)</span><br><span class="line">&gt;<span class="comment">//---------------------------------------------</span></span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;resolveCommon()  <span class="comment">//调用普通promise函数</span></span><br><span class="line">&gt;resolveAsync()    <span class="comment">//调用await+async</span></span><br><span class="line">&gt;<span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;运行结果</span></span><br><span class="line"><span class="comment">&gt;1.resolveCommon() 运行结果:    Promise &#123; &lt;pending&gt; &#125;</span></span><br><span class="line"><span class="comment">&gt;2.resolveAsync() 运行结果:     </span></span><br><span class="line"><span class="comment">&gt;这是async+await结果</span></span><br><span class="line"><span class="comment">&gt;第二个promise的then()中打印并返回: 这是async+await结果+经过第二个promise加工</span></span><br><span class="line"><span class="comment">&gt;最终结果:第二个promise外部结果打印, 这是async+await结果+经过第二个promise加工,经过then()加工返回</span></span><br><span class="line"><span class="comment">&gt;*/</span></span><br></pre></td></tr></table></figure><p>原因解析:</p><ol><li><p>new Promise()是一个异步任务,会加到异步队列中,而正常运行比如console.log()是同步运行的(即从上往下运行),会加到同步队列 </p><p>所以 Promise()通常是会在同一等级的同步任务之后才得到结果的 所以你得到的是一个挂起的 Promise { <pending> } 对象</pending></p></li><li><p>而await则是让跟在后面的异步任务转为同步任务(效果如此,就通俗来讲,具体概念需要自学),所以result就能得到一个已经修改状态为成功或者失败的值</p><p>所以下面的任务就可以使用到这个值</p></li><li><p>为什么这些操作要放在同一个async fn()=&gt;{} 中?</p></li></ol><p>1)Promise==&gt;异步</p><p>2)await==&gt;异步转同步</p><ol><li><p>await 可以理解为是 async wait 的简写。await 必须出现在 async 函数内部，不能单独使用。</p></li><li><p>await 后面可以跟任何的JS 表达式。虽然说 await 可以等很多类型的东西，但是它最主要的意图是用来等待 Promise 对象的状态被 resolved。如果await的是 promise对象会造成异步函数停止执行并且等待 promise 的解决,如果等的是正常的表达式则立即执行  </p></li></ol><p>3)async==&gt;同步转异步</p><p> 方法体内部的某个表达式使用await修饰，那么这个方法体所属方法必须要用async修饰所以使用awit方法会自动升级为异步方法</p></blockquote><h1 id="宏任务与微任务"><a href="#宏任务与微任务" class="headerlink" title="宏任务与微任务"></a>宏任务与微任务</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><blockquote><p>原理图:</p><p><img src="/promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index/6.png"></p><p>说明:</p><ol><li><p>JS中用来存储待执行回调函数的队列包含2个不同特定的列队</p><ul><li><code>宏队列</code>:用来保存待执行的宏任务(回调),比如:<code>定时器</code>回调/ajax回调/dom事件回调</li><li><code>微队列</code>:用来保存待执行的微任务(回调),比如:<code>Promise</code>的回调/muntation回调</li></ul></li><li><p>JS执行时会区别这2个队列:</p><ul><li>JS执行引擎首先必须执行所有的<code>初始化同步任务</code>代码</li><li>每次准备取出第一个<code>宏任务执行前</code>,都要将所有的<code>微任务</code>一个一个取出来执行</li><li><strong>同步任务</strong> —&gt; <strong>微任务</strong> —&gt; <strong>宏任务</strong></li></ul></li></ol></blockquote><h2 id="Ⅱ-代码与示例"><a href="#Ⅱ-代码与示例" class="headerlink" title="Ⅱ-代码与示例"></a>Ⅱ-代码与示例</h2><blockquote><p>你需要一些栗子来帮助验证自己的想法是否正确,尽量先不看结果去自己思考下打印结果顺序</p></blockquote><h3 id="1、代码示例"><a href="#1、代码示例" class="headerlink" title="1、代码示例:"></a>1、代码示例:</h3><h4 id="a-首先给出注释的栗子举一个"><a href="#a-首先给出注释的栗子举一个" class="headerlink" title="a) 首先给出注释的栗子举一个"></a>a) 首先给出注释的栗子举一个</h4><blockquote><p>此处会给出每个打印放入什么队列,加深你的印象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&#x27;timeout callback1（）&#x27;</span>) <span class="comment">//立即放入宏队列</span></span><br><span class="line">     <span class="built_in">Promise</span>.resolve(<span class="number">3</span>).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&#x27;Promise onResolved3()&#x27;</span>, value) <span class="comment">//当这个宏任务执行后 立马放入微队列,所以这个微任务执行完后下个宏任务才能执行</span></span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;, <span class="number">0</span>)</span><br><span class="line">   </span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timeout callback2（）&#x27;</span>) <span class="comment">//立即放入宏队列,</span></span><br><span class="line"> &#125;, <span class="number">0</span>)</span><br><span class="line">   </span><br><span class="line"> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Promise onResolved1()&#x27;</span>, value) <span class="comment">//立即放入微队列</span></span><br><span class="line">   <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&#x27;timeout callback3（）&#x27;</span>, value) <span class="comment">//立即放入宏任务</span></span><br><span class="line">     &#125;, <span class="number">0</span>)</span><br><span class="line">   &#125;)</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">Promise</span>.resolve(<span class="number">2</span>).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&#x27;Promise onResolved2()&#x27;</span>, value) <span class="comment">//立即放入微队列</span></span><br><span class="line"> &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;同步代码&#x27;</span>) <span class="comment">//同步代码立即执行</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>   结果放在下方,就怕你不小心瞄到</p></blockquote><h4 id="b-尝试自己思考下"><a href="#b-尝试自己思考下" class="headerlink" title="b) 尝试自己思考下"></a>b) 尝试自己思考下</h4><blockquote><p>尝试自己脑海中用自己理解 ‘运行’ 一下, 然后把结果写下来,再去下面结果做对比</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;代码开始执行&#x27;</span>), <span class="number">0</span>)</span><br><span class="line">&gt;<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;开始for循环&#x27;</span>)</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">   i == <span class="number">99</span> &amp;&amp; resolve()</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;).then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;执行then函数&#x27;</span>))</span><br><span class="line">&gt;<span class="built_in">console</span>.log(<span class="string">&#x27;代码执行结束&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h3 id="2、示例结果"><a href="#2、示例结果" class="headerlink" title="2、示例结果:"></a>2、示例结果:</h3><h4 id="a-第一个栗子的结果"><a href="#a-第一个栗子的结果" class="headerlink" title="a) 第一个栗子的结果"></a>a) 第一个栗子的结果</h4><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&#x27;同步代码&#x27;</span>,</span><br><span class="line">&gt;<span class="string">&#x27;Promise onResolved1()&#x27;</span>,</span><br><span class="line">&gt;<span class="string">&#x27;Promise onResolved2()&#x27;</span>,</span><br><span class="line">&gt;<span class="string">&#x27;timeout callback1（）&#x27;</span>,</span><br><span class="line">&gt;<span class="string">&#x27;Promise onResolved3()&#x27;</span>,</span><br><span class="line">&gt;<span class="string">&#x27;timeout callback2（）&#x27;</span>,</span><br><span class="line">&gt;<span class="string">&#x27;timeout callback3（）&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="b-第二个栗子的结果"><a href="#b-第二个栗子的结果" class="headerlink" title="b) 第二个栗子的结果"></a>b) 第二个栗子的结果</h4><blockquote><p><img src="/promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index/7.png"></p><p>PS: 可以忽略<code>undefined</code>这个打印结果, 因为这会加重我们对于宏任务与微任务的理解负担.</p><p>当然人都是会好奇的,没有打破砂锅问到底的精神呢也当不了一个好程序员,那我就在下方额外给出解释</p></blockquote><h1 id="五、对浏览器console控制台输出undefined的分析"><a href="#五、对浏览器console控制台输出undefined的分析" class="headerlink" title="五、对浏览器console控制台输出undefined的分析"></a>五、对浏览器console控制台输出undefined的分析</h1><h2 id="Ⅰ-出现场景"><a href="#Ⅰ-出现场景" class="headerlink" title="Ⅰ- 出现场景"></a>Ⅰ- 出现场景</h2><blockquote><p><img src="/promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index/8.png"></p></blockquote><h2 id="Ⅱ-尝试输入其他内容进行分析"><a href="#Ⅱ-尝试输入其他内容进行分析" class="headerlink" title="Ⅱ - 尝试输入其他内容进行分析"></a>Ⅱ - 尝试输入其他内容进行分析</h2><blockquote><p><img src="/promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index/9.png"></p><p>那么做个合理推测: 应该是在控制台输入的内容,它的 <code>返回值</code> 会显示出来,这让我们不禁想到JS的 [ <strong>eval()</strong> ]</p></blockquote><h2 id="Ⅲ-eval（string）"><a href="#Ⅲ-eval（string）" class="headerlink" title="Ⅲ - eval（string）"></a>Ⅲ - eval（string）</h2><blockquote><p>其作用是将 接收的 string 字符串作为参数，对其进行JavaScript 表达式或语句 计算，返回得到的值；</p><p>如果是没有返回值的表达式或语句，则会返回 undefined ；</p><p>如果没有合法的表达式和语句，则会抛出 SyntaxError 异常 。</p><p>于是我们可以猜测Console控制台的实质 就是 调用了eval（）函数</p></blockquote><h2 id="Ⅳ-验证一下"><a href="#Ⅳ-验证一下" class="headerlink" title="Ⅳ - 验证一下"></a>Ⅳ - 验证一下</h2><blockquote><p><img src="/promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index/10.png"></p><p>大家都是聪明人,看到这个结果应该就不用我组织语言来解释了吧 </p></blockquote><h2 id="Ⅴ-分析其在宏任务与微任务的打印顺序"><a href="#Ⅴ-分析其在宏任务与微任务的打印顺序" class="headerlink" title="Ⅴ -  分析其在宏任务与微任务的打印顺序"></a>Ⅴ -  分析其在宏任务与微任务的打印顺序</h2><blockquote><p>首先看图:<img src="/promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index/MyFile\Blog\source\_posts\7.png"></p><p>可以看到 [ undefined ] 实在微任务完成后,宏任务执行前 打印</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Nginx学习笔记</title>
      <link href="/nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"/>
      <url>/nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx-简介"><a href="#Nginx-简介" class="headerlink" title="Nginx 简介"></a>Nginx 简介</h1><h2 id="Nginx概述"><a href="#Nginx概述" class="headerlink" title="Nginx概述"></a>Nginx概述</h2><p>Nginx (“engine x”)是一个高性能的 HTTP 和反向代理服务器 特点是占有内存少，并发能力强，事实上 nginx 的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用 nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等</p><h2 id="Nginx-作为-web-服务器"><a href="#Nginx-作为-web-服务器" class="headerlink" title="Nginx 作为 web 服务器"></a>Nginx 作为 web 服务器</h2><p>Nginx可以作为静态页面的 web 服务器，同时还支持 CGI 协议的动态语言，比如 pe rl 、 php等。但是不支持 java 。 Java 程序只能通过与 tomcat 配合完成。 Nginx 专为性能优化而开发，性能是其最重要的考量 实现上非常注重效率 ，能经受高负载的考验 有报告表明能支持高达 50,000 个并发连接数。</p><p><a href="https://lnmp.org/nginx.html">https://lnmp.org/nginx.html</a></p><h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><p>Nginx不仅可以做反向代理，实现负载均衡。还能用作正向代理来进行上网等功能。</p><p>正向代理：如果把局域网外的Internet 想象成一个巨大的资源库，则局域网中的客户端要访问 Internet ，则需要通过代理服务器来访问，这种代理服务就称为正向代理。</p><p><img src="/nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index/1.jpg"></p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器 IP 地址。</p><p><img src="/nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index/2.jpg"></p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>客户端发送多个请求到服务器，服务器处理请求，有一些可能要与数据库进行交互，服务器处理完毕后，再将结果返回给客户端。 这种架构模式对于早期的系统相对单一，并发请求相对较少的情况下是比较适合的，成本也低。但是随着信息数量的不断增长，访问量和数据量的飞速增长，以及系统业务的复杂度增加，这种架构会造成服务器相应客户端的请求日益缓慢，并发量特别大的时候，还容易造成服务器直接崩溃。很明显这是由于服务器性能的瓶颈造成的问题，那么如何解决这种情况呢？ </p><p>我们首先想到的可能是升级服务器的配置，比如提高CPU执行频率，加大内存等提高机器的物理性能来解决此问题，但是我们知道摩尔定律的日益失效，硬件的性能提升已经不能满足日益提升的需求了。最明显的一个例子，天猫双十一当天，某个热销商品的瞬时访问量是极其庞大的，那么类似上面的系统架构，将机器都增加到现有的顶级物理配置，都是不能够满足需求的。那么怎么办呢？ </p><p>上面的分析我们去掉了增加服务器物理配置来解决问题的办法，也就是说纵向解决问题的办法行不通了，那么横向增加服务器的数量呢？这时候集群的概念产生了，单个服务器解决不了，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的<strong>负载均衡</strong></p><p><img src="/nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index/3.jpg"></p><h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><p>为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。</p><p><img src="/nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index/4.jpg"></p><h1 id="Nginx-安装"><a href="#Nginx-安装" class="headerlink" title="Nginx 安装"></a>Nginx 安装</h1><h2 id="进入-nginx-官网，下载"><a href="#进入-nginx-官网，下载" class="headerlink" title="进入 nginx 官网，下载"></a>进入 nginx 官网，下载</h2><p><a href="http://nginx.org/">http://nginx.org/</a></p><p><img src="/nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index/5.jpg"></p><h2 id="安装-nginx"><a href="#安装-nginx" class="headerlink" title="安装 nginx"></a>安装 nginx</h2><p><strong>第一步，安装 pcre</strong><br><code>wget http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre8.37.tar.gz</code></p><p>解压文件，<br><code>./configure</code>完成后，回到 pcre 目录下执行 <code>make</code><br>再执行<br><code>make install</code></p><p><strong>第二步，安装 openssl</strong><br><strong>第三步，安装 zlib</strong><br><code>yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel</code></p><p><strong>第四步,安装 nginx</strong></p><ol><li><p>解压缩 nginx xx.tar.gz 包。</p></li><li><p>进入解压缩目录 执行 ./configure 。</p></li><li><p>make &amp;&amp; make install</p></li></ol><p><strong>查看开放的端口号</strong><br><code>firewall-cmd --list all</code><br><strong>设置开放的端口号</strong><br><code>firewall-cmd --add-service=http --permanent</code><br><code>sudo firewall-cmd --add -port=80/tcp --permanent</code><br><strong>重启防火墙</strong><br><code>firewall-cmd --reload</code></p><h1 id="nginx-常用的命令和配置文件"><a href="#nginx-常用的命令和配置文件" class="headerlink" title="nginx 常用的命令和配置文件"></a>nginx 常用的命令和配置文件</h1><h2 id="nginx-常用的命令"><a href="#nginx-常用的命令" class="headerlink" title="nginx 常用的命令"></a>nginx 常用的命令</h2><ul><li><p><strong>启动命令</strong></p><p>在<code>/usr/local/nginx/sbin</code> 目录下执行 <code>./nginx</code></p></li><li><p><strong>关闭命令</strong><br>在<code>/usr/local/nginx/sbin</code> 目录下执行 <code>./nginx -s stop</code></p></li><li><p><strong>重新加载命令</strong><br>在<code>/usr/local/nginx/sbin</code> 目录下执行 <code>./nginx -s reload</code></p></li></ul><h2 id="nginx-conf-配置文件"><a href="#nginx-conf-配置文件" class="headerlink" title="nginx.conf 配置文件"></a>nginx.conf 配置文件</h2><p>nginx 安装目录下，其默认的配置文件都放在这个目录的 conf 目录下，而 主配置文件 nginx.conf 也在其中，后续对 nginx 的使用基本上都是对此配置文件进行相应的修改</p><p><img src="/nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index/6.jpg"></p><p>配置文件中有很多 开头的表示注释内容，我们去掉所有以 # 开头的段落，精简之后的内容如下：</p><p><img src="/nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index/7.jpg"></p><p>根据上述文件，我们可以很明显的将 nginx.conf 配置文件分为<strong>三部分</strong>：</p><h3 id="第一部分：全局块"><a href="#第一部分：全局块" class="headerlink" title="第一部分：全局块"></a><strong>第一部分：全局块</strong></h3><p>从配置文件开始到 events 块之间的内容，主要会设置一些影响nginx 服务器整体运行的配置指令，主要包括配置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以及配置文件的引入等。 比如上面第一行配置的：</p><p><img src="/nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index/8.jpg"></p><p>这是 Nginx 服务器并发处理服务的关键配置，worker_processes 值越大，可以支持的并发处理量也越多，但是会受到硬件、软件等设备的制约</p><h3 id="第二部分：events块"><a href="#第二部分：events块" class="headerlink" title="第二部分：events块"></a><strong>第二部分：events块</strong></h3><p>比如上面的配置：</p><p><img src="/nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index/9.jpg"></p><p>events 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word process 可以同时支持的最大连接数等。 </p><p>上述例子就表示每个 work process 支持的最大连接数为 1024. </p><p>这部分的配置对 Nginx 的性能影响较大，在实际中应该灵活配置。</p><h3 id="第三部分：http块"><a href="#第三部分：http块" class="headerlink" title="第三部分：http块"></a><strong>第三部分：http块</strong></h3><p><img src="/nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index/10.jpg"></p><p>这算是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。 需要注意的是：http 块也可以包括 <strong>http全局块、server 块</strong>。</p><p><strong>http 全局块</strong><br>http全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。</p><p><strong>server 块</strong><br>这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。 </p><p>每个 http 块可以<strong>包括多个 server 块</strong>，而每个 server 块就相当于一个虚拟主机。 </p><p>而每个 server 块也分为全局 server 块，以及可以同时<strong>包含多个 locaton 块</strong>。</p><ul><li><strong>全局 server 块</strong> </li></ul><p>最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或IP配置。 </p><ul><li><strong>location 块</strong></li></ul><p>一个 server 块可以配置多个 location 块。 这块的主要作用是基于 Nginx 服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟主机名称（也可以是IP别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。</p><h1 id="nginx-配置实例-反向代理"><a href="#nginx-配置实例-反向代理" class="headerlink" title="nginx 配置实例 反向代理"></a>nginx 配置实例 反向代理</h1><h2 id="反向代理实例一"><a href="#反向代理实例一" class="headerlink" title="反向代理实例一"></a>反向代理实例一</h2><p><strong>实现效果</strong>：使用 n ginx 反向代理，访问 www 123 com 直接跳转到 127.0.0.1:8080</p><h3 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h3><ol><li>启动一个 tomcat ，浏览器地址栏输入 127.0.0.1:8080 ，出现如下界面</li></ol><p><img src="/nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index/11.jpg"></p><ol><li><p>通过修改本地 host 文件，将 www. 123 .com 映射到 127.0.0.1</p><p><img src="/nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index/12.jpg"></p></li></ol><p>配置完成之后，我们便可以通过<code>www.123.com:8080</code> 访问到第一步出现的 Tomcat初始界面。那么如何只需要输入<code>www.123.com</code>便可以跳转到 Tomcat初始界面呢？便用到 nginx的反向代理。</p><ol><li><p>在 <code>nginx.conf</code>配置文件中增加如下配置</p><p><img src="/nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index/13.jpg"></p></li></ol><p>如上配置，我们监听80端口，访问域名为www.123.com，不加端口号时默认为80端口，故访问该域名时会跳转到127.0.0.1:8080路径上。在浏览器端输入 www.123.com 结果如下：</p><p><img src="/nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index/14.jpg"></p><h2 id="反向代理实例二"><a href="#反向代理实例二" class="headerlink" title="反向代理实例二"></a>反向代理实例二</h2><p><strong>实现效果：</strong>使用 nginx 反向代理， 根据访问的路径跳转到不同端口的服务中<br>nginx 监听端口为 9001<br>访问 <a href="http://127.0.0.1:9001/edu/">http://127.0.0.1:9001/edu/</a> 直接跳转到 127.0.0.1:8081<br>访问 <a href="http://127.0.0.1:9001/vod/">http://127.0.0.1:9001/vod/</a> 直接跳转到 127.0.0.1:8082</p><h3 id="实验代码-1"><a href="#实验代码-1" class="headerlink" title="实验代码"></a>实验代码</h3><p>第一步，准备两个 tomcat ，一个 8001 端口，一个 8002 端口，并准备好测试的页面<br>第二步，修改 nginx 的配置文件<br>在<strong>http 块</strong>中添加 server{}<br><img src="/nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index/15.jpg"></p><p>location 指令说明<br>该指令用于匹配 URL。 语法如下：</p><p><img src="/nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index/16.jpg"></p><p>1、= ：用于不含正则表达式的 uri 前，要求请求字符串与 uri 严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求。 </p><p>2、~：用于表示 uri 包含正则表达式，并且区分大小写。 </p><p>3、~*：用于表示 uri 包含正则表达式，并且不区分大小写。 </p><p>4、^~：用于不含正则表达式的 uri 前，要求 Nginx 服务器找到标识 uri 和请求字符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location 块中的正则 uri 和请求字符串做匹配。 </p><p><strong><em>注意：如果 url 包含正则表达式，则必须要有 ~ 或者 ~\</em> 标识。</strong></p><h1 id="nginx-配置实例-负载均衡"><a href="#nginx-配置实例-负载均衡" class="headerlink" title="nginx 配置实例 负载均衡"></a>nginx 配置实例 负载均衡</h1><p><strong>实现效果</strong>： 配置负载均衡</p><h2 id="实验代码-2"><a href="#实验代码-2" class="headerlink" title="实验代码"></a>实验代码</h2><ol><li>首先准备两个同时启动的 Tomcat</li><li>在 nginx.conf 中进行配置</li></ol><p><img src="/nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index/17.jpg"></p><p>随着互联网信息的爆炸性增长，负载均衡（load balance ）已经不再是一个很陌生的话题顾名思义，负载均衡即是将负载分摊到不同的服务单元，既保证服务的可用性，又保证响应足够快，给用户很好的体验。快速增长的访问量和数据流量催生了各式各样的负载均衡产品，很多专业的负载均衡硬件提供了很好的功能，但却价格不菲，这使得负载均衡软件大受欢迎，nginx 就是其中的一个，在 linux 下有 Nginx 、 LVS 、 Haproxy 等等服务可以提供负载均衡服务，而且 Nginx 提供了几种分配方式 策略:</p><p><strong>1、轮询（默认）</strong><br>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。<br><strong>2、weight</strong><br>weight代表权 重默认为 1, 权重越高被分配的客户端越多。指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 例如：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream server_pool&#123; </span><br><span class="line"><span class="built_in">server </span>192.168.5.21 <span class="attribute">weight</span>=10; </span><br><span class="line"><span class="built_in">server </span>192.168.5.22 <span class="attribute">weight</span>=10; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、ip_hash</strong><br>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 例如：</p><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream server_pool&#123; </span><br><span class="line"><span class="attribute">ip_hash; </span></span><br><span class="line"><span class="attribute">server 192.168.5.21</span>:80; </span><br><span class="line"><span class="attribute">server 192.168.5.22</span>:80; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4、fair（第三方）</strong></p><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream server_pool&#123; </span><br><span class="line"><span class="keyword">server</span> <span class="number">192.168</span><span class="number">.5</span><span class="number">.21</span>:<span class="number">80</span>; </span><br><span class="line"><span class="keyword">server</span> <span class="number">192.168</span><span class="number">.5</span><span class="number">.22</span>:<span class="number">80</span>; </span><br><span class="line">fair; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="nginx-配置实例-动静分离"><a href="#nginx-配置实例-动静分离" class="headerlink" title="nginx 配置实例 动静分离"></a>nginx 配置实例 动静分离</h1><p>Nginx 动静分离简单来说就是把动态跟静态请求分开，不能理解成只是单纯的把动态页面和静态页面物理分离。严格意义上说应该是动态请求跟静态请求分开，可以理解成使用Nginx 处理静态页面，Tomcat处理动态页面。</p><p>动静分离从目前实现角度来讲大致分为两种， </p><p>一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，<strong>也是目前主流推崇的方案</strong>；</p><p> 另外一种方法就是动态跟静态文件混合在一起发布，通过 nginx 来分开。 通过 location 指定不同的后缀名实现不同的请求转发。通过 expires 参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量。具体 Expires 定义：是给一个资源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。此种方法非常适合不经常变动的资源。（如果经常更新的文件，不建议使用 Expires 来缓存），我这里设置 3d，表示在这 3 天之内访问这个 URL，发送一个请求，比对服务器该文件最后更新时间没有变化，则不会从服务器抓取，返回状态码 304，如果有修改，则直接从服务器重新下载，返回状态码 200。</p><h2 id="实验代码-3"><a href="#实验代码-3" class="headerlink" title="实验代码"></a>实验代码</h2><ol><li><p>项目资源准备</p></li><li><p>进行 nginx 配置<br>找到 nginx 安装目录，打开 /conf/nginx.conf 配置文件，</p><p><img src="/nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index/18.jpg"></p></li></ol><p>添加监听端口、访问名字<br>重点是添加location,最后检查 Nginx 配置是否正确即可，然后测试动静分离是否成功，之需要删除后端 tomcat服务器上的某个静态文件，查看是否能访问，如果可以访问说明静态资源 nginx 直接返回了，不走后端 tomcat 服务器.</p>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AJAX学习笔记</title>
      <link href="/ajax%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"/>
      <url>/ajax%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html</url>
      
        <content type="html"><![CDATA[<p>本笔记是视频课程的笔记。<a href="https://www.bilibili.com/video/BV1WC4y1b78y">【尚硅谷】3小时AJAX入门到精通</a></p><p>笔记转载自<a href="https://gitee.com/hongjilin/hongs-study-notes/blob/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Ajax%E3%80%81Axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Ajax%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md">这里</a>,做了适当改动。</p><p>此部分知识为学习axios预备知识,预备知识链:ajax —&gt; promise —&gt; axios —&gt; react/vue</p><h1 id="Ajax简介"><a href="#Ajax简介" class="headerlink" title="Ajax简介"></a>Ajax简介</h1><blockquote><p>AJAX 简介 AJAX 全称为 Asynchronous JavaScript And XML，就是异步的 JS 和 XML。</p><p>通过 AJAX 可以在浏览器中向服务器发送异步请求，最大的优势：<code>无刷新获取数据</code>。</p><p>AJAX 不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式。</p></blockquote><h2 id="XML简介"><a href="#XML简介" class="headerlink" title="XML简介"></a>XML简介</h2><blockquote><ol><li>XML 可扩展标记语言。</li><li>XML 被设计用来传输和存储数据。</li><li>XML 和 HTML 类似，不同的是 HTML 中都是预定义标签，而 XML 中没有预定义标签， 全都是自定义标签，用来表示一些数据。</li></ol><p>比如说我有一个学生数据： name = “孙悟空” ; age = 18 ; gender = “男” ;</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">用 XML 表示：</span><br><span class="line"><span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>孙悟空<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">age</span>&gt;</span>18<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>现在已经被 JSON 取代了。</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;孙悟空&quot;</span>,<span class="attr">&quot;age&quot;</span>:<span class="number">18</span>,<span class="attr">&quot;gender&quot;</span>:<span class="string">&quot;男&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="Ajax的特点"><a href="#Ajax的特点" class="headerlink" title="Ajax的特点"></a>Ajax的特点</h2><h3 id="AJAX-的优点"><a href="#AJAX-的优点" class="headerlink" title="AJAX 的优点"></a>AJAX 的优点</h3><blockquote><ol><li>可以无需刷新页面而与服务器端进行通信。</li><li>允许你根据用户事件来更新部分页面内容。</li></ol></blockquote><h3 id="Ajax的缺点"><a href="#Ajax的缺点" class="headerlink" title="Ajax的缺点"></a>Ajax的缺点</h3><blockquote><ol><li>没有浏览历史，不能回退</li><li>存在跨域问题(同源)</li><li>SEO (搜索引擎优化）不友好，爬虫无法爬到</li></ol></blockquote><h2 id="HTTP简介"><a href="#HTTP简介" class="headerlink" title="HTTP简介"></a>HTTP简介</h2><blockquote><p>HTTP（hypertext transport protocol）协议『超文本传输协议』，协议详细规定了浏览器和万维网服务器之间互相通信的规则、约定,、规则</p></blockquote><h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">重点是格式与参数</span><br><span class="line">行   POST /s?ie=utf<span class="number">-8</span> HTTP/<span class="number">1.1</span> </span><br><span class="line"></span><br><span class="line">头   Host: atguigu.com</span><br><span class="line">    Cookie: <span class="type">name</span>=guigu</span><br><span class="line">    Content-<span class="keyword">type</span>: application/x-www-form-urlencoded</span><br><span class="line">    <span class="keyword">User</span>-Agent: chrome <span class="number">83</span></span><br><span class="line">空行</span><br><span class="line">体   username=<span class="keyword">admin</span>&amp;<span class="keyword">password</span>=<span class="keyword">admin</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h3><blockquote><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">行   HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line"></span><br><span class="line">头   Content-Type: <span class="type">text</span>/html;charset=utf-<span class="number">8</span></span><br><span class="line">    Content-length: <span class="number">2048</span></span><br><span class="line">    Content-encoding: gzip</span><br><span class="line">空行  </span><br><span class="line">体   <span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml">      </span><span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml">      </span><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">        </span><span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>尚硅谷<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Chrome网络控制台查看通信报文"><a href="#Chrome网络控制台查看通信报文" class="headerlink" title="Chrome网络控制台查看通信报文"></a>Chrome网络控制台查看通信报文</h3><blockquote><p>1、Network —&gt; Hearders 请求头</p><p>2、Network —&gt; Response 响应体:通常返回的是html</p></blockquote><h1 id="原生Ajax"><a href="#原生Ajax" class="headerlink" title="原生Ajax"></a>原生Ajax</h1><blockquote><p>1、XMLHttpRequest，AJAX 的所有操作都是通过该对象进行的。</p><p>2、当你前端想设置自定义的请求头时,需要如此后端设置响应头</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span>表示接收任意类型的请求</span><br><span class="line">app.all(<span class="string">&#x27;/server&#x27;</span>, (request, response) =&gt; &#123; <span class="regexp">//</span>响应头 允许跨域     运行自定义响应头</span><br><span class="line">    response.setHeader(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>); response.setHeader(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);&#125;</span><br></pre></td></tr></table></figure><p>3、<code>ajax请求状态</code>:xhr.readyState 0：请求未初始化，还没有调用 open()。</p><p> 1：请求已经建立，但是还没有发送，还没有调用 send()。</p><p> 2：请求已发送，正在处理中（通常现在可以从响应中获取内容头）。</p><p> 3：请求在处理中；通常响应中已有部分数据可用了，没有全部完成。</p><p> 4：响应已完成；您可以获取并使用服务器的响应了</p></blockquote><h2 id="Ajax的使用"><a href="#Ajax的使用" class="headerlink" title="Ajax的使用"></a>Ajax的使用</h2><blockquote><p>使用步骤:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) 创建 XMLHttpRequest 对象</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="number">2</span>) 设置请求信息</span><br><span class="line">xhr.open(method, url);</span><br><span class="line"><span class="comment">//可以设置请求头，一般不设置</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span><br><span class="line"><span class="number">3</span>) 发送请求</span><br><span class="line">xhr.send(body) <span class="comment">//get 请求不传 body 参数，只有 post 请求使用</span></span><br><span class="line"><span class="number">4</span>) 接收响应</span><br><span class="line"><span class="comment">//xhr.responseXML 接收 xml 格式的响应数据</span></span><br><span class="line"><span class="comment">//xhr.responseText 接收文本格式的响应数据</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> text = xhr.responseText;</span><br><span class="line"><span class="built_in">console</span>.log(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0: 请求未初始化</span></span><br><span class="line"><span class="comment">1: 服务器连接已建立</span></span><br><span class="line"><span class="comment">2: 请求已接收</span></span><br><span class="line"><span class="comment">3: 请求处理中</span></span><br><span class="line"><span class="comment">4: 请求已完成，且响应已就绪</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="Get方式"><a href="#Get方式" class="headerlink" title="Get方式"></a>Get方式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定事件</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//1. 创建对象</span></span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  <span class="comment">//2. 初始化 设置请求方法和 url</span></span><br><span class="line">  <span class="comment">// 使用&amp;分割参数</span></span><br><span class="line">  xhr.open(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;http://127.0.0.1:8000/server?a=100&amp;b=200&amp;c=300&#x27;</span>);</span><br><span class="line">  <span class="comment">//3. 发送</span></span><br><span class="line">  xhr.send();</span><br><span class="line">  <span class="comment">//4. 事件绑定 处理服务端返回的结果</span></span><br><span class="line">  <span class="comment">// on  when 当....时候</span></span><br><span class="line">  <span class="comment">// readystate 是 xhr 对象中的属性, 表示状态 0 1 2 3 4</span></span><br><span class="line">  <span class="comment">// change  改变</span></span><br><span class="line">  xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//判断 (服务端返回了所有的结果)</span></span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="comment">//判断响应状态码 200  404  403 401 500</span></span><br><span class="line">      <span class="comment">// 2xx 成功</span></span><br><span class="line">      <span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">        <span class="comment">//处理结果  行 头 空行 体</span></span><br><span class="line">        <span class="comment">//响应 </span></span><br><span class="line">        <span class="comment">// console.log(xhr.status);//状态码</span></span><br><span class="line">        <span class="comment">// console.log(xhr.statusText);//状态字符串</span></span><br><span class="line">        <span class="comment">// console.log(xhr.getAllResponseHeaders());//所有响应头</span></span><br><span class="line">        <span class="comment">// console.log(xhr.response);//响应体</span></span><br><span class="line">        <span class="comment">//设置 result 的文本</span></span><br><span class="line">        result.innerHTML = xhr.response;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Post方式"><a href="#Post方式" class="headerlink" title="Post方式"></a>Post方式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定事件</span></span><br><span class="line">   result.addEventListener(<span class="string">&quot;mouseover&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="comment">//1. 创建对象</span></span><br><span class="line">       <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">       <span class="comment">//2. 初始化 设置类型与 URL</span></span><br><span class="line">       xhr.open(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;http://127.0.0.1:8000/server&#x27;</span>);</span><br><span class="line">       <span class="comment">//设置请求头</span></span><br><span class="line">       xhr.setRequestHeader(<span class="string">&#x27;Content-Type&#x27;</span>,<span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>)</span><br><span class="line">       <span class="comment">// 下面这个是自定义的头信息，在后端代码中要设置允许所有的请求头，否则失败</span></span><br><span class="line">       xhr.setRequestHeader(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;atguigu&#x27;</span>);</span><br><span class="line">       <span class="comment">//3. 发送</span></span><br><span class="line">       xhr.send(<span class="string">&#x27;a=100&amp;b=200&amp;c=300&#x27;</span>);</span><br><span class="line">       <span class="comment">// xhr.send(&#x27;a:100&amp;b:200&amp;c:300&#x27;);</span></span><br><span class="line">       <span class="comment">// xhr.send(&#x27;1233211234567&#x27;);</span></span><br><span class="line">       <span class="comment">//4. 事件绑定</span></span><br><span class="line">       xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">           <span class="comment">//判断</span></span><br><span class="line">           <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span>(xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>)&#123;</span><br><span class="line">                   <span class="comment">//处理服务端返回的结果</span></span><br><span class="line">                   result.innerHTML = xhr.response;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><h2 id="解决ie缓存问题"><a href="#解决ie缓存问题" class="headerlink" title="解决ie缓存问题"></a>解决ie缓存问题</h2><blockquote><p>问题：在一些浏览器中(IE),由于<code>缓存机制</code>的存在，ajax 只会发送的第一次请求，剩余多次请求不会再发送给浏览器而是直接加载缓存中的数据。</p><p>解决方式：浏览器的缓存是根据 url地址来记录的，所以我们只需要修改 url 地址 即可避免缓存问题 <code>xhr.open(&quot;get&quot;,&quot;/testAJAX?t=&quot;+Date.now());</code></p></blockquote><h2 id="请求超时与网络异常"><a href="#请求超时与网络异常" class="headerlink" title="请求超时与网络异常"></a>请求超时与网络异常</h2><blockquote><p>当你的请求时间过长,或者无网络时,进行的相应处理</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">         <span class="comment">//超时设置 2s 设置</span></span><br><span class="line">         xhr.timeout = <span class="number">2000</span>;</span><br><span class="line">         <span class="comment">//超时回调</span></span><br><span class="line">         xhr.ontimeout = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             alert(<span class="string">&quot;网络异常, 请稍后重试!!&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//网络异常回调</span></span><br><span class="line">         xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             alert(<span class="string">&quot;你的网络似乎出了一些问题!&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         xhr.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&#x27;http://127.0.0.1:8000/delay&#x27;</span>);</span><br><span class="line">         xhr.send();</span><br><span class="line">         xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">                 <span class="keyword">if</span>(xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status&lt; <span class="number">300</span>)&#123;</span><br><span class="line">                     result.innerHTML = xhr.response;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;)</span><br></pre></td></tr></table></figure><h2 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h2><blockquote><p>在请求发出去后<code>但是未响应完成</code>时可以进行取消请求操作</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btns = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> x = <span class="literal">null</span>;</span><br><span class="line">btns[<span class="number">0</span>].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    x = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    x.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&#x27;http://127.0.0.1:8000/delay&#x27;</span>);</span><br><span class="line">    x.send();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abort</span></span><br><span class="line">btns[<span class="number">1</span>].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    x.abort();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重复请求问题"><a href="#重复请求问题" class="headerlink" title="重复请求问题"></a>重复请求问题</h2><blockquote><p>利用之前取消请求知识点,当我点击时判断之前请求是否在发送中,如果是,则停止请求</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">btns[<span class="number">0</span>].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="comment">//判断标识变量</span></span><br><span class="line">         <span class="keyword">if</span>(isSending) x.abort();<span class="comment">// 如果正在发送, 则取消该请求, 创建一个新的请求</span></span><br><span class="line">         x = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">         <span class="comment">//修改 标识变量的值</span></span><br><span class="line">         isSending = <span class="literal">true</span>;</span><br><span class="line">         x.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&#x27;http://127.0.0.1:8000/delay&#x27;</span>);</span><br><span class="line">         x.send();</span><br><span class="line">         x.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             <span class="keyword">if</span>(x.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">                 <span class="comment">//修改标识变量</span></span><br><span class="line">                 isSending = <span class="literal">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h1 id="常见三种Ajax请求方式"><a href="#常见三种Ajax请求方式" class="headerlink" title="常见三种Ajax请求方式"></a>常见三种Ajax请求方式</h1><h2 id="jQuery发送AJAX请求"><a href="#jQuery发送AJAX请求" class="headerlink" title="jQuery发送AJAX请求"></a>jQuery发送AJAX请求</h2><blockquote><p>jQuery有三种发送请求方法:</p><p>当你只是简单的请求数据,可以直接使用前两种方式请求,当你需要设置的东西较多的时候,可以使用<code>$.ajax()</code>方法</p></blockquote><h3 id="get"><a href="#get" class="headerlink" title="$.get()"></a>$.get()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;button&#x27;</span>).eq(<span class="number">0</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          $.get(<span class="string">&#x27;http://127.0.0.1:8000/jquery-server&#x27;</span>, &#123;<span class="attr">a</span>:<span class="number">100</span>, <span class="attr">b</span>:<span class="number">200</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">              <span class="built_in">console</span>.log(data);</span><br><span class="line">          &#125;,<span class="string">&#x27;json&#x27;</span>);</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure><h3 id="post"><a href="#post" class="headerlink" title="$.post()"></a>$.post()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;button&#x27;</span>).eq(<span class="number">1</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          $.post(<span class="string">&#x27;http://127.0.0.1:8000/jquery-server&#x27;</span>, &#123;<span class="attr">a</span>:<span class="number">100</span>, <span class="attr">b</span>:<span class="number">200</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">              <span class="built_in">console</span>.log(data);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure><h3 id="ajax"><a href="#ajax" class="headerlink" title="$.ajax"></a>$.ajax</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;button&#x27;</span>).eq(<span class="number">2</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         $.ajax(&#123;</span><br><span class="line">             <span class="comment">//url</span></span><br><span class="line">             <span class="attr">url</span>: <span class="string">&#x27;http://127.0.0.1:8000/jquery-server&#x27;</span>,</span><br><span class="line">             <span class="comment">//参数</span></span><br><span class="line">             <span class="attr">data</span>: &#123;<span class="attr">a</span>:<span class="number">100</span>, <span class="attr">b</span>:<span class="number">200</span>&#125;,</span><br><span class="line">             <span class="comment">//请求类型</span></span><br><span class="line">             <span class="attr">type</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">             <span class="comment">//响应体结果</span></span><br><span class="line">             <span class="attr">dataType</span>: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">             <span class="comment">//成功的回调</span></span><br><span class="line">             <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">                 <span class="built_in">console</span>.log(data);</span><br><span class="line">             &#125;,</span><br><span class="line">             <span class="comment">//超时时间</span></span><br><span class="line">             <span class="attr">timeout</span>: <span class="number">2000</span>,</span><br><span class="line">             <span class="comment">//失败的回调</span></span><br><span class="line">             <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                 <span class="built_in">console</span>.log(<span class="string">&#x27;出错啦!!&#x27;</span>);</span><br><span class="line">             &#125;,</span><br><span class="line">             <span class="comment">//头信息</span></span><br><span class="line">             <span class="attr">headers</span>: &#123;</span><br><span class="line">                 <span class="attr">c</span>:<span class="number">300</span>,</span><br><span class="line">                 <span class="attr">d</span>:<span class="number">400</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure><h2 id="Axios发送AJAX请求"><a href="#Axios发送AJAX请求" class="headerlink" title="Axios发送AJAX请求"></a>Axios发送AJAX请求</h2><h3 id="axios-get"><a href="#axios-get" class="headerlink" title="axios.get()"></a>axios.get()</h3><blockquote><p>axios.get(url,data,params)</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置 baseURL</span></span><br><span class="line">  axios.defaults.baseURL = <span class="string">&#x27;http://127.0.0.1:8000&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  btns[<span class="number">0</span>].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//GET 请求</span></span><br><span class="line">    axios.get(<span class="string">&#x27;/axios-server&#x27;</span>, &#123;</span><br><span class="line">      <span class="comment">//url 参数</span></span><br><span class="line">      <span class="attr">params</span>: &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">100</span>,</span><br><span class="line">        <span class="attr">vip</span>: <span class="number">7</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">//请求头信息</span></span><br><span class="line">      <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;atguigu&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(value);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="axios-post"><a href="#axios-post" class="headerlink" title="axios.post()"></a>axios.post()</h3><blockquote><p>axios.post(url,data,params)</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//配置 baseURL</span></span><br><span class="line">   axios.defaults.baseURL = <span class="string">&#x27;http://127.0.0.1:8000&#x27;</span>;  </span><br><span class="line">btns[<span class="number">1</span>].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     axios.post(<span class="string">&#x27;/axios-server&#x27;</span>, &#123;</span><br><span class="line">       <span class="attr">username</span>: <span class="string">&#x27;admin&#x27;</span>,</span><br><span class="line">       <span class="attr">password</span>: <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">     &#125;, &#123;</span><br><span class="line">       <span class="comment">//url </span></span><br><span class="line">       <span class="attr">params</span>: &#123;</span><br><span class="line">         <span class="attr">id</span>: <span class="number">200</span>,</span><br><span class="line">         <span class="attr">vip</span>: <span class="number">9</span></span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="comment">//请求头参数</span></span><br><span class="line">       <span class="attr">headers</span>: &#123;</span><br><span class="line">         <span class="attr">height</span>: <span class="number">180</span>,</span><br><span class="line">         <span class="attr">weight</span>: <span class="number">180</span>,</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="axios-常用"><a href="#axios-常用" class="headerlink" title="axios() 常用"></a>axios() <code>常用</code></h3><blockquote><p>axios({})</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//配置 baseURL</span></span><br><span class="line">   axios.defaults.baseURL = <span class="string">&#x27;http://127.0.0.1:8000&#x27;</span>;</span><br><span class="line">btns[<span class="number">2</span>].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     axios(&#123;</span><br><span class="line">       <span class="comment">//请求方法</span></span><br><span class="line">       <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">       <span class="comment">//url</span></span><br><span class="line">       <span class="attr">url</span>: <span class="string">&#x27;/axios-server&#x27;</span>,</span><br><span class="line">       <span class="comment">//url参数</span></span><br><span class="line">       <span class="attr">params</span>: &#123;</span><br><span class="line">         <span class="attr">vip</span>: <span class="number">10</span>,</span><br><span class="line">         <span class="attr">level</span>: <span class="number">30</span></span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="comment">//头信息,此部分如果使用自定义的头信息,需要服务端进行相应修改,正常不设置</span></span><br><span class="line">       <span class="attr">headers</span>: &#123;</span><br><span class="line">         <span class="attr">a</span>: <span class="number">100</span>,</span><br><span class="line">         <span class="attr">b</span>: <span class="number">200</span></span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="comment">//请求体参数</span></span><br><span class="line">       <span class="attr">data</span>: &#123;</span><br><span class="line">         <span class="attr">username</span>: <span class="string">&#x27;admin&#x27;</span>,</span><br><span class="line">         <span class="attr">password</span>: <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="comment">//响应状态码</span></span><br><span class="line">       <span class="built_in">console</span>.log(response.status);</span><br><span class="line">       <span class="comment">//响应状态字符串</span></span><br><span class="line">       <span class="built_in">console</span>.log(response.statusText);</span><br><span class="line">       <span class="comment">//响应头信息</span></span><br><span class="line">       <span class="built_in">console</span>.log(response.headers);</span><br><span class="line">       <span class="comment">//响应体</span></span><br><span class="line">       <span class="built_in">console</span>.log(response.data);</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="Fetch发送AJAX请求"><a href="#Fetch发送AJAX请求" class="headerlink" title="Fetch发送AJAX请求"></a>Fetch发送AJAX请求</h2><blockquote><p>代码示例</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    fetch(<span class="string">&#x27;http://127.0.0.1:8000/fetch-server?vip=10&#x27;</span>, &#123;</span><br><span class="line">      <span class="comment">//请求方法</span></span><br><span class="line">      <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">      <span class="comment">//请求头</span></span><br><span class="line">      <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;atguigu&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">//请求体</span></span><br><span class="line">      <span class="attr">body</span>: <span class="string">&#x27;username=admin&amp;password=admin&#x27;</span></span><br><span class="line">    &#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// return response.text();</span></span><br><span class="line">      <span class="keyword">return</span> response.json();</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(response);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="跨域与解决"><a href="#跨域与解决" class="headerlink" title="跨域与解决"></a>跨域与解决</h1><blockquote><h5 id="1、什么是跨越？"><a href="#1、什么是跨越？" class="headerlink" title="1、什么是跨越？"></a>1、什么是跨越？</h5><ul><li>一个网页向另一个不同域名/不同协议/不同端口的网页请求资源，这就是跨域。</li><li>跨域原因产生：在当前域名请求网站中，默认不允许通过ajax请求发送其他域名。</li></ul><h5 id="2、为什么会产生跨域请求？"><a href="#2、为什么会产生跨域请求？" class="headerlink" title="2、为什么会产生跨域请求？"></a>2、为什么会产生跨域请求？</h5><ul><li>因为浏览器使用了同源策略</li></ul><h5 id="3、什么是同源策略？"><a href="#3、什么是同源策略？" class="headerlink" title="3、什么是同源策略？"></a>3、什么是同源策略？</h5><ul><li>同源策略是Netscape提出的一个著名的安全策略，现在所有支持JavaScript的浏览器都会使用这个策略。同源策略是浏览器最核心也最基本的安全功能，如果缺少同源策略，浏览器的正常功能可能受到影响。可以说web是构建在同源策略的基础之上的，浏览器只是针对同源策略的一种实现。</li><li>同源： 协议、域名、端口号 <strong>必须完全相同</strong>。 <code>违背同源策略就是跨域</code>。</li></ul><h5 id="4、为什么浏览器要使用同源策略？"><a href="#4、为什么浏览器要使用同源策略？" class="headerlink" title="4、为什么浏览器要使用同源策略？"></a>4、为什么浏览器要使用同源策略？</h5><ul><li>是为了保证用户的信息安全，防止恶意网站窃取数据，如果网页之间不满足同源要求，将不能:</li><li><ul><li>1、共享Cookie、LocalStorage、IndexDB</li></ul></li><li><ul><li>2、获取DOM</li></ul></li><li><ul><li>3、AJAX请求不能发送</li></ul></li></ul><h5 id="5、跨域的五个解决方式"><a href="#5、跨域的五个解决方式" class="headerlink" title="5、跨域的五个解决方式:"></a>5、跨域的五个解决方式:</h5><p> 1、前端使用jsonp （不推荐使用）</p><p> 2、后台Http请求转发</p><p> 3、后台配置同源Cors （推荐）</p><p> 4、使用SpringCloud网关</p><p> 5、使用nginx做转发 (推荐)</p><p>本课程提到了其中的两种:</p></blockquote><h2 id="jsonP"><a href="#jsonP" class="headerlink" title="jsonP"></a>jsonP</h2><blockquote><p>1)JSONP 是什么?</p><p> JSONP(JSON with Padding)，是一个非官方的跨域解决方案，纯粹凭借程序员的聪明 才智开发出来，只支持 get 请求。</p><p>2)JSONP 怎么工作的？</p><p> 在网页有一些标签天生具有跨域能力，比如：img link iframe script。 JSONP 就是利用 script 标签的跨域能力来发送请求的。</p></blockquote><h3 id="jsonP的使用"><a href="#jsonP的使用" class="headerlink" title="jsonP的使用"></a>jsonP的使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 1. 动态的创建一个 script 标签------------------------------------------------------------</span></span><br><span class="line">   <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line"><span class="comment">//2. 设置 script 的 src， 设置回调函数</span></span><br><span class="line">   script.src = <span class="string">&quot;http://localhost:3000/testAJAX?callback=abc&quot;</span>;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">abc</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">     alert(data.name);</span><br><span class="line">   &#125;;</span><br><span class="line">  <span class="comment">// 3. 将 script 添加到 body 中</span></span><br><span class="line">   <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 服务器中路由的处理------------------------------------------------------</span></span><br><span class="line">   router.get(<span class="string">&quot;/testAJAX&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&quot;收到请求&quot;</span>);</span><br><span class="line">     <span class="keyword">var</span> callback = req.query.callback;</span><br><span class="line">     <span class="keyword">var</span> obj = &#123;</span><br><span class="line">       <span class="attr">ame</span>: <span class="string">&quot;孙悟空&quot;</span>,</span><br><span class="line">       <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">     &#125;</span><br><span class="line">     res.send(callback + <span class="string">&quot;(&quot;</span> + <span class="built_in">JSON</span>.stringify(obj) + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><h3 id="jQuery发送jsonP请求"><a href="#jQuery发送jsonP请求" class="headerlink" title="jQuery发送jsonP请求"></a>jQuery发送jsonP请求</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前端代码-----------------------------------------------------------------------------------</span></span><br><span class="line">$(<span class="string">&#x27;button&#x27;</span>).eq(<span class="number">0</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  $.getJSON(<span class="string">&#x27;http://127.0.0.1:8000/jquery-jsonp-server?callback=?&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    $(<span class="string">&#x27;#result&#x27;</span>).html(<span class="string">`</span></span><br><span class="line"><span class="string">                名称: <span class="subst">$&#123;data.name&#125;</span>&lt;br&gt;</span></span><br><span class="line"><span class="string">                校区: <span class="subst">$&#123;data.city&#125;</span></span></span><br><span class="line"><span class="string">            `</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务端代码-----------------------------------------------------------</span></span><br><span class="line">app.all(<span class="string">&#x27;/jquery-jsonp-server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;);</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;尚硅谷&#x27;</span>,</span><br><span class="line">    <span class="attr">city</span>: [<span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;上海&#x27;</span>, <span class="string">&#x27;深圳&#x27;</span>]</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//将数据转化为字符串</span></span><br><span class="line">  <span class="keyword">let</span> str = <span class="built_in">JSON</span>.stringify(data);</span><br><span class="line">  <span class="comment">//接收 callback 参数</span></span><br><span class="line">  <span class="keyword">let</span> cb = request.query.callback;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回结果</span></span><br><span class="line">  <span class="comment">// $&#123;&#125; 可以将str转变成对象</span></span><br><span class="line">  response.end(<span class="string">`<span class="subst">$&#123;cb&#125;</span>(<span class="subst">$&#123;str&#125;</span>)`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="原作者开发封装的jsonP插件"><a href="#原作者开发封装的jsonP插件" class="headerlink" title="原作者开发封装的jsonP插件"></a>原作者开发封装的jsonP插件</h3><blockquote><p>1、代价:需要前后端联动 2、精髓:自动的由插件生成方法名,并在当前的页面动态的生成函数,然后再生成的函数里头调用用户预留的回调函数 3、插件：自动化的去模拟基于script去实现跨域请求的过程（对用户来说是黑盒子） 4、参数拼接：url已经是带参的。和不带参的 5、id优化 额可以添加一个容器来管理id</p><p>1、前端调用测试封装好的jsonP代码</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试调用函数</span></span><br><span class="line">    <span class="keyword">let</span> test=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        jsonP.req(&#123;</span><br><span class="line">            <span class="attr">url</span>:<span class="string">&quot;http://localhost:3000/jsonpx&quot;</span>,</span><br><span class="line">            <span class="attr">data</span>:&#123;</span><br><span class="line">                <span class="attr">a</span>:<span class="string">&quot;111&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">callback</span>:<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">                alert(<span class="string">&quot;成功&quot;</span>+result)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>2、服务端测试代码</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">&#x27;/jsonpx&#x27;</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">req, resp, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> callback=req.query.callback;</span><br><span class="line">    <span class="keyword">let</span> data=req.query.a;</span><br><span class="line">    <span class="keyword">if</span> (!data)&#123;</span><br><span class="line">        resp.send(<span class="string">`<span class="subst">$&#123;callback&#125;</span>(&#x27;洪jl:我是服务端代码&#x27;)`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    resp.send(<span class="string">`<span class="subst">$&#123;callback&#125;</span>(&#x27;洪jl:我是服务端代码`</span>+data+<span class="string">`&#x27;)`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>3、封装原生代码</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">/**author:<span class="doctag">@hongjilin</span></span></span><br><span class="line"><span class="comment">     * 1.声明一个jsonP插件对象</span></span><br><span class="line"><span class="comment">     * 作用：隔开作用域</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">let</span> jsonP = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *2.在插件对象中创建两个名字备用符数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    jsonP.char = &#123;</span><br><span class="line">        <span class="attr">Number</span>: <span class="string">&#x27;0123456789&#x27;</span>,</span><br><span class="line">        <span class="attr">Letter</span>: <span class="string">&#x27;qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过随机数抽取备用字符数组库拼凑函数id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="variable">charLen</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="variable">numLen</span></span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    jsonP.newFunId = <span class="function"><span class="keyword">function</span> (<span class="params">charLen, numLen</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> id = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; charLen; i++) &#123;</span><br><span class="line">            id += <span class="built_in">this</span>.char.Letter.charAt(<span class="built_in">Math</span>.random() * <span class="number">52</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; numLen; j++) &#123;</span><br><span class="line">            id += <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拼接路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="variable">url</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="variable">key</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="variable">value</span></span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    jsonP.jointUrl = <span class="function"><span class="keyword">function</span> (<span class="params">url, key, value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url &amp;&amp; key &amp;&amp; value) &#123;</span><br><span class="line">            <span class="keyword">let</span> sign = <span class="string">&quot;&amp;&quot;</span></span><br><span class="line">            <span class="comment">//如果是第一次</span></span><br><span class="line">            <span class="keyword">if</span> (url.indexOf(<span class="string">&#x27;?&#x27;</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">                sign = <span class="string">&#x27;?&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            url += sign + key + <span class="string">&quot;=&quot;</span> + value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     封装err属性方便</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    jsonP.err = <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(msg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送请求函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="variable">options</span></span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    jsonP.req = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> jsonId=&#123;&#125;;</span><br><span class="line">        <span class="comment">//1.生成方法名</span></span><br><span class="line">        jsonId.funId = <span class="built_in">this</span>.newFunId(<span class="number">4</span>,<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">let</span> Userurl = options.url;</span><br><span class="line">        <span class="keyword">let</span> Userdata = options.data;</span><br><span class="line">        <span class="keyword">if</span> (!options) &#123;</span><br><span class="line">            <span class="built_in">this</span>.err(<span class="string">&quot;输入不能空&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!Userurl) &#123;</span><br><span class="line">            <span class="built_in">this</span>.err(<span class="string">&quot;url不能空&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!Userdata) &#123;</span><br><span class="line">            <span class="comment">//如果没有data,初始化</span></span><br><span class="line">            Userdata = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将函数名赋值给userdata的回调函数属性中</span></span><br><span class="line">        Userdata.callback = jsonId.funId;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> Userdata) &#123;</span><br><span class="line">            Userurl = <span class="built_in">this</span>.jointUrl(Userurl, key, Userdata[key])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">        script.setAttribute(<span class="string">&quot;id&quot;</span> , jsonId.funId);</span><br><span class="line">        script.setAttribute(<span class="string">&quot;src&quot;</span> , Userurl);</span><br><span class="line">        <span class="comment">//动态生成函数</span></span><br><span class="line">        <span class="keyword">let</span> callback=<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;xxxxxxx&quot;</span>)</span><br><span class="line">            <span class="comment">//业务逻辑回调</span></span><br><span class="line">            <span class="keyword">if</span> (options.callback)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    options.callback(result)</span><br><span class="line">                &#125;<span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.err(e.message)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//善后</span></span><br><span class="line">            <span class="keyword">let</span> tmp=<span class="built_in">document</span>.getElementById(jsonId.funId)</span><br><span class="line">            tmp.parentNode.removeChild(tmp);</span><br><span class="line">            <span class="built_in">eval</span>(jsonId.funId+<span class="string">&#x27;=null&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">eval</span>(<span class="string">&quot;window.&quot;</span>+jsonId.funId+<span class="string">&quot;=function(result)&#123; callback(result) &#125;&quot;</span>)</span><br><span class="line">        <span class="built_in">document</span>.head.appendChild(script)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><blockquote><p>1、<a href="https://gitee.com/link?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FCORS">CORS文档链接</a></p><p>2、CORS是什么?</p><p> CORS（Cross-Origin Resource Sharing），跨域资源共享。CORS 是官方的跨域解决方 案，它的特点是不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持 get 和 post 请求。跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些 源站通过浏览器有权限访问哪些资源</p><p>3、CORS是怎么工作的?</p><p> CORS 是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应 以后就会对响应放行。</p></blockquote><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">app.all(<span class="string">&#x27;/cors-server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头</span></span><br><span class="line">    <span class="comment">//响应首部中可以携带一个 Access-Control-Allow-Origin 字段</span></span><br><span class="line">  response.setHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">    <span class="comment">//Access-Control-Allow-Headers 首部字段用于预检请求的响应。其指明了实际请求中允许携带的首部字</span></span><br><span class="line">  response.setHeader(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    <span class="comment">//Access-Control-Allow-Methods 首部字段用于预检请求的响应。其指明了实际请求所允许使用的 HTTP</span></span><br><span class="line">  response.setHeader(<span class="string">&quot;Access-Control-Allow-Method&quot;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">// response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://127.0.0.1:5500&quot;);</span></span><br><span class="line">  response.send(<span class="string">&#x27;hello CORS&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="HTTP-响应首部字段"><a href="#HTTP-响应首部字段" class="headerlink" title="HTTP 响应首部字段"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FCORS%23http_%E5%93%8D%E5%BA%94%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5">HTTP 响应首部字段</a></h3><blockquote><p>本节列出了规范所定义的响应首部字段。上一小节中，我们已经看到了这些首部字段在实际场景中是如何工作的。</p></blockquote><h4 id="Access-Control-Allow-Origin"><a href="#Access-Control-Allow-Origin" class="headerlink" title="Access-Control-Allow-Origin"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FCORS%23access-control-allow-origin">Access-Control-Allow-Origin</a></h4><blockquote><p>响应首部中可以携带一个 <a href="https://gitee.com/link?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FHeaders%2FAccess-Control-Allow-Origin"><code>Access-Control-Allow-Origin</code></a> 字段，其语法如下:</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: <span class="variable">&lt;origin&gt;</span> |<span class="string"> *</span></span><br></pre></td></tr></table></figure><p>其中，origin 参数的值指定了允许访问该资源的外域 URI。对于不需要携带身份凭证的请求，服务器可以指定该字段的值为通配符，表示允许来自所有域的请求。</p><p>例如，下面的字段值将允许来自 <a href="https://gitee.com/link?target=http%3A%2F%2Fmozilla.com">http://mozilla.com</a> 的请求：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http:<span class="regexp">//m</span>ozilla.com</span><br></pre></td></tr></table></figure><p>如果服务端指定了具体的域名而非“*”，那么响应首部中的 Vary 字段的值必须包含 Origin。这将告诉客户端：服务器对不同的源站返回不同的内容。</p></blockquote><h4 id="Access-Control-Expose-Headers"><a href="#Access-Control-Expose-Headers" class="headerlink" title="Access-Control-Expose-Headers"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FCORS%23access-control-expose-headers">Access-Control-Expose-Headers</a></h4><blockquote><p>译者注：在跨源访问时，XMLHttpRequest对象的getResponseHeader()方法只能拿到一些最基本的响应头，Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。</p><p><a href="https://gitee.com/link?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FHeaders%2FAccess-Control-Expose-Headers"><code>Access-Control-Expose-Headers</code></a> 头让服务器把允许浏览器访问的头放入白名单，例如：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Access</span>-Control-Expose-Headers: X-My-Custom-<span class="keyword">Header</span>, X-Another-Custom-<span class="keyword">Header</span></span><br></pre></td></tr></table></figure><p>这样浏览器就能够通过getResponseHeader访问<code>X-My-Custom-Header</code>和 <code>X-Another-Custom-Header</code> 响应头了。</p></blockquote><h4 id="Access-Control-Max-Age"><a href="#Access-Control-Max-Age" class="headerlink" title="Access-Control-Max-Age"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FCORS%23access-control-max-age">Access-Control-Max-Age</a></h4><blockquote><p><a href="https://gitee.com/link?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FHeaders%2FAccess-Control-Max-Age"><code>Access-Control-Max-Age</code></a> 头指定了preflight请求的结果能够被缓存多久，请参考本文在前面提到的preflight例子。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Access</span>-Control-Max-Age: &lt;<span class="keyword">delta</span>-seconds&gt;</span><br></pre></td></tr></table></figure><p><code>delta-seconds</code> 参数表示preflight请求的结果在多少秒内有效。</p></blockquote><h4 id="Access-Control-Allow-Credentials"><a href="#Access-Control-Allow-Credentials" class="headerlink" title="Access-Control-Allow-Credentials"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FCORS%23access-control-allow-credentials">Access-Control-Allow-Credentials</a></h4><blockquote><p><a href="https://gitee.com/link?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FHeaders%2FAccess-Control-Allow-Credentials"><code>Access-Control-Allow-Credentials</code></a> 头指定了当浏览器的<code>credentials</code>设置为true时是否允许浏览器读取response的内容。当用在对preflight预检测请求的响应中时，它指定了实际的请求是否可以使用<code>credentials</code>。请注意：简单 GET 请求不会被预检；如果对此类请求的响应中不包含该字段，这个响应将被忽略掉，并且浏览器也不会将相应内容返回给网页。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Access</span>-Control-Allow-Credentials: <span class="literal">true</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="Access-Control-Allow-Methods"><a href="#Access-Control-Allow-Methods" class="headerlink" title="Access-Control-Allow-Methods"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FCORS%23access-control-allow-methods">Access-Control-Allow-Methods</a></h4><blockquote><p><a href="https://gitee.com/link?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FHeaders%2FAccess-Control-Allow-Methods"><code>Access-Control-Allow-Methods</code></a> 首部字段用于预检请求的响应。其指明了实际请求所允许使用的 HTTP 方法。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Methods: &lt;<span class="function"><span class="keyword">method</span>&gt;[, &lt;<span class="title">method</span>&gt;]*</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="Access-Control-Allow-Headers"><a href="#Access-Control-Allow-Headers" class="headerlink" title="Access-Control-Allow-Headers"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FCORS%23access-control-allow-headers">Access-Control-Allow-Headers</a></h4><blockquote><p><a href="https://gitee.com/link?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FHeaders%2FAccess-Control-Allow-Headers"><code>Access-Control-Allow-Headers</code></a> 首部字段用于预检请求的响应。其指明了实际请求中允许携带的首部字段。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Access</span>-Control-Allow-Headers: &lt;field-<span class="keyword">name</span>&gt;[, &lt;field-<span class="keyword">name</span>&gt;]*</span><br></pre></td></tr></table></figure></blockquote><h3 id="HTTP-请求首部字段"><a href="#HTTP-请求首部字段" class="headerlink" title="HTTP 请求首部字段"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FCORS%23http_%E8%AF%B7%E6%B1%82%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5">HTTP 请求首部字段</a></h3><blockquote><p>本节列出了可用于发起跨源请求的首部字段。请注意，这些首部字段无须手动设置。 当开发者使用 XMLHttpRequest 对象发起跨源请求时，它们已经被设置就绪。</p></blockquote><h4 id="Origin"><a href="#Origin" class="headerlink" title="Origin"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FCORS%23origin">Origin</a></h4><blockquote><p><a href="https://gitee.com/link?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FHeaders%2FOrigin"><code>Origin</code></a> 首部字段表明预检请求或实际请求的源站。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Origin:</span> <span class="params">&lt;origin&gt;</span></span><br></pre></td></tr></table></figure><p>origin 参数的值为源站 URI。它不包含任何路径信息，只是服务器名称。</p><p><strong>Note:</strong> 有时候将该字段的值设置为空字符串是有用的，例如，当源站是一个 data URL 时。</p><p>注意，在所有访问控制请求（Access control request）中，<a href="https://gitee.com/link?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FHeaders%2FOrigin"><code>Origin</code></a> 首部字段<strong>总是</strong>被发送</p></blockquote><h4 id="Access-Control-Request-Method"><a href="#Access-Control-Request-Method" class="headerlink" title="Access-Control-Request-Method"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FCORS%23access-control-request-method">Access-Control-Request-Method</a></h4><blockquote><p><a href="https://gitee.com/link?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FHeaders%2FAccess-Control-Request-Method"><code>Access-Control-Request-Method</code></a> 首部字段用于预检请求。其作用是，将实际请求所使用的 HTTP 方法告诉服务器。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Request-<span class="function"><span class="keyword">Method</span>:</span> &lt;<span class="function"><span class="keyword">method</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="Access-Control-Request-Headers"><a href="#Access-Control-Request-Headers" class="headerlink" title="Access-Control-Request-Headers"></a><a href="https://gitee.com/link?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FCORS%23access-control-request-headers">Access-Control-Request-Headers</a></h4><blockquote><p><a href="https://gitee.com/link?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FHeaders%2FAccess-Control-Request-Headers"><code>Access-Control-Request-Headers</code></a> 首部字段用于预检请求。其作用是，将实际请求所携带的首部字段告诉服务器。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Access</span>-Control-Request-Headers: &lt;field-<span class="keyword">name</span>&gt;[, &lt;field-<span class="keyword">name</span>&gt;]*</span><br></pre></td></tr></table></figure></blockquote><hr><hr><h1 id="服务端代码示例"><a href="#服务端代码示例" class="headerlink" title="服务端代码示例"></a>服务端代码示例</h1><blockquote><p>配合以上前端代码的服务端代码</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 引入express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 创建应用对象</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 创建路由规则</span></span><br><span class="line"><span class="comment">// request 是对请求报文的封装</span></span><br><span class="line"><span class="comment">// response 是对响应报文的封装</span></span><br><span class="line">app.get(<span class="string">&#x27;/server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头  设置允许跨域</span></span><br><span class="line">  response.setHeader(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">//设置响应体</span></span><br><span class="line">  response.send(<span class="string">&#x27;HELLO AJAX - 2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以接收任意类型的请求 </span></span><br><span class="line">app.all(<span class="string">&#x27;/server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头  设置允许跨域</span></span><br><span class="line">  response.setHeader(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">//响应头</span></span><br><span class="line">  response.setHeader(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">//设置响应体</span></span><br><span class="line">  response.send(<span class="string">&#x27;HELLO AJAX POST&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//JSON 响应</span></span><br><span class="line">app.all(<span class="string">&#x27;/json-server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头  设置允许跨域</span></span><br><span class="line">  response.setHeader(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  response.setHeader(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">//响应一个数据</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;atguigu&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//对对象进行字符串转换</span></span><br><span class="line">  <span class="keyword">let</span> str = <span class="built_in">JSON</span>.stringify(data);</span><br><span class="line">  <span class="comment">//设置响应体</span></span><br><span class="line">  response.send(str);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//针对 IE 缓存</span></span><br><span class="line">app.get(<span class="string">&#x27;/ie&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头  设置允许跨域</span></span><br><span class="line">  response.setHeader(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">//设置响应体</span></span><br><span class="line">  response.send(<span class="string">&#x27;HELLO IE - 5&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//延时响应</span></span><br><span class="line">app.all(<span class="string">&#x27;/delay&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头  设置允许跨域</span></span><br><span class="line">  response.setHeader(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  response.setHeader(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//设置响应体</span></span><br><span class="line">    response.send(<span class="string">&#x27;延时响应&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//jQuery 服务</span></span><br><span class="line">app.all(<span class="string">&#x27;/jquery-server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头  设置允许跨域</span></span><br><span class="line">  response.setHeader(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  response.setHeader(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">// response.send(&#x27;Hello jQuery AJAX&#x27;);</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;尚硅谷&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 只能send字符串数据，不能直接发送data，所以这里使用了JSON.stringfy()方法</span></span><br><span class="line">  response.send(<span class="built_in">JSON</span>.stringify(data));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//axios 服务</span></span><br><span class="line">app.all(<span class="string">&#x27;/axios-server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头  设置允许跨域</span></span><br><span class="line">  response.setHeader(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  response.setHeader(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">// response.send(&#x27;Hello jQuery AJAX&#x27;);</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;尚硅谷&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 只能send字符串数据，不能直接发送data，所以这里使用了JSON.stringfy()方法</span></span><br><span class="line">  response.send(<span class="built_in">JSON</span>.stringify(data));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//fetch 服务</span></span><br><span class="line">app.all(<span class="string">&#x27;/fetch-server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头  设置允许跨域</span></span><br><span class="line">  response.setHeader(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  response.setHeader(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">// response.send(&#x27;Hello jQuery AJAX&#x27;);</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;尚硅谷&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 只能send字符串数据，不能直接发送data，所以这里使用了JSON.stringfy()方法</span></span><br><span class="line">  response.send(<span class="built_in">JSON</span>.stringify(data));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//jsonp服务</span></span><br><span class="line">app.all(<span class="string">&#x27;/jsonp-server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;);</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;尚硅谷atguigu&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//将数据转化为字符串</span></span><br><span class="line">  <span class="keyword">let</span> str = <span class="built_in">JSON</span>.stringify(data);</span><br><span class="line">  <span class="comment">//返回结果</span></span><br><span class="line">  response.end(<span class="string">`handle(<span class="subst">$&#123;str&#125;</span>)`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//用户名检测是否存在</span></span><br><span class="line">app.all(<span class="string">&#x27;/check-username&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;);</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">exist</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;用户名已经存在&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//将数据转化为字符串</span></span><br><span class="line">  <span class="keyword">let</span> str = <span class="built_in">JSON</span>.stringify(data);</span><br><span class="line">  <span class="comment">//返回结果</span></span><br><span class="line">  response.end(<span class="string">`handle(<span class="subst">$&#123;str&#125;</span>)`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">app.all(<span class="string">&#x27;/jquery-jsonp-server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;);</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;尚硅谷&#x27;</span>,</span><br><span class="line">    <span class="attr">city</span>: [<span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;上海&#x27;</span>, <span class="string">&#x27;深圳&#x27;</span>]</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//将数据转化为字符串</span></span><br><span class="line">  <span class="keyword">let</span> str = <span class="built_in">JSON</span>.stringify(data);</span><br><span class="line">  <span class="comment">//接收 callback 参数</span></span><br><span class="line">  <span class="keyword">let</span> cb = request.query.callback;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回结果</span></span><br><span class="line">  response.end(<span class="string">`<span class="subst">$&#123;cb&#125;</span>(<span class="subst">$&#123;str&#125;</span>)`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.all(<span class="string">&#x27;/cors-server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头</span></span><br><span class="line">  response.setHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">  response.setHeader(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  response.setHeader(<span class="string">&quot;Access-Control-Allow-Method&quot;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">// response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://127.0.0.1:5500&quot;);</span></span><br><span class="line">  response.send(<span class="string">&#x27;hello CORS&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 监听端口启动服务</span></span><br><span class="line">app.listen(<span class="number">8000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;服务已经启动, 8000 端口监听中....&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>状态压缩dp</title>
      <link href="/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp/index.html"/>
      <url>/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="旅行商问题（曼哈顿路）"><a href="#旅行商问题（曼哈顿路）" class="headerlink" title="旅行商问题（曼哈顿路）"></a>旅行商问题（曼哈顿路）</h2><p><strong>题目：</strong>有一个商人想要<strong>旅行各地</strong>并进行贸易。各地之间有若干条<strong>单向的通道</strong>相连，商人从一个地方出发，想要用最短的路程把所有地区环游一遍，请问环游需要的最短路程是多少？在这题当中，我们假设商人从0位置出发，最后依然回到位置0。</p><p>这是一个NP问题，如果采用递归的话会很耗时，总体的复杂度是n!, 如果采用压缩状态dp，总体的时间复杂度是$n^22^n$ </p><p>动态规划的问题都是从小规模的问题整合成大规模的问题，对于这道题，小规模的问题是，商人已经走过了除了起点以外所有的点，最后走向起点，完成。假设一共有3个节点，那么采用状压dp就会有8种状态。</p><p><img src="https://pic2.zhimg.com/80/v2-c3b0f1e6b1a00e082daf4d4291fd80b5_720w.jpg" alt="img"></p><p>图片来自<a href="https://zhuanlan.zhihu.com/p/131585177">知乎</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    inf = <span class="number">1</span> &lt;&lt; <span class="number">31</span></span><br><span class="line">    <span class="comment"># 邻接矩阵存储边权重</span></span><br><span class="line">    d = [[inf <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">    <span class="comment"># 测试数据</span></span><br><span class="line">    edges = [[<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">0</span>, <span class="number">7</span>], [<span class="number">4</span>, <span class="number">1</span>, <span class="number">6</span>], [<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>]]</span><br><span class="line">    <span class="keyword">for</span> u, v, l <span class="keyword">in</span> edges:</span><br><span class="line">        d[u][v] = l</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化成近似无穷大的值</span></span><br><span class="line">    dp = [[inf <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>((<span class="number">1</span> &lt;&lt; <span class="number">5</span>))]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历状态</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, (<span class="number">1</span> &lt;&lt; <span class="number">5</span>)):</span><br><span class="line">        <span class="keyword">for</span> u <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">            <span class="comment"># 遍历决策</span></span><br><span class="line"><span class="comment"># 当我们使用的是dp[0][0]初始化的时候就不需要在对u做限制</span></span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">                <span class="comment"># 必须要求这个点没有去过</span></span><br><span class="line">                <span class="keyword">if</span> (s &gt;&gt; v) &amp; <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                dp[s][v] = <span class="built_in">min</span>(dp[s][v], dp[s - (<span class="number">1</span> &lt;&lt; v)][u] + d[u][v])</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(dp[(<span class="number">1</span> &lt;&lt; <span class="number">5</span>) - <span class="number">1</span>][<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>注意几点：</p><ul><li><p><code>dp[s][v]</code><strong>表示处于s状态，并且站在v节点时产生的最小路径</strong></p></li><li><p>在遍历的时候，我们习惯用u表示路径的起点，v表示路径的终点</p></li><li><p>对于每一个状态（例如，11110)，每一个二进制位表示一个节点，二进制位为1表示节点已经去过，二进制位为0表示节点没有去过。状压Dp从小规模问题合并成大规模问题，小规模问题是(00000)，也就是没有任何一个节点被访问过。</p></li><li><p>这段代码当中有两个细节，第一个细节是<strong>我们没有做u的合法判断</strong>，有可能我们u是不合法的，比如我们的集合当中只有2和3两个点，但是我们却枚举了从4到5的策略。这样是没问题的，因为我们开始的时候把所有的状态都设置成了无穷大，<strong>只有合法的状态才不是无穷</strong>，由于我们希望最后得到的结果越小越好，不合法的状态是不会被用来更新的。</p></li></ul><p>  第二个细节稍微隐蔽一些，就是我们在初始化的时候设置了<code>dp[0][0] = 0</code>。这表示我们是从空集开始的，而不是从0点开始的。因为0点已经遍历过的状态对应的数字是1，当然我们也可以设置成0已经访问过了，从0点开始，这样的话由于每个点不能重复访问，所以最后我们是无法回到0点的，要得到正确结果我们还需要加上回到0点需要的消耗。</p><p>  分析一下会发现第一点是第二点的基础，如果我们在枚举策略的时候都判断一下u点是否也合法，那么这个算法就没有办法执行，因为<strong>对于空集而言，所有点都是未访问过的</strong>，也都是非法状态，我们就找不到一个访问过的u作为决策的起点。（引用自<a href="https://zhuanlan.zhihu.com/p/131585177">这里</a>）</p><ul><li><strong>输入了一个数（节点个数），路径可以看作是已知的，还需要一个当前所在节点才能确定一个情况，所以是二维的</strong></li></ul><p>这道题还有第二种做法，比较容易理解，在我们的我们设置初始状态是<code>dp[1][0]</code>也就是一开始就访问了节点1，由于每一个节点只能访问一次，座椅最后一定是在除了0号节点的某一个节点上，所以最后还要加上回到0号节点的路程，在取最小</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, (<span class="number">1</span> &lt;&lt; <span class="number">5</span>)):</span><br><span class="line">        <span class="keyword">for</span> u <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">            <span class="comment"># 严格限制u必须已经遍历过</span></span><br><span class="line">            <span class="keyword">if</span> (s &gt;&gt; u) &amp; <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">                <span class="keyword">if</span> (s &gt;&gt; v) &amp; <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                dp[s][v] = <span class="built_in">min</span>(dp[s][v], dp[s - (<span class="number">1</span> &lt;&lt; v)][u] + d[u][v])</span><br><span class="line"></span><br><span class="line">    ans = inf</span><br><span class="line">    <span class="comment"># 最后加上回到0点的距离</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, dp[(<span class="number">1</span> &lt;&lt; <span class="number">5</span>) - <span class="number">1</span>][i] + d[i][<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure><h2 id="路径（2021蓝桥杯省赛E）"><a href="#路径（2021蓝桥杯省赛E）" class="headerlink" title="路径（2021蓝桥杯省赛E）"></a>路径（2021蓝桥杯省赛E）</h2><p>蓝桥学院由21栋教学楼组成，教学楼编号1到21。对于两栋教学楼a和b,当a和b互质时，a和b之间有一条走廊直接相连，两个方向皆可通行，否则没有直接连接的走廊。</p><p>小蓝现在在第一栋教学楼，他想要访问每栋教学楼正好一次，最终回到第一栋教学楼（即走一条哈密尔顿回路），请问他有多少种不同的访问方案？两个访问方案不同是指存在某个i,小蓝在两个访问方法中访问完教学楼i后访问了不同的教学楼。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">hasRoad = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span>(i != j):</span><br><span class="line">            <span class="keyword">if</span> math.gcd(i+<span class="number">1</span>,j + <span class="number">1</span>) == <span class="number">1</span>: <span class="comment">#注意这个gcd函数</span></span><br><span class="line">                hasRoad[i][j] = <span class="number">1</span></span><br><span class="line">                hasRoad[j][i] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> &lt;&lt; n)]</span><br><span class="line">dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>&lt;&lt;n): <span class="comment"># 取状态s</span></span><br><span class="line">    <span class="keyword">for</span> u <span class="keyword">in</span> <span class="built_in">range</span>(n): <span class="comment">#取起点</span></span><br><span class="line">        <span class="keyword">if</span> s &amp; (<span class="number">1</span> &lt;&lt; u) != <span class="number">0</span>: <span class="comment">#节点u以及被遍历，注意这里只能写 !=0 不能写成==1</span></span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">range</span>(n): <span class="comment"># 终点v</span></span><br><span class="line">                <span class="comment"># 终点v也已经被遍历并且uv之间有道路</span></span><br><span class="line">                <span class="keyword">if</span> s &amp; (<span class="number">1</span> &lt;&lt; v) != <span class="number">0</span> <span class="keyword">and</span> hasRoad[u][v]: </span><br><span class="line">                    dp[s][v] += dp[s - (<span class="number">1</span> &lt;&lt; v)][u]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>])- dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][<span class="number">0</span>])</span><br></pre></td></tr></table></figure><ul><li>根据第一题的第二种解法，我们这里采用上一题的第二种解法。<code>dp[s][v]</code><strong>表示达到状态是s,并且站在节点v上的情况有几种</strong>。说明节点v包含在状态v中。由于一开始也是就遍历的节点0，所以需要知道的是，最后会停留在除了0号节点的一个节点，倘若这个节点和0号节点有路（也就是1号楼，根据题目，一号楼和所有的楼都有路），那么就把他们相加，也就是<code>dp[1 &lt;&lt; 21 - 1][1]+ ...dp[1 &lt;&lt; 21 - 1][20]</code></li><li><strong>需要当前状态和所在节点作为指标，所以是二维的</strong></li></ul><h2 id="互不侵犯"><a href="#互不侵犯" class="headerlink" title="互不侵犯"></a><a href="https://www.luogu.com.cn/problem/P1896">互不侵犯</a></h2><p>在N×N的棋盘里面放K个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共8个格子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">N = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">K = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">stateCount = <span class="number">0</span></span><br><span class="line">state = []</span><br><span class="line">oneCountsInState = []</span><br><span class="line"><span class="comment">#预处理,找到每一个合法的摆放，记为一个状态</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> &lt;&lt; N):</span><br><span class="line">    <span class="keyword">if</span> (i &amp; (i &lt;&lt; <span class="number">1</span>) == <span class="number">0</span>):</span><br><span class="line">        <span class="comment"># 如果有两个相邻的位置都是1，那么就不会进入这个循环</span></span><br><span class="line">        oneCount = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            <span class="keyword">if</span>(i &amp; (<span class="number">1</span> &lt;&lt; j) != <span class="number">0</span>):</span><br><span class="line">                oneCount += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span>(oneCount &lt;= K):</span><br><span class="line">            oneCountsInState.append(oneCount)</span><br><span class="line">            state.append(i)</span><br><span class="line">            stateCount += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">dp = [[[<span class="number">0</span>]*(K+<span class="number">1</span>) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(stateCount)] <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(state)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(K+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span>(oneCountsInState[i] == j):</span><br><span class="line">            dp[<span class="number">0</span>][i][j] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N):</span><br><span class="line">    <span class="comment">#遍历每一行</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(state)):</span><br><span class="line">        <span class="comment">#遍历第i行每种状态</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(K+<span class="number">1</span>):</span><br><span class="line">            <span class="comment">#遍历到i行为止（包括i）使用了多少国王</span></span><br><span class="line">            <span class="keyword">if</span>(oneCountsInState[j] &lt;= k):</span><br><span class="line">                <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(state)):</span><br><span class="line">                    <span class="comment">#遍历第i-1行</span></span><br><span class="line">                    <span class="comment">#if(oneCountsInState[m] &lt;= k): 这一行加不加都可以</span></span><br><span class="line">                        <span class="keyword">if</span>((state[j] &amp; state[m] ==<span class="number">0</span>) <span class="keyword">and</span> (state[j] &lt;&lt; <span class="number">1</span>) &amp; state[m] == <span class="number">0</span> <span class="keyword">and</span> (state[j] &gt;&gt; <span class="number">1</span>) &amp; state[m] == <span class="number">0</span>):</span><br><span class="line">                            dp[i][j][k] += dp[i-<span class="number">1</span>][m][k-oneCountsInState[j]]</span><br><span class="line"></span><br><span class="line">result = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(state)):</span><br><span class="line">    result += dp[N-<span class="number">1</span>][i][K]</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><ul><li>对于状压dp,都是1 &lt;&lt; N种情况，所以这里就要考虑到，每种情况其实是对应每一行的状态。</li><li>这道题中，对于数据进行了预处理，由于每一行不能有相邻的1,所以要先选出可以被防止在行上的状态，将可以使用的状态放在state数组中，之后采用下标来访问状态。</li><li><code>dp[i][j][k]</code>表示在第i行，防止j号状态的时候，打算一共用k个国王有几种放法</li><li><strong>这道题输入了两个参数，N和K,所以这道题的dp是三维的</strong></li><li>写的的时候先是写的关系，也就是那个四层循环，然后才是写的初始化部分代码，通过相邻的两层之间的关系推出初始化的值</li></ul><h2 id="炮兵阵地"><a href="#炮兵阵地" class="headerlink" title="炮兵阵地"></a><a href="https://www.luogu.com.cn/problem/P2704">炮兵阵地</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">m, n = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().strip().split())</span><br><span class="line">states = []</span><br><span class="line">nums = [<span class="number">0</span>] * (<span class="number">1</span> &lt;&lt; n)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    list1 = <span class="built_in">list</span>(<span class="built_in">input</span>().strip())</span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(list1)):</span><br><span class="line">        <span class="keyword">if</span> (list1[j] == <span class="string">&#x27;H&#x27;</span>):</span><br><span class="line">            num += <span class="number">2</span> ** (<span class="built_in">len</span>(list1) - <span class="number">1</span> - j)</span><br><span class="line">    state = []</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> &lt;&lt; n):</span><br><span class="line">        <span class="keyword">if</span> (k &amp; num) == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 排除在山地放炮兵的情况</span></span><br><span class="line">            <span class="keyword">if</span> (k &amp; (k &lt;&lt; <span class="number">1</span>) == <span class="number">0</span> <span class="keyword">and</span> k &amp; (k &lt;&lt; <span class="number">2</span>) == <span class="number">0</span>):</span><br><span class="line">                <span class="comment"># 排除在同一行的炮兵可以打到对方的情况</span></span><br><span class="line">                state.append(k)</span><br><span class="line">                <span class="comment"># 计算状态k中有多少个1</span></span><br><span class="line">                count = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                    <span class="keyword">if</span> k &amp; (k &lt;&lt; t) != <span class="number">0</span>:</span><br><span class="line">                        count += <span class="number">1</span></span><br><span class="line">                nums[k] = count</span><br><span class="line"></span><br><span class="line">    states.append(state)</span><br><span class="line"></span><br><span class="line">dp = [[[<span class="number">0</span>] * ((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>) <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> &lt;&lt; n)] <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line"><span class="comment"># 如果只有一行</span></span><br><span class="line"><span class="keyword">if</span> (m == <span class="number">1</span>):</span><br><span class="line">    Max = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> states[<span class="number">0</span>]:</span><br><span class="line">        Max = <span class="built_in">max</span>(Max, nums[i])</span><br><span class="line">    <span class="built_in">print</span>(Max)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 初始化第一行</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> states[<span class="number">0</span>]:</span><br><span class="line">        dp[<span class="number">0</span>][s][<span class="number">0</span>] = nums[s]</span><br><span class="line">    <span class="comment"># 初始化第二行</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> states[<span class="number">0</span>]:</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> states[<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">if</span> (s &amp; t == <span class="number">0</span>):</span><br><span class="line">                dp[<span class="number">1</span>][t][s] = nums[s] + nums[t]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, m):</span><br><span class="line">        <span class="comment"># 遍历每一行</span></span><br><span class="line">        <span class="keyword">for</span> cur <span class="keyword">in</span> states[i]:</span><br><span class="line">            <span class="comment"># 每一行的当前状态</span></span><br><span class="line">            <span class="keyword">for</span> pre <span class="keyword">in</span> states[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># 上一行的状态</span></span><br><span class="line">                <span class="keyword">for</span> prepre <span class="keyword">in</span> states[i - <span class="number">2</span>]:</span><br><span class="line">                    <span class="comment"># 上上行的状态</span></span><br><span class="line">                    <span class="keyword">if</span> cur &amp; pre == <span class="number">0</span> <span class="keyword">and</span> cur &amp; prepre == <span class="number">0</span> <span class="keyword">and</span> pre &amp; prepre == <span class="number">0</span>:</span><br><span class="line">                        dp[i % <span class="number">3</span>][cur][pre] = <span class="built_in">max</span>(dp[i % <span class="number">3</span>][cur][pre], dp[(i - <span class="number">1</span>) % <span class="number">3</span>][pre][prepre] + nums[cur])</span><br><span class="line"></span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> states[m - <span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> states[m - <span class="number">2</span>]:</span><br><span class="line">            result = <span class="built_in">max</span>(result, dp[(m - <span class="number">1</span>) % <span class="number">3</span>][i][j])</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><ul><li>原来测了几个都是对的，但是，提交的时候3个过了，剩下的8个全部说是内存超限了，不知道为啥。后来发现是dp太大了，其实要使用滚动数组，也就是dp永远是存储三行。于是有了上面的代码，这样提交发现是4个对，8个左右是错的，也就是Wrong Answer.但是实在找不到哪里错了。同样的逻辑，使用C++就可以AC</li><li>此外，之前我一直以为是输入n个数字，dp就是n+1维的，后来发现不是，这道题虽然输入了N,M（地图不算），但是N，M完全可以是一样 的，但是dp仍然是三维的。其实是更具约束定的，上一题（互不侵犯）每一行只和上一行有关，这是一个约束，还有一个就是行号，而这道题，每一行与之前的两行有关，这是两个约束，加上行好的约束，所以是三维的。</li></ul><h2 id="P1441-砝码称重"><a href="#P1441-砝码称重" class="headerlink" title="P1441 砝码称重"></a><a href="https://www.luogu.com.cn/problem/P1441">P1441 砝码称重</a></h2><p>方法是一定是正确的，但是时间超限。</p><p><code>dp[i][j]</code>表示在状态i，能否表示重量j，状态i用二进制表示，二进制位是1，表示选取这一位的砝码，例如最低位是1表示选取第一个砝码，最高位是1表示选取最后一个砝码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().strip().split())</span><br><span class="line">weight = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().strip().split()))</span><br><span class="line">nums = [<span class="number">0</span>] * (<span class="number">1</span> &lt;&lt; n)  <span class="comment"># 记录每一个状态有几个砝码</span></span><br><span class="line">allWeight =<span class="built_in">sum</span>(weight)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> &lt;&lt; n):</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; j)) != <span class="number">0</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">    nums[i] = count</span><br><span class="line">dp = [[<span class="number">0</span>] * (allWeight + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> &lt;&lt; n)]</span><br><span class="line"><span class="comment">#初始化没有砝码的情况</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(allWeight + <span class="number">1</span>):</span><br><span class="line">    dp[<span class="number">0</span>][i] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">numOfWeights = [<span class="number">0</span>] * (<span class="number">1</span> &lt;&lt; n) <span class="comment">#记录每种状态可以计算几种重量</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">1</span> &lt;&lt; n):</span><br><span class="line">    numOfWeight = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(allWeight + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; k)) != <span class="number">0</span>:</span><br><span class="line">                    w = weight[k]</span><br><span class="line">                    dp[i][w] = <span class="number">1</span></span><br><span class="line">                    dp[i][j] |= dp[i - (<span class="number">1</span> &lt;&lt;k)][j]</span><br><span class="line">                    dp[i][j] |= dp[i-(<span class="number">1</span> &lt;&lt;k)][j-w]</span><br><span class="line">                    <span class="keyword">if</span>(dp[i][j]):</span><br><span class="line">                        numOfWeight += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">    numOfWeights[i] = numOfWeight</span><br><span class="line">remain = n - m</span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> &lt;&lt; n):</span><br><span class="line">    <span class="keyword">if</span>(nums[i] == remain):</span><br><span class="line">        res = <span class="built_in">max</span>(res,numOfWeights[i])</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="蓝桥杯2019年第十届省赛真题-糖果"><a href="#蓝桥杯2019年第十届省赛真题-糖果" class="headerlink" title="蓝桥杯2019年第十届省赛真题-糖果"></a>蓝桥杯2019年第十届省赛真题-糖果</h2><p><strong>python</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和下面C++代码逻辑一样，但是时间超限</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">n,m,k = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">dp = [sys.maxsize <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>( <span class="number">1</span> &lt;&lt; m)]</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">f = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">110</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    list1 = (<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> list1:</span><br><span class="line">        f[i]  = f[i] | (<span class="number">1</span> &lt;&lt; (j-<span class="number">1</span>))</span><br><span class="line">    dp[f[i]] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> &lt;&lt; m):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        dp[s | f[j]] = <span class="built_in">min</span>(dp[s | f[j]],dp[s] + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span>(dp[(<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>] == sys.maxsize):</span><br><span class="line">    <span class="built_in">print</span>(-<span class="number">1</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(dp[(<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>C++</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最好不要用vector，能用数组就不要用vector</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; options;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1</span> &lt;&lt; <span class="number">21</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> maxN = (<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxN; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = <span class="number">110</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; temp;</span><br><span class="line">            f[i] |= (<span class="number">1</span> &lt;&lt; (temp - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        dp[f[i]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt;= maxN; s++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            dp[s | (f[j])] = <span class="built_in">min</span>(dp[s | (f[j])], dp[s] + <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dp[maxN] == <span class="number">110</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; dp[maxN];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>蓝桥杯</title>
      <link href="/%E8%93%9D%E6%A1%A5%E6%9D%AF/index.html"/>
      <url>/%E8%93%9D%E6%A1%A5%E6%9D%AF/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="2021蓝桥杯省赛"><a href="#2021蓝桥杯省赛" class="headerlink" title="2021蓝桥杯省赛"></a>2021蓝桥杯省赛</h2><h3 id="卡片"><a href="#卡片" class="headerlink" title="卡片"></a>卡片</h3><p>本题总分：5分<br>【问题描述】<br>小蓝有很多数字卡片，每张卡片上都是数字0到9</p><p>小蓝准备用这些卡片来拼一些数，他想从1开始拼出正整数，每拼一个，就保存起来，卡片就不能用来拼其它数了。</p><p>小蓝想知道自己能从1拼到多少。</p><p>例如，当小蓝有30张卡片，其中0到9各3张，则小蓝可以拼出1到10,但是拼11时卡片1已经只有一张了，不够拼出11</p><p>现在小蓝手里有0到9的卡片各2021张，共20210张，请问小蓝可以从1拼到多少？</p><p>提示：建议使用计算机编程解决问题。</p><p><span id="string/listBack"><strong>【string和list的转换】</strong></span>  <a href="#string/list">总结</a></p><p><span id="字符和整型的转换back"><strong>【字符和整型的转换】</strong></span>  <a href="#字符和整型的转换">总结</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">1</span></span><br><span class="line">numlist = [<span class="number">2021</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    flag = <span class="literal">True</span></span><br><span class="line">    list1 = <span class="built_in">list</span>(<span class="built_in">str</span>(num))</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> list1:</span><br><span class="line">        numlist[<span class="built_in">int</span>(n)] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span>(numlist[<span class="built_in">int</span>(n)]&lt;<span class="number">0</span>):</span><br><span class="line">            flag = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">not</span> flag):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    num += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(num - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3181</span></span><br></pre></td></tr></table></figure><h3 id="直线"><a href="#直线" class="headerlink" title="直线"></a>直线</h3><p>本题总分：5分<br>【问题描述】<br>在平面直角坐标系中，两点可以确定一条直线。如果有多点在一条直线上，那么这些点中任意两点确定的直线是同一条。</p><p>给定平面上2×3个整点{ ( x , y ) | 0 ≤ x &lt; 2 , 0 ≤ y &lt; 3 , x ∈ Z , y ∈ Z } , 即横坐标是0到1(包含0和1)之间的整数、纵坐标是0到2(包含0和2)之间的整数的点。这些点一共确定了11条不同的直线。</p><p>给定平面上20×21个整点{ ( x , y ) | 0 ≤ x &lt; 20 , 0 ≤ y &lt; 21 , x ∈ Z , y ∈ Z},即横坐标是0到19(包含0和19)之间的整数、纵坐标是0到20(包含0和20)之间的整数的点。请问这些点一共确定了多少条不同的直线。</p><p><strong>【暴力求解/set的使用】</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">set1 = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x1 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">    <span class="keyword">for</span> x2 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">        <span class="keyword">for</span> y1 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">21</span>):</span><br><span class="line">            <span class="keyword">for</span> y2 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">21</span>):</span><br><span class="line">                <span class="keyword">if</span>(x1 != x2 <span class="keyword">and</span> y1 != y2):</span><br><span class="line">                    k = (y2 - y1) / (x2 - x1)</span><br><span class="line">                    <span class="comment"># b = (y1 - ((y2 - y1) / (x2 - x1)*x1)) 不能这这样写，因为y1 - k*x1这样会造成精确度的问题</span></span><br><span class="line">                    b = ((y1 * x2) - (y2 * x1))/(x2 - x1)</span><br><span class="line">                    set1.add((k, b))</span><br><span class="line">                    </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(set1) + <span class="number">41</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 40257</span></span><br></pre></td></tr></table></figure><h3 id="货物摆放"><a href="#货物摆放" class="headerlink" title="货物摆放"></a>货物摆放</h3><p>本题总分：10分<br>【问题描述】<br>小蓝有一个超大的仓库，可以摆放很多货物。</p><p>现在，小蓝有n箱货物要摆放在仓库，每箱货物都是规则的正方体。小蓝规定了长、宽、高三个互相垂直的方向，每箱货物的边都必须严格平行于长、宽、高。</p><p>小蓝希望所有的货物最终摆成一个大的立方体。即在长、宽、高的方向上分别堆L、W、H的货物，满足n=L×W×H</p><p>给定n,请问有多少种堆放货物的方案满足要求。</p><p>例如，当n=4时，有以下6种方案：1×1×4、1×2×2、1×4×1、2×1×2、2×2×1、4×1×1</p><p>请问，当n=2021041820210418(注意有16位数字)时，总共有多少种方案？</p><p>提示：建议使用计算机编程解决问题。</p><p><strong>【计算所有因子的简便方法】</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 超时</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">list1 = []</span><br><span class="line">res =<span class="built_in">set</span>()</span><br><span class="line"><span class="comment"># 计算公约数太费劲了</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> (n % i == <span class="number">0</span>):</span><br><span class="line">        list1.append(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list1:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> list1:</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> list1:</span><br><span class="line">            <span class="keyword">if</span> (i * j * k) == n:</span><br><span class="line">                res.add((i,j,k))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(res))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 超时</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">list1 = []</span><br><span class="line">res =<span class="built_in">set</span>()</span><br><span class="line"><span class="comment"># 记住这种方法</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">int</span>(<span class="built_in">pow</span>(n,<span class="number">0.5</span>)) + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> (n % i == <span class="number">0</span>):</span><br><span class="line">        list1.append(i)</span><br><span class="line">        list1.append(n // i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list1:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> list1:</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> list1:</span><br><span class="line">            <span class="keyword">if</span> (i * j * k) == n:</span><br><span class="line">                res.add((i,j,k))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(res))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2430</span></span><br></pre></td></tr></table></figure><h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><p>本题总分：10分<br>【问题描述】 </p><p>小蓝学习了最短路径之后特别高兴，他定义了一个特别的图，希望找到图中的最短路径。</p><p>小蓝的图由2021个结点组成，依次编号1至2021</p><p>对于两个不同的结点a,b,如果a和b的差的绝对值大于21,则两个结点之间没有边相连；如果a和b的差的绝对值小于等于21,则两个点之间有一条长度为a和b的最小公倍数的无向边相连。</p><p>例如：结点1和结点23之间没有边相连；结点3和结点24之间有一条无向边，长度为24;结点15和结点25之间有一条无向边，长度为75.</p><p>请计算，结点1和结点2021之间的最短路径长度是多少。</p><p>提示：建议使用计算机编程解决问题。</p><p><strong>【动态规划】</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">list1 = [sys.maxsize <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2021</span>+<span class="number">1</span>)] <span class="comment">#list1[i] 表示从1节点到i节点的最短路径</span></span><br><span class="line">list1[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">list1[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calBeishu</span>(<span class="params">m,n</span>):</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">abs</span>(m-n) &gt; <span class="number">21</span>):</span><br><span class="line">        <span class="keyword">return</span> sys.maxsize</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(m*n/math.gcd(m,n))</span><br><span class="line"></span><br><span class="line"><span class="comment">#当节点i小于22时，1节点到这个节点的最短路径就是1*i</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">23</span>):</span><br><span class="line">    list1[i] = i</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">23</span>, <span class="number">2022</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i-<span class="number">21</span>, i):</span><br><span class="line">        list1[i] = <span class="built_in">min</span>(list1[i], list1[j] + calBeishu(j,i))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(list1[<span class="number">2021</span>])</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 10266837</span></span><br></pre></td></tr></table></figure><h3 id="回路计算"><a href="#回路计算" class="headerlink" title="回路计算"></a>回路计算</h3><p>本题总分：15分<br>【问题描述】</p><p>蓝桥学院由21栋教学楼组成，教学楼编号1到21。对于两栋教学楼a和b,当a和b互质时，a和b之间有一条走廊直接相连，两个方向皆可通行，否则没有直接连接的走廊。</p><p>小蓝现在在第一栋教学楼，他想要访问每栋教学楼正好一次，最终回到第一栋教学楼（即走一条哈密尔顿回路），请问他有多少种不同的访问方案？两个访问方案不同是指存在某个i,小蓝在两个访问方法中访问完教学楼i后访问了不同的教学楼。</p><p>提示：建议使用计算机编程解决问题。</p><p><strong>【动态规划/状压dp】</strong> <a href="https://hasuer.github.io/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp/index.html#/%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98%EF%BC%88%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%AF%EF%BC%89">更多例题</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">hasRoad = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span>(i != j):</span><br><span class="line">            <span class="keyword">if</span> math.gcd(i+<span class="number">1</span>,j + <span class="number">1</span>) == <span class="number">1</span>: <span class="comment">#注意这个gcd函数</span></span><br><span class="line">                hasRoad[i][j] = <span class="number">1</span></span><br><span class="line">                hasRoad[j][i] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> &lt;&lt; n)]</span><br><span class="line">dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>&lt;&lt;n): <span class="comment"># 取状态s</span></span><br><span class="line">    <span class="keyword">for</span> u <span class="keyword">in</span> <span class="built_in">range</span>(n): <span class="comment">#取起点</span></span><br><span class="line">        <span class="keyword">if</span> s &amp; (<span class="number">1</span> &lt;&lt; u) != <span class="number">0</span>: <span class="comment">#节点u以及被遍历，注意这里只能写 !=0 不能写成==1</span></span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">range</span>(n): <span class="comment"># 终点v</span></span><br><span class="line">                <span class="comment"># 终点v也已经被遍历并且uv之间有道路</span></span><br><span class="line">                <span class="keyword">if</span> s &amp; (<span class="number">1</span> &lt;&lt; v) != <span class="number">0</span> <span class="keyword">and</span> hasRoad[u][v]: </span><br><span class="line">                    dp[s][v] += dp[s - (<span class="number">1</span> &lt;&lt; v)][u]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>])- dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 881012367360</span></span><br></pre></td></tr></table></figure><p><code>dp[s][v]</code><strong>表示达到状态是s,并且站在节点v上的情况有几种</strong>。说明节点v包含在状态v中。由于一开始也是就遍历的节点0，所以需要知道的是，最后会停留在除了0号节点的一个节点，倘若这个节点和0号节点有路（也就是1号楼，根据题目，一号楼和所有的楼都有路），那么就把他们相加，也就是<code>dp[1 &lt;&lt; 21 - 1][1]+ ...dp[1 &lt;&lt; 21 - 1][20]</code></p><h3 id="时间显示"><a href="#时间显示" class="headerlink" title="时间显示"></a>时间显示</h3><p>时间限制：1.0s内存限制：256.0MB本题总分：15分</p><p>【问题描述】</p><p>小蓝要和朋友合作开发一个时间显示的网站。在服务器上，朋友已经获取了当前的时间，用一个整数表示，值为从1970年1月1日00:00:00到当前时刻经过的毫秒数。</p><p>现在，小蓝要在客户端显示出这个时间。小蓝不用显示出年月日，只需要显示出时分秒即可，毫秒也不用显示，直接舍去即可。</p><p>给定一个用整数表示的时间，请将这个时间对应的时分秒输出。</p><p>【输入格式】</p><p>输入一行包含一个整数，表示时间。</p><p>【输出格式】</p><p>输出时分秒表示的当前时间，格式形如HH:MM:SS,其中H表示时，值为0到23,MM表示分，值为0到59,SS表示秒，值为0到59时、分、秒不足两位时补前导0</p><p>[样例输入1]</p><p>46800999</p><p>[样例输出1]</p><p>13:00:00</p><p>[样例输入2]</p><p>1618708103123</p><p>[样例输出2]</p><p>01:08:23</p><p><span id="time库的使用back"><strong>【time库的使用】</strong></span>  <a href="#time库的使用">总结</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 涉及到时间的题目不需要考虑时区的问题</span></span><br><span class="line"><span class="comment"># 正确100</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="built_in">print</span>(time.ctime(n//<span class="number">1000</span>))</span><br><span class="line"><span class="built_in">print</span>(new_n[<span class="number">11</span>:<span class="number">19</span>])</span><br></pre></td></tr></table></figure><h3 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h3><p>时间限制：1.0s内存限制：256.0MB本题总分：20分</p><p>【问题描述】</p><p>下面的图形是著名的杨辉三角形：</p><p><img src="/%E8%93%9D%E6%A1%A5%E6%9D%AF/index/1_1.png"></p><p>如果我们按从上到下、从左到右的顺序把所有数排成一列，可以得到如下数列：</p><p>1,1,1,1,2,1,1,3,3,1,1,4,6,4,1,</p><p>给定一个正整数N,请你输出数列中第一次出现N是在第几个数？</p><p>【输入格式】</p><p>输入一个整数N.</p><p>【输出格式】</p><p>输出一个整数代表答案。</p><p>【样例输入】</p><p>6</p><p>【样例输出】</p><p>13</p><p><strong>【暴力解法】</strong></p><p>&lt;span id = “排列组合的计算back’’&gt; <strong>【拓展：排列组合的计算】</strong>&lt;/span&gt; </p><p><span id="排列组合的计算back"><strong>【拓展：排列组合的计算】</strong></span>  <a href="#排列组合的计算">总结</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 时间超限45</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_n</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    res = <span class="number">3</span>  <span class="comment"># 已计算过的个数</span></span><br><span class="line">    li, line = [<span class="number">1</span>, <span class="number">2</span>], <span class="number">3</span>  <span class="comment"># 将要进行比对的行的元素及其行数</span></span><br><span class="line">    <span class="comment"># 奇数行存的是前一半加上中间</span></span><br><span class="line">    <span class="comment"># 偶数行存的是前一半加上下一个</span></span><br><span class="line">    <span class="keyword">while</span> n <span class="keyword">not</span> <span class="keyword">in</span> li:</span><br><span class="line">        res += <span class="built_in">len</span>(li) * <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> (line % <span class="number">2</span> == <span class="number">0</span>):</span><br><span class="line">            res -= <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res -= <span class="number">1</span></span><br><span class="line">        line += <span class="number">1</span></span><br><span class="line">        li = [<span class="number">1</span>] + [li[i] + li[i + <span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li) - <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">if</span> (line % <span class="number">2</span> == <span class="number">0</span>):</span><br><span class="line">            li += [li[-<span class="number">1</span>]]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> res + li.index(n) + <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(find_n(n))</span><br></pre></td></tr></table></figure><h3 id="左孩子右兄弟"><a href="#左孩子右兄弟" class="headerlink" title="左孩子右兄弟"></a>左孩子右兄弟</h3><p>时间限制：1.0s内存限制：256.0MB本题总分：20分</p><p>【问题描述】</p><p>对于一棵多叉树，我们可以通过“左孩子右兄弟”表示法，将其转化成一棵二叉树。</p><p>如果我们认为每个结点的子结点是无序的，那么得到的二叉树可能不唯一。换句话说，每个结点可以选任意子结点作为左孩子，并按任意顺序连接右兄弟。</p><p>给定一棵包含N个结点的多叉树，结点从1至N编号，其中1号结点是根，每个结点的父结点的编号比自己的编号小。请你计算其通过“左孩子右兄弟”表示法转化成的二叉树，高度最高是多少。注：只有根结点这一个结点的树高度为0。</p><p>例如如下的多叉树：</p><p><img src="/%E8%93%9D%E6%A1%A5%E6%9D%AF/index/1_3.png"></p><p>可能有以下3种(这里只列出3种，并不是全部)不同的“左孩子右兄弟”表示：</p><p><img src="/%E8%93%9D%E6%A1%A5%E6%9D%AF/index/1_4.png"></p><p>其中最后一种高度最高，为4</p><p>【输入格式】</p><p>输入的第一行包含一个整数N。</p><p>以下N-1行，每行包含一个整数，依次表示2至N号结点的父结点编号。</p><p>【输出格式】</p><p>输出一个整数表示答案。</p><p>【样例输入】</p><p>5<br>1<br>1<br>1<br>2</p><p>【样例输出】</p><p>4</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 时间超限73</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">childList = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">parentList = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line">    parent = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    parentList[i + <span class="number">2</span>] = parent</span><br><span class="line">    childList[parent].append(i+<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">len</span>(childList[n]) == <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> childList[n]:</span><br><span class="line">        res = <span class="built_in">max</span>(res,cal(i))</span><br><span class="line">    <span class="keyword">return</span> res + <span class="built_in">len</span>(childList[n])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(cal(<span class="number">1</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="异或数列"><a href="#异或数列" class="headerlink" title="异或数列"></a>异或数列</h3><p>时间限制：1.0s内存限制：256.0MB本题总分：20分</p><p>【问题描述】</p><p>Alice和Bob正在玩一个异或数列的游戏。初始时， Alice和Bob分别有一个整数a和b（a和b初始都为0）,有一个给定的长度为n的公共数列<script type="math/tex">\pi</script></p><p>Alice和Bob轮流操作， Alice先手，每步可以在以下两种选项中选一种：<br>选项1:从数列中选一个X给 Alice的数异或上，或者说令a变为$a⊕X_i$ （其中⊕表示按位异或）</p><p>选项2:从数列中选一个X给Bob的数异或上，或者说令b变为$b⊕X_i $</p><p>每个数$X_i$ 都只能用一次，当所有$X_i$ 均被使用后(n轮后)游戏结束。游戏结束时，拥有的数比较大的一方获胜，如果双方数值相同，即为平手。现在双方都足够聪明，都采用最优策略，请问谁能获胜？</p><p>【输入格式】</p><p>每个评测用例包含多组询问。询问之间彼此独立。</p><p>输入的第一行包含一个整数T,表示询问数。</p><p>接下来T行每行包含一组询问。其中第i行的第一个整数$n_i$</p><p> 表示数列长度，随后$n_i $</p><p> 个整数$X_1 , X_2 , X _3 , . . . , X n i $表示数列中的每个数。</p><p>【输出格式】</p><p>输出T行，依次对应每组询问的答案。</p><p>每行包含一个整数1、0或-1分别表示 Alice胜、平局或败。</p><p>【样例输入】</p><p>4<br>1 1<br>1 0<br>2 2 1<br>7 992438 1006399 781139 985280 4729 872779 563580</p><p>【样例输出】<br>1<br>0<br>1<br>1</p><p>【评测用例规模与约定】</p><p>对于所有评测用例，1≤T≤200000, $1 &lt;= \sum_{i=1}^{T}n_i &lt;= 200000 0 &lt;= X_i &lt;= 2^{20}$ </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 时间超限67</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    line = <span class="built_in">input</span>()</span><br><span class="line">    list1 = line.split()</span><br><span class="line">    count = <span class="built_in">int</span>(list1[<span class="number">0</span>])</span><br><span class="line">    nums = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">22</span>)]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> list1[<span class="number">1</span>:]:</span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">22</span>):</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">int</span>(j) &amp; (<span class="number">1</span> &lt;&lt; m)) != <span class="number">0</span>:</span><br><span class="line">                nums[m] += <span class="number">1</span></span><br><span class="line">    flag = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">21</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span>(nums[k] % <span class="number">2</span> == <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># nums[m]是奇数</span></span><br><span class="line">        <span class="keyword">if</span>(nums[k] == <span class="number">1</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;1&quot;</span>) <span class="comment">#先手赢</span></span><br><span class="line">            flag = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span>((count - nums[k]) % <span class="number">2</span> == <span class="number">0</span>):</span><br><span class="line">            <span class="comment"># 有偶数个0 ，奇数个1</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">            flag = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 有奇数个0 ，奇数个1</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;-1&quot;</span>)</span><br><span class="line">            flag = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">not</span> flag):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;0&quot;</span>)</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/m0_49924838/article/details/122796494">网上解答</a></p><h3 id="括号序列"><a href="#括号序列" class="headerlink" title="括号序列"></a><strong>括号序列</strong></h3><p>时间限制：1.0s内存限制：256.0MB本题总分：25分</p><p>【问题描述】</p><p>给定一个括号序列，要求尽可能少地添加若干括号使得括号序列变得合法，当添加完成后，会产生不同的添加结果，请问有多少种本质不同的添加结果。两个结果是本质不同的是指存在某个位置一个结果是左括号，而另一个是右括号。</p><p>例如，对于括号序列(（（）,只需要添加两个括号就能让其合法，有以下几种不同的添加结果：（）（）（）、（）(（）)、(（）)（）、(（）（）)和(（（）））。</p><p>【输入格式】</p><p>输入一行包含一个字符串s,表示给定的括号序列，序列中只有左括号和右括号。</p><p>【输出格式】</p><p>输出一个整数表示答案，答案可能很大，请输出答案除以1000000007(即1 0 9 10^910<br>9<br> +7)的余数。</p><p>【样例输入】</p><p>（（（）</p><p>【样例输出】</p><p>5</p><p>【评测用例规模与约定】</p><p>对于40%的评测用例，|s|≤200</p><p>对于所有评测用例，1≤|s|≤5000</p><p><strong>不会做，解法：<a href="https://www.bilibili.com/video/BV1fv411L78t?p=3&amp;t=1318">视频</a>，最后1p讲的就是这道题</strong></p><h2 id="2020蓝桥杯省赛"><a href="#2020蓝桥杯省赛" class="headerlink" title="2020蓝桥杯省赛"></a>2020蓝桥杯省赛</h2><h3 id="门牌制作"><a href="#门牌制作" class="headerlink" title="门牌制作"></a>门牌制作</h3><p>本题总分：5 分<br>【问题描述】<br>小蓝要为一条街的住户制作门牌号。<br>这条街一共有 2020 位住户，门牌号从 1 到 2020 编号。<br>小蓝制作门牌的方法是先制作 0 到 9 这几个数字字符，最后根据需要将字符粘贴到门牌上，例如门牌 1017 需要依次粘贴字符 1、0、1、7，即需要 1 个字符 0，2 个字符 1，1 个字符 7。<br>请问要制作所有的 1 到 2020 号门牌，总共需要多少个字符 2？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">2021</span>):</span><br><span class="line">    num += <span class="built_in">str</span>(i).count(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output: 624</span></span><br></pre></td></tr></table></figure><h3 id="寻找2020"><a href="#寻找2020" class="headerlink" title="寻找2020"></a>寻找2020</h3><p>本题总分：5 分<br>【问题描述】<br>小蓝有一个数字矩阵，里面只包含数字 0 和 2。<br>小蓝很喜欢 2020，他想找到这个数字矩阵中有多少个 2020 。<br>小蓝只关注三种构成 2020 的方式：<br>• 同一行里面连续四个字符从左到右构成 2020。<br>• 同一列里面连续四个字符从上到下构成 2020。<br>• 在一条从左上到右下的斜线上连续四个字符，从左上到右下构成 2020。<br>例如，对于下面的矩阵：<br>220000<br>000000<br>002202<br>000000<br>000022<br>002020<br>一共有 5 个 2020。其中 1 个是在同一行里的，1 个是在同一列里的，3 个是斜线上的。<br>小蓝的矩阵比上面的矩阵要大，由于太大了，他只好将这个矩阵放在了一个文件里面，在试题目录下有一个文件 2020.txt，里面给出了小蓝的矩阵。<br>请帮助小蓝确定在他的矩阵中有多少个 2020。</p><p><span id="文件输入输出back">【文件输入输出】</span> <a href="#文件输入输出">总结</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;2020.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">lists = []</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">    lists.append(<span class="built_in">list</span>(line.strip()))</span><br><span class="line"></span><br><span class="line">num  =<span class="number">0</span> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lists)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lists[<span class="number">0</span>])-<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">if</span>(lists[i][j] == <span class="string">&#x27;2&#x27;</span> <span class="keyword">and</span> lists[i][j+<span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span> <span class="keyword">and</span> lists[i][j+<span class="number">2</span>] == <span class="string">&#x27;2&#x27;</span> <span class="keyword">and</span> lists[i][j+<span class="number">3</span>] == <span class="string">&#x27;0&#x27;</span>):</span><br><span class="line">           num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lists)-<span class="number">3</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lists[<span class="number">0</span>])):</span><br><span class="line">        <span class="keyword">if</span>(lists[i][j] == <span class="string">&#x27;2&#x27;</span> <span class="keyword">and</span> lists[i+<span class="number">1</span>][j] == <span class="string">&#x27;0&#x27;</span> <span class="keyword">and</span> lists[i+<span class="number">2</span>][j] == <span class="string">&#x27;2&#x27;</span> <span class="keyword">and</span> lists[i+<span class="number">3</span>][j] == <span class="string">&#x27;0&#x27;</span>):</span><br><span class="line">           num += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lists)-<span class="number">3</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lists[<span class="number">0</span>])-<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">if</span>(lists[i][j] == <span class="string">&#x27;2&#x27;</span> <span class="keyword">and</span> lists[i+<span class="number">1</span>][j+<span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span> <span class="keyword">and</span> lists[i+<span class="number">2</span>][j+<span class="number">2</span>] == <span class="string">&#x27;2&#x27;</span> <span class="keyword">and</span> lists[i+<span class="number">3</span>][j+<span class="number">3</span>] == <span class="string">&#x27;0&#x27;</span>):</span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure><h3 id="跑步训练"><a href="#跑步训练" class="headerlink" title="跑步训练"></a>跑步训练</h3><p>本题总分：10 分<br>【问题描述】<br>小蓝每天都锻炼身体。<br>正常情况下，小蓝每天跑 1 千米。<br>如果某天是周一或者月初（1 日），为了激励自己，小蓝要跑2千米。如果同时是周一或月初，小蓝也是跑2千米。<br>小蓝跑步已经坚持了很长时间，从2000年1月1日周六（含）到2020年10月1日周四（含）。<br>请问这段时间小蓝总共跑步多少千米？</p><p><strong>【datetime库使用】查看帮助文档</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">num = <span class="number">0</span></span><br><span class="line">start = datetime.date(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">end = datetime.date(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">day = start</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">if</span>(day.weekday() == <span class="number">0</span>):</span><br><span class="line">        num += <span class="number">2</span></span><br><span class="line">    <span class="keyword">elif</span> day.day == <span class="number">1</span>:</span><br><span class="line">        num += <span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">    day += datetime.timedelta(days=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span>(day == end):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8879</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">start = datetime.date(<span class="number">2000</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">end = datetime.date(<span class="number">2020</span>,<span class="number">10</span>,<span class="number">1</span>)</span><br><span class="line">days = datetime.timedelta(days=<span class="number">1</span>)  <span class="comment"># 用以可用于计算的一天  timedelta代表两个时间之间的时间差</span></span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> start &lt;= end:</span><br><span class="line">    <span class="keyword">if</span> start.day == <span class="number">1</span> <span class="keyword">or</span> start.weekday() == <span class="number">0</span>:</span><br><span class="line">        res += <span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        res += <span class="number">1</span></span><br><span class="line">    start += days</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output: 8879</span></span><br></pre></td></tr></table></figure><h3 id="蛇形填空"><a href="#蛇形填空" class="headerlink" title="蛇形填空"></a>蛇形填空</h3><p>本题总分：10 分<br>【问题描述】<br>如下图所示，小明用从1开始的正整数“蛇形”填充无限大的矩阵。<br>1 2 6 7 15 …<br>3 5 8 14 …<br>4 9 13 …<br>10 12 …<br>11 …<br>…<br>容易看出矩阵第二行第二列中的数是 5。<br>请你计算矩阵中第 20 行第 20 列的数是多少？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数学问题，找规律求解，没有编程</span></span><br><span class="line"><span class="comment"># 761</span></span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>本题总分：15 分<br>【问题描述】<br>小蓝最近学习了一些排序算法，其中冒泡排序让他印象深刻。<br>在冒泡排序中，每次只能交换相邻的两个元素。<br>小蓝发现，如果对一个字符串中的字符排序，只允许交换相邻的两个字符，则在所有可能的排序方案中，冒泡排序的总交换次数是最少的。<br>例如，对于字符串 lan 排序，只需要 1 次交换。<br>对于字符串 qiao 排序，总共需要 4 次交换。<br>小蓝找到了很多字符串试图排序，他恰巧碰到一个字符串，需要 100 次交换，可是他忘了吧这个字符串记下来，现在找不到了。<br>请帮助小蓝找一个只包含小写英文字母且没有字母重复出现的字符串，对该串的字符排序，正好需要 100 次交换。<br>如果可能找到多个，请告诉小蓝最短的那个。<br>如果最短的仍然有多个，请告诉小蓝字典序最小的那个。<br>请注意字符串中可以包含相同的字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># jonmlkihgfedcba</span></span><br></pre></td></tr></table></figure><blockquote><p>一段字符串两两交换，使得其成为正序。只有当且仅当其刚好为反序的时候交换次数最多。<br>而通过计算也可以知道当字符串有15个字符且各不相同的时候交换次数为105次，也即：onmlkjighfedecba，当字符串不到15个字符的时候交换次数是绝对到不了100次的。因为题目要求字典序最小的字符串，所以将’j’提至最前刚好满足100次，即答案为：jonmlkihgfedcba。</p></blockquote><h3 id="成绩统计"><a href="#成绩统计" class="headerlink" title="成绩统计"></a>成绩统计</h3><p>时间限制: 1.0s 内存限制: 512.0MB 本题总分：15 分<br>【问题描述】<br>小蓝给学生们组织了一场考试，卷面总分为 100 分，每个学生的得分都是一个 0 到 100 的整数。<br>如果得分至少是 60 分，则称为及格。如果得分至少为 85 分，则称为优秀。<br>请计算及格率和优秀率，用百分数表示，百分号前的部分四舍五入保留整数。<br>【输入格式】<br>输入的第一行包含一个整数 n，表示考试人数。<br>接下来 n 行，每行包含一个 0 至 100 的整数，表示一个学生的得分。<br>【输出格式】<br>输出两行，每行一个百分数，分别表示及格率和优秀率。<br>百分号前的部分四舍五入保留整数。<br>【样例输入】<br>7<br>80<br>92<br>56<br>74<br>88<br>100<br>0<br>【样例输出】<br>71%<br>43%</p><p><span id="格式化输出back"><strong>【格式化输出】</strong></span> <a href="#格式化输出">总结</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#正确100</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">jige = <span class="number">0</span></span><br><span class="line">youxiu = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    score = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    <span class="keyword">if</span>( score &gt;= <span class="number">60</span>):</span><br><span class="line">        jige += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span>(score &gt;= <span class="number">85</span>):</span><br><span class="line">        youxiu += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;:.0f&#125;%&#x27;</span>.<span class="built_in">format</span>(jige/n * <span class="number">100</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;:.0f&#125;%&#x27;</span>.<span class="built_in">format</span>(youxiu/n * <span class="number">100</span>))</span><br><span class="line"><span class="comment"># print(&#x27;%.0f&#x27;%(jige/n * 100)+&#x27;%&#x27;) 这样也可以</span></span><br></pre></td></tr></table></figure><h3 id="单词分析"><a href="#单词分析" class="headerlink" title="单词分析"></a>单词分析</h3><p>时间限制: 1.0s 内存限制: 512.0MB 本题总分：20 分<br>【问题描述】<br>小蓝正在学习一门神奇的语言，这门语言中的单词都是由小写英文字母组成，有些单词很长，远远超过正常英文单词的长度。小蓝学了很长时间也记不住一些单词，他准备不再完全记忆这些单词，而是根据单词中哪个字母出现得最多来分辨单词。<br>现在，请你帮助小蓝，给了一个单词后，帮助他找到出现最多的字母和这个字母出现的次数。<br>【输入格式】<br>输入一行包含一个单词，单词只由小写英文字母组成。<br>【输出格式】<br>输出两行，第一行包含一个英文字母，表示单词中出现得最多的字母是哪个。<br>如果有多个字母出现的次数相等，输出字典序最小的那个。<br>第二行包含一个整数，表示出现得最多的那个字母在单词中出现的次数。<br>【样例输入】<br>lanqiao<br>【样例输出】<br>a<br>2<br>【样例输入】<br>longlonglongistoolong<br>【样例输出】<br>o<br>6<br>【评测用例规模与约定】<br>对于所有的评测用例，输入的单词长度不超过 1000。</p><p><span id="对象排序back"> <strong>【对象排序】</strong></span> <a href="#对象排序">总结</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正确100</span></span><br><span class="line">string = <span class="built_in">input</span>()</span><br><span class="line">maxChar = <span class="string">&#x27;z&#x27;</span></span><br><span class="line">maxNum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> string:</span><br><span class="line">    count = string.count(i)</span><br><span class="line">    <span class="keyword">if</span>(count &gt; maxNum):</span><br><span class="line">        maxNum = count</span><br><span class="line">        maxChar = i</span><br><span class="line">    <span class="keyword">if</span>(count == maxNum):</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">ord</span>(i) &lt; <span class="built_in">ord</span>(maxChar)):</span><br><span class="line">            maxChar = i</span><br><span class="line"><span class="built_in">print</span>(maxChar)</span><br><span class="line"><span class="built_in">print</span>(maxNum)</span><br></pre></td></tr></table></figure><h3 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h3><p>时间限制: 1.0s 内存限制: 512.0MB 本题总分：20 分<br>【问题描述】<br>上图给出了一个数字三角形。<br>从三角形的顶部到底部有很多条不同的路径。<br>对于每条路径，把路径上面的数加起来可以得到一个和，你的任务就是找到最大的和。<br>路径上的每一步只能从一个数走到下一层和它最近的左边的那个数或者右边的那个数。<br>此外，向左下走的次数与向右下走的次数相差不能超过 1。<br>【输入格式】<br>输入的第一行包含一个整数 N (1 &lt; N ≤ 100)，表示三角形的行数。<br>下面的N 行给出数字三角形。<br>数字三角形上的数都是 0 至 100 之间的整数。<br>【输出格式】<br>输出一个整数，表示答案。<br>【样例输入】<br>5<br>7<br>3 8<br>8 1 0<br>2 7 4 4<br>4 5 2 6 5<br>【样例输出】<br>27</p><p><strong>【动态规划】</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正确100</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">a = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    a[i] = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line"></span><br><span class="line">dp = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = a[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span>):</span><br><span class="line">            <span class="comment"># 最左边由右上得来</span></span><br><span class="line">            dp[i][j] = dp[i-<span class="number">1</span>][j] + a[i][j]</span><br><span class="line">        <span class="keyword">if</span>(j == i):</span><br><span class="line">            <span class="comment"># 最右边由左上得来</span></span><br><span class="line">            dp[i][j] = dp[i-<span class="number">1</span>][j - <span class="number">1</span>] + + a[i][j]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][j-<span class="number">1</span>], dp[i-<span class="number">1</span>][j]) + a[i][j]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( n % <span class="number">2</span> ==<span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">max</span>(dp[n-<span class="number">1</span>][<span class="built_in">int</span>(n/<span class="number">2</span>) - <span class="number">1</span>], dp[n-<span class="number">1</span>][<span class="built_in">int</span>(n/<span class="number">2</span>)])) <span class="comment">#下标要取整</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(dp[n-<span class="number">1</span>][math.floor(n/<span class="number">2</span>)])</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>思路分析：</p><p>1.循环遍历</p><p>遇到金字塔形状数据，先构建二重for循环，遍历每个数，进行求和计算O(∩_∩)O</p><p>2.递推公式</p><p>求和一共三种情况：元素在 最左边 or 中间 or 最右边</p><p>3.打印答案</p><p>最后打印需要分类讨论，奇数和偶数。</p><p>因为题目中要求：”向左下走的次数与向右下走的次数相差不能超过1“</p><p>按这个规则自己走一下，会发现答案必然落在中间。</p><p>如果n为奇数时，最后必然走到倒数第一行中间的数 <code>a[-1][n//2]</code><br>而如果n为偶数时，则取中间两个数的最大值 <code>max(a[-1][n//2-1],a[-1][n//2])</code></p></blockquote><h3 id="平面切分"><a href="#平面切分" class="headerlink" title="平面切分"></a>平面切分</h3><p>时间限制: 1.0s 内存限制: 512.0MB 本题总分：25 分<br>【问题描述】<br>平面上有 N 条直线，其中第 i 条直线是 y = Ai · x + Bi。<br>请计算这些直线将平面分成了几个部分。<br>【输入格式】<br>第一行包含一个整数 N。<br>以下 N 行，每行包含两个整数 Ai, Bi。<br>【输出格式】<br>一个整数代表答案。<br>【样例输入】<br>3<br>1 1<br>2 2<br>3 3<br>【样例输出】<br>6<br>【评测用例规模与约定】<br>对于 50% 的评测用例，1 ≤ N ≤ 4, −10 ≤ Ai, Bi ≤ 10。<br>对于所有评测用例，1 ≤ N ≤ 1000, −100000 ≤ Ai, Bi ≤ 100000。</p><p>思路：初始时一条线只有分为两个部分，之后添加一条线l可能和之前的图形有交点，线l上有n个节点，就增加（n + 1）个部分，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正确100</span></span><br><span class="line">k = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">res = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">lines = [] <span class="comment">#存放已经处理的直线</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">    a1,b1 = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    <span class="keyword">if</span>((a1,b1) <span class="keyword">not</span> <span class="keyword">in</span> lines): <span class="comment">#排除已经出现过的直线</span></span><br><span class="line">        nodes = <span class="built_in">set</span>() <span class="comment">#存放交点</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            a2 = line[<span class="number">0</span>] <span class="comment">#斜率</span></span><br><span class="line">            b2 = line[<span class="number">1</span>] <span class="comment">#截距</span></span><br><span class="line">            <span class="keyword">if</span>(a1 != a2):</span><br><span class="line">                <span class="comment"># 不平行</span></span><br><span class="line">                x = (b2 - b1)/(a1-a2)</span><br><span class="line">                y = (a1*b2 - a2*b1)/(a1-a2)</span><br><span class="line">                nodes.add((x,y))</span><br><span class="line">        lines.append((a1,b1))  </span><br><span class="line">        res += (<span class="built_in">len</span>(nodes) +<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="装饰珠"><a href="#装饰珠" class="headerlink" title="装饰珠"></a>装饰珠</h3><p>时间限制: 1.0s 内存限制: 512.0MB 本题总分：25 分<br>【问题描述】<br>在怪物猎人这一款游戏中，玩家可以通过给装备镶嵌不同的装饰珠来获取相应的技能，以提升自己的战斗能力。<br>已知猎人身上一共有 6 件装备，每件装备可能有若干个装饰孔，每个装饰孔有各自的等级，可以镶嵌一颗小于等于自身等级的装饰珠 (也可以选择不镶嵌)。<br>装饰珠有 M 种，编号 1 至 M，分别对应 M 种技能，第 i 种装饰珠的等级为 Li，只能镶嵌在等级大于等于 Li 的装饰孔中。<br>对第 i 种技能来说，当装备相应技能的装饰珠数量达到 Ki 个时，会产生Wi(Ki) 的价值。镶嵌同类技能的数量越多，产生的价值越大，即 Wi(Ki − 1) &lt;Wi(Ki)。但每个技能都有上限 Pi(1 ≤ Pi ≤ 7)，当装备的珠子数量超过 Pi 时，只会产生 Wi(Pi) 的价值。<br>对于给定的装备和装饰珠数据，求解如何镶嵌装饰珠，使得 6 件装备能得到的总价值达到最大。<br>【输入格式】<br>输入的第 1 至 6 行，包含 6 件装备的描述。其中第 i 的第一个整数 Ni 表示第 i 件装备的装饰孔数量。后面紧接着 Ni 个整数，分别表示该装备上每个装饰孔的等级 L(1 ≤ L ≤ 4)。<br>第 7 行包含一个正整数 M，表示装饰珠 (技能) 种类数量。<br>第 8 至 M + 7 行，每行描述一种装饰珠 (技能) 的情况。每行的前两个整数Lj(1 ≤ Lj ≤ 4) 和 Pj(1 ≤ Pi ≤ 7) 分别表示第 j 种装饰珠的等级和上限。接下来Pj 个整数，其中第 k 个数表示装备该中装饰珠数量为 k 时的价值 Wj(k)。<br>【输出格式】<br>输出一行包含一个整数，表示能够得到的最大价值。<br>【样例输入】<br>1 1<br>2 1 2<br>1 1<br>2 2 2<br>1 1<br>1 3<br>3<br>1 5 1 2 3 5 8<br>2 4 2 4 8 15<br>3 2 5 10<br>【样例输出】<br>20<br>【样例说明】<br>按照如下方式镶嵌珠子得到最大价值 18，括号内表示镶嵌的装饰珠的种类编号：<br>1: (1)<br>2: (1) (2)<br>3: (1)<br>4: (2) (2)<br>5: (1)<br>6: (2)<br>4 颗技能 1 装饰珠，4 颗技能 2 装饰珠 W1(4) + W2(4) = 5 + 15 = 20。<br>【评测用例规模与约定】<br>对于 30% 的评测用例，1 ≤ Ni ≤ 10, 1 ≤ M ≤ 20, 1 ≤ Wj(k) ≤ 500；<br>对于所有评测用例，1 ≤ Ni ≤ 50, 1 ≤ M ≤ 10000, 1 ≤ Wj(k) ≤ 10000。</p><h2 id="2012填空"><a href="#2012填空" class="headerlink" title="2012填空"></a>2012填空</h2><h3 id="微生物增殖"><a href="#微生物增殖" class="headerlink" title="# 微生物增殖"></a># 微生物增殖</h3><p>假设有两种微生物 X 和 Y<br>X出生后每隔3分钟分裂一次（数目加倍），Y出生后每隔2分钟分裂一次（数目加倍）。<br>一个新出生的X，半分钟之后吃掉1个Y，并且，从此开始，每隔1分钟吃1个Y。<br>现在已知有新出生的 X=10, Y=89，求60分钟后Y的数目。<br>如果X=10，Y=90呢？<br>本题的要求就是写出这两种初始条件下，60分钟后Y的数目。<br>题目的结果令你震惊吗？这不是简单的数字游戏！真实的生物圈有着同样脆弱的性质！也许因为你消灭的那只 Y 就是最终导致 Y 种群灭绝的最后一根稻草！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line">y =  <span class="number">89</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">121</span>):</span><br><span class="line">    <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">1</span>):</span><br><span class="line">        y -= x</span><br><span class="line">    <span class="keyword">if</span>( i % <span class="number">4</span> == <span class="number">0</span>):</span><br><span class="line">        y *= <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span>(i % <span class="number">6</span> == <span class="number">0</span>):</span><br><span class="line">        x *= <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(x ,y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 10485760 94371840</span></span><br></pre></td></tr></table></figure><h3 id="古堡算式"><a href="#古堡算式" class="headerlink" title="古堡算式"></a>古堡算式</h3><p>福尔摩斯到某古堡探险，看到门上写着一个奇怪的算式：<br>ABCDE * ? = EDCBA<br>他对华生说：“ABCDE应该代表不同的数字，问号也代表某个数字！”<br>华生：“我猜也是！”<br>于是，两人沉默了好久，还是没有算出合适的结果来。<br>请你利用计算机的优势，找到破解的答案。<br>把 ABCDE 所代表的数字写出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>,<span class="number">100000</span>):</span><br><span class="line">    temp = <span class="built_in">str</span>(i)</span><br><span class="line">    flag =<span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(temp)):</span><br><span class="line">        <span class="keyword">if</span>(temp[j] <span class="keyword">in</span> temp[:j]):</span><br><span class="line">            flag =<span class="literal">False</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span>(flag):</span><br><span class="line">        temp2 = temp[::-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">int</span>(temp2) % <span class="built_in">int</span>(temp) == <span class="number">0</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">int</span>(temp))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 21978</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="比酒量"><a href="#比酒量" class="headerlink" title="比酒量"></a>比酒量</h3><p>题目描述<br>有一群海盗（不多于20人），在船上比拼酒量。过程如下：打开一瓶酒，所有在场的人平分喝下，有几个人倒下了。再打开一瓶酒平分，又有倒下的，再次重复——直到开了第4瓶酒，坐着的已经所剩无几，海盗船长也在其中。当第4瓶酒平分喝下后，大家都倒下了。等船长醒来，发现海盗船搁浅了。他在航海日志中写到：“…昨天，我正好喝了一瓶…奉劝大家，开船不喝酒，喝酒别开船…”<br>请你根据这些信息，推断开始有多少人，每一轮喝下来还剩多少人。如果有多个可能的答案，请列出所有答案，每个答案占一行。格式是：人数，人数，…<br>例如，有一种可能是：20,5,4,2,0</p><p><strong>【浮点数比较】</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i-<span class="number">1</span> ,<span class="number">0</span> ,-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(j-<span class="number">1</span> , <span class="number">0</span> , -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span> , <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(<span class="number">1</span> - <span class="number">1</span>/i - <span class="number">1</span>/j - <span class="number">1</span>/k - <span class="number">1</span>/n) &lt; <span class="number">0.001</span>):</span><br><span class="line">                    <span class="built_in">print</span>(i ,j ,k , n , <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 20 5 4 2 0</span></span><br><span class="line"><span class="comment"># 18 9 3 2 0</span></span><br><span class="line"><span class="comment"># 15 10 3 2 0</span></span><br><span class="line"><span class="comment"># 12 6 4 2 0</span></span><br></pre></td></tr></table></figure><h3 id="奇怪的比赛"><a href="#奇怪的比赛" class="headerlink" title="奇怪的比赛"></a>奇怪的比赛</h3><p>题目描述<br>某电视台举办了低碳生活大奖赛。题目的计分规则相当奇怪：每位选手需要回答10个问题（其编号为1到10），越后面越有难度。答对的，当前分数翻倍；答错了则扣掉与题号相同的分数（选手必须回答问题，不回答按错误处理）。每位选手的起步分都是10分，某获胜选手最终得分刚好是100分，如果不让你看比赛过程，你能推断出他（她）哪个题目答对了，哪个题目答错了吗？如果把答对的记为1，答错的记为0，则10个题目的回答情况可用仅含1和0的串来表示，如0010110011就是可能的情况。<br>你的任务是算出所有可能情况，每个答案占一行。</p><p><strong>【递归】</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line">res = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal</span>(<span class="params">index, list1, res,n</span>):</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">100</span> <span class="keyword">and</span> <span class="built_in">len</span>(res) == <span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>(res)</span><br><span class="line">    <span class="keyword">if</span>(index &gt;= <span class="built_in">len</span>(list1)):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    cal(index + <span class="number">1</span>, list1,res + <span class="string">&quot;0&quot;</span>, n - index-<span class="number">1</span>)</span><br><span class="line">    cal(index + <span class="number">1</span>, list1, res + <span class="string">&quot;1&quot;</span>, n*<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">cal(<span class="number">0</span>,list1, res,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0010110011</span></span><br><span class="line"><span class="comment"># 0111010000</span></span><br><span class="line"><span class="comment"># 1011010000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="方阵转置"><a href="#方阵转置" class="headerlink" title="# 方阵转置"></a># 方阵转置</h3><p>题目描述<br>对一个方阵转置，就是把原来的行号变列号，原来的列号变行号。例如，如下方阵：<br>1 2 3 4<br>5 6 7 8<br>9 10 11 12<br>13 14 15 16<br>转置后变为：<br>1 5 9 13<br>2 6 10 14<br>3 7 11 15<br>4 8 12 16<br>但如果是对该方阵顺时针旋转（不是转置），却是如下结果：<br>13 9 5 1<br>14 10 6 2<br>15 11 7 3<br>16 12 8 4<br>下面代码实现的功能就是要把一个方阵顺时针旋转，请推测划线处的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> *x,<span class="keyword">int</span> rank)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">int</span> *y=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(___________________);  <span class="comment">//填空</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rank*rank;i++)</span><br><span class="line">&#123; </span><br><span class="line">y[___________________]= x[i];  <span class="comment">//填空</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;rank*rank;i++) x[i]=y[i];</span><br><span class="line"><span class="built_in">free</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">int</span> x[<span class="number">4</span>][<span class="number">4</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,&#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;,&#123;<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> rank=<span class="number">4</span>;</span><br><span class="line"><span class="built_in">rotate</span>(&amp;x[<span class="number">0</span>][<span class="number">0</span>],rank);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rank;i++)</span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;rank;j++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%4d&quot;</span>,x[i][j]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目分析<br>第一个填空只需要了解了malloc的用法就能理解，这里找了一篇malloc的用法:malloc的用法.<br>第二个填空处：<br>矩阵的普通的倒置是x[j][i]=x[i][j];</p><p>顺时针倒置是x[j][3-i]=x[i][j];</p><p>此处还要将i转化成两个坐标，使用除法和取余运算，即：x[i]-&gt;x[i/4][i%4]</p><p>那么，通过顺时针倒置，则有 x[i%4][3-i/4]=x[i/4][i%4]=x[i]</p><p>即：x[(i%4)*4+3-i/4]=x[i];</p><h2 id="2013填空"><a href="#2013填空" class="headerlink" title="2013填空"></a>2013填空</h2><h3 id="世纪末的星期"><a href="#世纪末的星期" class="headerlink" title="世纪末的星期"></a>世纪末的星期</h3><p><strong>题目描述</strong><br>曾有邪教称1999年12月31日是世界末日。当然该谣言已经不攻自破。还有人称今后的某个世纪末的12月31日，如果是星期一则会…<br>有趣的是，任何一个世纪末的年份的12月31日都不可能是星期一!!<br>于是，“谣言制造商”又修改为星期日…1999年的12月31日是星期五，请问：未来哪一个离我们最近的一个世纪末年（即xx99年）的12月31日正好是星期天（即星期日）？<br>请回答该年份（只写这个4位整数，不要写12月31等多余信息）</p><p><strong>【日期】</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">year = <span class="number">2099</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">if</span>(datetime.datetime(year,<span class="number">12</span>,<span class="number">31</span>).weekday() + <span class="number">1</span>) == <span class="number">7</span>:</span><br><span class="line">        <span class="built_in">print</span>(year)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    year += <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2299</span></span><br></pre></td></tr></table></figure><h3 id="振兴中华"><a href="#振兴中华" class="headerlink" title="振兴中华"></a>振兴中华</h3><p><strong>题目描述</strong><br>小明参加了学校的趣味运动会，其中的一个项目是：跳格子。地上画着一些格子，每个格子里写一个字，如下所示：（也可参见p1.jpg）<br>从我做起振<br>我做起振兴<br>做起振兴中<br>起振兴中华<br>比赛时，先站在左上角的写着“从”字的格子里，可以横向或纵向跳到相邻的格子里，但不能跳到对角的格子或其它位置。一直要跳到“华”字结束。<br>要求跳过的路线刚好构成“从我做起振兴中华”这句话。<br>请你帮助小明算一算他一共有多少种可能的跳跃路线呢？<br>答案是一个整数，请通过浏览器直接提交该数字。<br>注意：不要提交解答过程，或其它辅助说明类的内容。</p><p>【动态规划】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    dp[<span class="number">0</span>][i] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">4</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">        dp[i][j] = (dp[i][j-<span class="number">1</span>] + dp[i-<span class="number">1</span>][j])</span><br><span class="line"><span class="built_in">print</span>(dp[<span class="number">3</span>][<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 35</span></span><br></pre></td></tr></table></figure><h3 id="梅森素数"><a href="#梅森素数" class="headerlink" title="梅森素数"></a>梅森素数</h3><p><strong>题目描述</strong><br>如果一个数字的所有真因子之和等于自身，则称它为“完全数”或“完美数”例如：<br>6 = 1 + 2 + 3<br>28 = 1 + 2 + 4 + 7 + 14<br>早在公元前300多年，欧几里得就给出了判定完全数的定理：<br>若 2^n - 1 是素数，则 2^(n-1) <em> (2^n - 1) 是完全数。 其中 ^ 表示“乘方”运算，乘方的优先级比四则运算高，例如：2^3 = 8， 2 </em> 2^3 = 16, 2^3-1 = 7但人们很快发现，当n很大时，判定一个大数是否为素数到今天也依然是个难题。因为法国数学家梅森的猜想，我们习惯上把形如：2^n - 1 的素数称为：梅森素数。截止2013年2月，一共只找到了48个梅森素数。 新近找到的梅森素数太大，以至于难于用一般的编程思路窥其全貌，所以我们把任务的难度降低一点：1963年，美国伊利诺伊大学为了纪念他们找到的第23个梅森素数 n=11213，在每个寄出的信封上都印上了“2^11213-1 是素数”的字样。 2^11213 - 1 这个数字已经很大(有3000多位)，请你编程求出这个素数的十进制表示的最后100位。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">11213</span>) - <span class="number">1</span></span><br><span class="line">res = <span class="built_in">str</span>(n)</span><br><span class="line"><span class="built_in">print</span>(res[-<span class="number">100</span>: -<span class="number">1</span>] + res[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8586718527586602439602335283513944980064327030278104224144971883680541689784796267391476087696392191</span></span><br></pre></td></tr></table></figure><h3 id="颠倒的价牌"><a href="#颠倒的价牌" class="headerlink" title="颠倒的价牌"></a>颠倒的价牌</h3><p>题目描述<br>小李的店里专卖其它店中下架的样品电视机，可称为：样品电视专卖店。其标价都是4位数字（即千元不等）。小李为了标价清晰、方便，使用了预制的类似数码管的标价签，只要用颜色笔涂数字就可以了（参见p1.jpg）。这种价牌有个特点，对一些数字，倒过来看也是合理的数字。如：1 2 5 6 8 9 0 都可以。这样一来，如果牌子挂倒了，有可能完全变成了另一个价格，比如：1958 倒着挂就是：8561，差了几千元啊!! 当然，多数情况不能倒读，比如，1110 就不能倒过来，因为0不能作为开始数字。有一天，悲剧终于发生了。某个店员不小心把店里的某两个价格牌给挂倒了。并且这两个价格牌的电视机都卖出去了!庆幸的是价格出入不大，其中一个价牌赔了2百多，另一个价牌却赚了8百多，综合起来，反而多赚了558元。<br>请根据这些信息计算：赔钱的那个价牌正确的价格应该是多少？<br>答案是一个4位的整数，请通过浏览器直接提交该数字。<br>注意：不要提交解答过程，或其它辅助说明类的内容。</p><p><img src="/%E8%93%9D%E6%A1%A5%E6%9D%AF/index/3_1.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>]</span><br><span class="line">list2 = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">0</span>]</span><br><span class="line">set1 = <span class="built_in">set</span>()</span><br><span class="line">set2 = <span class="built_in">set</span>()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal</span>(<span class="params">n</span>):</span></span><br><span class="line">    a = n // <span class="number">1000</span></span><br><span class="line">    b = n // <span class="number">100</span> % <span class="number">10</span></span><br><span class="line">    c = n // <span class="number">10</span> % <span class="number">10</span></span><br><span class="line">    d = n % <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cal2(d) * <span class="number">1000</span> + cal2(c) * <span class="number">100</span> + cal2(b) * <span class="number">10</span> + cal2(a)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal2</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> list2[list1.index(n)]</span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">                num1 = <span class="number">1000</span>*list1[m] + <span class="number">100</span>*list1[j] + <span class="number">10</span> * list1[n] + list1[k]</span><br><span class="line">                num2 = <span class="number">1000</span>*list2[k] + <span class="number">100</span>*list2[n] + <span class="number">10</span> * list2[j] + list2[m]</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">200</span>&lt;=<span class="built_in">abs</span>(num1-num2)&lt;<span class="number">300</span>):</span><br><span class="line">                    set1.add(<span class="built_in">max</span>(num1,num2)) <span class="comment"># 这里一开始写成了min</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="number">800</span>&lt;=<span class="built_in">abs</span>(num1-num2)&lt;<span class="number">900</span>):</span><br><span class="line">                    set2.add(<span class="built_in">min</span>(num1,num2)) <span class="comment"># 这里一开始写成了max</span></span><br><span class="line"><span class="keyword">for</span> num1 <span class="keyword">in</span> set1:</span><br><span class="line">    <span class="keyword">for</span> num2 <span class="keyword">in</span> set2:</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(num2 - cal(num2)) - <span class="built_in">abs</span>(num1 - cal(num1)) == <span class="number">558</span>):</span><br><span class="line">            <span class="built_in">print</span>(num1, num2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 9088</span></span><br></pre></td></tr></table></figure><h3 id="三部排序"><a href="#三部排序" class="headerlink" title="三部排序"></a>三部排序</h3><p><strong>题目描述</strong><br>一般的排序有许多经典算法，如快速排序、希尔排序等。<br>但实际应用时，经常会或多或少有一些特殊的要求。我们没必要套用那些经典算法，可以根据实际情况建立更好的解法。<br>比如，对一个整型数组中的数字进行分类排序：<br>使得负数都靠左端，正数都靠右端，0在中部。注意问题的特点是：负数区域和正数区域内并不要求有序。可以利用这个特点通过1次线性扫描就结束战斗!!<br>以下的程序实现了该目标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = x.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(p&lt;=right)&#123;</span><br><span class="line"><span class="keyword">if</span>(x[p]&lt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> t = x[left];</span><br><span class="line">x[left] = x[p];</span><br><span class="line">x[p] = t;</span><br><span class="line">left++;</span><br><span class="line">p++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x[p]&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> t = x[right];</span><br><span class="line">x[right] = x[p];</span><br><span class="line">x[p] = t;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">_________________________;  <span class="comment">//代码填空位置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// p++</span></span><br></pre></td></tr></table></figure><h3 id="马虎的算式"><a href="#马虎的算式" class="headerlink" title="马虎的算式"></a>马虎的算式</h3><p><strong>题目描述</strong><br>小明是个急性子，上小学的时候经常把老师写在黑板上的题目抄错了。有一次，老师出的题目是：36 x 495 = ? 他却给抄成了：396 x 45 = ?但结果却很戏剧性，他的答案竟然是对的！！因为 36 <em> 495 = 396 </em> 45 = 17820 类似这样的巧合情况可能还有很多，比如：27 <em> 594 = 297 </em> 54 假设 a b c d e 代表1~9不同的5个数字（注意是<strong>各不相同</strong>的数字，且不含0）能满足形如： ab <em> cde = adb </em> ce 这样的算式一共有多少种呢？请你利用计算机的优势寻找所有的可能，并回答不同算式的种类数。满足乘法交换律的算式计为不同的种类，所以答案肯定是个偶数。<br>答案直接通过浏览器提交。<br>注意：只提交一个表示最终统计种类数的数字，不要提交解答过程或其它多余的内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">    temp1 = <span class="built_in">str</span>(a)</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">str</span>(b) <span class="keyword">in</span> temp1):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        temp2 = temp1 + <span class="built_in">str</span>(b)</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> , <span class="number">10</span>):</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">str</span>(c) <span class="keyword">in</span> temp2):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            temp3 = temp2 + <span class="built_in">str</span>(c)</span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">str</span>(d) <span class="keyword">in</span> temp3):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                temp4 = temp3 + <span class="built_in">str</span>(d)</span><br><span class="line">                <span class="keyword">for</span>  e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">str</span>(e) <span class="keyword">in</span> temp4):</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    num1 = <span class="number">10</span>*a + b</span><br><span class="line">                    num2 = <span class="number">100</span> * c + <span class="number">10</span> * d + e</span><br><span class="line">                    num3 = <span class="number">100</span> * a + <span class="number">10</span> * d + b</span><br><span class="line">                    num4 = <span class="number">10</span> * c + e</span><br><span class="line">                    <span class="keyword">if</span>(num1 * num2 == num3 * num4):</span><br><span class="line">                        res += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 142</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="【看】黄金连分数"><a href="#【看】黄金连分数" class="headerlink" title="【看】黄金连分数"></a>【看】黄金连分数</h3><p><strong>题目描述</strong><br>黄金分割数0.61803… 是个无理数，这个常数十分重要，在许多工程问题中会出现。有时需要把这个数字求得很精确。对于某些精密工程，常数的精度很重要。也许你听说过哈勃太空望远镜，它首次升空后就发现了一处人工加工错误，对那样一个庞然大物，其实只是镜面加工时有比头发丝还细许多倍的一处错误而已，却使它成了“近视眼”!!<br>言归正传，我们如何求得黄金分割数的尽可能精确的值呢？有许多方法。比较简单的一种是用连分数：</p><pre><code>                1黄金数 = ---------------------                    1         1 + -----------------                      1             1 + -------------                        1                 1 + ---------                      1 + ...</code></pre><p>这个连分数计算的“层数”越多，它的值越接近黄金分割数。 请你利用这一特性，求出黄金分割数的足够精确值，要求四舍五入到小数点后100位。<br>小数点后3位的值为：0.618<br>小数点后4位的值为：0.6180<br>小数点后5位的值为：0.61803<br>小数点后7位的值为：0.6180340<br>（注意尾部的0，不能忽略）<br>你的任务是：写出精确到小数点后100位精度的黄金分割值。<br>注意：尾数的四舍五入！ 尾数是0也要保留！<br>显然答案是一个小数，其小数点后有100位数字，请通过浏览器直接提交该数字。<br>注意：不要提交解答过程，或其它辅助说明类的内容。</p><p><span id="decimalback">【deciaml】</span> <a href="#decimal">总结</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">getcontext().prec=<span class="number">101</span></span><br><span class="line"></span><br><span class="line">a=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3000</span>):</span><br><span class="line">  </span><br><span class="line">  a=Decimal(<span class="number">1</span>/(<span class="number">1</span>+a))</span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0.6180339887498948482045868343656381177203091798057628621354486227052604628189024497072072041893911375</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="高斯日记"><a href="#高斯日记" class="headerlink" title="高斯日记"></a>高斯日记</h3><p><strong>题目描述</strong><br>大数学家高斯有个好习惯：无论如何都要记日记。<br>他的日记有个与众不同的地方，他从不注明年月日，而是用一个整数代替，比如：4210<br>后来人们知道，那个整数就是日期，它表示那一天是高斯出生后的第几天。这或许也是个好习惯，它时时刻刻提醒着主人：日子又过去一天，还有多少时光可以用于浪费呢？<br>高斯出生于：1777年4月30日。<br>在高斯发现的一个重要定理的日记上标注着：5343，因此可算出那天是：1791年12月15日。<br>高斯获得博士学位的那天日记上标着：8113<br>请你算出高斯获得博士学位的年月日。<br>提交答案的格式是：yyyy-mm-dd, 例如：1980-03-21</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">start = datetime.date(<span class="number">1777</span>, <span class="number">4</span>, <span class="number">30</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8112</span>):</span><br><span class="line">    start += datetime.timedelta(days  = <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(start)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1799-07-16</span></span><br></pre></td></tr></table></figure><h3 id="【看】排它平方数"><a href="#【看】排它平方数" class="headerlink" title="【看】排它平方数"></a>【看】排它平方数</h3><p><strong>题目描述</strong><br>小明正看着 203879 这个数字发呆。<br>原来，203879 * 203879 = 41566646641<br>这有什么神奇呢？仔细观察，203879 是个6位数，并且它的每个数上的数字都是不同的，并且它平方后的所有数位上都不出现组成它自身的数字。<br>具有这样特点的6位数还有一个，请你找出它！<br>再归纳一下筛选要求：</p><ol><li>6位正整数</li><li>每个数位上的数字不同</li><li>其平方数的每个数位不含原数字的任何组成数位<br>答案是一个6位的正整数。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>,<span class="number">1000000</span>):</span><br><span class="line">    temp = <span class="built_in">str</span>(j)</span><br><span class="line">    flag = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">        <span class="keyword">if</span>(temp[i] <span class="keyword">in</span> temp[:i]):</span><br><span class="line">            flag = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span>(flag):</span><br><span class="line">        temp1 = <span class="built_in">str</span>(j * j)</span><br><span class="line">        flag2 = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> temp1:</span><br><span class="line">            <span class="keyword">if</span>(m <span class="keyword">in</span> temp[:]):</span><br><span class="line">                flag2 = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(flag2):</span><br><span class="line">            <span class="built_in">print</span>(j)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 203879</span></span><br><span class="line"><span class="comment"># 639172</span></span><br></pre></td></tr></table></figure><h3 id="【看】第39级台阶"><a href="#【看】第39级台阶" class="headerlink" title="【看】第39级台阶"></a>【看】第39级台阶</h3><p><strong>题目描述</strong><br>小明刚刚看完电影《第39级台阶》，离开电影院的时候，他数了数礼堂前的台阶数，恰好是39级！站在台阶前，他突然又想着一个问题：<br>如果我每一步只能迈上1个或2个台阶，先迈左脚，然后左右交替，最后一步是迈右脚，也就是说一共要走偶数步。那么，上完39级台阶，有多少种不同的上法呢？<br>请你利用计算机的优势，帮助小明寻找答案。要求提交的是一个整数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal</span>(<span class="params">n, bushu</span>):</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span> <span class="keyword">and</span> bushu % <span class="number">2</span> == <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> cal(n-<span class="number">1</span>, bushu + <span class="number">1</span>,res) + cal(n - <span class="number">2</span>, bushu  + <span class="number">1</span>,res)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(cal(<span class="number">39</span>,<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这样递归不可以</span></span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal</span>(<span class="params">n, bushu,res</span>):</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span> <span class="keyword">and</span> bushu % <span class="number">2</span> == <span class="number">0</span>):</span><br><span class="line">        res += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    cal(n-<span class="number">1</span>, bushu + <span class="number">1</span>,res)</span><br><span class="line">    cal(n - <span class="number">2</span>, bushu  + <span class="number">1</span>,res)</span><br><span class="line"></span><br><span class="line">cal(<span class="number">39</span>,<span class="number">0</span>,res)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 会返回0，因为Python对象分为可变对象(list,dict,set等)和不可变对象(number,string,tuple等)，当传递的参数是可变对象的引用时，因为可变对象的值可以修改，因此可以通过修改参数值而修改原对象，这类似于C语言中的引用传递；当传递的参数是不可变对象的引用时，虽然传递的是引用，参数变量和原变量都指向同一内存地址，但是不可变对象无法修改，所以参数的重新赋值不会影响原对象，这类似于C语言中的值传递。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 改写</span></span><br><span class="line"><span class="comment"># 根据上述准则，可以把变量存在list里面</span></span><br><span class="line">list1 = [<span class="number">0</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal</span>(<span class="params">n, bushu, list1</span>):</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span> <span class="keyword">and</span> bushu % <span class="number">2</span> == <span class="number">0</span>):</span><br><span class="line">        list1[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    cal(n-<span class="number">1</span>, bushu + <span class="number">1</span>, list1)</span><br><span class="line">    cal(n - <span class="number">2</span>, bushu  + <span class="number">1</span>, list1)</span><br><span class="line"></span><br><span class="line">cal(<span class="number">39</span>,<span class="number">0</span>, list1)</span><br><span class="line"><span class="built_in">print</span>(list1[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态规划</span></span><br><span class="line">dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">39</span>)]</span><br><span class="line"><span class="comment"># arr[a][b]的含义分为arr[a][0] 左脚踏上第a阶的方案数，</span></span><br><span class="line"><span class="comment"># arr[a][1]为右脚踏上第a阶的方案数</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">39</span>):</span><br><span class="line">    dp[i][<span class="number">1</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + dp[i-<span class="number">2</span>][<span class="number">0</span>]</span><br><span class="line">    dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">1</span>] + dp[i-<span class="number">2</span>][<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(dp[<span class="number">38</span>][<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 51167078</span></span><br></pre></td></tr></table></figure><h2 id="2014填空"><a href="#2014填空" class="headerlink" title="2014填空"></a>2014填空</h2><h3 id="猜年龄"><a href="#猜年龄" class="headerlink" title="猜年龄"></a>猜年龄</h3><p><strong>题目描述</strong><br>小明带两个妹妹参加元宵灯会。别人问她们多大了，她们调皮地说：“我们俩的年龄之积是年龄之和的6倍”。小明又补充说：“她们可不是双胞胎，年龄差肯定也不超过8岁啊。”<br>请你写出：小明的较小的妹妹的年龄。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">100</span>):</span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(n,n + <span class="number">9</span>):</span><br><span class="line">        <span class="keyword">if</span>(n*m % (n + m) == <span class="number">0</span> <span class="keyword">and</span> n * m // (n + m) == <span class="number">6</span>):</span><br><span class="line">            <span class="built_in">print</span>(n ,m)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 10 15 应该是10</span></span><br><span class="line"><span class="comment"># 12 12 相同了</span></span><br></pre></td></tr></table></figure><h3 id="李白打酒"><a href="#李白打酒" class="headerlink" title="李白打酒"></a>李白打酒</h3><p><strong>题目描述</strong><br>话说大诗人李白，一生好饮。幸好他从不开车。<br>一天，他提着酒壶，从家里出来，酒壶中有酒2斗。他边走边唱：<br>无事街上走，提壶去打酒。<br>逢店加一倍，遇花喝一斗。<br>这一路上，他一共遇到店5次，遇到花10次，已知最后一次遇到的是花，他正好把酒喝光了。<br>请你计算李白遇到店和花的次序，可以把遇店记为a，遇花记为b。则：babaabbabbabbbb 就是合理的次序。像这样的答案一共有多少呢？请你计算出所有可能方案的个数（包含题目给出的）。<br>注意：通过浏览器提交答案。答案是个整数。不要书写任何多余的内容。</p><p>【和去年的“第39级台阶”有点像】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 倒数第二次还有一斗酒</span></span><br><span class="line">list1 = [<span class="number">0</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal</span>(<span class="params">dian, hua, res,jiu,list1</span>):</span></span><br><span class="line">    <span class="keyword">if</span>(dian &lt; <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span>(hua &lt; <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span>(dian == <span class="number">0</span> <span class="keyword">and</span> hua == <span class="number">0</span> <span class="keyword">and</span> jiu == <span class="number">1</span>):</span><br><span class="line">        list1[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">    cal(dian - <span class="number">1</span>, hua , res + <span class="string">&quot;a&quot;</span>,jiu * <span class="number">2</span>,list1)</span><br><span class="line">    cal(dian, hua - <span class="number">1</span>,res + <span class="string">&quot;b&quot;</span>, jiu - <span class="number">1</span>,list1)</span><br><span class="line">cal(<span class="number">5</span>,<span class="number">9</span>,<span class="string">&quot;&quot;</span>, <span class="number">2</span>,list1)</span><br><span class="line"><span class="built_in">print</span>(list1[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 14</span></span><br></pre></td></tr></table></figure><h3 id="【看】神奇算式"><a href="#【看】神奇算式" class="headerlink" title="【看】神奇算式"></a>【看】神奇算式</h3><p><strong>题目描述</strong><br>由4个不同的数字，组成的一个乘法算式，它们的乘积仍然由这4个数字组成。<br>比如：<br>210 x 6 = 1260<br>8 x 473 = 3784<br>27 x 81 = 2187<br>都符合要求。<br>如果满足乘法交换律的算式算作同一种情况，那么，包含上边已列出的3种情况，一共有多少种满足要求的算式。<br>请填写该数字，通过浏览器提交答案，不要填写多余内容（例如：列出所有算式）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal</span>(<span class="params">num1, num2,temp</span>):</span></span><br><span class="line">    p = <span class="built_in">str</span>(num1 * num2)</span><br><span class="line">    set1 = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> p:</span><br><span class="line">        set1.add(k)</span><br><span class="line">    flag = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> p:</span><br><span class="line">        <span class="keyword">if</span>(k <span class="keyword">not</span> <span class="keyword">in</span> temp):</span><br><span class="line">            flag = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span>(flag <span class="keyword">and</span> <span class="built_in">len</span>(set1) == <span class="number">4</span>):</span><br><span class="line"><span class="comment">##        print(num1, num2)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一开始错在temp,temp1,temp2,temp3没有区分，都是用temp代替，这是错误的</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">    temp = <span class="built_in">str</span>(i)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">str</span>(j) <span class="keyword">in</span> temp):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        temp1 = temp + <span class="built_in">str</span>(j)</span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>):</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">str</span>(m) <span class="keyword">in</span> temp1):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            temp2 = temp1 + <span class="built_in">str</span>(m)</span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>):</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">str</span>(n) <span class="keyword">in</span> temp2):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                temp3 = temp2 + <span class="built_in">str</span>(n)</span><br><span class="line">                num1 = i</span><br><span class="line">                num2 = <span class="number">100</span>*j + <span class="number">10</span>* m + n</span><br><span class="line">                num3 = <span class="number">10</span>*i + j</span><br><span class="line">                num4 = <span class="number">10</span>*m + n</span><br><span class="line">                num5 = <span class="number">100</span>*i + <span class="number">10</span>*j + m</span><br><span class="line">                num6 = n</span><br><span class="line">                res += cal(num1, num2,temp3)</span><br><span class="line">                res += cal(num3, num4,temp3)</span><br><span class="line">                res += cal(num5, num6,temp3)</span><br><span class="line"><span class="built_in">print</span>(res // <span class="number">2</span>)                 </span><br><span class="line">                    </span><br><span class="line">                </span><br><span class="line"><span class="comment"># 12</span></span><br></pre></td></tr></table></figure><h3 id="武功秘籍"><a href="#武功秘籍" class="headerlink" title="武功秘籍"></a>武功秘籍</h3><p>题目描述<br>小明到X山洞探险，捡到一本有破损的武功秘籍（2000多页！当然是伪造的）。他注意到：书的第10页和第11页在同一张纸上，但第11页和第12页不在同一张纸上。<br>小明只想练习该书的第81页到第92页的武功，又不想带着整本书。请问他至少要撕下多少张纸带走？<br>这是个整数，请通过浏览器提交该数字，不要填写任何多余的内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 口算</span></span><br><span class="line"><span class="comment"># 7</span></span><br></pre></td></tr></table></figure><h3 id="切面条"><a href="#切面条" class="headerlink" title="切面条"></a>切面条</h3><p>题目描述<br>一根高筋拉面，中间切一刀，可以得到2根面条。<br>如果先对折1次，中间切一刀，可以得到3根面条。<br>如果连续对折2次，中间切一刀，可以得到5根面条。<br>那么，连续对折10次，中间切一刀，会得到多少面条呢？<br>答案是个整数，请通过浏览器提交答案。不要填写任何多余的内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>)]</span><br><span class="line">list1[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">    list1[i] = <span class="number">2</span> * list1[i-<span class="number">1</span>] - <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(list1[<span class="number">10</span>])</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 1025</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="【看】猜字母"><a href="#【看】猜字母" class="headerlink" title="【看】猜字母"></a>【看】猜字母</h3><p>题目描述<br>把abcd…s共19个字母组成的序列重复拼接106次，得到长度为2014的串。接下来删除第1个字母（即开头的字母a），以及第3个，第5个等所有奇数位置的字母。得到的新串再进行删除奇数位置字母的动作。如此下去，最后只剩下一个字母，请写出该字母。<br>答案是一个小写字母，请通过浏览器提交答案。不要填写任何多余的内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dp = <span class="string">&quot;abcdefghijklmnopqrs&quot;</span> * <span class="number">106</span></span><br><span class="line"></span><br><span class="line">temp = <span class="built_in">list</span>(dp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(temp) &gt; <span class="number">1</span>:</span><br><span class="line">    length = <span class="built_in">len</span>(temp)</span><br><span class="line"><span class="comment">##    print(temp)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length - <span class="number">1</span>, - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span>((i+<span class="number">1</span>) % <span class="number">2</span> == <span class="number">1</span>):</span><br><span class="line">            temp.pop(i)</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(temp[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># q</span></span><br></pre></td></tr></table></figure><h3 id="啤酒和饮料"><a href="#啤酒和饮料" class="headerlink" title="啤酒和饮料"></a>啤酒和饮料</h3><p><strong>题目描述</strong><br>啤酒每罐2.3元，饮料每罐1.9元。小明买了若干啤酒和饮料，一共花了82.3元。我们还知道他买的啤酒比饮料的数量少，请你计算他买了几罐啤酒。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">36</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">abs</span>((<span class="number">82.3</span> - i * <span class="number">2.3</span>) % <span class="number">1.9</span>) &lt; <span class="number">0.0001</span>:</span><br><span class="line">        <span class="built_in">print</span>(i, (<span class="number">82.3</span> - i * <span class="number">2.3</span>) / <span class="number">1.9</span> )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 11 </span></span><br></pre></td></tr></table></figure><h2 id="2015填空"><a href="#2015填空" class="headerlink" title="2015填空"></a>2015填空</h2><h3 id="熊怪吃核桃"><a href="#熊怪吃核桃" class="headerlink" title="熊怪吃核桃"></a>熊怪吃核桃</h3><p>题目描述<br>森林里有一只熊怪，很爱吃核桃。不过它有个习惯，每次都把找到的核桃分成相等的两份，吃掉一份，留一份。如果不能等分，熊怪就会扔掉一个核桃再分。第二天再继续这个过程，直到最后剩一个核桃了，直接丢掉。有一天，熊怪发现了1543个核桃，请问，它在吃这些核桃的过程中，一共要丢掉多少个核桃。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">1543</span></span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(n != <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>):</span><br><span class="line">        n = n // <span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        n = (n - <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">        res +=<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(res + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5</span></span><br></pre></td></tr></table></figure><h3 id="星系炸弹"><a href="#星系炸弹" class="headerlink" title="星系炸弹"></a>星系炸弹</h3><p>题目描述<br>在X星系的广袤空间中漂浮着许多X星人造“炸弹”，用来作为宇宙中的路标。<br>每个炸弹都可以设定多少天之后爆炸。<br>比如：阿尔法炸弹2015年1月1日放置，定时为15天，则它在2015年1月16日爆炸。<br>有一个贝塔炸弹，2014年11月9日放置，定时为1000天，请你计算它爆炸的准确日期。</p><p>请填写该日期，格式为 yyyy-mm-dd 即4位年份2位月份2位日期。比如：2015-02-19<br>请严格按照格式书写。不能出现其它文字或符号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">excel</span><br><span class="line"><span class="comment"># 2017-08-05</span></span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">start = datetime.date(<span class="number">2014</span>,<span class="number">11</span>,<span class="number">9</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    start += datetime.timedelta(days = <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(start)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="九数分三组"><a href="#九数分三组" class="headerlink" title="九数分三组"></a>九数分三组</h3><p><strong>题目描述</strong><br>1~9的数字可以组成3个3位数，设为：A,B,C, 现在要求满足如下关系：<br>B = 2 <em> A<br>C = 3 </em> A</p><p>请你写出A的所有可能答案，数字间用空格分开，数字按升序排列。</p><p>注意：只提交A的值，严格按照格式要求输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">    temp1 = <span class="built_in">str</span>(a)</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">str</span>(b) <span class="keyword">in</span> temp1):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        temp2 = temp1 + <span class="built_in">str</span>(b)</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">str</span>(c) <span class="keyword">in</span> temp2):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            temp3 = temp2 + <span class="built_in">str</span>(c)</span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">str</span>(d) <span class="keyword">in</span> temp3):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                temp4 = temp3 + <span class="built_in">str</span>(d)</span><br><span class="line">                <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">str</span>(e) <span class="keyword">in</span> temp4):</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    temp5 = temp4 + <span class="built_in">str</span>(e)</span><br><span class="line">                    <span class="keyword">for</span> f <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">                        <span class="keyword">if</span>(<span class="built_in">str</span>(f) <span class="keyword">in</span> temp5):</span><br><span class="line">                            <span class="keyword">continue</span></span><br><span class="line">                        temp6 = temp5 + <span class="built_in">str</span>(f)</span><br><span class="line">                        <span class="keyword">for</span> g <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">                            <span class="keyword">if</span>(<span class="built_in">str</span>(g) <span class="keyword">in</span> temp6):</span><br><span class="line">                                <span class="keyword">continue</span></span><br><span class="line">                            temp7 = temp6 + <span class="built_in">str</span>(g)</span><br><span class="line">                            <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">                                <span class="keyword">if</span>(<span class="built_in">str</span>(h) <span class="keyword">in</span> temp7):</span><br><span class="line">                                    <span class="keyword">continue</span></span><br><span class="line">                                temp8 = temp7 + <span class="built_in">str</span>(h)</span><br><span class="line">                                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">                                    <span class="keyword">if</span>(<span class="built_in">str</span>(i) <span class="keyword">in</span> temp8):</span><br><span class="line">                                        <span class="keyword">continue</span></span><br><span class="line">                                    num1 = <span class="number">100</span>*a + <span class="number">10</span> * b + c</span><br><span class="line">                                    num2 = <span class="number">100</span>*d + <span class="number">10</span> * e + f</span><br><span class="line">                                    num3 = <span class="number">100</span>*g + <span class="number">10</span> * h + i</span><br><span class="line">                                    <span class="keyword">if</span>(num2 == <span class="number">2</span>* num1 <span class="keyword">and</span> num3 == <span class="number">3</span> * num1):</span><br><span class="line">                                        <span class="built_in">print</span>(num1)</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line"><span class="number">192</span></span><br><span class="line"><span class="number">219</span></span><br><span class="line"><span class="number">273</span></span><br><span class="line"><span class="number">327</span></span><br></pre></td></tr></table></figure><h3 id="三角形面积"><a href="#三角形面积" class="headerlink" title="三角形面积"></a>三角形面积</h3><p><strong>题目描述</strong><br>如图1所示。图中的所有小方格面积都是1。<br>那么，图中的三角形面积应该是多少呢？<br>请填写三角形的面积。不要填写任何多余内容或说明性文字。</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 小学数学</span></span><br></pre></td></tr></table></figure><h3 id="立方变自身"><a href="#立方变自身" class="headerlink" title="立方变自身"></a>立方变自身</h3><p><strong>题目描述</strong><br>观察下面的现象,某个数字的立方，按位累加仍然等于自身。<br>1^3 = 1<br>8^3 = 512 5+1+2=8<br>17^3 = 4913 4+9+1+3=17<br>…</p><p>请你计算包括1,8,17在内，符合这个性质的正整数一共有多少个？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">1</span> &lt;&lt; <span class="number">64</span>):</span><br><span class="line">    n = <span class="built_in">pow</span>(i,<span class="number">3</span>)</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    list1 = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">str</span>(n)))</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> list1:</span><br><span class="line">        res += num</span><br><span class="line">    <span class="keyword">if</span>(res == i):</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">26</span></span><br><span class="line"><span class="number">27</span></span><br><span class="line">这<span class="number">6</span>个</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>2579</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">n , m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">list1 = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">weight = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>):</span><br><span class="line">    list1[i] = i</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    a,b,c = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    <span class="keyword">if</span>(a ==<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span>(b &gt; c):</span><br><span class="line">            d = b</span><br><span class="line">            b = c</span><br><span class="line">            c = d</span><br><span class="line">        list1[c] = b</span><br><span class="line">        <span class="keyword">while</span>(list1[list1[c]] != list1[c]):</span><br><span class="line">            list1[c] = list1[list1[c]]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cate = list1[b]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span>(list1[i] == cate):</span><br><span class="line">                weight[i] += c</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span>(i == n):</span><br><span class="line">        <span class="built_in">print</span>(weight[i],end = <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(weight[i],end = <span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>1083</strong></p><ul><li><p>输入输出</p></li><li><p>看解答的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    line = sys.stdin.readline()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> line:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> line.split():</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">int</span>(_)),end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul><p><strong>1094</strong></p><ul><li><p>输入输出</p></li><li><p>自己写的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">while</span>(n):</span><br><span class="line">    line = sys.stdin.readline()</span><br><span class="line">    n-=<span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(line)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    line = sys.stdin.readline().strip()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> line:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    a = line.split()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">        <span class="built_in">print</span>(i,end=<span class="string">&quot;\n\n&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><p><strong>最大值最小值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">max_value = sys.maxsize</span><br><span class="line">min_value = -sys.maxsize - <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>1096</strong></p><ul><li><p>创建二维数组</p></li><li><p>自己写的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">x = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">y = [-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">time = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    a,b = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().strip().split())</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">0</span> <span class="keyword">and</span> b == <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    matrix = []</span><br><span class="line">    output = [[<span class="string">&#x27;0&#x27;</span>] * b <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(a)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, a):</span><br><span class="line">        matr = []</span><br><span class="line">        line = sys.stdin.readline().strip()</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(line)):</span><br><span class="line">            matr.append((line[j]))</span><br><span class="line">        matrix.append(matr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,a):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, b):</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="string">&#x27;*&#x27;</span>):</span><br><span class="line">                output[i][j] = <span class="string">&#x27;*&#x27;</span></span><br><span class="line">            <span class="keyword">else</span>:   </span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">8</span>):</span><br><span class="line">                    m = i + x[k]</span><br><span class="line">                    n = j + y[k]</span><br><span class="line">                    <span class="keyword">if</span>( m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, a) <span class="keyword">and</span>  n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span> ,b)):</span><br><span class="line">                        <span class="keyword">if</span>(matrix[m][n] == <span class="string">&#x27;*&#x27;</span>):</span><br><span class="line">                            output[i][j] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(output[i][j]) + <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Field #&quot;</span> + <span class="built_in">str</span>(time) + <span class="string">&quot;:&quot;</span>)</span><br><span class="line">    time += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,a):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join([<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> output[i]]))</span><br><span class="line">    <span class="built_in">print</span>()        </span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p><strong>1434</strong></p><p>列表逆序：reverse()方法改变原有的数组，没有副本，使用切片可以解决 <a href="https://blog.csdn.net/xijuezhu8128/article/details/88555003">点击这里</a></p><p><strong>1117</strong></p><p><a href="https://blog.dotcpp.com/a/74384">解答</a></p><h3 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a><span id="文件输入输出">文件输入输出</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 适合读取一行操作一行</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;2020.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">lists = []</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">    lists.append(<span class="built_in">list</span>(line.strip()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 适合查看内容</span></span><br><span class="line"><span class="comment">#以 utf-8 的编码格式打开指定文件</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;my_file.txt&quot;</span>,encoding = <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="comment">#输出读取到的数据</span></span><br><span class="line"><span class="built_in">print</span>(f.read())</span><br><span class="line"><span class="comment">#关闭文件</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>readlines() 函数用于读取文件中的所有行，它和调用不指定 size 参数的 read() 函数类似，只不过该函数返回是一个字符串列表，其中每个元素为文件中的一行内容。</p><blockquote><p>和 readline() 函数一样，readlines() 函数在读取每一行时，<strong>会连同行尾的换行符一块读取。</strong></p></blockquote><p>readlines() 函数的基本语法格式如下：</p><p><code>file.readlines()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 适合一下子读取所有的内容，存在数组中</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;my_file.txt&quot;</span>,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">byt = f.readlines()</span><br><span class="line"><span class="built_in">print</span>(byt)</span><br><span class="line"><span class="comment">#[&#x27;PDF24664D1A723646BB\n&#x27;, &#x27;PDFD7F97D56644290DB\n&#x27;, &#x27;PDFC5826A0764EE9B4C\n&#x27;, &#x27;PDFE178C770A33F9EA1\n&#x27;, &#x27;PDF4FF9B92C273F1D01\n&#x27;, &#x27;PDFFF70075838B3AAFE\n&#x27;, &#x27;PDF9B1CA4EB63B2B7B4\n&#x27;, &#x27;PDF32A1C6DB7CB3562F&#x27;]</span></span><br></pre></td></tr></table></figure><p><a href="#文件输入输出back">back</a></p><h3 id="String-和-list转换"><a href="#String-和-list转换" class="headerlink" title="String 和 list转换 "></a><span id="string/list">String 和 list转换 </span></h3><ul><li>str转换成list</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">&#x27;abcde&#x27;</span></span><br><span class="line">str2 = <span class="string">&#x27;a b c d   e&#x27;</span></span><br><span class="line">str3 = <span class="string">&#x27;a, b, c, d, e&#x27;</span></span><br><span class="line">result1 = <span class="built_in">list</span>(str1)</span><br><span class="line">result2 = str2.split()</span><br><span class="line">result3 = str3.split(<span class="string">&#x27;, &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result1)</span><br><span class="line"><span class="built_in">print</span>(result2)</span><br><span class="line"><span class="built_in">print</span>(result3)</span><br><span class="line"><span class="comment"># [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span></span><br><span class="line"><span class="comment"># [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span></span><br><span class="line"><span class="comment"># [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span></span><br></pre></td></tr></table></figure><ul><li><p>list转化为str</p><p>当list中存放的数据是字符串时，一般是通过str中的join函数进行转换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>]</span><br><span class="line">str1 = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">list</span>)</span><br><span class="line">str2 = <span class="string">&#x27; &#x27;</span>.join(<span class="built_in">list</span>)</span><br><span class="line">str3 = <span class="string">&#x27;.&#x27;</span>.join(<span class="built_in">list</span>)</span><br><span class="line">list1  = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">list</span>(<span class="built_in">input</span>()))) <span class="comment"># 把输入的数字字符串，变成整型数组</span></span><br><span class="line"><span class="built_in">print</span>(str1)</span><br><span class="line"><span class="built_in">print</span>(str2)</span><br><span class="line"><span class="built_in">print</span>(str3)</span><br><span class="line"><span class="comment"># abcd</span></span><br><span class="line"><span class="comment"># a b c d</span></span><br><span class="line"><span class="comment"># a.b.c.d</span></span><br></pre></td></tr></table></figure><p>但是当list中存放的数据是整型数据或者数字的话，需要先将数据转换为字符串再进行转换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">str1 = <span class="string">&#x27;&#x27;</span>.join([<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span>])</span><br><span class="line">str2 = <span class="string">&#x27; &#x27;</span>.join([<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span>])</span><br><span class="line">str3 = <span class="string">&#x27;.&#x27;</span>.join([<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span>])</span><br><span class="line"><span class="built_in">print</span>(str1)</span><br><span class="line"><span class="built_in">print</span>(str2)</span><br><span class="line"><span class="built_in">print</span>(str3)</span><br><span class="line"><span class="comment"># 1234</span></span><br><span class="line"><span class="comment"># 1 2 3 4</span></span><br><span class="line"><span class="comment"># 1.2.3.4</span></span><br></pre></td></tr></table></figure><p>  <a href="#string/listBack">back</a></p></li></ul><h3 id="字符和整型的转换"><a href="#字符和整型的转换" class="headerlink" title="字符和整型的转换 "></a><span id="字符和整型的转换"><strong>字符和整型的转换</strong> </span></h3><ul><li><p>Python内置<code>ord</code>函数</p><p>用来将字符转化成ASCII码</p><p>用法为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;字符0 的ASCII码表示为&#x27;</span>,<span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符0 的ASCII码表示为 48</span></span><br></pre></td></tr></table></figure></li><li><p>Python内置chr函数</p><p>用来将ASCII码化成字符</p><p>用法为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ASCII码为97对应的字符为&#x27;</span>,<span class="built_in">chr</span>(<span class="number">97</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># ASCII码为97对应的字符为 a</span></span><br></pre></td></tr></table></figure><p><a href="#字符和整型的转换back">back</a></p></li></ul><h3 id="【time库的使用】"><a href="#【time库的使用】" class="headerlink" title="【time库的使用】 "></a><span id="time库的使用">【time库的使用】 </span></h3><p>查看<a href="https://zhuanlan.zhihu.com/p/111022726#:~:text=1.Time%E5%BA%93%E7%9A%84%E4%BD%9C%E7%94%A8.%20time%E5%BA%93%E6%98%AFPython%E4%B8%AD%E5%A4%84%E7%90%86%E6%97%B6%E9%97%B4%E7%9A%84%20%E6%A0%87%E5%87%86%E5%BA%93.%20%E6%8F%90%E4%BE%9B%20%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%20%E5%B9%B6%20%E6%A0%BC%E5%BC%8F%E5%8C%96%20%E8%BE%93%E5%87%BA%E5%8A%9F%E8%83%BD.,2.%20Time%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8.%20%E5%85%88%E6%98%8E%E7%A1%AE%E5%87%A0%E4%B8%AA%E6%A6%82%E5%BF%B5%EF%BC%9A.%20%E6%97%B6%E9%97%B4%E6%88%B3%EF%BC%9A%20%E6%A0%BC%E6%9E%97%E5%A8%81%E6%B2%BB%E6%97%B6%E9%97%B41970%E5%B9%B401%E6%9C%8801%E6%97%A500%E5%88%8600%E7%A7%92%EF%BC%88%E5%8C%97%E4%BA%AC%E6%97%B6%E9%97%B41970%E5%B9%B401%E6%9C%8801%E6%97%A508%E6%97%B600%E5%88%8600%E7%A7%92%EF%BC%89%E8%B5%B7%E8%87%B3%E7%8E%B0%E5%9C%A8%E7%9A%84%20%E6%80%BB%E7%A7%92%E6%95%B0%EF%BC%8C%E6%98%AF%E4%B8%AA%E6%95%B0%E5%AD%97%20%E3%80%82.%20Python%E4%B8%AD%E8%8E%B7%E5%8F%96%E6%97%B6%E9%97%B4%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%98%AF%EF%BC%8C%E5%85%88%E5%BE%97%E5%88%B0%E6%97%B6%E9%97%B4%E6%88%B3%EF%BC%8C%E5%86%8D%E5%B0%86%E5%85%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E6%83%B3%E8%A6%81%E7%9A%84%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E3%80%82.">这里</a></p><p>  <a href="#time库的使用back">back</a></p><h3 id="排列组合计算"><a href="#排列组合计算" class="headerlink" title="排列组合计算 "></a><span id="排列组合的计算">排列组合计算 </span></h3><p><img src="/%E8%93%9D%E6%A1%A5%E6%9D%AF/index/1_2.png"></p><ul><li>组合数：<code>math.comb(m, n)</code></li><li><p>排列数：<code>math.comb(m,n) * math.factorial(m)</code></p><p><a href="#排列组合的计算back">back</a></p></li></ul><h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出 "></a><span id="格式化输出">格式化输出 </span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">####格式化浮点数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%f&#x27;</span> % <span class="number">1.11</span>)  <span class="comment"># 默认保留6位小数</span></span><br><span class="line"> <span class="comment"># 1.110000</span></span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&#x27;%.1f&#x27;</span> % <span class="number">1.11</span>)  <span class="comment"># 取1位小数</span></span><br><span class="line"> <span class="comment"># 1.1</span></span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&#x27;%e&#x27;</span> % <span class="number">1.11</span>)  <span class="comment"># 默认6位小数，用科学计数法</span></span><br><span class="line"> <span class="comment"># 1.110000e+00</span></span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&#x27;%.3e&#x27;</span> % <span class="number">1.11</span>)  <span class="comment"># 取3位小数，用科学计数法</span></span><br><span class="line"> <span class="comment"># 1.110e+00</span></span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&#x27;%g&#x27;</span> % <span class="number">1111.1111</span>)  <span class="comment"># 默认6位有效数字</span></span><br><span class="line"> <span class="comment"># 1111.11</span></span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&#x27;%.7g&#x27;</span> % <span class="number">1111.1111</span>)  <span class="comment"># 取7位有效数字</span></span><br><span class="line"> <span class="comment"># 1111.111</span></span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&#x27;%.2g&#x27;</span> % <span class="number">1111.1111</span>)  <span class="comment"># 取2位有效数字，自动转换为科学计数法</span></span><br><span class="line"> <span class="comment"># 1.1e+03</span></span><br><span class="line">    </span><br><span class="line"> <span class="comment"># 百分比</span></span><br><span class="line">显示小数点后<span class="number">2</span>位：</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;percent: &#123;:.2f&#125;%&#x27;</span>.<span class="built_in">format</span>(<span class="number">42</span>/<span class="number">50</span>*<span class="number">100</span>))</span><br><span class="line"><span class="comment"># percent: 84.00%</span></span><br><span class="line"></span><br><span class="line">显示小数点后<span class="number">1</span>位：</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;percent: &#123;:.1f&#125;%&#x27;</span>.<span class="built_in">format</span>(<span class="number">42</span>/<span class="number">50</span>*<span class="number">100</span>))</span><br><span class="line"><span class="comment"># percent: 84.0%</span></span><br><span class="line"></span><br><span class="line">只显示整数位：</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;percent: &#123;:.0f&#125;%&#x27;</span>.<span class="built_in">format</span>(<span class="number">42</span>/<span class="number">50</span>*<span class="number">100</span>))</span><br><span class="line"><span class="comment"># percent: 84%</span></span><br></pre></td></tr></table></figure><p><a href="#格式化输出back">back</a></p><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">n,k = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> &lt;&lt; n):</span><br><span class="line">    binary = <span class="built_in">str</span>(<span class="built_in">bin</span>(i))</span><br><span class="line">    <span class="built_in">print</span>(binary)</span><br><span class="line">    count = binary[<span class="number">2</span>:].count(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span>(count == k):</span><br><span class="line">        <span class="keyword">if</span>(check(<span class="built_in">int</span>(binary,<span class="number">2</span>))):</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line">https://www.luogu.com.cn/problem/P1036</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/weixin_43353539/article/details/89444838">这里</a></p><h3 id="对象排序-python"><a href="#对象排序-python" class="headerlink" title="对象排序 python"></a><span id="对象排序">对象排序 </span>python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a = (<span class="number">0</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>)</span><br><span class="line">    b = [(<span class="string">&#x27;a&#x27;</span>, <span class="number">12</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">12</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;d&#x27;</span>, <span class="number">13</span>), (<span class="string">&#x27;e&#x27;</span>, <span class="number">2</span>)]</span><br><span class="line">    person_list = [Person(<span class="string">&#x27;q&#x27;</span>, <span class="number">2</span>), Person(<span class="string">&#x27;w&#x27;</span>, <span class="number">1</span>), Person(<span class="string">&#x27;e&#x27;</span>, <span class="number">3</span>), Person(<span class="string">&#x27;r&#x27;</span>, <span class="number">6</span>)]</span><br><span class="line">    a.sort(cmp=<span class="literal">None</span>, key=<span class="literal">None</span>, reverse=<span class="literal">True</span>)   <span class="comment"># reverse 参数为 True 时逆向排序</span></span><br><span class="line">    <span class="built_in">print</span> a</span><br><span class="line">    b.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>]) <span class="comment">#正序</span></span><br><span class="line">    b.sort(key=<span class="keyword">lambda</span> x: -x[<span class="number">1</span>]) <span class="comment">#逆序</span></span><br><span class="line">    b.sort(key=<span class="keyword">lambda</span> x: (x[<span class="number">1</span>],-x[<span class="number">0</span>]) <span class="comment">#先按照下标1正序，相同，按照第一个元素递减</span></span><br><span class="line">    <span class="built_in">print</span> b</span><br><span class="line">    person_list.sort(key=<span class="keyword">lambda</span> x: x.age)  <span class="comment">#这里</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> person_list:</span><br><span class="line">        <span class="built_in">print</span> i.age</span><br><span class="line">           </span><br><span class="line"><span class="comment"># 如果要实现部分排序，并且数组不是numpy数组，使用sorted</span></span><br><span class="line"> b[i:j] = b.<span class="built_in">sorted</span>(b[i:j], key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line">           </span><br><span class="line"><span class="comment"># 高阶自定义排序</span></span><br><span class="line"><span class="keyword">import</span>  functools</span><br><span class="line">a = [<span class="number">3</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compare_personal</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x%<span class="number">7</span>-y%<span class="number">7</span></span><br><span class="line">a.sort(key=functools.cmp_to_key(compare_personal))</span><br><span class="line">b = <span class="built_in">sorted</span>(a,key=functools.cmp_to_key(compare_personal))</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="对象排序-C"><a href="#对象排序-C" class="headerlink" title="对象排序 C++"></a>对象排序 C++</h3><h4 id="数组-单元素"><a href="#数组-单元素" class="headerlink" title="数组+单元素"></a>数组+单元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 升序</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">7</span>] = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(a, a + <span class="number">7</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">7</span>; i ++)&#123;</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 降序</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &gt; y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">7</span>] = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(a, a + <span class="number">7</span>,cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">7</span>; i ++)&#123;</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组-结构体"><a href="#数组-结构体" class="headerlink" title="数组 + 结构体"></a>数组 + 结构体</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">&#125; a[<span class="number">6</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> node &amp;a, <span class="keyword">const</span> node&amp;b)</span> </span>&#123;</span><br><span class="line"><span class="comment">//return a.num &lt; b.num; // 按照num升序</span></span><br><span class="line"><span class="comment">//return a.num &gt; b.num; // 按照num降序</span></span><br><span class="line"><span class="comment">//return a.val &gt; b.val; // 按照val降序</span></span><br><span class="line"><span class="keyword">return</span> a.val &lt; b.val; <span class="comment">// 按照val升序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">a[<span class="number">0</span>].num = <span class="number">3</span>;</span><br><span class="line">a[<span class="number">0</span>].val = <span class="number">10</span>;</span><br><span class="line">a[<span class="number">1</span>].num = <span class="number">4</span>;</span><br><span class="line">a[<span class="number">1</span>].val = <span class="number">8</span>;</span><br><span class="line">a[<span class="number">2</span>].num = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">2</span>].val = <span class="number">2</span>;</span><br><span class="line">a[<span class="number">3</span>].num = <span class="number">6</span>;</span><br><span class="line">a[<span class="number">3</span>].val = <span class="number">4</span>;</span><br><span class="line">a[<span class="number">4</span>].num = <span class="number">2</span>;</span><br><span class="line">a[<span class="number">4</span>].val = <span class="number">7</span>;</span><br><span class="line">a[<span class="number">5</span>].num = <span class="number">9</span>;</span><br><span class="line">a[<span class="number">5</span>].val = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">sort</span>(a, a + <span class="number">6</span>,cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">6</span>; i ++) &#123;</span><br><span class="line">cout &lt;&lt; a[i].num &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a[i].val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vector-单元素"><a href="#vector-单元素" class="headerlink" title="vector + 单元素"></a>vector + 单元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 升序</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; a = &#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">6</span>; i ++) &#123;</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 降序</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &gt; y; <span class="comment">// 降序 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; a = &#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(),cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">6</span>; i ++) &#123;</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vector-结构体"><a href="#vector-结构体" class="headerlink" title="vector + 结构体"></a>vector + 结构体</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> node &amp;a, <span class="keyword">const</span> node&amp;b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.num &lt; b.num; <span class="comment">// 按照num升序</span></span><br><span class="line"><span class="comment">//return a.num &gt; b.num; // 按照num降序</span></span><br><span class="line"><span class="comment">//return a.val &gt; b.val; // 按照val降序</span></span><br><span class="line"><span class="comment">//return a.val &lt; b.val; // 按照val升序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;node&gt; a;</span><br><span class="line">a.<span class="built_in">push_back</span>(&#123;<span class="number">3</span>,<span class="number">10</span>&#125;);</span><br><span class="line">a.<span class="built_in">push_back</span>(&#123;<span class="number">4</span>,<span class="number">8</span>&#125;);</span><br><span class="line">a.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>,<span class="number">2</span>&#125;);</span><br><span class="line">a.<span class="built_in">push_back</span>(&#123;<span class="number">6</span>,<span class="number">4</span>&#125;);</span><br><span class="line">a.<span class="built_in">push_back</span>(&#123;<span class="number">2</span>,<span class="number">7</span>&#125;);</span><br><span class="line">a.<span class="built_in">push_back</span>(&#123;<span class="number">9</span>,<span class="number">1</span>&#125;);</span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(),cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">6</span>; i ++) &#123;</span><br><span class="line">cout &lt;&lt; a[i].num &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a[i].val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="priority-queue-单元素"><a href="#priority-queue-单元素" class="headerlink" title="priority_queue + 单元素"></a>priority_queue + 单元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 默认降序 </span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">a.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">a.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line">a.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">a.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">a.<span class="built_in">push</span>(<span class="number">9</span>);</span><br><span class="line">a.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">a.<span class="built_in">push</span>(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">while</span>(!a.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">cout &lt;&lt; a.<span class="built_in">top</span>() &lt;&lt;endl;</span><br><span class="line">a.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q;<span class="comment">//默认是从大到小</span></span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt; ,less&lt;<span class="keyword">int</span>&gt; &gt;q;<span class="comment">//从大到小排序</span></span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt;q;<span class="comment">//从小到大排序</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="priority-queue-结构体"><a href="#priority-queue-结构体" class="headerlink" title="priority_queue + 结构体"></a>priority_queue + 结构体</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node&amp; b) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="comment">//return num &lt; b.num; // 按照num降序</span></span><br><span class="line"><span class="comment">//return num &gt; b.num; // 按照num升序</span></span><br><span class="line"><span class="comment">//return val &lt; b.val; // 按照val降序</span></span><br><span class="line"><span class="keyword">return</span> val &gt; b.val; <span class="comment">// 按照val升序</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;node&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">a.<span class="built_in">push</span>(&#123;<span class="number">3</span>,<span class="number">10</span>&#125;);</span><br><span class="line">a.<span class="built_in">push</span>(&#123;<span class="number">4</span>,<span class="number">8</span>&#125;);</span><br><span class="line">a.<span class="built_in">push</span>(&#123;<span class="number">1</span>,<span class="number">2</span>&#125;);</span><br><span class="line">a.<span class="built_in">push</span>(&#123;<span class="number">6</span>,<span class="number">4</span>&#125;);</span><br><span class="line">a.<span class="built_in">push</span>(&#123;<span class="number">2</span>,<span class="number">7</span>&#125;);</span><br><span class="line">a.<span class="built_in">push</span>(&#123;<span class="number">9</span>,<span class="number">1</span>&#125;);</span><br><span class="line"><span class="keyword">while</span>(!a.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">cout &lt;&lt; a.<span class="built_in">top</span>().num &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a.<span class="built_in">top</span>().val &lt;&lt; endl;</span><br><span class="line">a.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#对象排序back">back</a></p><h3 id="整除问题"><a href="#整除问题" class="headerlink" title="整除问题"></a>整除问题</h3><p>有一个序列，序列的第一个数是 ，后面的每个数是前一个数整除 2，请输出这个序列中值为正数的项。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>( n != <span class="number">0</span> <span class="keyword">and</span> n &gt; <span class="number">0</span>):</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(n ,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        <span class="built_in">print</span>(n,end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    n //= <span class="number">2</span> <span class="comment"># 注意不能使用（floor(n/2),浮点数有精度问题）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="关于日期"><a href="#关于日期" class="headerlink" title="关于日期"></a>关于日期</h3><p><a href="https://www.dotcpp.com/oj/problem2571.html">2571</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">n = <span class="built_in">input</span>()</span><br><span class="line">year = <span class="built_in">int</span>(n[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line"><span class="keyword">if</span>(n[<span class="number">4</span>] == <span class="string">&#x27;0&#x27;</span>):</span><br><span class="line">    month = <span class="built_in">int</span>(n[<span class="number">5</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    month = <span class="built_in">int</span>(n[<span class="number">4</span>:<span class="number">6</span>])</span><br><span class="line"><span class="keyword">if</span>(n[<span class="number">6</span>] == <span class="string">&#x27;0&#x27;</span>):</span><br><span class="line">    day = <span class="built_in">int</span>(n[<span class="number">7</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    day = <span class="built_in">int</span>(n[<span class="number">6</span>:<span class="number">8</span>])</span><br><span class="line">now = datetime.date(year,month,day)</span><br><span class="line"><span class="comment">##print(now.year)</span></span><br><span class="line"><span class="comment">##print(now.month)</span></span><br><span class="line"><span class="comment">##print(now.day)</span></span><br><span class="line"><span class="comment">##print(str(now))</span></span><br><span class="line">find1 = <span class="literal">False</span></span><br><span class="line">find2 =<span class="literal">False</span></span><br><span class="line">huiwen = <span class="string">&quot;&quot;</span></span><br><span class="line">ABhuiwen = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    now = now + datetime.timedelta(days = <span class="number">1</span>)</span><br><span class="line">    daystr = <span class="built_in">str</span>(now)[<span class="number">0</span>:<span class="number">4</span>] + <span class="built_in">str</span>(now)[<span class="number">5</span>:<span class="number">7</span>] + <span class="built_in">str</span>(now)[<span class="number">8</span>:<span class="number">10</span>]</span><br><span class="line">    <span class="keyword">if</span>(daystr == daystr[::-<span class="number">1</span>] <span class="keyword">and</span> <span class="keyword">not</span> find1):</span><br><span class="line">        huiwen = daystr</span><br><span class="line">        find1 = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">not</span> find2 <span class="keyword">and</span> daystr[<span class="number">0</span>] == daystr[<span class="number">2</span>] == daystr[<span class="number">5</span>]== daystr[<span class="number">7</span>]</span><br><span class="line">       <span class="keyword">and</span> daystr[<span class="number">1</span>] == daystr[<span class="number">3</span>] == daystr[<span class="number">4</span>] == daystr[<span class="number">6</span>]</span><br><span class="line">       <span class="keyword">and</span> daystr[<span class="number">0</span>] != daystr[<span class="number">1</span>]):</span><br><span class="line">        ABhuiwen = daystr</span><br><span class="line">        find2= <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span>(find1 <span class="keyword">and</span> find2):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(huiwen)</span><br><span class="line"><span class="built_in">print</span>(ABhuiwen)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="字符串求子串"><a href="#字符串求子串" class="headerlink" title="字符串求子串"></a>字符串求子串</h3><p><a href="https://www.dotcpp.com/oj/problem2572.html">题目</a></p><p><a href="https://blog.csdn.net/weixin_46239370/article/details/115277142">思路</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="built_in">input</span>()</span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(str1)):</span><br><span class="line">    pre = str1.rfind(str1[i],<span class="number">0</span>,i)</span><br><span class="line">    nextIndex = str1.find(str1[i],i + <span class="number">1</span>, <span class="built_in">len</span>(str1) + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span>(nextIndex == -<span class="number">1</span>):</span><br><span class="line">        nextIndex = <span class="built_in">len</span>(str1)</span><br><span class="line">    res += (i-pre)*(nextIndex - i)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><h3 id="Decimal"><a href="#Decimal" class="headerlink" title="Decimal"></a>Decimal</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#需要导入这个库</span></span><br><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#设置精度</span></span><br><span class="line">getcontext().prec=<span class="number">6</span></span><br><span class="line">a=Decimal(<span class="number">1</span>)/Decimal(<span class="number">7</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0.142857</span></span><br><span class="line"><span class="comment"># &lt;class &#x27;decimal.Decimal&#x27;&gt;</span></span><br></pre></td></tr></table></figure><p><a href="#decimalback">back</a></p><p><strong>使用reverse会改变原来，使用replace 不会改变原来</strong></p><h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><p>index()</p><h3 id="空格包括回车和制表符！！"><a href="#空格包括回车和制表符！！" class="headerlink" title="空格包括回车和制表符！！"></a>空格包括回车和制表符！！</h3><h3 id="读入字符串一定要去收尾空格！"><a href="#读入字符串一定要去收尾空格！" class="headerlink" title="读入字符串一定要去收尾空格！"></a>读入字符串一定要去收尾空格！</h3><p><a href="https://www.luogu.com.cn/problem/P1308">https://www.luogu.com.cn/problem/P1308</a> </p><p><a href="https://www.luogu.com.cn/problem/P3741">https://www.luogu.com.cn/problem/P3741</a></p><p>删除前后零 <a href="https://www.luogu.com.cn/problem/P1553">https://www.luogu.com.cn/problem/P1553</a></p><p>高精度乘 <a href="https://www.luogu.com.cn/problem/P1303">https://www.luogu.com.cn/problem/P1303</a></p><p>全局变量的使用 <a href="https://www.luogu.com.cn/problem/P1518">https://www.luogu.com.cn/problem/P1518</a></p><p>字符串展开 <a href="https://www.luogu.com.cn/problem/P1098">https://www.luogu.com.cn/problem/P1098</a></p><p>计算2**n 的长度，n很大的时候不能使用len，会超限 <a href="https://www.luogu.com.cn/problem/P1045">https://www.luogu.com.cn/problem/P1045</a></p><p>C++中用find找字符串中的子串，找不到会返回一个诡异的数字（反正比字符串长），dev C++中不能使用 string:npos</p><h3 id="输出限制场宽"><a href="#输出限制场宽" class="headerlink" title="输出限制场宽"></a>输出限制场宽</h3><h3 id="全排列问题"><a href="#全排列问题" class="headerlink" title="全排列问题"></a>全排列问题</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># include &lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"><span class="built_in">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">int</span> main () &#123;</span><br><span class="line"><span class="built_in">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i =<span class="number">1</span>; i &lt; n+<span class="number">1</span>; i ++)&#123;</span><br><span class="line">a[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">do&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i =<span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">printf(<span class="string">&quot;%5d&quot;</span>,a[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;<span class="keyword">while</span>(next_permutation(a+<span class="number">1</span>,a+n+<span class="number">1</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line">nums = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> itertools.permutations(nums, <span class="number">3</span>):</span><br><span class="line">    a = num[<span class="number">0</span>] + num[<span class="number">1</span>] + num[<span class="number">2</span>]</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">   </span><br><span class="line">  abc 输出：</span><br><span class="line">abc</span><br><span class="line">acb</span><br><span class="line">bac</span><br><span class="line">bca</span><br><span class="line">cab</span><br><span class="line">cba`</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="以固定场宽输出"><a href="#以固定场宽输出" class="headerlink" title="以固定场宽输出"></a>以固定场宽输出</h3><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805135224455168">https://pintia.cn/problem-sets/994805046380707840/problems/994805135224455168</a></p><p>C++与其类似</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%5d&quot;</span>, a[s][i]);</span><br></pre></td></tr></table></figure><h3 id="取整问题"><a href="#取整问题" class="headerlink" title="取整问题"></a>取整问题</h3><p><img src="/%E8%93%9D%E6%A1%A5%E6%9D%AF/index/1.png"></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>19. Conclusions</title>
      <link href="/19-conclusions/index.html"/>
      <url>/19-conclusions/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="Where-to-Go-from-Here"><a href="#Where-to-Go-from-Here" class="headerlink" title="Where to Go from Here"></a>Where to Go from Here</h2><h3 id="Other-courses"><a href="#Other-courses" class="headerlink" title="Other courses"></a>Other courses</h3><p>If you are looking for a similar pattern-based approach to solve <strong>Dynamic Programming</strong> problems, take a look at <a href="https://www.educative.io/collection/5668639101419520/5633779737559040">Grokking Dynamic Programming Patterns for Coding Interviews</a>.</p><p>Here are a couple of other courses for design interviews:</p><ul><li><a href="https://www.educative.io/collection/5668639101419520/5649050225344512">Grokking the System Design Interview</a></li><li><a href="https://www.educative.io/collection/5668639101419520/5692201761767424">Grokking the Object Oriented Design Interview</a></li></ul><h3 id="Contact-Us"><a href="#Contact-Us" class="headerlink" title="Contact Us"></a>Contact Us</h3><p>For feedback, comments, and suggestions, we can be reached at <a href="mailto:hello@designgurus.org">hello@designgurus.org</a></p><h3 id="Acknowledgements"><a href="#Acknowledgements" class="headerlink" title="Acknowledgements"></a>Acknowledgements</h3><p>We would like to acknowledge everyone who helped us review this course or pointed out errors. We keep improving the course and introducing more content. If you see any mistake or if you feel there is a better approach to solving a problem, please do let us know. Our sincere thanks to the following people for making their contributions to this course:</p><ul><li>Chris Redford</li><li>Mike Veselovsky</li><li>Fahim ul Haq</li><li>Hamid Zia</li><li>Ankit Gomkale</li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>18. Miscellaneous</title>
      <link href="/18-miscellaneous/index.html"/>
      <url>/18-miscellaneous/index.html</url>
      
        <content type="html"><![CDATA[<h3 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given an unsorted array of numbers, find Kth smallest number in it.</p><p>Please note that it is the Kth smallest number in the sorted order, not the Kth distinct element.</p><p><strong>Example 1:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> [<span class="number">1</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">5</span>], K = <span class="number">3</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="number">5</span></span><br><span class="line"><span class="symbol">Explanation:</span> The <span class="number">3</span>rd smallest number <span class="built_in">is</span> <span class="comment">&#x27;5&#x27;, as the first two smaller numbers are [1, 2].</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Inpu<span class="variable">t:</span> [<span class="number">1</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">5</span>], K = <span class="number">4</span></span><br><span class="line">Outpu<span class="variable">t:</span> <span class="number">5</span></span><br><span class="line">Explanation: The <span class="number">4</span><span class="keyword">th</span> smallest <span class="keyword">number</span> <span class="keyword">is</span> <span class="string">&#x27;5&#x27;</span>, <span class="keyword">as</span> the <span class="keyword">first</span> three small numbers are [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>].</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> [<span class="number">5</span>, <span class="number">12</span>, <span class="number">11</span>, -<span class="number">1</span>, <span class="number">12</span>], K = <span class="number">3</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="number">11</span></span><br><span class="line"><span class="symbol">Explanation:</span> The <span class="number">3</span>rd smallest number <span class="built_in">is</span> <span class="comment">&#x27;11&#x27;, as the first two small numbers are [5, -1].</span></span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself"><a href="#Try-it-yourself" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跳过</span></span><br></pre></td></tr></table></figure><p>This is a well-known problem and there are multiple solutions available to solve this. A few other similar problems are:</p><ol><li>Find the Kth largest number in an unsorted array.</li><li>Find ‘K’ smallest or largest numbers in an unsorted array.</li><li>Find the median of an unsorted array</li></ol><p>Let’s discuss different algorithms to solve this problem and understand their time and space complexity. Similar solutions can be devised for the above-mentioned three problems.</p><h3 id="1-Brute-force"><a href="#1-Brute-force" class="headerlink" title="1. Brute-force"></a>1. Brute-force</h3><p>The simplest brute-force algorithm will be to find the Kth smallest number in a step by step fashion. This means that, first, we will find the smallest element, then 2nd smallest, then 3rd smallest and so on, until we have found the Kth smallest element. Here is what the algorithm will look like:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthSmallestNumber</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findKthSmallestNumber</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// to handle duplicates, we will keep track of previous smallest number</span></span><br><span class="line">        <span class="comment">// and its index</span></span><br><span class="line">        <span class="keyword">int</span> previousSmallestNum = INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> previousSmallestIndex = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> currrentSmallNum = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> currentSmallestIndex = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; previousSmallestNum &amp;&amp;</span><br><span class="line">                    nums[j] &lt; currrentSmallNum) &#123;</span><br><span class="line">                    <span class="comment">// found the next smallest number</span></span><br><span class="line">                    currrentSmallNum = nums[j];</span><br><span class="line">                    currentSmallestIndex = j;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[j] == previousSmallestNum &amp;&amp;</span><br><span class="line">                           j &gt; previousSmallestIndex) &#123;</span><br><span class="line">                    <span class="comment">// found a number which is equal to the previous smallest</span></span><br><span class="line">                    <span class="comment">// number, since numbers can repeat, we will consider</span></span><br><span class="line">                    <span class="comment">// &#x27;num[j]&#x27; only if it has different index than previous</span></span><br><span class="line">                    <span class="comment">// smallest</span></span><br><span class="line">                    currrentSmallNum = nums[j];</span><br><span class="line">                    currentSmallestIndex = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            previousSmallestIndex = currentSmallestIndex;</span><br><span class="line">            previousSmallestNum = currrentSmallNum;</span><br><span class="line">            currrentSmallNum = INT_MAX;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> previousSmallestNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = KthSmallestNumber::<span class="built_in">findKthSmallestNumber</span>(</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">5</span>&#125;, <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Kth smallest number is: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    result = KthSmallestNumber::<span class="built_in">findKthSmallestNumber</span>(</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">5</span>&#125;, <span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Kth smallest number is: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    result = KthSmallestNumber::<span class="built_in">findKthSmallestNumber</span>(</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">5</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">-1</span>, <span class="number">12</span>&#125;, <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Kth smallest number is: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Time-amp-Space-Complexity"><a href="#Time-amp-Space-Complexity" class="headerlink" title="Time &amp; Space Complexity"></a>Time &amp; Space Complexity</h4><p>The time complexity of the above algorithm will be <strong><em>O(N\</em>K)*</strong>. The algorithm runs in constant space <strong><em>O(1)</em></strong>.</p><h3 id="2-Brute-force-using-Sorting"><a href="#2-Brute-force-using-Sorting" class="headerlink" title="2. Brute-force using Sorting"></a>2. Brute-force using Sorting</h3><p>We can use an in-place sort like a <strong>HeapSort</strong> to sort the input array to get the Kth smallest number. Following is the code for this solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthSmallestNumber</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findKthSmallestNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> nums[k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; input = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> result = KthSmallestNumber::<span class="built_in">findKthSmallestNumber</span>(input, <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Kth smallest number is: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    input = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    result = KthSmallestNumber::<span class="built_in">findKthSmallestNumber</span>(input, <span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Kth smallest number is: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    input = &#123;<span class="number">5</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">-1</span>, <span class="number">12</span>&#125;;</span><br><span class="line">    result = KthSmallestNumber::<span class="built_in">findKthSmallestNumber</span>(input, <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Kth smallest number is: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Time-amp-Space-Complexity-1"><a href="#Time-amp-Space-Complexity-1" class="headerlink" title="Time &amp; Space Complexity"></a>Time &amp; Space Complexity</h4><p>Sorting will take <strong><em>O(NlogN)</em></strong> and if we are not using an in-place sorting algorithm, we will need <strong><em>O(N)</em></strong> space.</p><h3 id="3-Using-Max-Heap"><a href="#3-Using-Max-Heap" class="headerlink" title="3. Using Max-Heap"></a>3. Using Max-Heap</h3><p>As discussed in <a href="https://hasuer.github.io/14-pattern-top-k-elements/index.html#/Code"><em>Kth Smallest Number</em></a>, we can iterate the array and use a <strong>Max Heap</strong> to keep track of ‘K’ smallest number. In the end, the root of the heap will have the Kth smallest number.</p><p>Here is what this algorithm will look like:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthSmallestNumber</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findKthSmallestNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>&gt; maxHeap;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// put first k numbers in the max heap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            maxHeap.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// go through the remaining numbers of the array, if the number from the</span></span><br><span class="line">        <span class="comment">// array is smaller than the top(biggest) number of the heap, remove the</span></span><br><span class="line">        <span class="comment">// top number from heap and add the number from array</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; maxHeap.<span class="built_in">top</span>()) &#123;</span><br><span class="line">                maxHeap.<span class="built_in">pop</span>();</span><br><span class="line">                maxHeap.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// the root of the heap has the kth smallest number</span></span><br><span class="line">        <span class="keyword">return</span> maxHeap.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; input = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> result = KthSmallestNumber::<span class="built_in">findKthSmallestNumber</span>(input, <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Kth smallest number is: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    input = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    result = KthSmallestNumber::<span class="built_in">findKthSmallestNumber</span>(input, <span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Kth smallest number is: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    input = &#123;<span class="number">5</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">-1</span>, <span class="number">12</span>&#125;;</span><br><span class="line">    result = KthSmallestNumber::<span class="built_in">findKthSmallestNumber</span>(input, <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Kth smallest number is: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Time-amp-Space-Complexity-2"><a href="#Time-amp-Space-Complexity-2" class="headerlink" title="Time &amp; Space Complexity"></a>Time &amp; Space Complexity</h4><p>The time complexity of the above algorithm is <strong><em>O(KlogK + (N-K)logK)</em></strong> which is asymptotically equal to <strong><em>O(N\</em>logK)*</strong>. The space complexity will be <strong><em>O(K)</em></strong> because we need to store ‘K’ smallest numbers in the heap.</p><h3 id="4-Using-Min-Heap"><a href="#4-Using-Min-Heap" class="headerlink" title="4. Using Min-Heap"></a>4. Using Min-Heap</h3><p>Also discussed in <em>Kth Smallest Number</em>, we can use a <strong>Min Heap</strong> to find the Kth smallest number. We can insert all the numbers in the min-heap and then extract the top ‘K’ numbers from the heap to find the Kth smallest number.</p><h4 id="Time-amp-Space-Complexity-3"><a href="#Time-amp-Space-Complexity-3" class="headerlink" title="Time &amp; Space Complexity"></a>Time &amp; Space Complexity</h4><p>Inserting all numbers in the heap will take <strong><em>O(N\</em>logN)*</strong> and extracting ‘K’ numbers will take <strong><em>O(K\</em>logN)*</strong>. Overall, the time complexity of this algorithm will be <strong><em>O(NlogN+KlogN)</em></strong> and the space complexity will be <strong><em>O(N)</em></strong>.</p><h3 id="5-Using-Partition-Scheme-of-Quicksort"><a href="#5-Using-Partition-Scheme-of-Quicksort" class="headerlink" title="5. Using Partition Scheme of Quicksort"></a>5. Using Partition Scheme of Quicksort</h3><p><a href="https://en.wikipedia.org/wiki/Quicksort">Quicksort</a> picks a number called <strong>pivot</strong> and partition the input array around it. After partitioning, all numbers smaller than the pivot are to the left of the pivot, and all numbers greater than or equal to the pivot are to the right of the pivot. This ensures that the pivot has reached its correct sorted position.</p><p>We can use this partitioning scheme to find the Kth smallest number. We will recursively partition the input array and if, after partitioning, our pivot is at the <code>K-1</code> index we have found our required number; if not, we will choose one the following option:</p><ol><li>If pivot’s position is larger than <code>K-1</code>, we will recursively partition the array on numbers lower than the pivot.</li><li>If pivot’s position is smaller than <code>K-1</code>, we will recursively partition the array on numbers greater than the pivot.</li></ol><p>Here is what our algorithm will look like:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthSmallestNumber</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findKthSmallestNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findKthSmallestNumberRec</span>(nums, k, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findKthSmallestNumberRec</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="keyword">int</span> k,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="keyword">int</span> start,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="built_in">partition</span>(nums, start, end);</span><br><span class="line">        <span class="keyword">if</span> (p == k - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p &gt; k - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findKthSmallestNumberRec</span>(nums, k, start, p - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findKthSmallestNumberRec</span>(nums, k, p + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (low == high) &#123;</span><br><span class="line">            <span class="keyword">return</span> low;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pivot = nums[high];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = low; i &lt; high; i++) &#123;</span><br><span class="line">            <span class="comment">// all elements less than &#x27;povit&#x27; will be before the index &#x27;low&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; pivot) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums, low++, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// put the pivot in its correct place</span></span><br><span class="line">        <span class="built_in">swap</span>(nums, low, high);</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; input = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> result = KthSmallestNumber::<span class="built_in">findKthSmallestNumber</span>(input, <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Kth smallest number is: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    input = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    result = KthSmallestNumber::<span class="built_in">findKthSmallestNumber</span>(input, <span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Kth smallest number is: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    input = &#123;<span class="number">5</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">-1</span>, <span class="number">12</span>&#125;;</span><br><span class="line">    result = KthSmallestNumber::<span class="built_in">findKthSmallestNumber</span>(input, <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Kth smallest number is: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Time-amp-Space-Complexity-4"><a href="#Time-amp-Space-Complexity-4" class="headerlink" title="Time &amp; Space Complexity"></a>Time &amp; Space Complexity</h4><p>The above algorithm is known as <a href="https://en.wikipedia.org/wiki/Quickselect">QuickSelect</a> and has a Worst case time complexity of <strong><em>O(N^2)</em></strong>. The best and average case is <strong><em>O(N)</em></strong>, which is better than the best and average case of <a href="https://en.wikipedia.org/wiki/Quicksort">QuickSort</a>. Overall, QuickSelect uses the same approach as QuickSort i.e., partitioning the data into two parts based on a pivot. However, contrary to QuickSort, instead of recursing into both sides QuickSelect only recurses into one side – the side with the element it is searching for. This reduces the average and best case time complexity from <strong><em>O(N\</em>logN)*</strong> to <strong><em>O(N)</em></strong>.</p><p>The worst-case occurs when, at every step, the partition procedure splits the N-length array into arrays of size ‘11’ and ‘N−1’. This can only happen when the input array is sorted or if all of its elements are the same. This “unlucky” selection of pivot elements requires <strong><em>O(N)</em></strong> recursive calls, leading to an <strong><em>O(N^2)</em></strong> worst-case.</p><p>Worst-case space complexity will be <strong><em>O(N)</em></strong> used for the recursion stack. See details under <a href="https://en.wikipedia.org/wiki/Quicksort">Quicksort</a>.</p><h3 id="6-Using-Randomized-Partitioning-Scheme-of-Quicksort"><a href="#6-Using-Randomized-Partitioning-Scheme-of-Quicksort" class="headerlink" title="6. Using Randomized Partitioning Scheme of Quicksort"></a>6. Using Randomized Partitioning Scheme of Quicksort</h3><p>As mentioned above, the worst case for <strong>Quicksort</strong> occurs when the partition procedure splits the N-length array into arrays of size ‘11’ and ‘N−1’. To mitigate this, instead of always picking a fixed index for pivot (e.g., in the above algorithm we always pick <code>nums[high]</code> as the pivot), we can randomly select an element as pivot. After randomly choosing the pivot element, we expect the split of the input array to be reasonably well balanced on average.</p><p>Here is what our algorithm will look like (only the highlighted lines have changed):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthSmallestNumber</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findKthSmallestNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findKthSmallestNumberRec</span>(nums, k, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findKthSmallestNumberRec</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="keyword">int</span> k,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="keyword">int</span> start,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="built_in">partition</span>(nums, start, end);</span><br><span class="line">        <span class="keyword">if</span> (p == k - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p &gt; k - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findKthSmallestNumberRec</span>(nums, k, start, p - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findKthSmallestNumberRec</span>(nums, k, p + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (low == high) &#123;</span><br><span class="line">            <span class="keyword">return</span> low;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> pivotIndex = low + <span class="built_in">rand</span>() % (high - low);</span><br><span class="line">        <span class="built_in">swap</span>(nums, pivotIndex, high);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pivotIndex: &quot;</span> &lt;&lt; pivotIndex &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[high];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = low; i &lt; high; i++) &#123;</span><br><span class="line">            <span class="comment">// all elements less than &#x27;povit&#x27; will be before the index &#x27;low&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; pivot) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums, low++, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// put the pivot in its correct place</span></span><br><span class="line">        <span class="built_in">swap</span>(nums, low, high);</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; input = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> result = KthSmallestNumber::<span class="built_in">findKthSmallestNumber</span>(input, <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Kth smallest number is: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    input = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    result = KthSmallestNumber::<span class="built_in">findKthSmallestNumber</span>(input, <span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Kth smallest number is: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    input = &#123;<span class="number">5</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">-1</span>, <span class="number">12</span>&#125;;</span><br><span class="line">    result = KthSmallestNumber::<span class="built_in">findKthSmallestNumber</span>(input, <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Kth smallest number is: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Time-amp-Space-Complexity-5"><a href="#Time-amp-Space-Complexity-5" class="headerlink" title="Time &amp; Space Complexity"></a>Time &amp; Space Complexity</h4><p>The above algorithm has the same worst and average case time complexities as mentioned for the previous algorithm. But choosing the pivot randomly has the effect of rendering the worst-case very unlikely, particularly for large arrays. Therefore, the <strong>expected</strong> time complexity of the above algorithm will be <strong><em>O(N)</em></strong>, but the absolute worst case is still <strong><em>O(N^2)</em></strong>. Practically, this algorithm is a lot faster than the non-randomized version.</p><h3 id="7-Using-the-Median-of-Medians"><a href="#7-Using-the-Median-of-Medians" class="headerlink" title="7. Using the Median of Medians"></a>7. Using the Median of Medians</h3><p>We can use the <a href="https://en.wikipedia.org/wiki/Median_of_medians">Median of Medians</a> algorithm to choose a <strong>good pivot</strong> for the partitioning algorithm of the <strong>Quicksort</strong>. This algorithm finds an approximate median of an array in linear time O(N)<em>O</em>(<em>N</em>). When this approximate median is used as the pivot, the worst-case complexity of the partitioning procedure reduces to linear O(N)<em>O</em>(<em>N</em>), which is also the asymptotically optimal worst-case complexity of any sorting/selection algorithm. This algorithm was originally developed by Blum, Floyd, Pratt, Rivest, and Tarjan and was describe in their <a href="http://people.csail.mit.edu/rivest/pubs/BFPRT73.pdf">1973 paper</a>.</p><p>This is how the partitioning algorithm works:</p><ol><li>If we have 5 or less than 5 elements in the input array, we simply take its first element as the pivot. If not then we divide the input array into subarrays of five elements (for simplicity we can ignore any subarray having less than five elements).</li><li>Sort each subarray to determine its median. Sorting a small and fixed numbered array takes constant time. At the end of this step, we have an array containing medians of all the subarray.</li><li>Recursively call the partitioning algorithm on the array containing medians until we get our pivot.</li><li>Every time the partition procedure needs to find a pivot, it will follow the above three steps.</li></ol><p>Here is what this algorithm will look like:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthSmallestNumber</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findKthSmallestNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findKthSmallestNumberRec</span>(nums, k, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findKthSmallestNumberRec</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="keyword">int</span> k,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="keyword">int</span> start,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="built_in">partition</span>(nums, start, end);</span><br><span class="line">        <span class="keyword">if</span> (p == k - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p &gt; k - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findKthSmallestNumberRec</span>(nums, k, start, p - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findKthSmallestNumberRec</span>(nums, k, p + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (low == high) &#123;</span><br><span class="line">            <span class="keyword">return</span> low;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> median = <span class="built_in">medianOfMedians</span>(nums, low, high);</span><br><span class="line">        <span class="comment">// find the midian in the array and swap it woth nums[high] which will</span></span><br><span class="line">        <span class="comment">// become the pivot</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = low; i &lt; high; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == median) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums, i, high);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[high];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = low; i &lt; high; i++) &#123;</span><br><span class="line">            <span class="comment">// all elements less than &#x27;povit&#x27; will be before the index &#x27;low&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; pivot) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums, low++, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// put the pivot in its correct place</span></span><br><span class="line">        <span class="built_in">swap</span>(nums, low, high);</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">medianOfMedians</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = high - low + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// if we have less than 5 element, ignore the partitioning algorithm</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[low];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for simplicity, lets ignore any partition with less than 5 elements</span></span><br><span class="line">        <span class="keyword">int</span> numOfPartitions =</span><br><span class="line">            n / <span class="number">5</span>;  <span class="comment">// represents total number of 5 elements partitions</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">medians</span><span class="params">(numOfPartitions)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numOfPartitions; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> partitionStart =</span><br><span class="line">                low + i * <span class="number">5</span>;  <span class="comment">// starting index of the current partition</span></span><br><span class="line">            <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>() + partitionStart,</span><br><span class="line">                 nums.<span class="built_in">begin</span>() + partitionStart +</span><br><span class="line">                     <span class="number">5</span>);  <span class="comment">// sort the 5 elements array</span></span><br><span class="line">            medians[i] = nums[partitionStart + <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">partition</span>(medians, <span class="number">0</span>, numOfPartitions - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; input = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> result = KthSmallestNumber::<span class="built_in">findKthSmallestNumber</span>(input, <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Kth smallest number is: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    input = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    result = KthSmallestNumber::<span class="built_in">findKthSmallestNumber</span>(input, <span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Kth smallest number is: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    input = &#123;<span class="number">5</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">-1</span>, <span class="number">12</span>&#125;;</span><br><span class="line">    result = KthSmallestNumber::<span class="built_in">findKthSmallestNumber</span>(input, <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Kth smallest number is: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Time-amp-Space-Complexity-6"><a href="#Time-amp-Space-Complexity-6" class="headerlink" title="Time &amp; Space Complexity"></a>Time &amp; Space Complexity</h4><p>The above algorithm has a guaranteed <strong><em>O(N)</em></strong> worst-case time. Please see the proof of its running time <a href="https://en.wikipedia.org/wiki/Median_of_medians">here</a> and under “<a href="https://en.wikipedia.org/wiki/Quicksort#Selection-based_pivoting">Selection-based pivoting</a>”. The worst-case space complexity is <strong><em>O(N)</em></strong>.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>Theoretically, the Median of Medians algorithm gives the best time complexity of <strong><em>O(N)</em></strong> but practically both the Median of Medians and the Randomized Partitioning algorithms nearly perform equally.</p><p>In the context of <strong>Quicksort</strong>, given an <strong><em>O(N)</em></strong> selection algorithm using the Median of Medians, one can use it to find the ideal pivot (the median) at every step of quicksort and thus produce a sorting algorithm with <strong><em>O(NlogN)</em></strong> running time in the worst-case. Though practical implementations of this variant are considerably slower on average, they are of theoretical interest because they show that an optimal selection algorithm can yield an optimal sorting algorithm.</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>17. Pattern Topological Sort (Graph)</title>
      <link href="/17-pattern-topological-sort-graph/index.html"/>
      <url>/17-pattern-topological-sort-graph/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><a href="https://en.wikipedia.org/wiki/Topological_sorting">Topological Sort</a> is used to find a linear ordering of elements that have dependencies on each other. For example, if event ‘B’ is dependent on event ‘A’, ‘A’ comes before ‘B’ in topological ordering.</p><p>This pattern defines an easy way to understand the technique for performing topological sorting of a set of elements and then solves a few problems using it.</p><p>Let’s see this pattern in action.</p><h2 id="Topological-Sort-medium"><a href="#Topological-Sort-medium" class="headerlink" title="*Topological Sort (medium)"></a>*Topological Sort (medium)</h2><h3 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p><a href="https://en.wikipedia.org/wiki/Topological_sorting">Topological Sort</a> of a directed graph (a graph with unidirectional edges) is a linear ordering of its vertices such that for every directed edge (U, V) from vertex <code>U</code> to vertex <code>V</code>, <code>U</code> comes before <code>V</code> in the ordering.</p><p>Given a directed graph, find the topological ordering of its vertices.</p><p><strong>Example 1:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: Vertices=<span class="number">4</span>, Edges=[<span class="number">3</span>, <span class="number">2</span>],<span class="meta"> [3, 0], [2, 0], [2, 1]</span></span><br><span class="line"><span class="attribute">Output</span>: Following are the two valid topological sorts for the given graph:</span><br><span class="line"><span class="attribute">1</span>) <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="attribute">2</span>) <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span></span><br></pre></td></tr></table></figure><p><img src="/17-pattern-topological-sort-graph/index/1_1.png"></p><p><strong>Example 2:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: Vertices=<span class="number">5</span>, Edges=[<span class="number">4</span>, <span class="number">2</span>],<span class="meta"> [4, 3], [2, 0], [2, 1], [3, 1]</span></span><br><span class="line"><span class="attribute">Output</span>: Following are <span class="literal">all</span> valid topological sorts for the given graph:</span><br><span class="line"><span class="attribute">1</span>) <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="attribute">2</span>) <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="attribute">3</span>) <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line"><span class="attribute">4</span>) <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line"><span class="attribute">5</span>) <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="/17-pattern-topological-sort-graph/index/1_2.png"></p><p><strong>Example 3:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: Vertices=<span class="number">7</span>, Edges=[<span class="number">6</span>, <span class="number">4</span>],<span class="meta"> [6, 2], [5, 3], [5, 4], [3, 0], [3, 1], [3, 2], [4, 1]</span></span><br><span class="line"><span class="attribute">Output</span>: Following are <span class="literal">all</span> valid topological sorts for the given graph:</span><br><span class="line"><span class="attribute">1</span>) <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="attribute">2</span>) <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="attribute">3</span>) <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span></span><br><span class="line"><span class="attribute">4</span>) <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="attribute">5</span>) <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span></span><br><span class="line"><span class="attribute">6</span>) <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span></span><br><span class="line"> </span><br><span class="line"><span class="attribute">There</span> are other valid topological ordering of the graph too.</span><br></pre></td></tr></table></figure><p><img src="/17-pattern-topological-sort-graph/index/1_3.png"></p><h3 id="Try-it-yourself"><a href="#Try-it-yourself" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不会</span></span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>The basic idea behind the topological sort is to provide a partial ordering among the vertices of the graph such that if there is an edge from <code>U</code> to <code>V</code> then U≤V i.e., <code>U</code> comes before <code>V</code> in the ordering. Here are a few fundamental concepts related to topological sort:</p><ol><li><strong>Source:</strong> Any node that has no incoming edge and has only outgoing edges is called a source.</li><li><strong>Sink:</strong> Any node that has only incoming edges and no outgoing edge is called a sink.</li><li>So, we can say that a topological ordering starts with one of the sources and ends at one of the sinks.</li><li>A topological ordering is possible only when the graph has no directed cycles, i.e. if the graph is a <strong>Directed Acyclic Graph (DAG)</strong>. If the graph has a cycle, some vertices will have cyclic dependencies which makes it impossible to find a linear ordering among vertices.</li></ol><p>To find the topological sort of a graph we can traverse the graph in a <strong>Breadth First Search (BFS)</strong> way. We will start with all the sources, and in a stepwise fashion, save all sources to a sorted list. We will then remove all sources and their edges from the graph. After the removal of the edges, we will have new sources, so we will repeat the above process until all vertices are visited.</p><p>也可以采用DFS，在每一个节点上标记好开始和结束的时间，然后更具结束的使劲按逆序排列就能得到答案，具体步骤可以参考书籍《算法导论》</p><p>Here is the visual representation of this algorithm for Example-3:</p><p><img src="/17-pattern-topological-sort-graph/index/1_4.png"></p><p>This is how we can implement this algorithm:</p><p><strong>a. Initialization</strong></p><ol><li>We will store the graph in <strong>Adjacency Lists</strong>, which means each parent vertex will have a list containing all of its children. We will do this using a <strong>HashMap</strong> where the ‘key’ will be the parent vertex number and the value will be a <strong>List</strong> containing children vertices.</li><li>To find the sources, we will keep a <strong>HashMap</strong> to count the in-degrees i.e., count of incoming edges of each vertex. Any vertex with ‘0’ in-degree will be a source.</li></ol><p><strong>b. Build the graph and find in-degrees of all vertices</strong></p><ol><li>We will build the graph from the input and populate the in-degrees <strong>HashMap</strong>.</li></ol><p><strong>c. Find all sources</strong></p><ol><li>All vertices with ‘0’ in-degrees will be our sources and we will store them in a <strong>Queue</strong>.</li></ol><p><strong>d. Sort</strong></p><ol><li>For each source, do the following things:<ul><li>Add it to the sorted list.</li><li>Get all of its children from the graph.</li><li>Decrement the in-degree of each child by 1.</li><li>If a child’s in-degree becomes ‘0’, add it to the sources <strong>Queue</strong>.</li></ul></li><li>Repeat step 1, until the source <strong>Queue</strong> is empty.</li></ol><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><p>Here is what our algorithm will look like:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TopologicalSort</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> vector&lt;<span class="keyword">int</span>&gt; <span class="title">sort</span><span class="params">(<span class="keyword">int</span> vertices, <span class="keyword">const</span> vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; sortedOrder;</span><br><span class="line">        <span class="keyword">if</span> (vertices &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sortedOrder;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// a. initialize the graph</span></span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;</span><br><span class="line">            inDegree;  <span class="comment">// count of incoming edges for every vertex</span></span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;&gt; graph;  <span class="comment">// adjacency list graph</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertices; i++) &#123;</span><br><span class="line">            inDegree[i] = <span class="number">0</span>;</span><br><span class="line">            graph[i] = vector&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// b. build the graph</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> parent = edges[i][<span class="number">0</span>], child = edges[i][<span class="number">1</span>];</span><br><span class="line">            graph[parent].<span class="built_in">push_back</span>(</span><br><span class="line">                child);         <span class="comment">// put the child into its parent&#x27;s list</span></span><br><span class="line">            inDegree[child]++;  <span class="comment">// increment child&#x27;s inDegree</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// c. Find all sources i.e. all vertices with 0 in-degrees</span></span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; sources;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> entry : inDegree) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.second == <span class="number">0</span>) &#123;</span><br><span class="line">                sources.<span class="built_in">push</span>(entry.first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// d. for each source,  add it to the sortedOrder and subtract one from</span></span><br><span class="line">        <span class="comment">// all of its children&#x27;s in-degree if a child&#x27;s indegree becomes zero,</span></span><br><span class="line">        <span class="comment">// add it to the sources queue</span></span><br><span class="line">        <span class="keyword">while</span> (!sources.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> vertex = sources.<span class="built_in">front</span>();</span><br><span class="line">            sources.<span class="built_in">pop</span>();</span><br><span class="line">            sortedOrder.<span class="built_in">push_back</span>(vertex);</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; children = graph[vertex];  <span class="comment">// get the node&#x27;s children to</span></span><br><span class="line">                                                   <span class="comment">// decrement their indegrees</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> child : children) &#123;</span><br><span class="line">                inDegree[child]--;</span><br><span class="line">                <span class="keyword">if</span> (inDegree[child] == <span class="number">0</span>) &#123;</span><br><span class="line">                    sources.<span class="built_in">push</span>(child);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sortedOrder.<span class="built_in">size</span>() != vertices) &#123;</span><br><span class="line">            <span class="comment">// topological sort is not possible as the graph has a cycle</span></span><br><span class="line">            <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sortedOrder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; input = &#123;&#123;<span class="number">3</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">0</span>&#125;, &#123;<span class="number">2</span>, <span class="number">0</span>&#125;, &#123;<span class="number">2</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; result = TopologicalSort::<span class="built_in">sort</span>(<span class="number">4</span>, input);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> num : result) &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    input = &#123;&#123;<span class="number">4</span>, <span class="number">2</span>&#125;, &#123;<span class="number">4</span>, <span class="number">3</span>&#125;, &#123;<span class="number">2</span>, <span class="number">0</span>&#125;, &#123;<span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">3</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    result = TopologicalSort::<span class="built_in">sort</span>(<span class="number">5</span>, input);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> num : result) &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    input = &#123;&#123;<span class="number">6</span>, <span class="number">4</span>&#125;, &#123;<span class="number">6</span>, <span class="number">2</span>&#125;, &#123;<span class="number">5</span>, <span class="number">3</span>&#125;, &#123;<span class="number">5</span>, <span class="number">4</span>&#125;, &#123;<span class="number">3</span>, <span class="number">0</span>&#125;, &#123;<span class="number">3</span>, <span class="number">1</span>&#125;, &#123;<span class="number">3</span>, <span class="number">2</span>&#125;, &#123;<span class="number">4</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    result = TopologicalSort::<span class="built_in">sort</span>(<span class="number">7</span>, input);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> num : result) &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Time-Complexity"><a href="#Time-Complexity" class="headerlink" title="Time Complexity"></a>Time Complexity</h4><p>In step ‘d’, each vertex will become a source only once and each edge will be accessed and removed once. Therefore, the time complexity of the above algorithm will be <strong><em>O(V+E)</em></strong>, where ‘V’ is the total number of vertices and ‘E’ is the total number of edges in the graph.</p><h4 id="Space-Complexity"><a href="#Space-Complexity" class="headerlink" title="Space Complexity"></a>Space Complexity</h4><p>The space complexity will be <strong><em>O(V+E)</em></strong>, since we are storing all of the edges for each vertex in an adjacency list.</p><hr><h3 id="Similar-Problems"><a href="#Similar-Problems" class="headerlink" title="Similar Problems"></a>Similar Problems</h3><p><strong>Problem 1:</strong> Find if a given <strong>Directed Graph</strong> has a cycle in it or not.</p><p><strong>Solution:</strong> If we can’t determine the topological ordering of all the vertices of a directed graph, the graph has a cycle in it. This was also referred to in the above code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sortedOrder.<span class="built_in">size</span>() != vertices) <span class="comment">// topological sort is not possible as the graph has a cycle</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><h2 id="Tasks-Scheduling-medium"><a href="#Tasks-Scheduling-medium" class="headerlink" title="Tasks Scheduling (medium)"></a>Tasks Scheduling (medium)</h2><h3 id="Problem-Statement-1"><a href="#Problem-Statement-1" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>There are ‘N’ tasks, labeled from ‘0’ to ‘N-1’. Each task can have some prerequisite tasks which need to be completed before it can be scheduled. Given the number of tasks and a list of prerequisite pairs, find out if it is possible to schedule all the tasks.</p><p><strong>Example 1:</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Inpu<span class="variable">t:</span> Tasks=<span class="number">3</span>, Prerequisites=[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">Outpu<span class="variable">t:</span> true</span><br><span class="line">Explanation: To <span class="keyword">execute</span> task <span class="string">&#x27;1&#x27;</span>, task <span class="string">&#x27;0&#x27;</span> needs <span class="keyword">to</span> <span class="keyword">finish</span> <span class="keyword">first</span>. Similarly, task <span class="string">&#x27;1&#x27;</span> needs <span class="keyword">to</span> <span class="keyword">finish</span> </span><br><span class="line">before <span class="string">&#x27;2&#x27;</span> can <span class="keyword">be</span> scheduled. A possible sceduling of tasks i<span class="variable">s:</span> [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>] </span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: Tasks=<span class="number">3</span>, Prerequisites=[<span class="number">0</span>, <span class="number">1</span>],<span class="meta"> [1, 2], [2, 0]</span></span><br><span class="line"><span class="attribute">Output</span>: false</span><br><span class="line"><span class="attribute">Explanation</span>: The tasks have cyclic dependency, therefore they cannot be sceduled.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: Tasks=6, Prerequisites=<span class="comment">[2, 5]</span>, <span class="comment">[0, 5]</span>, <span class="comment">[0, 4]</span>, <span class="comment">[1, 4]</span>, <span class="comment">[3, 2]</span>, <span class="comment">[1, 3]</span></span><br><span class="line">Output: true</span><br><span class="line">Explanation: A possible sceduling <span class="keyword">of</span> tasks <span class="keyword">is</span>: <span class="comment">[0 1 4 3 2 5]</span> </span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-1"><a href="#Try-it-yourself-1" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改编了上一题的答案</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskScheduling</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">isSchedulingPossible</span><span class="params">(<span class="keyword">int</span> tasks,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">const</span> vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; sortedOrder;</span><br><span class="line">        <span class="keyword">if</span> (tasks &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// a. initialize the graph</span></span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;</span><br><span class="line">            inDegree;  <span class="comment">// count of incoming edges for every vertex</span></span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;&gt; graph;  <span class="comment">// adjacency list graph</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasks; i++) &#123;</span><br><span class="line">            inDegree[i] = <span class="number">0</span>;</span><br><span class="line">            graph[i] = vector&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// b. build the graph</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> parent = prerequisites[i][<span class="number">0</span>], child = prerequisites[i][<span class="number">1</span>];</span><br><span class="line">            graph[parent].<span class="built_in">push_back</span>(</span><br><span class="line">                child);         <span class="comment">// put the child into its parent&#x27;s list</span></span><br><span class="line">            inDegree[child]++;  <span class="comment">// increment child&#x27;s inDegree</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// c. Find all sources i.e. all vertices with 0 in-degrees</span></span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; sources;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> entry : inDegree) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.second == <span class="number">0</span>) &#123;</span><br><span class="line">                sources.<span class="built_in">push</span>(entry.first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// d. for each source,  add it to the sortedOrder and subtract one from</span></span><br><span class="line">        <span class="comment">// all of its children&#x27;s in-degree if a child&#x27;s indegree becomes zero,</span></span><br><span class="line">        <span class="comment">// add it to the sources queue</span></span><br><span class="line">        <span class="keyword">while</span> (!sources.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> vertex = sources.<span class="built_in">front</span>();</span><br><span class="line">            sources.<span class="built_in">pop</span>();</span><br><span class="line">            sortedOrder.<span class="built_in">push_back</span>(vertex);</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; children = graph[vertex];  <span class="comment">// get the node&#x27;s children to</span></span><br><span class="line">                                                   <span class="comment">// decrement their indegrees</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> child : children) &#123;</span><br><span class="line">                inDegree[child]--;</span><br><span class="line">                <span class="keyword">if</span> (inDegree[child] == <span class="number">0</span>) &#123;</span><br><span class="line">                    sources.<span class="built_in">push</span>(child);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sortedOrder.<span class="built_in">size</span>() != tasks) &#123;</span><br><span class="line">            <span class="comment">// topological sort is not possible as the graph has a cycle</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; input = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line">    cout &lt;&lt; TaskScheduling::<span class="built_in">isSchedulingPossible</span>(<span class="number">3</span>, input) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    input = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line">    cout &lt;&lt; TaskScheduling::<span class="built_in">isSchedulingPossible</span>(<span class="number">3</span>, input) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    input = &#123;&#123;<span class="number">2</span>, <span class="number">5</span>&#125;, &#123;<span class="number">0</span>, <span class="number">5</span>&#125;, &#123;<span class="number">0</span>, <span class="number">4</span>&#125;, &#123;<span class="number">1</span>, <span class="number">4</span>&#125;, &#123;<span class="number">3</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line">    cout &lt;&lt; TaskScheduling::<span class="built_in">isSchedulingPossible</span>(<span class="number">6</span>, input) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>This problem is asking us to find out if it is possible to find a topological ordering of the given tasks. The tasks are equivalent to the vertices and the prerequisites are the edges.</p><p>We can use a similar algorithm as described in <em>Topological Sort</em> to find the topological ordering of the tasks. If the ordering does not include all the tasks, we will conclude that some tasks have cyclic dependencies.</p><h4 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h4><p>Here is what our algorithm will look like (only the highlighted lines have changed):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和我的解答一样，这距离就不再赘述了</span></span><br></pre></td></tr></table></figure><h4 id="Time-complexity"><a href="#Time-complexity" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>In step ‘d’, each task can become a source only once and each edge (prerequisite) will be accessed and removed once. Therefore, the time complexity of the above algorithm will be <strong><em>O(V+E)</em></strong>, where ‘V’ is the total number of tasks and ‘E’ is the total number of prerequisites.</p><h4 id="Space-complexity"><a href="#Space-complexity" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity will be <strong><em>O(V+E)</em></strong>, since we are storing all of the prerequisites for each task in an adjacency list.</p><hr><h3 id="Similar-Problems-1"><a href="#Similar-Problems-1" class="headerlink" title="Similar Problems"></a>Similar Problems</h3><p><strong>Course Schedule:</strong> There are ‘N’ courses, labeled from ‘0’ to ‘N-1’. Each course can have some prerequisite courses which need to be completed before it can be taken. Given the number of courses and a list of prerequisite pairs, find if it is possible for a student to take all the courses.</p><p><strong>Solution:</strong> This problem is exactly similar to our parent problem. In this problem, we have courses instead of tasks.</p><h2 id="Tasks-Scheduling-Order-medium"><a href="#Tasks-Scheduling-Order-medium" class="headerlink" title="Tasks Scheduling Order (medium)"></a>Tasks Scheduling Order (medium)</h2><h3 id="Problem-Statement-2"><a href="#Problem-Statement-2" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>There are ‘N’ tasks, labeled from ‘0’ to ‘N-1’. Each task can have some prerequisite tasks which need to be completed before it can be scheduled. Given the number of tasks and a list of prerequisite pairs, write a method to find the ordering of tasks we should pick to finish all tasks.</p><p><strong>Example 1:</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Inpu<span class="variable">t:</span> Tasks=<span class="number">3</span>, Prerequisites=[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">Outpu<span class="variable">t:</span> [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">Explanation: To <span class="keyword">execute</span> task <span class="string">&#x27;1&#x27;</span>, task <span class="string">&#x27;0&#x27;</span> needs <span class="keyword">to</span> <span class="keyword">finish</span> <span class="keyword">first</span>. Similarly, task <span class="string">&#x27;1&#x27;</span> needs <span class="keyword">to</span> <span class="keyword">finish</span> </span><br><span class="line">before <span class="string">&#x27;2&#x27;</span> can <span class="keyword">be</span> scheduled. A possible scheduling of tasks i<span class="variable">s:</span> [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>] </span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: Tasks=<span class="number">3</span>, Prerequisites=[<span class="number">0</span>, <span class="number">1</span>],<span class="meta"> [1, 2], [2, 0]</span></span><br><span class="line"><span class="attribute">Output</span>:<span class="meta"> []</span></span><br><span class="line"><span class="attribute">Explanation</span>: The tasks have cyclic dependency, therefore they cannot be scheduled.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: Tasks=6, Prerequisites=<span class="comment">[2, 5]</span>, <span class="comment">[0, 5]</span>, <span class="comment">[0, 4]</span>, <span class="comment">[1, 4]</span>, <span class="comment">[3, 2]</span>, <span class="comment">[1, 3]</span></span><br><span class="line">Output: <span class="comment">[0 1 4 3 2 5]</span> </span><br><span class="line">Explanation: A possible scheduling <span class="keyword">of</span> tasks <span class="keyword">is</span>: <span class="comment">[0 1 4 3 2 5]</span> </span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-2"><a href="#Try-it-yourself-2" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 题目和第一题一摸一样，只是形参不同罢了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskSchedulingOrder</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> vector&lt;<span class="keyword">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="keyword">int</span> tasks,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="keyword">const</span> vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; preprequisites)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; sortedOrder;</span><br><span class="line">        <span class="keyword">if</span> (tasks &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sortedOrder;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// a. initialize the graph</span></span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;</span><br><span class="line">            inDegree;  <span class="comment">// count of incoming edges for every vertex</span></span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;&gt; graph;  <span class="comment">// adjacency list graph</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasks; i++) &#123;</span><br><span class="line">            inDegree[i] = <span class="number">0</span>;</span><br><span class="line">            graph[i] = vector&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// b. build the graph</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; preprequisites.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> parent = preprequisites[i][<span class="number">0</span>], child = preprequisites[i][<span class="number">1</span>];</span><br><span class="line">            graph[parent].<span class="built_in">push_back</span>(</span><br><span class="line">                child);         <span class="comment">// put the child into its parent&#x27;s list</span></span><br><span class="line">            inDegree[child]++;  <span class="comment">// increment child&#x27;s inDegree</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// c. Find all sources i.e. all vertices with 0 in-degrees</span></span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; sources;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> entry : inDegree) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.second == <span class="number">0</span>) &#123;</span><br><span class="line">                sources.<span class="built_in">push</span>(entry.first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// d. for each source,  add it to the sortedOrder and subtract one from</span></span><br><span class="line">        <span class="comment">// all of its children&#x27;s in-degree if a child&#x27;s indegree becomes zero,</span></span><br><span class="line">        <span class="comment">// add it to the sources queue</span></span><br><span class="line">        <span class="keyword">while</span> (!sources.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> vertex = sources.<span class="built_in">front</span>();</span><br><span class="line">            sources.<span class="built_in">pop</span>();</span><br><span class="line">            sortedOrder.<span class="built_in">push_back</span>(vertex);</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; children = graph[vertex];  <span class="comment">// get the node&#x27;s children to</span></span><br><span class="line">                                                   <span class="comment">// decrement their indegrees</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> child : children) &#123;</span><br><span class="line">                inDegree[child]--;</span><br><span class="line">                <span class="keyword">if</span> (inDegree[child] == <span class="number">0</span>) &#123;</span><br><span class="line">                    sources.<span class="built_in">push</span>(child);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sortedOrder.<span class="built_in">size</span>() != tasks) &#123;</span><br><span class="line">            <span class="comment">// topological sort is not possible as the graph has a cycle</span></span><br><span class="line">            <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sortedOrder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; input = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; result = TaskSchedulingOrder::<span class="built_in">findOrder</span>(<span class="number">3</span>, input);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> num : result) &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    input = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line">    result = TaskSchedulingOrder::<span class="built_in">findOrder</span>(<span class="number">3</span>, input);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> num : result) &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    input = &#123;&#123;<span class="number">2</span>, <span class="number">5</span>&#125;, &#123;<span class="number">0</span>, <span class="number">5</span>&#125;, &#123;<span class="number">0</span>, <span class="number">4</span>&#125;, &#123;<span class="number">1</span>, <span class="number">4</span>&#125;, &#123;<span class="number">3</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line">    result = TaskSchedulingOrder::<span class="built_in">findOrder</span>(<span class="number">6</span>, input);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> num : result) &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>This problem is similar to <em>Tasks Scheduling</em>, the only difference being that we need to find the best ordering of tasks so that it is possible to schedule them all.</p><h4 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h4><p>Here is what our algorithm will look like (only the highlighted lines have changed):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和我的答案一摸一样，这里就不再重复了</span></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-1"><a href="#Time-complexity-1" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>In step ‘d’, each task can become a source only once and each edge (prerequisite) will be accessed and removed once. Therefore, the time complexity of the above algorithm will be <strong><em>O(V+E)</em></strong>, where ‘V’ is the total number of tasks and ‘E’ is the total number of prerequisites.</p><h4 id="Space-complexity-1"><a href="#Space-complexity-1" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity will be <strong><em>O(V+E)</em></strong>, since we are storing all of the prerequisites for each task in an adjacency list.</p><hr><h3 id="Similar-Problems-2"><a href="#Similar-Problems-2" class="headerlink" title="Similar Problems"></a>Similar Problems</h3><p><strong>Course Schedule:</strong> There are ‘N’ courses, labeled from ‘0’ to ‘N-1’. Each course has some prerequisite courses which need to be completed before it can be taken. Given the number of courses and a list of prerequisite pairs, write a method to find the best ordering of the courses that a student can take in order to finish all courses.</p><p><strong>Solution:</strong> This problem is exactly similar to our parent problem. In this problem, we have courses instead of tasks.</p><h2 id="All-Tasks-Scheduling-Orders-hard"><a href="#All-Tasks-Scheduling-Orders-hard" class="headerlink" title="*All Tasks Scheduling Orders (hard)"></a>*All Tasks Scheduling Orders (hard)</h2><h3 id="Problem-Statement-3"><a href="#Problem-Statement-3" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>There are ‘N’ tasks, labeled from ‘0’ to ‘N-1’. Each task can have some prerequisite tasks which need to be completed before it can be scheduled. Given the number of tasks and a list of prerequisite pairs, write a method to print all possible ordering of tasks meeting all prerequisites.</p><p><strong>Example 1:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: Tasks=<span class="number">3</span>, Prerequisites=[<span class="number">0</span>, <span class="number">1</span>],<span class="meta"> [1, 2]</span></span><br><span class="line"><span class="attribute">Output</span>:<span class="meta"> [0, 1, 2]</span></span><br><span class="line"><span class="attribute">Explanation</span>: There is only possible ordering of the tasks.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: Tasks=<span class="number">4</span>, Prerequisites=[<span class="number">3</span>, <span class="number">2</span>],<span class="meta"> [3, 0], [2, 0], [2, 1]</span></span><br><span class="line"><span class="attribute">Output</span>: </span><br><span class="line"><span class="attribute">1</span>)<span class="meta"> [3, 2, 0, 1]</span></span><br><span class="line"><span class="attribute">2</span>)<span class="meta"> [3, 2, 1, 0]</span></span><br><span class="line"><span class="attribute">Explanation</span>: There are two possible orderings of the tasks meeting <span class="literal">all</span> prerequisites.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input: Tasks=6, Prerequisites=<span class="comment">[2, 5]</span>, <span class="comment">[0, 5]</span>, <span class="comment">[0, 4]</span>, <span class="comment">[1, 4]</span>, <span class="comment">[3, 2]</span>, <span class="comment">[1, 3]</span></span><br><span class="line">Output: </span><br><span class="line">1) <span class="comment">[0, 1, 4, 3, 2, 5]</span></span><br><span class="line">2) <span class="comment">[0, 1, 3, 4, 2, 5]</span></span><br><span class="line">3) <span class="comment">[0, 1, 3, 2, 4, 5]</span></span><br><span class="line">4) <span class="comment">[0, 1, 3, 2, 5, 4]</span></span><br><span class="line">5) <span class="comment">[1, 0, 3, 4, 2, 5]</span></span><br><span class="line">6) <span class="comment">[1, 0, 3, 2, 4, 5]</span></span><br><span class="line">7) <span class="comment">[1, 0, 3, 2, 5, 4]</span></span><br><span class="line">8) <span class="comment">[1, 0, 4, 3, 2, 5]</span></span><br><span class="line">9) <span class="comment">[1, 3, 0, 2, 4, 5]</span></span><br><span class="line">10) <span class="comment">[1, 3, 0, 2, 5, 4]</span></span><br><span class="line">11) <span class="comment">[1, 3, 0, 4, 2, 5]</span></span><br><span class="line">12) <span class="comment">[1, 3, 2, 0, 5, 4]</span></span><br><span class="line">13) <span class="comment">[1, 3, 2, 0, 4, 5]</span></span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-3"><a href="#Try-it-yourself-3" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不会</span></span><br></pre></td></tr></table></figure><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>This problem is similar to <em>Tasks Scheduling Order</em> the only difference is that we need to find all the topological orderings of the tasks.</p><p>At any stage, if we have more than one source available and since we can choose any source, therefore, in this case, we will have multiple orderings of the tasks. We can use a recursive approach with <strong>Backtracking</strong> to consider all sources at any step.</p><h4 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h4><p>Here is what our algorithm will look like:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AllTaskSchedulingOrders</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printOrders</span><span class="params">(<span class="keyword">int</span> tasks,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">const</span> vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; preprequisites)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; sortedOrder;</span><br><span class="line">        <span class="keyword">if</span> (tasks &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// a. initialize the graph</span></span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;</span><br><span class="line">            inDegree;  <span class="comment">// count of incoming edges for every vertex</span></span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;&gt; graph;  <span class="comment">// adjacency list graph</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasks; i++) &#123;</span><br><span class="line">            inDegree[i] = <span class="number">0</span>;</span><br><span class="line">            graph[i] = vector&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// b. build the graph</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; preprequisites.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> parent = preprequisites[i][<span class="number">0</span>], child = preprequisites[i][<span class="number">1</span>];</span><br><span class="line">            graph[parent].<span class="built_in">push_back</span>(</span><br><span class="line">                child);         <span class="comment">// put the child into its parent&#x27;s list</span></span><br><span class="line">            inDegree[child]++;  <span class="comment">// increment child&#x27;s inDegree</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// c. Find all sources i.e. all vertices with 0 in-degrees</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; sources;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> entry : inDegree) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.second == <span class="number">0</span>) &#123;</span><br><span class="line">                sources.<span class="built_in">push_back</span>(entry.first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printAllTopologicalSorts</span>(graph, inDegree, sources, sortedOrder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAllTopologicalSorts</span><span class="params">(unordered_map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; inDregree,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; sources,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         vector&lt;<span class="keyword">int</span>&gt;&amp; sortedOrder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!sources.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> vertex : sources) &#123;</span><br><span class="line">                sortedOrder.<span class="built_in">push_back</span>(vertex);</span><br><span class="line">                vector&lt;<span class="keyword">int</span>&gt; sourcesForNextCall = sources;</span><br><span class="line">                <span class="comment">// only remove the current source, all other sources should</span></span><br><span class="line">                <span class="comment">// remain in the queue for next call</span></span><br><span class="line">                sourcesForNextCall.<span class="built_in">erase</span>(</span><br><span class="line">                    <span class="built_in">find</span>(sourcesForNextCall.<span class="built_in">begin</span>(), sourcesForNextCall.<span class="built_in">end</span>(),</span><br><span class="line">                         vertex));  <span class="comment">// find 函数需要引用algothrim头文件</span></span><br><span class="line"></span><br><span class="line">                vector&lt;<span class="keyword">int</span>&gt; children = graph[vertex];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> child : children) &#123;</span><br><span class="line">                    inDregree[child]--;</span><br><span class="line">                    <span class="keyword">if</span> (inDregree[child] == <span class="number">0</span>) &#123;</span><br><span class="line">                        sourcesForNextCall.<span class="built_in">push_back</span>(child);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// recuesive call to print other orderings from the remaining</span></span><br><span class="line">                <span class="comment">// (and new) sources</span></span><br><span class="line">                <span class="built_in">printAllTopologicalSorts</span>(graph, inDregree, sourcesForNextCall,</span><br><span class="line">                                         sortedOrder);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// backtrack, remove the vertex form the sorted order and put</span></span><br><span class="line">                <span class="comment">// all of ot children back to consider the next source instead</span></span><br><span class="line">                <span class="comment">// of the current vertex</span></span><br><span class="line">                sortedOrder.<span class="built_in">erase</span>(</span><br><span class="line">                    <span class="built_in">find</span>(sortedOrder.<span class="built_in">begin</span>(), sortedOrder.<span class="built_in">end</span>(), vertex));</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> child : children) &#123;</span><br><span class="line">                    inDregree[child]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if sortedOrder doesnt contain all tasks, either we have a cyclic</span></span><br><span class="line">        <span class="comment">// dependency between tasks, or we have not processed all the tasks in</span></span><br><span class="line">        <span class="comment">// this recursive call</span></span><br><span class="line">        <span class="keyword">if</span> (sortedOrder.<span class="built_in">size</span>() == inDregree.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : sortedOrder) &#123;</span><br><span class="line">                cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; input = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line">    AllTaskSchedulingOrders::<span class="built_in">printOrders</span>(<span class="number">3</span>, input);</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">    input = &#123;&#123;<span class="number">3</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">0</span>&#125;, &#123;<span class="number">2</span>, <span class="number">0</span>&#125;, &#123;<span class="number">2</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    AllTaskSchedulingOrders::<span class="built_in">printOrders</span>(<span class="number">4</span>, input);</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    input = &#123;&#123;<span class="number">2</span>, <span class="number">5</span>&#125;, &#123;<span class="number">0</span>, <span class="number">5</span>&#125;, &#123;<span class="number">0</span>, <span class="number">4</span>&#125;, &#123;<span class="number">1</span>, <span class="number">4</span>&#125;, &#123;<span class="number">3</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line">    AllTaskSchedulingOrders::<span class="built_in">printOrders</span>(<span class="number">6</span>, input);</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Time-and-Space-Complexity"><a href="#Time-and-Space-Complexity" class="headerlink" title="Time and Space Complexity"></a>Time and Space Complexity</h4><p>If we don’t have any prerequisites, all combinations of the tasks can represent a topological ordering. As we know, that there can be N!<em>N</em>! combinations for ‘N’ numbers, therefore the time and space complexity of our algorithm will be <strong><em>O(V! </em> E)*</strong> where ‘V’ is the total number of tasks and ‘E’ is the total prerequisites. We need the ‘E’ part because in each recursive call, at max, we remove (and add back) all the edges.</p><h2 id="Alien-Dictionary-hard"><a href="#Alien-Dictionary-hard" class="headerlink" title="*Alien Dictionary (hard)"></a>*Alien Dictionary (hard)</h2><h3 id="Problem-Statement-4"><a href="#Problem-Statement-4" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>There is a dictionary containing words from an alien language for which we don’t know the ordering of the characters. Write a method to find the correct order of characters in the alien language.</p><p><strong>Example 1:</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: Words: [<span class="string">&quot;ba&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;ac&quot;</span>, <span class="string">&quot;cab&quot;</span>]</span><br><span class="line">Output: bac</span><br><span class="line">Explanation: Given that <span class="keyword">the</span> <span class="keyword">words</span> are sorted lexicographically <span class="keyword">by</span> <span class="keyword">the</span> rules <span class="keyword">of</span> <span class="keyword">the</span> alien language, so</span><br><span class="line"><span class="built_in">from</span> <span class="keyword">the</span> given <span class="keyword">words</span> we can conclude <span class="keyword">the</span> following ordering <span class="keyword">among</span> its <span class="keyword">characters</span>:</span><br><span class="line"> </span><br><span class="line"><span class="number">1.</span> From <span class="string">&quot;ba&quot;</span> <span class="keyword">and</span> <span class="string">&quot;bc&quot;</span>, we can conclude that <span class="string">&#x27;a&#x27;</span> comes <span class="keyword">before</span> <span class="string">&#x27;c&#x27;</span>.</span><br><span class="line"><span class="number">2.</span> From <span class="string">&quot;bc&quot;</span> <span class="keyword">and</span> <span class="string">&quot;ac&quot;</span>, we can conclude that <span class="string">&#x27;b&#x27;</span> comes <span class="keyword">before</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line"> </span><br><span class="line">From <span class="keyword">the</span> above <span class="literal">two</span> points, we can conclude that <span class="keyword">the</span> correct <span class="keyword">character</span> order is: <span class="string">&quot;bac&quot;</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: Words: [<span class="string">&quot;cab&quot;</span>, <span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;aab&quot;</span>]</span><br><span class="line">Output: cab</span><br><span class="line">Explanation: From <span class="keyword">the</span> given <span class="keyword">words</span> we can conclude <span class="keyword">the</span> following ordering <span class="keyword">among</span> its <span class="keyword">characters</span>:</span><br><span class="line"> </span><br><span class="line"><span class="number">1.</span> From <span class="string">&quot;cab&quot;</span> <span class="keyword">and</span> <span class="string">&quot;aaa&quot;</span>, we can conclude that <span class="string">&#x27;c&#x27;</span> comes <span class="keyword">before</span> <span class="string">&#x27;a&#x27;</span>.</span><br><span class="line"><span class="number">2.</span> From <span class="string">&quot;aaa&quot;</span> <span class="keyword">and</span> <span class="string">&quot;aab&quot;</span>, we can conclude that <span class="string">&#x27;a&#x27;</span> comes <span class="keyword">before</span> <span class="string">&#x27;b&#x27;</span></span><br><span class="line"> </span><br><span class="line">From <span class="keyword">the</span> above <span class="literal">two</span> points, we can conclude that <span class="keyword">the</span> correct <span class="keyword">character</span> order is: <span class="string">&quot;cab&quot;</span></span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: Words: [<span class="string">&quot;ywx&quot;</span>, <span class="string">&quot;wz&quot;</span>, <span class="string">&quot;xww&quot;</span>, <span class="string">&quot;xz&quot;</span>, <span class="string">&quot;zyy&quot;</span>, <span class="string">&quot;zwz&quot;</span>]</span><br><span class="line">Output: ywxz</span><br><span class="line">Explanation: From <span class="keyword">the</span> given <span class="keyword">words</span> we can conclude <span class="keyword">the</span> following ordering <span class="keyword">among</span> its <span class="keyword">characters</span>:</span><br><span class="line"> </span><br><span class="line"><span class="number">1.</span> From <span class="string">&quot;ywx&quot;</span> <span class="keyword">and</span> <span class="string">&quot;wz&quot;</span>, we can conclude that <span class="string">&#x27;y&#x27;</span> comes <span class="keyword">before</span> <span class="string">&#x27;w&#x27;</span>.</span><br><span class="line"><span class="number">2.</span> From <span class="string">&quot;wz&quot;</span> <span class="keyword">and</span> <span class="string">&quot;xww&quot;</span>, we can conclude that <span class="string">&#x27;w&#x27;</span> comes <span class="keyword">before</span> <span class="string">&#x27;x&#x27;</span>.</span><br><span class="line"><span class="number">3.</span> From <span class="string">&quot;xww&quot;</span> <span class="keyword">and</span> <span class="string">&quot;xz&quot;</span>, we can conclude that <span class="string">&#x27;w&#x27;</span> comes <span class="keyword">before</span> <span class="string">&#x27;z&#x27;</span></span><br><span class="line"><span class="number">4.</span> From <span class="string">&quot;xz&quot;</span> <span class="keyword">and</span> <span class="string">&quot;zyy&quot;</span>, we can conclude that <span class="string">&#x27;x&#x27;</span> comes <span class="keyword">before</span> <span class="string">&#x27;z&#x27;</span></span><br><span class="line"><span class="number">5.</span> From <span class="string">&quot;zyy&quot;</span> <span class="keyword">and</span> <span class="string">&quot;zwz&quot;</span>, we can conclude that <span class="string">&#x27;y&#x27;</span> comes <span class="keyword">before</span> <span class="string">&#x27;w&#x27;</span></span><br><span class="line"> </span><br><span class="line">From <span class="keyword">the</span> above <span class="literal">five</span> points, we can conclude that <span class="keyword">the</span> correct <span class="keyword">character</span> order is: <span class="string">&quot;ywxz&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-4"><a href="#Try-it-yourself-4" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不会</span></span><br></pre></td></tr></table></figure><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><p>Since the given words are sorted lexicographically by the rules of the alien language, we can always compare two adjacent words to determine the ordering of the characters. Take Example-1 above: [“ba”, “bc”, “ac”, “cab”]</p><ol><li>Take the first two words “ba” and “bc”. Starting from the beginning of the words, find the first character that is different in both words: it would be ‘a’ from “ba” and ‘c’ from “bc”. Because of the sorted order of words (i.e. the dictionary!), we can conclude that ‘a’ comes before ‘c’ in the alien language.</li><li>Similarly, from “bc” and “ac”, we can conclude that ‘b’ comes before ‘a’.</li></ol><p>These two points tell us that we are actually asked to find the topological ordering of the characters, and that the ordering rules should be inferred from adjacent words from the alien dictionary.</p><p>This makes the current problem similar to <em>Tasks Scheduling Order</em>, the only difference being that we need to build the graph of the characters by comparing adjacent words first, and then perform the topological sort for the graph to determine the order of the characters.</p><h4 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h4><p>Here is what our algorithm will look like (only the highlighted lines have changed):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlienDictionary</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> string <span class="title">findOrder</span><span class="params">(<span class="keyword">const</span> vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        string sortedOrder;</span><br><span class="line">        <span class="keyword">if</span> (words.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// a. initialize the graph</span></span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; inDegree;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, vector&lt;<span class="keyword">char</span>&gt;&gt; graph;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> word : words) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> chr : word) &#123;</span><br><span class="line">                inDegree[chr] = <span class="number">0</span>;</span><br><span class="line">                graph[chr] = vector&lt;<span class="keyword">char</span>&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// b. build the graph</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            string w1 = words[i],</span><br><span class="line">                   w2 = words[i + <span class="number">1</span>];  <span class="comment">// find ordering of characters from</span></span><br><span class="line">                                       <span class="comment">// adjacent words</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">min</span>(w1.<span class="built_in">length</span>(), w2.<span class="built_in">length</span>()); j++) &#123;</span><br><span class="line">                <span class="keyword">char</span> parent = w1[j], child = w2[j];</span><br><span class="line">                <span class="keyword">if</span> (parent != child) &#123;  <span class="comment">// if the two characters are different</span></span><br><span class="line">                    graph[parent].<span class="built_in">push_back</span>(</span><br><span class="line">                        child);         <span class="comment">// put the child into its parent&#x27;s list</span></span><br><span class="line">                    inDegree[child]++;  <span class="comment">// increment child&#x27;s inDegree</span></span><br><span class="line">                    <span class="keyword">break</span>;  <span class="comment">// only the first different character between the</span></span><br><span class="line">                            <span class="comment">// two words will help us find the order</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// c. find all sources</span></span><br><span class="line">        queue&lt;<span class="keyword">char</span>&gt; sources;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> entry : inDegree) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.second == <span class="number">0</span>) &#123;</span><br><span class="line">                sources.<span class="built_in">push</span>(entry.first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// d. for each source, add it to the sortedOrder and subtract one from</span></span><br><span class="line">        <span class="comment">// all of its children&#x27;s in-degrees if a child&#x27;s in-degree becomes zero,</span></span><br><span class="line">        <span class="comment">// all it to the sources queue</span></span><br><span class="line">        <span class="keyword">while</span> (!sources.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">char</span> vertex = sources.<span class="built_in">front</span>();</span><br><span class="line">            sources.<span class="built_in">pop</span>();</span><br><span class="line">            sortedOrder += vertex;</span><br><span class="line">            vector&lt;<span class="keyword">char</span>&gt; children = graph[vertex];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> child : children) &#123;</span><br><span class="line">                inDegree[child]--;</span><br><span class="line">                <span class="keyword">if</span> (inDegree[child] == <span class="number">0</span>) &#123;</span><br><span class="line">                    sources.<span class="built_in">push</span>(child);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if sortedOrder doesnt contain all characters ,there is a cyclic</span></span><br><span class="line">        <span class="comment">// dependency between characters , therefore, we will not find the</span></span><br><span class="line">        <span class="comment">// correct ordering of the characters</span></span><br><span class="line">        <span class="keyword">if</span> (sortedOrder.<span class="built_in">length</span>() != inDegree.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sortedOrder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string result =</span><br><span class="line">        AlienDictionary::<span class="built_in">findOrder</span>(vector&lt;string&gt;&#123;<span class="string">&quot;ba&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;ac&quot;</span>, <span class="string">&quot;cab&quot;</span>&#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Character order: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    result = AlienDictionary::<span class="built_in">findOrder</span>(vector&lt;string&gt;&#123;<span class="string">&quot;cab&quot;</span>, <span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;aab&quot;</span>&#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Character order: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    result = AlienDictionary::<span class="built_in">findOrder</span>(</span><br><span class="line">        vector&lt;string&gt;&#123;<span class="string">&quot;ywx&quot;</span>, <span class="string">&quot;wz&quot;</span>, <span class="string">&quot;xww&quot;</span>, <span class="string">&quot;xz&quot;</span>, <span class="string">&quot;zyy&quot;</span>, <span class="string">&quot;zwz&quot;</span>&#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Character order: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Time-complexity-2"><a href="#Time-complexity-2" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>In step ‘d’, each task can become a source only once and each edge (a rule) will be accessed and removed once. Therefore, the time complexity of the above algorithm will be <strong><em>O(V+E)</em></strong>, where ‘V’ is the total number of different characters and ‘E’ is the total number of the rules in the alien language. Since, at most, each pair of words can give us one rule, therefore, we can conclude that the upper bound for the rules is <strong><em>O(N)</em></strong> where ‘N’ is the number of words in the input. So, we can say that the time complexity of our algorithm is <strong><em>O(V+N)</em></strong>.</p><h4 id="Space-complexity-2"><a href="#Space-complexity-2" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity will be <strong><em>O(V+N)</em></strong>, since we are storing all of the rules for each character in an adjacency list.</p><h2 id="Problem-Challenge-1"><a href="#Problem-Challenge-1" class="headerlink" title="*Problem Challenge 1"></a>*Problem Challenge 1</h2><h3 id="Reconstructing-a-Sequence-hard"><a href="#Reconstructing-a-Sequence-hard" class="headerlink" title="Reconstructing a Sequence (hard)"></a>Reconstructing a Sequence (hard)</h3><p>Given a sequence <code>originalSeq</code> and an array of sequences, write a method to find if <code>originalSeq</code> can be uniquely reconstructed from the array of sequences.</p><p>Unique reconstruction means that we need to find if <code>originalSeq</code> is the only sequence such that all sequences in the array are subsequences of it.</p><p><strong>Example 1:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input</span>: originalSeq: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], seqs: [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="symbol">Output</span>: true</span><br><span class="line"><span class="symbol">Explanation</span>: <span class="symbol">The</span> sequences [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">3</span>], and [<span class="number">3</span>, <span class="number">4</span>] can uniquely reconstruct   </span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], in other words, all the given sequences uniquely define the order of numbers </span><br><span class="line">in the <span class="string">&#x27;originalSeq&#x27;</span>. </span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: originalSeq: <span class="comment">[1, 2, 3, 4]</span>, seqs: <span class="comment">[<span class="comment">[1, 2]</span>, <span class="comment">[2, 3]</span>, <span class="comment">[2, 4]</span>]</span></span><br><span class="line">Output: false</span><br><span class="line">Explanation: The sequences <span class="comment">[1, 2]</span>, <span class="comment">[2, 3]</span>, and <span class="comment">[2, 4]</span> cannot uniquely reconstruct </span><br><span class="line"><span class="comment">[1, 2, 3, 4]</span>. There <span class="keyword">are</span> two possible sequences we can construct from the given sequences:</span><br><span class="line">1) <span class="comment">[1, 2, 3, 4]</span></span><br><span class="line">2) <span class="comment">[1, 2, 4, 3]</span></span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input</span>: originalSeq: [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>], seqs: [[<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>], [<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>]]</span><br><span class="line"><span class="symbol">Output</span>: true</span><br><span class="line"><span class="symbol">Explanation</span>: <span class="symbol">The</span> sequences [<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>] and [<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>] can uniquely reconstruct </span><br><span class="line">[<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>].</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-5"><a href="#Try-it-yourself-5" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我写的答案只适用于Example 1 &amp; 2，对于Example3不适用，只有输入的每个vector只有两个元素才能够这样</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SequenceReconstruction</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">canContruct</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; originalSeq,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">const</span> vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; sequence)</span> </span>&#123;</span><br><span class="line">        string sortedOrder;</span><br><span class="line">        <span class="keyword">if</span> (sequence.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// a. initialize the graph</span></span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; inDegree;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, vector&lt;<span class="keyword">char</span>&gt;&gt; graph;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> seq : sequence) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> vertex : seq) &#123;</span><br><span class="line">                inDegree[vertex] = <span class="number">0</span>;</span><br><span class="line">                graph[vertex] = vector&lt;<span class="keyword">char</span>&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// b. build the graph</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sequence.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> parent = sequence[i][<span class="number">0</span>], child = sequence[i][<span class="number">1</span>];</span><br><span class="line">            graph[parent].<span class="built_in">push_back</span>(child);</span><br><span class="line">            inDegree[child]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// c. find all sources</span></span><br><span class="line">        queue&lt;<span class="keyword">char</span>&gt; sources;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> entry : inDegree) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.second == <span class="number">0</span>) &#123;</span><br><span class="line">                sources.<span class="built_in">push</span>(entry.first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// d. for each source, add it to the sortedOrder and subtract one from</span></span><br><span class="line">        <span class="comment">// all of its children&#x27;s in-degrees if a child&#x27;s in-degree becomes zero,</span></span><br><span class="line">        <span class="comment">// all it to the sources queue</span></span><br><span class="line">        <span class="keyword">while</span> (!sources.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sources.<span class="built_in">size</span>() != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 看了解答之后发现这个解答是不准确的，因为这只能检测出是否只有一种seqence，但是不能保证和给的一样</span></span><br><span class="line">            <span class="comment">// 标准解答看solution</span></span><br><span class="line">            <span class="keyword">char</span> vertex = sources.<span class="built_in">front</span>();</span><br><span class="line">            sources.<span class="built_in">pop</span>();</span><br><span class="line">            sortedOrder += vertex;</span><br><span class="line">            vector&lt;<span class="keyword">char</span>&gt; children = graph[vertex];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> child : children) &#123;</span><br><span class="line">                inDegree[child]--;</span><br><span class="line">                <span class="keyword">if</span> (inDegree[child] == <span class="number">0</span>) &#123;</span><br><span class="line">                    sources.<span class="built_in">push</span>(child);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if sortedOrder doesnt contain all characters ,there is a cyclic</span></span><br><span class="line">        <span class="comment">// dependency between characters , therefore, we will not find the</span></span><br><span class="line">        <span class="comment">// correct ordering of the characters</span></span><br><span class="line">        <span class="keyword">if</span> (sortedOrder.<span class="built_in">length</span>() != inDegree.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; originalSeq = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; sequences = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">bool</span> result = SequenceReconstruction::<span class="built_in">canContruct</span>(originalSeq, sequences);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Can w uniquely construct the sequence: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    originalSeq = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    sequences = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">2</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line">    result = SequenceReconstruction::<span class="built_in">canContruct</span>(originalSeq, sequences);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Can w uniquely construct the sequence: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// originalSeq = &#123;3, 1, 4, 2, 5&#125;;</span></span><br><span class="line">    <span class="comment">// sequences = &#123;&#123;3, 1, 5&#125;, &#123;1, 4, 2, 5&#125;&#125;;</span></span><br><span class="line">    <span class="comment">// bool result = SequenceReconstruction::canContruct(originalSeq,</span></span><br><span class="line">    <span class="comment">// sequences); cout &lt;&lt; &quot;Can w uniquely construct the sequence: &quot; &lt;&lt; result</span></span><br><span class="line">    <span class="comment">// &lt;&lt; endl;</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><p>Since each sequence in the given array defines the ordering of some numbers, we need to combine all these ordering rules to find two things:</p><ol><li>Is it possible to construct the <code>originalSeq</code> from all these rules?</li><li>Are these ordering rules not sufficient enough to define the unique ordering of all the numbers in the <code>originalSeq</code>? In other words, can these rules result in more than one sequence?</li></ol><p>Take Example-1:</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">originalSeq: <span class="comment">[1, 2, 3, 4]</span>, seqs:<span class="comment">[<span class="comment">[1, 2]</span>, <span class="comment">[2, 3]</span>, <span class="comment">[3, 4]</span>]</span></span><br></pre></td></tr></table></figure><p>The first sequence tells us that ‘1’ comes before ‘2’; the second sequence tells us that ‘2’ comes before ‘3’; the third sequence tells us that ‘3’ comes before ‘4’. Combining all these sequences will result in a unique sequence: [1, 2, 3, 4].</p><p>The above explanation tells us that we are actually asked to find the topological ordering of all the numbers and also to verify that there is only one topological ordering of the numbers possible from the given array of the sequences.</p><p>This makes the current problem similar to <em>Tasks Scheduling Order</em> with two differences:</p><ol><li>We need to build the graph of the numbers by comparing each pair of numbers in the given array of sequences.</li><li>We must perform the topological sort for the graph to determine two things:<ul><li>Can the topological ordering construct the <code>originalSeq</code>?</li><li>That there is only one topological ordering of the numbers possible. This can be confirmed if we do not have more than one source at any time while finding the topological ordering of numbers.</li></ul></li></ol><h4 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h4><p>Here is what our algorithm will look like (only the highlighted lines have changed):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SequenceReconstruction</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">canContruct</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; originalSeq,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">const</span> vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; sequences)</span> </span>&#123;</span><br><span class="line">        string sortedOrder;</span><br><span class="line">        <span class="keyword">if</span> (sequences.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// a. initialize the graph</span></span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; inDegree;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, vector&lt;<span class="keyword">char</span>&gt;&gt; graph;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> seq : sequences) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> vertex : seq) &#123;</span><br><span class="line">                inDegree[vertex] = <span class="number">0</span>;</span><br><span class="line">                graph[vertex] = vector&lt;<span class="keyword">char</span>&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// b. build the graph</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> seq : sequences) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; seq.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> parent = seq[i - <span class="number">1</span>], child = seq[i];</span><br><span class="line">                graph[parent].<span class="built_in">push_back</span>(child);</span><br><span class="line">                inDegree[child]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (inDegree.<span class="built_in">size</span>() != originalSeq.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// c. find all sources</span></span><br><span class="line">        queue&lt;<span class="keyword">char</span>&gt; sources;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> entry : inDegree) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.second == <span class="number">0</span>) &#123;</span><br><span class="line">                sources.<span class="built_in">push</span>(entry.first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// d. for each source, add it to the sortedOrder and subtract one from</span></span><br><span class="line">        <span class="comment">// all of its children&#x27;s in-degrees if a child&#x27;s in-degree becomes zero,</span></span><br><span class="line">        <span class="comment">// all it to the sources queue</span></span><br><span class="line">        <span class="keyword">while</span> (!sources.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sources.<span class="built_in">size</span>() != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (originalSeq[sortedOrder.<span class="built_in">size</span>()] != sources.<span class="built_in">front</span>()) &#123;</span><br><span class="line">                <span class="comment">// the next source is different from the original seqence</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> vertex = sources.<span class="built_in">front</span>();</span><br><span class="line">            sources.<span class="built_in">pop</span>();</span><br><span class="line">            sortedOrder.<span class="built_in">push_back</span>(vertex);</span><br><span class="line">            vector&lt;<span class="keyword">char</span>&gt; children = graph[vertex];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> child : children) &#123;</span><br><span class="line">                inDegree[child]--;</span><br><span class="line">                <span class="keyword">if</span> (inDegree[child] == <span class="number">0</span>) &#123;</span><br><span class="line">                    sources.<span class="built_in">push</span>(child);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if sortedOrder doesnt contain all characters ,there is a cyclic</span></span><br><span class="line">        <span class="comment">// dependency between characters , therefore, we will not find the</span></span><br><span class="line">        <span class="comment">// correct ordering of the characters</span></span><br><span class="line">        <span class="keyword">if</span> (sortedOrder.<span class="built_in">length</span>() != inDegree.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; originalSeq = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; sequences = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">bool</span> result = SequenceReconstruction::<span class="built_in">canContruct</span>(originalSeq, sequences);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Can w uniquely construct the sequence: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    originalSeq = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    sequences = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">2</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line">    result = SequenceReconstruction::<span class="built_in">canContruct</span>(originalSeq, sequences);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Can w uniquely construct the sequence: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    originalSeq = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    sequences = &#123;&#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>&#125;, &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>&#125;&#125;;</span><br><span class="line">    result = SequenceReconstruction::<span class="built_in">canContruct</span>(originalSeq, sequences);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Can w uniquely construct the sequence: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Time-complexity-3"><a href="#Time-complexity-3" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>In step ‘d’, each number can become a source only once and each edge (a rule) will be accessed and removed once. Therefore, the time complexity of the above algorithm will be <strong><em>O(V+E)</em></strong>, where ‘V’ is the count of distinct numbers and ‘E’ is the total number of the rules. Since, at most, each pair of numbers can give us one rule, we can conclude that the upper bound for the rules is <strong><em>O(N)</em></strong> where ‘N’ is the count of numbers in all sequences. So, we can say that the time complexity of our algorithm is <strong><em>O(V+N)</em></strong>.</p><h4 id="Space-complexity-3"><a href="#Space-complexity-3" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity will be <strong><em>O(V+N)</em></strong>, since we are storing all of the rules for each number in an adjacency list.</p><h2 id="Problem-Challenge-2"><a href="#Problem-Challenge-2" class="headerlink" title="*Problem Challenge 2"></a>*Problem Challenge 2</h2><h3 id="Minimum-Height-Trees-hard"><a href="#Minimum-Height-Trees-hard" class="headerlink" title="Minimum Height Trees (hard)"></a>Minimum Height Trees (hard)</h3><p>We are given an undirected graph that has characteristics of a <a href="https://en.wikipedia.org/wiki/K-ary_tree">k-ary tree</a>. In such a graph, we can choose any node as the root to make a k-ary tree. The root (or the tree) with the minimum height will be called <strong>Minimum Height Tree (MHT)</strong>. There can be multiple MHTs for a graph. In this problem, we need to find all those roots which give us MHTs. Write a method to find all MHTs of the given graph and return a list of their roots.</p><p><strong>Example 1:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input</span>: vertices: <span class="number">5</span>, <span class="symbol">Edges</span>: [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="symbol">Output</span>:[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="symbol">Explanation</span>: <span class="symbol">Choosing</span> <span class="string">&#x27;1&#x27;</span> or <span class="string">&#x27;2&#x27;</span> as roots give us <span class="symbol">MHTs</span>. <span class="symbol">In</span> the below diagram, we can see that the </span><br><span class="line">height of the trees with roots <span class="string">&#x27;1&#x27;</span> or <span class="string">&#x27;2&#x27;</span> is three which is minimum.</span><br></pre></td></tr></table></figure><p><img src="/17-pattern-topological-sort-graph/index/2_1.png"></p><p><strong>Example 2:</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Inpu<span class="variable">t:</span> vertice<span class="variable">s:</span> <span class="number">4</span>, Edge<span class="variable">s:</span> [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line">Outpu<span class="variable">t:</span>[<span class="number">0</span>, <span class="number">2</span>]</span><br><span class="line">Explanation: Choosing <span class="string">&#x27;0&#x27;</span> <span class="built_in">or</span> <span class="string">&#x27;2&#x27;</span> <span class="keyword">as</span> roots give us MHTs. In the below diagram, we can see that the </span><br><span class="line">height of the trees with roots <span class="string">&#x27;0&#x27;</span> <span class="built_in">or</span> <span class="string">&#x27;2&#x27;</span> <span class="keyword">is</span> three which <span class="keyword">is</span> minimum.</span><br></pre></td></tr></table></figure><p><img src="/17-pattern-topological-sort-graph/index/2_2.png"></p><p><strong>Example 3:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: vertices: 4, Edges: <span class="comment">[<span class="comment">[0, 1]</span>, <span class="comment">[1, 2]</span>, <span class="comment">[1, 3]</span>]</span></span><br><span class="line">Output:<span class="comment">[1]</span></span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-6"><a href="#Try-it-yourself-6" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不会</span></span><br></pre></td></tr></table></figure><h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h3><p>From the above-mentioned examples, we can clearly see that any leaf node (i.e., node with only one edge) can never give us an MHT because its adjacent non-leaf nodes will always give an MHT with a smaller height. All the adjacent non-leaf nodes will consider the leaf node as a subtree. Let’s understand this with another example. Suppose we have a tree with root ‘M’ and height ‘5’. Now, if we take another node, say ‘P’, and make the ‘M’ tree as its subtree, then the height of the overall tree with root ‘P’ will be ‘6’ (=5+1). Now, this whole tree can be considered a graph, where ‘P’ is a leaf as it has only one edge (connection with ‘M’). This clearly shows that the leaf node (‘P’) gives us a tree of height ‘6’ whereas its adjacent non-leaf node (‘M’) gives us a tree with smaller height ‘5’ - since ‘P’ will be a child of ‘M’.</p><p>This gives us a strategy to find MHTs. Since leaves can’t give us MHT, we can remove them from the graph and remove their edges too. Once we remove the leaves, we will have new leaves. Since these new leaves can’t give us MHT, we will repeat the process and remove them from the graph too. We will prune the leaves until we are left with one or two nodes which will be our answer and the roots for MHTs.</p><p>We can implement the above process using the topological sort. Any node with only one edge (i.e., a leaf) can be our source and, in a stepwise fashion, we can remove all sources from the graph to find new sources. We will repeat this process until we are left with one or two nodes in the graph, which will be our answer.</p><h4 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinimumHeightTrees</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> vector&lt;<span class="keyword">int</span>&gt; <span class="title">findTrees</span><span class="params">(<span class="keyword">int</span> nodes, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; minHeightTrees;</span><br><span class="line">        <span class="keyword">if</span> (nodes &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> minHeightTrees;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// with only one node, since its in-danger will be 0, therefore, we need</span></span><br><span class="line">        <span class="comment">// to handle it separately</span></span><br><span class="line">        <span class="keyword">if</span> (nodes == <span class="number">1</span>) &#123;</span><br><span class="line">            minHeightTrees.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> minHeightTrees;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// a. Initializde the graph</span></span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; inDegree;  <span class="comment">// count of incoming edges for vertex</span></span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;&gt; graph;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes; i++) &#123;</span><br><span class="line">            inDegree[i] == <span class="number">0</span>;</span><br><span class="line">            graph[i] = vector&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// b. build the graph</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> n1 = edges[i][<span class="number">0</span>], n2 = edges[i][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// since it is an undirected graph, therefore, add a link for both</span></span><br><span class="line">            <span class="comment">// nodes</span></span><br><span class="line">            graph[n1].<span class="built_in">push_back</span>(n2);</span><br><span class="line">            graph[n2].<span class="built_in">push_back</span>(n1);</span><br><span class="line">            <span class="comment">// increment the in-degrees of both the nodes</span></span><br><span class="line">            inDegree[n1]++;</span><br><span class="line">            inDegree[n2]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// c.find all leaves</span></span><br><span class="line">        deque&lt;<span class="keyword">int</span>&gt; leaves;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> entry : inDegree) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.second == <span class="number">1</span>) &#123;</span><br><span class="line">                leaves.<span class="built_in">push_back</span>(entry.first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// d. remove leaves level by level and subtract each leave&#x27;s children&#x27;s</span></span><br><span class="line">        <span class="comment">// in-degrees,repeat this until we are left with 1 or 2 nodes, which</span></span><br><span class="line">        <span class="comment">// will be our answer. any node that has already been a leaf connot ne</span></span><br><span class="line">        <span class="comment">// the root of a minimum height tree, because its adjacent non-leaf node</span></span><br><span class="line">        <span class="comment">// will always be a better candidate</span></span><br><span class="line">        <span class="keyword">int</span> totalNodes = nodes;</span><br><span class="line">        <span class="keyword">while</span> (totalNodes &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> leavesSize = leaves.<span class="built_in">size</span>();</span><br><span class="line">            totalNodes -= leavesSize;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; leavesSize; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> vertex = leaves.<span class="built_in">front</span>();</span><br><span class="line">                inDegree.<span class="built_in">erase</span>(inDegree.<span class="built_in">find</span>(vertex));</span><br><span class="line">                leaves.<span class="built_in">pop_front</span>();</span><br><span class="line">                vector&lt;<span class="keyword">int</span>&gt; children = graph[vertex];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> child : children) &#123;</span><br><span class="line">                    inDegree[child]--;</span><br><span class="line">                    <span class="keyword">if</span> (inDegree[child] == <span class="number">0</span>) &#123;</span><br><span class="line">                        leaves.<span class="built_in">push_back</span>(child);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> entry : inDegree) &#123;</span><br><span class="line">            minHeightTrees.<span class="built_in">push_back</span>(entry.first);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> minHeightTrees;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; vec = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">2</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; result = MinimumHeightTrees::<span class="built_in">findTrees</span>(<span class="number">5</span>, vec);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Roots of MHTs: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : result) &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    vec = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line">    result = MinimumHeightTrees::<span class="built_in">findTrees</span>(<span class="number">4</span>, vec);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Roots of MHTs: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : result) &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    vec = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line">    result = MinimumHeightTrees::<span class="built_in">findTrees</span>(<span class="number">4</span>, vec);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Roots of MHTs: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : result) &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Time-complexity-4"><a href="#Time-complexity-4" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>In step ‘d’, each node can become a source only once and each edge will be accessed and removed once. Therefore, the time complexity of the above algorithm will be <strong><em>O(V+E)</em></strong>, where ‘V’ is the total nodes and ‘E’ is the total number of the edges.</p><h4 id="Space-complexity-4"><a href="#Space-complexity-4" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity will be <strong><em>O(V+E)</em></strong>, since we are storing all of the edges for each node in an adjacency list.</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>马斯克的冒险人生</title>
      <link href="/%E9%A9%AC%E6%96%AF%E5%85%8B%E7%9A%84%E5%86%92%E9%99%A9%E4%BA%BA%E7%94%9F/index.html"/>
      <url>/%E9%A9%AC%E6%96%AF%E5%85%8B%E7%9A%84%E5%86%92%E9%99%A9%E4%BA%BA%E7%94%9F/index.html</url>
      
        <content type="html"><![CDATA[ <div class="row">    <embed src="https://hasuer.github.io/马斯克的冒险人生/index/document.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人物传记，企业管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>16. Pattern  0 or 1 Knapsack (Dynamic Programming)</title>
      <link href="/16-pattern-0-or-1-knapsack-dynamic-programming/index.html"/>
      <url>/16-pattern-0-or-1-knapsack-dynamic-programming/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><strong>0/1 Knapsack</strong> pattern is based on the famous problem with the same name which is efficiently solved using <strong>Dynamic Programming (DP)</strong>.</p><p>In this pattern, we will go through a set of problems to develop an understanding of DP. We will always start with a brute-force recursive solution to see the overlapping subproblems, i.e., realizing that we are solving the same problems repeatedly.</p><p>After the recursive solution, we will modify our algorithm to apply advanced techniques of <strong>Memoization</strong> and <strong>Bottom-Up Dynamic Programming</strong> to develop a complete understanding of this pattern.</p><p>Let’s jump onto our first problem.</p><h2 id="0-1-Knapsack-medium"><a href="#0-1-Knapsack-medium" class="headerlink" title="*0/1 Knapsack (medium)"></a>*0/1 Knapsack (medium)</h2><h3 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h3><p>Given the weights and profits of ‘N’ items, we are asked to put these items in a knapsack which has a capacity ‘C’. The goal is to get the maximum profit out of the items in the knapsack. Each item can only be selected once, as we don’t have multiple quantities of any item.</p><p>Let’s take the example of Merry, who wants to carry some fruits in the knapsack to get maximum profit. Here are the weights and profits of the fruits:</p><p><strong>Items:</strong> { Apple, Orange, Banana, Melon }<br><strong>Weights:</strong> { 2, 3, 1, 4 }<br><strong>Profits:</strong> { 4, 5, 3, 7 }<br><strong>Knapsack capacity:</strong> 5</p><p>Let’s try to put various combinations of fruits in the knapsack, such that their total weight is not more than 5:</p><p>Apple + Orange (total weight 5) =&gt; 9 profit<br>Apple + Banana (total weight 3) =&gt; 7 profit<br>Orange + Banana (total weight 4) =&gt; 8 profit<br>Banana + Melon (total weight 5) =&gt; 10 profit</p><p>This shows that <strong>Banana + Melon</strong> is the best combination as it gives us the maximum profit and the total weight does not exceed the capacity.</p><h3 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given two integer arrays to represent weights and profits of ‘N’ items, we need to find a subset of these items which will give us maximum profit such that their cumulative weight is not more than a given number ‘C’. Each item can only be selected once, which means either we put an item in the knapsack or we skip it.</p><h3 id="Basic-Solution"><a href="#Basic-Solution" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><p>A basic brute-force solution could be to try all combinations of the given items (as we did above), allowing us to choose the one with maximum profit and a weight that doesn’t exceed ‘C’. Take the example of four items (A, B, C, and D), as shown in the diagram below. To try all the combinations, our algorithm will look like:</p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/1_1.png"></p><p>Here is a visual representation of our algorithm:</p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/1_2.png"></p><p>All green boxes have a total weight that is less than or equal to the capacity (7), and all the red ones have a weight that is more than 7. The best solution we have is with items [B, D] having a total profit of 22 and a total weight of 7.</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><p>Here is the code for the brute-force solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Knapsack</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solveKnapsack</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; profits,</span></span></span><br><span class="line"><span class="params"><span class="function">                      vector&lt;<span class="keyword">int</span>&gt;&amp; weights,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">knapsackRecursive</span>(profits, weights, capacity, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">knapsackRecursive</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; profits,</span></span></span><br><span class="line"><span class="params"><span class="function">                          vector&lt;<span class="keyword">int</span>&gt;&amp; weights,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> capacity,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span> || currentIndex &gt;= profits.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> profit1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (weights[currentIndex] &lt;= capacity) &#123;</span><br><span class="line">            profit1 = profits[currentIndex] +</span><br><span class="line">                      <span class="built_in">knapsackRecursive</span>(profits, weights,</span><br><span class="line">                                        capacity - weights[currentIndex],</span><br><span class="line">                                        currentIndex + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> profit2 =</span><br><span class="line">            <span class="built_in">knapsackRecursive</span>(profits, weights, capacity, currentIndex + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(profit1, profit2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Knapsack ks;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; profits = &#123;<span class="number">1</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">16</span>&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; weights = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> maxProfit = ks.<span class="built_in">solveKnapsack</span>(profits, weights, <span class="number">7</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Total knapsack profits: &quot;</span> &lt;&lt; maxProfit &lt;&lt; endl;</span><br><span class="line">    maxProfit = ks.<span class="built_in">solveKnapsack</span>(profits, weights, <span class="number">6</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Total knapsack profits: &quot;</span> &lt;&lt; maxProfit &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Time-and-Space-complexity"><a href="#Time-and-Space-complexity" class="headerlink" title="Time and Space complexity"></a>Time and Space complexity</h4><p>The time complexity of the above algorithm is exponential <strong><em>O(2^n)</em></strong>, where ‘n’ represents the total number of items. This can also be confirmed from the above recursion tree. As we can see, we will have a total of ‘31’ recursive calls – calculated through <strong><em>(2^n) + (2^n) - 1</em></strong>, which is asymptotically equivalent to <strong><em>O(2^n)</em></strong>.</p><p>The space complexity is <strong><em>O(n)</em></strong>. This space will be used to store the recursion stack. Since the recursive algorithm works in a depth-first fashion, which means that we can’t have more than ‘n’ recursive calls on the call stack at any time.</p><p><strong>Overlapping Sub-problems:</strong> Let’s visually draw the recursive calls to see if there are any overlapping sub-problems. As we can see, in each recursive call, profits and weights arrays remain constant, and only capacity and currentIndex change. For simplicity, let’s denote capacity with ‘c’ and currentIndex with ‘i’:</p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/1_3.png"></p><p>We can clearly see that <strong>‘c:4, i=3’</strong> has been called twice. Hence we have an overlapping sub-problems pattern. We can use <a href="https://en.wikipedia.org/wiki/Memoization">Memoization</a> to efficiently solve overlapping sub-problems.</p><h3 id="Top-down-Dynamic-Programming-with-Memoization"><a href="#Top-down-Dynamic-Programming-with-Memoization" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><p>Memoization is when we store the results of all the previously solved sub-problems and return the results from memory if we encounter a problem that has already been solved.</p><p>Since we have two changing values (<code>capacity</code> and <code>currentIndex</code>) in our recursive function <code>knapsackRecursive()</code>, we can use a two-dimensional array to store the results of all the solved sub-problems. As mentioned above, we need to store results for every sub-array (i.e. for every possible index ‘i’) and for every possible capacity ‘c’.</p><h4 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h4><p>Here is the code with memoization (see changes in the highlighted lines):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Knapsack</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solveKnapsack</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; profits,</span></span></span><br><span class="line"><span class="params"><span class="function">                      vector&lt;<span class="keyword">int</span>&gt;&amp; weights,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(profits.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(capacity + <span class="number">1</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">knapsackRecursive</span>(dp, profits, weights, capacity, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">knapsackRecursive</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; dp,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; profits,</span></span></span><br><span class="line"><span class="params"><span class="function">                          vector&lt;<span class="keyword">int</span>&gt;&amp; weights,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> capacity,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span> || currentIndex &gt;= profits.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[currentIndex][capacity] != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[currentIndex][capacity];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> profit1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (weights[currentIndex] &lt;= capacity) &#123;</span><br><span class="line">            profit1 = profits[currentIndex] +</span><br><span class="line">                      <span class="built_in">knapsackRecursive</span>(dp, profits, weights,</span><br><span class="line">                                        capacity - weights[currentIndex],</span><br><span class="line">                                        currentIndex + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> profit2 =</span><br><span class="line">            <span class="built_in">knapsackRecursive</span>(dp, profits, weights, capacity, currentIndex + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        dp[currentIndex][capacity] = <span class="built_in">max</span>(profit1, profit2);</span><br><span class="line">        <span class="keyword">return</span> dp[currentIndex][capacity];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Knapsack ks;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; profits = &#123;<span class="number">1</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">16</span>&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; weights = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> maxProfit = ks.<span class="built_in">solveKnapsack</span>(profits, weights, <span class="number">7</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Total knapsack profits: &quot;</span> &lt;&lt; maxProfit &lt;&lt; endl;</span><br><span class="line">    maxProfit = ks.<span class="built_in">solveKnapsack</span>(profits, weights, <span class="number">6</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Total knapsack profits: &quot;</span> &lt;&lt; maxProfit &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Time-and-Space-complexity-1"><a href="#Time-and-Space-complexity-1" class="headerlink" title="Time and Space complexity"></a>Time and Space complexity</h4><p>Since our memoization array <code>dp[profits.length][capacity+1]</code> stores the results for all subproblems, we can conclude that we will not have more than N*C subproblems (where ‘N’ is the number of items and ‘C’ is the knapsack capacity). This means that our time complexity will be <strong><em>O(N\</em>C)*</strong>.</p><p>The above algorithm will use <strong><em>O(N\</em>C)*</strong> space for the memoization array. Other than that we will use <strong><em>O(N)</em></strong> space for the recursion call-stack. So the total space complexity will be <strong><em>O(N\</em>C + N)*</strong>, which is asymptotically equivalent to <strong><em>O(N\</em>C)*</strong>.</p><h3 id="Bottom-up-Dynamic-Programming"><a href="#Bottom-up-Dynamic-Programming" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><p>Let’s try to populate our <code>dp[][]</code> array from the above solution by working in a bottom-up fashion. Essentially, we want to find the maximum profit for every sub-array and for every possible capacity. <strong>This means that <code>dp[i][c]</code> will represent the maximum knapsack profit for capacity ‘c’ calculated from the first ‘i’ items.</strong></p><p>So, for each item at index ‘i’ (0 &lt;= i &lt; items.length) and capacity ‘c’ (0 &lt;= c &lt;= capacity), we have two options:</p><ol><li>Exclude the item at index ‘i’. In this case, we will take whatever profit we get from the sub-array excluding this item =&gt; <code>dp[i-1][c]</code></li><li>Include the item at index ‘i’ if its weight is not more than the capacity. In this case, we include its profit plus whatever profit we get from the remaining capacity and from remaining items =&gt; <code>profit[i] + dp[i-1][c-weight[i]]</code></li></ol><p>Finally, our optimal solution will be maximum of the above two values:</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp<span class="comment">[i]</span><span class="comment">[c]</span> = max (dp<span class="comment">[i-1]</span><span class="comment">[c]</span>, profit<span class="comment">[i]</span> + dp<span class="comment">[i-1]</span><span class="comment">[c-weight<span class="comment">[i]</span>]</span>) </span><br></pre></td></tr></table></figure><p>Let’s draw this visually and start with our base case of zero capacity:</p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/1_4.png"></p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/1_5.png"></p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/1_6.png"></p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/1_7.png"></p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/1_8.png"></p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/1_9.png"></p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/1_10.png"></p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/1_11.png"></p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/1_12.png"></p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/1_13.png"></p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/1_14.png"></p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/1_15.png"></p><h4 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h4><p>Here is the code for our bottom-up dynamic programming approach:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Knapsack</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solveKnapsack</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; profits,</span></span></span><br><span class="line"><span class="params"><span class="function">                      vector&lt;<span class="keyword">int</span>&gt;&amp; weights,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span> || profits.<span class="built_in">empty</span>() ||</span><br><span class="line">            weights.<span class="built_in">size</span>() != profits.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = profits.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n, vector&lt;<span class="keyword">int</span>&gt;(capacity + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算capacity是0的那一列，对于0 capacity,我们只有0 profits</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果我们只有一种重量，我们就拿他若他不超过背包容量的话</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt;= capacity; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (weights[<span class="number">0</span>] &lt;= c) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][c] = profits[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// process all sub-arrays for all the capacities</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt;= capacity; c++) &#123;</span><br><span class="line">                <span class="keyword">int</span> profit1 = <span class="number">0</span>, profit2 = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// include the item, if it is not more than the capacity</span></span><br><span class="line">                <span class="keyword">if</span> (weights[i] &lt;= c) &#123;</span><br><span class="line">                    profit1 = profits[i] + dp[i - <span class="number">1</span>][c - weights[i]];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// exclude the item</span></span><br><span class="line">                profit2 = dp[i - <span class="number">1</span>][c];</span><br><span class="line">                dp[i][c] = <span class="built_in">max</span>(profit1, profit2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][capacity];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Knapsack ks;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; profits = &#123;<span class="number">1</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">16</span>&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; weights = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> maxProfit = ks.<span class="built_in">solveKnapsack</span>(profits, weights, <span class="number">7</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Total knapsack profits: &quot;</span> &lt;&lt; maxProfit &lt;&lt; endl;</span><br><span class="line">    maxProfit = ks.<span class="built_in">solveKnapsack</span>(profits, weights, <span class="number">6</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Total knapsack profits: &quot;</span> &lt;&lt; maxProfit &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Time-and-Space-complexity-2"><a href="#Time-and-Space-complexity-2" class="headerlink" title="Time and Space complexity"></a>Time and Space complexity</h4><p>The above solution has the time and space complexity of <strong><em>O(N\</em>C)*</strong>, where ‘N’ represents total items and ‘C’ is the maximum capacity.</p><h4 id="How-can-we-find-the-selected-items"><a href="#How-can-we-find-the-selected-items" class="headerlink" title="How can we find the selected items?"></a>How can we find the selected items?</h4><p>As we know, the final profit is at the bottom-right corner. Therefore, we will start from there to find the items that will be going into the knapsack.</p><p>As you remember, at every step we had two options: include an item or skip it. If we skip an item, we take the profit from the remaining items (i.e. from the cell right above it); if we include the item, then we jump to the remaining profit to find more items.</p><p>Let’s understand this from the above example:</p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/1_16.png"></p><ol><li>‘22’ did not come from the top cell (which is 17); hence we must include the item at index ‘3’ (which is item ‘D’).</li><li>Subtract the profit of item ‘D’ from ‘22’ to get the remaining profit ‘6’. We then jump to profit ‘6’ on the same row.</li><li>‘6’ came from the top cell, so we jump to row ‘2’.</li><li>Again ‘6’ came from the top cell, so we jump to row ‘1’.</li><li>‘6’ is different than the top cell, so we must include this item (which is item ‘B’).</li><li>Subtract the profit of ‘B’ from ‘6’ to get profit ‘0’. We then jump to profit ‘0’ on the same row. As soon as we hit zero remaining profit, we can finish our item search.</li><li>Thus the items going into the knapsack are {B, D}.</li></ol><p>Let’s write a function to print the set of items included in the knapsack.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Knapsack</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solveKnapsack</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; profits,</span></span></span><br><span class="line"><span class="params"><span class="function">                      vector&lt;<span class="keyword">int</span>&gt;&amp; weights,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span> || profits.<span class="built_in">empty</span>() ||</span><br><span class="line">            weights.<span class="built_in">size</span>() != profits.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = profits.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n, vector&lt;<span class="keyword">int</span>&gt;(capacity + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算capacity是0的那一列，对于0 capacity,我们只有0 profits</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果我们只有一种重量，我们就拿他若他不超过背包容量的话</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt;= capacity; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (weights[<span class="number">0</span>] &lt;= c) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][c] = profits[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// process all sub-arrays for all the capacities</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt;= capacity; c++) &#123;</span><br><span class="line">                <span class="keyword">int</span> profit1 = <span class="number">0</span>, profit2 = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// include the item, if it is not more than the capacity</span></span><br><span class="line">                <span class="keyword">if</span> (weights[i] &lt;= c) &#123;</span><br><span class="line">                    profit1 = profits[i] + dp[i - <span class="number">1</span>][c - weights[i]];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// exclude the item</span></span><br><span class="line">                profit2 = dp[i - <span class="number">1</span>][c];</span><br><span class="line">                dp[i][c] = <span class="built_in">max</span>(profit1, profit2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printSelectedElements</span>(dp, weights, profits, capacity);</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printSelectedElements</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; dp,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; weights,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; profits,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Selected weights: &quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> totalProfits = dp[weights.<span class="built_in">size</span>() - <span class="number">1</span>][capacity];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = weights.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (totalProfits != dp[i - <span class="number">1</span>][capacity]) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; weights[i];</span><br><span class="line">                capacity -= weights[i];</span><br><span class="line">                totalProfits -= profits[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (totalProfits != <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; weights[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Knapsack ks;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; profits = &#123;<span class="number">1</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">16</span>&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; weights = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> maxProfit = ks.<span class="built_in">solveKnapsack</span>(profits, weights, <span class="number">7</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Total knapsack profits: &quot;</span> &lt;&lt; maxProfit &lt;&lt; endl;</span><br><span class="line">    maxProfit = ks.<span class="built_in">solveKnapsack</span>(profits, weights, <span class="number">6</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Total knapsack profits: &quot;</span> &lt;&lt; maxProfit &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h3><p>Can we improve our bottom-up DP solution even further? Can you find an algorithm that has <strong><em>O(C)</em></strong> space complexity?</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Knapsack</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solveKnapsack</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; profits,</span></span></span><br><span class="line"><span class="params"><span class="function">                      vector&lt;<span class="keyword">int</span>&gt;&amp; weights,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// we only need one previous row to find the optimal solution, overall</span></span><br><span class="line">        <span class="comment">// we need &#x27;2&#x27; rows we need &#x27;2&#x27; rows the above solution is similar to</span></span><br><span class="line">        <span class="comment">// the previous solution, the only difference is that we use &#x27;i%2&#x27;</span></span><br><span class="line">        <span class="comment">// instead of &#x27;i&#x27; and &#x27;(i-1) % 2&#x27; insteadof &#x27;i - 1&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span> || profits.<span class="built_in">empty</span>() ||</span><br><span class="line">            weights.<span class="built_in">size</span>() != profits.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = profits.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n, vector&lt;<span class="keyword">int</span>&gt;(capacity + <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 初始化两行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt;= capacity; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (weights[<span class="number">0</span>] &lt;= c) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][c] = dp[<span class="number">1</span>][c] = profits[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// process all sub-arrays for all the capacities</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt;= capacity; c++) &#123;</span><br><span class="line">                <span class="keyword">int</span> profit1 = <span class="number">0</span>, profit2 = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// include the item, if it is not more than the capacity</span></span><br><span class="line">                <span class="keyword">if</span> (weights[i] &lt;= c) &#123;</span><br><span class="line">                    profit1 = profits[i] + dp[(i - <span class="number">1</span>) % <span class="number">2</span>][c - weights[i]];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// exclude the item</span></span><br><span class="line">                profit2 = dp[(i - <span class="number">1</span>) % <span class="number">2</span>][c];</span><br><span class="line">                dp[i % <span class="number">2</span>][c] = <span class="built_in">max</span>(profit1, profit2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[(n - <span class="number">1</span>) % <span class="number">2</span>][capacity];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Knapsack ks;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; profits = &#123;<span class="number">1</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">16</span>&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; weights = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> maxProfit = ks.<span class="built_in">solveKnapsack</span>(profits, weights, <span class="number">7</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Total knapsack profits: &quot;</span> &lt;&lt; maxProfit &lt;&lt; endl;</span><br><span class="line">    maxProfit = ks.<span class="built_in">solveKnapsack</span>(profits, weights, <span class="number">6</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Total knapsack profits: &quot;</span> &lt;&lt; maxProfit &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The solution above is similar to the previous solution, the only difference is that we use <code>i%2</code> instead if <code>i</code> and <code>(i-1)%2</code> instead if <code>i-1</code>. This solution has a space complexity of <strong><em>O(2\</em>C) = O(C)*</strong>, where ‘C’ is the maximum capacity of the knapsack.</p><p>This space optimization solution can also be implemented using a single array. It is a bit tricky, but the intuition is to use the same array for the previous and the next iteration!</p><p>If you see closely, we need two values from the previous iteration: <code>dp[c]</code> and <code>dp[c-weight[i]]</code></p><p>Since our inner loop is iterating over <code>c:0--&gt;capacity</code>, let’s see how this might affect our two required values:</p><ol><li>When we access <code>dp[c]</code>, it has not been overridden yet for the current iteration, so it should be fine.</li><li><code>dp[c-weight[i]]</code> might be overridden if “weight[i] &gt; 0”. Therefore we can’t use this value for the current iteration.</li></ol><p>To solve the second case, we can change our inner loop to process in the reverse direction: <code>c:capacity--&gt;0</code>. This will ensure that whenever we change a value in <code>dp[]</code>, we will not need it again in the current iteration.</p><p>Can you try writing this algorithm?</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Knapsack</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solveKnapsack</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; profits,</span></span></span><br><span class="line"><span class="params"><span class="function">                      vector&lt;<span class="keyword">int</span>&gt;&amp; weights,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span> || profits.<span class="built_in">empty</span>() ||</span><br><span class="line">            weights.<span class="built_in">size</span>() != profits.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = profits.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;(capacity + <span class="number">1</span>))</span></span>;</span><br><span class="line">        <span class="comment">// 初始化两行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt;= capacity; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (weights[<span class="number">0</span>] &lt;= c) &#123;</span><br><span class="line">                dp[c] = profits[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// process all sub-arrays for all the capacities</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = capacity; c &gt;= <span class="number">0</span>; c--) &#123;</span><br><span class="line">                <span class="keyword">int</span> profit1 = <span class="number">0</span>, profit2 = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// include the item, if it is not more than the capacity</span></span><br><span class="line">                <span class="keyword">if</span> (weights[i] &lt;= c) &#123;</span><br><span class="line">                    profit1 = profits[i] + dp[c - weights[i]];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// exclude the item</span></span><br><span class="line">                profit2 = dp[c];</span><br><span class="line">                dp[c] = <span class="built_in">max</span>(profit1, profit2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Knapsack ks;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; profits = &#123;<span class="number">1</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">16</span>&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; weights = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> maxProfit = ks.<span class="built_in">solveKnapsack</span>(profits, weights, <span class="number">7</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Total knapsack profits: &quot;</span> &lt;&lt; maxProfit &lt;&lt; endl;</span><br><span class="line">    maxProfit = ks.<span class="built_in">solveKnapsack</span>(profits, weights, <span class="number">6</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Total knapsack profits: &quot;</span> &lt;&lt; maxProfit &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Equal-Subset-Sum-Partition-medium"><a href="#Equal-Subset-Sum-Partition-medium" class="headerlink" title="Equal Subset Sum Partition (medium)"></a>Equal Subset Sum Partition (medium)</h2><h3 id="Problem-Statement-1"><a href="#Problem-Statement-1" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given a set of positive numbers, find if we can partition it into two subsets such that the sum of elements in both subsets is equal.</p><p><strong>Example 1:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="attribute">Output</span>: True</span><br><span class="line"><span class="attribute">Explanation</span>: The given set can be partitioned into two subsets with equal sum: &#123;<span class="number">1</span>, <span class="number">4</span>&#125; &amp; &#123;<span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>&#125;</span><br><span class="line"><span class="attribute">Output</span>: True</span><br><span class="line"><span class="attribute">Explanation</span>: The given set can be partitioned into two subsets with equal sum: &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125; &amp; &#123;<span class="number">1</span>, <span class="number">7</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line">Output: False</span><br><span class="line">Explanation: The <span class="keyword">given</span> <span class="keyword">set</span> cannot be partitioned <span class="keyword">into</span> two subsets <span class="keyword">with</span> <span class="keyword">equal</span> sum.</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself"><a href="#Try-it-yourself" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>This problem looks similar to the 0/1 Knapsack problem. Try solving it before moving on to see the solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴力解法，先使用Pattern 11的求子集的方法得到了所有的子集，然后去遍历，看看有没有和是一半的。</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Partition</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; subsets;</span><br><span class="line">        subsets.<span class="built_in">push_back</span>(&#123;&#125;);</span><br><span class="line">        <span class="keyword">int</span> Sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            Sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 偶数</span></span><br><span class="line">        <span class="keyword">if</span> (Sum % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = subsets.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">set</span><span class="params">(subsets[i])</span></span>;</span><br><span class="line">                set.<span class="built_in">push_back</span>(num);</span><br><span class="line">                subsets.<span class="built_in">push_back</span>(set);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> subset : subsets) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = subset.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                sum += subset[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum == Sum / <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; num = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    cout &lt;&lt; Partition::<span class="built_in">canPartition</span>(num) &lt;&lt; endl;</span><br><span class="line">    num = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    cout &lt;&lt; Partition::<span class="built_in">canPartition</span>(num) &lt;&lt; endl;</span><br><span class="line">    num = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    cout &lt;&lt; Partition::<span class="built_in">canPartition</span>(num) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Basic-Solution-1"><a href="#Basic-Solution-1" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><p>This problem follows the <strong>0/1 Knapsack pattern</strong>. A basic brute-force solution could be to try all combinations of partitioning the given numbers into two sets to see if any pair of sets has an equal sum.</p><p>Assume that <code>S</code> represents the total sum of all the given numbers. Then the two equal subsets must have a sum equal to <code>S/2</code>. This essentially transforms our problem to: “Find a subset of the given numbers that has a total sum of <code>S/2</code>“.</p><p>So our brute-force algorithm will look like:</p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/2_1.png"></p><h4 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h4><p>Here is the code for the brute-force solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Partition</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">canPartitionRecursive</span>(nums, sum / <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">canPartitionRecursive</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; num,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">int</span> sum,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (num.<span class="built_in">empty</span>() || currentIndex &gt;= num.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num[currentIndex] &lt;= sum) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">canPartitionRecursive</span>(num, sum - num[currentIndex],</span><br><span class="line">                                      currentIndex + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">canPartitionRecursive</span>(num, sum, currentIndex + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; num = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    cout &lt;&lt; Partition::<span class="built_in">canPartition</span>(num) &lt;&lt; endl;</span><br><span class="line">    num = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    cout &lt;&lt; Partition::<span class="built_in">canPartition</span>(num) &lt;&lt; endl;</span><br><span class="line">    num = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    cout &lt;&lt; Partition::<span class="built_in">canPartition</span>(num) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Time-and-Space-complexity-3"><a href="#Time-and-Space-complexity-3" class="headerlink" title="Time and Space complexity"></a>Time and Space complexity</h4><p>The time complexity of the above algorithm is exponential <strong><em>O(2^n)</em></strong>, where ‘n’ represents the total number. The space complexity is <strong><em>O(n)</em></strong>, which will be used to store the recursion stack.</p><h3 id="Top-down-Dynamic-Programming-with-Memoization-1"><a href="#Top-down-Dynamic-Programming-with-Memoization-1" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><p>We can use memoization to overcome the overlapping sub-problems. As stated in previous lessons, memoization is when we store the results of all the previously solved sub-problems so we can return the results from memory if we encounter a problem that has already been solved.</p><p>Since we need to store the results for every subset and for every possible sum, therefore we will be using a two-dimensional array to store the results of the solved sub-problems. The first dimension of the array will represent different subsets and the second dimension will represent different ‘sums’ that we can calculate from each subset. These two dimensions of the array can also be inferred from the two changing values (sum and currentIndex) in our recursive function <code>canPartitionRecursive()</code>.</p><h4 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h4><p>Here is the code for Top-down DP with memoization:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Partition</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(nums.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(sum / <span class="number">2</span> + <span class="number">1</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">canPartitionRecursive</span>(dp, nums, sum / <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">canPartitionRecursive</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; dp,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; num,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">int</span> sum,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (num.<span class="built_in">empty</span>() || currentIndex &gt;= num.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[currentIndex][sum] == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[currentIndex] &lt;= sum) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">canPartitionRecursive</span>(dp, num, sum - num[currentIndex],</span><br><span class="line">                                          currentIndex + <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[currentIndex][sum] =</span><br><span class="line">            <span class="built_in">canPartitionRecursive</span>(dp, num, sum, currentIndex + <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> dp[currentIndex][sum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; num = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    cout &lt;&lt; Partition::<span class="built_in">canPartition</span>(num) &lt;&lt; endl;</span><br><span class="line">    num = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    cout &lt;&lt; Partition::<span class="built_in">canPartition</span>(num) &lt;&lt; endl;</span><br><span class="line">    num = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    cout &lt;&lt; Partition::<span class="built_in">canPartition</span>(num) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Time-and-Space-complexity-4"><a href="#Time-and-Space-complexity-4" class="headerlink" title="Time and Space complexity"></a>Time and Space complexity</h4><p>The above algorithm has the time and space complexity of <strong><em>O(N\</em>S)*</strong>, where ‘N’ represents total numbers and ‘S’ is the total sum of all the numbers.</p><h3 id="Bottom-up-Dynamic-Programming-1"><a href="#Bottom-up-Dynamic-Programming-1" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><p>Let’s try to populate our <code>dp[][]</code> array from the above solution by working in a bottom-up fashion. Essentially, we want to find if we can make all possible sums with every subset. <strong>This means, <code>dp[i][s]</code> will be ‘true’ if we can make the sum ‘s’ from the first ‘i’ numbers.</strong></p><p>So, for each number at index ‘i’ (0 &lt;= i &lt; num.length) and sum ‘s’ (0 &lt;= s &lt;= S/2), we have two options:</p><ol><li>Exclude the number. In this case, we will see if we can get ‘s’ from the subset excluding this number: <code>dp[i-1][s]</code></li><li>Include the number if its value is not more than ‘s’. In this case, we will see if we can find a subset to get the remaining sum: <code>dp[i-1][s-num[i]]</code></li></ol><p>If either of the two above scenarios is true, we can find a subset of numbers with a sum equal to ‘s’.</p><p>Let’s start with our base case of zero capacity:</p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/2_2.png"></p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/2_3.png"></p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/2_4.png"></p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/2_5.png"></p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/2_6.png"></p><p>From the above visualization, we can clearly see that it is possible to partition the given set into two subsets with equal sums, as shown by bottom-right cell: <code>dp[3][5] =&gt; T</code></p><h4 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h4><p>Here is the code for our bottom-up dynamic programming approach:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Partition</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">dp</span>(n, vector&lt;<span class="keyword">bool</span>&gt;(sum + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算sum = 0的列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] == <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算第一行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt;= sum; s++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][s] = (nums[<span class="number">0</span>] == s ? <span class="literal">true</span> : <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// process all subsets for all sums</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt;= sum; s++) &#123;</span><br><span class="line">                <span class="comment">// we can get the sum &#x27;s&#x27; without the number at index &#x27;i&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i - <span class="number">1</span>][s]) &#123;</span><br><span class="line">                    dp[i][s] = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt;= s) &#123;</span><br><span class="line">                    dp[i][s] = dp[i - <span class="number">1</span>][s - nums[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][sum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; num = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    cout &lt;&lt; Partition::<span class="built_in">canPartition</span>(num) &lt;&lt; endl;</span><br><span class="line">    num = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    cout &lt;&lt; Partition::<span class="built_in">canPartition</span>(num) &lt;&lt; endl;</span><br><span class="line">    num = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    cout &lt;&lt; Partition::<span class="built_in">canPartition</span>(num) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Time-and-Space-complexity-5"><a href="#Time-and-Space-complexity-5" class="headerlink" title="Time and Space complexity"></a>Time and Space complexity</h4><p>The above solution the has time and space complexity of <strong><em>O(N\</em>S)*</strong>, where ‘N’ represents total numbers and ‘S’ is the total sum of all the numbers.</p><h2 id="Subset-Sum-medium"><a href="#Subset-Sum-medium" class="headerlink" title="Subset Sum (medium)"></a>Subset Sum (medium)</h2><h3 id="Problem-Statement-2"><a href="#Problem-Statement-2" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given a set of positive numbers, determine if a subset exists whose sum is equal to a given number ‘S’.</p><p><strong>Example 1:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>&#125;, S=<span class="number">6</span></span><br><span class="line"><span class="attribute">Output</span>: True</span><br><span class="line"><span class="attribute">The</span> given set has a subset whose sum is &#x27;<span class="number">6</span>&#x27;: &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>&#125;, S=<span class="number">10</span></span><br><span class="line"><span class="attribute">Output</span>: True</span><br><span class="line"><span class="attribute">The</span> given set has a subset whose sum is &#x27;<span class="number">10</span>&#x27;: &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>&#125;, S=<span class="number">6</span></span><br><span class="line">Output: False</span><br><span class="line">The <span class="keyword">given</span> <span class="keyword">set</span> <span class="keyword">does</span> <span class="keyword">not</span> have any subset <span class="keyword">whose</span> sum <span class="keyword">is</span> <span class="keyword">equal</span> <span class="keyword">to</span> &#x27;<span class="number">6</span>&#x27;.</span><br></pre></td></tr></table></figure><h3 id="Basic-Solution-2"><a href="#Basic-Solution-2" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><p>This problem follows the <strong>0/1 Knapsack pattern</strong> and is quite similar to <em>Equal Subset Sum Partition</em>. A basic brute-force solution could be to try all subsets of the given numbers to see if any set has a sum equal to ‘S’.</p><p>So our brute-force algorithm will look like:</p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/3_1.png"></p><p>Since this problem is quite similar to <em>Equal Subset Sum Partition</em>, let’s jump directly to the bottom-up dynamic programming solution.</p><h3 id="Bottom-up-Dynamic-Programming-2"><a href="#Bottom-up-Dynamic-Programming-2" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><p>We’ll try to find if we can make all possible sums with every subset to populate the array <code>dp[TotalNumbers][S+1]</code>.</p><p>For every possible sum ‘s’ (where 0 &lt;= s &lt;= S), we have two options:</p><ol><li>Exclude the number. In this case, we will see if we can get the sum ‘s’ from the subset excluding this number =&gt; <code>dp[index-1][s]</code></li><li>Include the number if its value is not more than ‘s’. In this case, we will see if we can find a subset to get the remaining sum =&gt; <code>dp[index-1][s-num[index]]</code></li></ol><p>If either of the above two scenarios returns true, we can find a subset with a sum equal to ‘s’.</p><p>Let’s draw this visually, with the example input {1, 2, 3, 7}, and start with our base case of size zero:</p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/3_2.png"></p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/3_3.png"></p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/3_4.png"></p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/3_5.png"></p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/3_6.png"></p><h4 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h4><p>Here is the code for our bottom-up dynamic programming approach:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubsetSum</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">dp</span>(n, vector&lt;<span class="keyword">bool</span>&gt;(sum + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算sum = 0的列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] == <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算第一行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt;= sum; s++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][s] = (nums[<span class="number">0</span>] == s ? <span class="literal">true</span> : <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// process all subsets for all sums</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt;= sum; s++) &#123;</span><br><span class="line">                <span class="comment">// we can get the sum &#x27;s&#x27; without the number at index &#x27;i&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i - <span class="number">1</span>][s]) &#123;</span><br><span class="line">                    dp[i][s] = dp[i - <span class="number">1</span>][s];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt;= s) &#123;</span><br><span class="line">                    dp[i][s] = dp[i - <span class="number">1</span>][s - nums[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][sum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; num = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    cout &lt;&lt; SubsetSum::<span class="built_in">canPartition</span>(num, <span class="number">6</span>) &lt;&lt; endl;</span><br><span class="line">    num = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; SubsetSum::<span class="built_in">canPartition</span>(num, <span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">    num = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    cout &lt;&lt; SubsetSum::<span class="built_in">canPartition</span>(num, <span class="number">6</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Time-and-Space-complexity-6"><a href="#Time-and-Space-complexity-6" class="headerlink" title="Time and Space complexity"></a>Time and Space complexity</h4><p>The above solution has the time and space complexity of <strong><em>O(N\</em>S)*</strong>, where ‘N’ represents total numbers and ‘S’ is the required sum.</p><h3 id="Challenge-1"><a href="#Challenge-1" class="headerlink" title="Challenge"></a>Challenge</h3><p>Can we improve our bottom-up DP solution even further? Can you find an algorithm that has <strong><em>O(S)</em></strong> space complexity?</p><p><strong>Hint</strong></p><p>Similar to the space optimized solution for <strong><em>0/1 Knapsack</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubsetSum</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">dp</span><span class="params">(sum + <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算sum = 0的列</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 计算第一行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt;= sum; s++) &#123;</span><br><span class="line">            dp[s] = (nums[<span class="number">0</span>] == s ? <span class="literal">true</span> : <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// process all subsets for all sums</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s = sum; s &gt;= <span class="number">0</span>; s--) &#123;</span><br><span class="line">                <span class="comment">// 如果dp[s]==true, 这意味这我们不需要包含num[i]就可以得到s,</span></span><br><span class="line">                <span class="comment">// 因此我们前进到下一个数字</span></span><br><span class="line">                <span class="comment">// 否则，我们包含num[i],去看看我们是否可以得到一个子集的和是剩下的sum</span></span><br><span class="line">                <span class="keyword">if</span> (!dp[s] &amp;&amp; s &gt;= nums[i]) &#123;</span><br><span class="line">                    dp[s] = dp[s - nums[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[sum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; num = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    cout &lt;&lt; SubsetSum::<span class="built_in">canPartition</span>(num, <span class="number">6</span>) &lt;&lt; endl;</span><br><span class="line">    num = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; SubsetSum::<span class="built_in">canPartition</span>(num, <span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">    num = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    cout &lt;&lt; SubsetSum::<span class="built_in">canPartition</span>(num, <span class="number">6</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Minimum-Subset-Sum-Difference-hard"><a href="#Minimum-Subset-Sum-Difference-hard" class="headerlink" title="Minimum Subset Sum Difference (hard)"></a>Minimum Subset Sum Difference (hard)</h2><h3 id="Problem-Statement-3"><a href="#Problem-Statement-3" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given a set of positive numbers, partition the set into two subsets with minimum difference between their subset sums.</p><p><strong>Example 1:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>&#125;</span><br><span class="line"><span class="attribute">Output</span>: <span class="number">3</span></span><br><span class="line"><span class="attribute">Explanation</span>: We can partition the given set into two subsets where minimum absolute difference </span><br><span class="line"><span class="attribute">between</span> the sum of numbers is &#x27;<span class="number">3</span>&#x27;. Following are the two subsets: &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; &amp; &#123;<span class="number">9</span>&#125;.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="attribute">Output</span>: <span class="number">0</span></span><br><span class="line"><span class="attribute">Explanation</span>: We can partition the given set into two subsets where minimum absolute difference </span><br><span class="line"><span class="attribute">between</span> the sum of number is &#x27;<span class="number">0</span>&#x27;. Following are the two subsets: &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>&#125; &amp; &#123;<span class="number">7</span>, <span class="number">1</span>&#125;.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">100</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="attribute">Output</span>: <span class="number">92</span></span><br><span class="line"><span class="attribute">Explanation</span>: We can partition the given set into two subsets where minimum absolute difference </span><br><span class="line"><span class="attribute">between</span> the sum of numbers is &#x27;<span class="number">92</span>&#x27;. Here are the two subsets: &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125; &amp; &#123;<span class="number">100</span>&#125;.</span><br></pre></td></tr></table></figure><h3 id="Basic-Solution-3"><a href="#Basic-Solution-3" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><p>This problem follows the <strong>0/1 Knapsack pattern</strong> and can be converted into a <em>Subset Sum</em> problem.</p><p>Let’s assume S1 and S2 are the two desired subsets. A basic brute-force solution could be to try adding each element either in S1 or S2 in order to find the combination that gives the minimum sum difference between the two sets.</p><p>So our brute-force algorithm will look like:</p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/4_1.png"></p><h4 id="Code-7"><a href="#Code-7" class="headerlink" title="Code"></a>Code</h4><p>Here is the code for the brute-force solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PartitionSet</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">canPartitionRecursive</span>(num, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">canPartitionRecursive</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; num,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">int</span> currentIndex,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">int</span> sum1,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">int</span> sum2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentIndex == num.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(sum1 - sum2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> diff1 = <span class="built_in">canPartitionRecursive</span>(num, currentIndex + <span class="number">1</span>,</span><br><span class="line">                                          sum1 + num[currentIndex], sum2);</span><br><span class="line">        <span class="keyword">int</span> diff2 = <span class="built_in">canPartitionRecursive</span>(num, currentIndex + <span class="number">1</span>, sum1,</span><br><span class="line">                                          sum2 + num[currentIndex]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(diff1, diff2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; num = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    cout &lt;&lt; PartitionSet::<span class="built_in">canPartition</span>(num) &lt;&lt; endl;</span><br><span class="line">    num = vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; PartitionSet::<span class="built_in">canPartition</span>(num) &lt;&lt; endl;</span><br><span class="line">    num = vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">100</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    cout &lt;&lt; PartitionSet::<span class="built_in">canPartition</span>(num) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Time-and-Space-complexity-7"><a href="#Time-and-Space-complexity-7" class="headerlink" title="Time and Space complexity"></a>Time and Space complexity</h4><p>Because of the two recursive calls, the time complexity of the above algorithm is exponential <strong><em>O(2^n)</em></strong>, where ‘n’ represents the total number. The space complexity is <strong><em>O(n)</em></strong> which is used to store the recursion stack.</p><h3 id="Top-down-Dynamic-Programming-with-Memoization-2"><a href="#Top-down-Dynamic-Programming-with-Memoization-2" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><p>We can use memoization to overcome the overlapping sub-problems.</p><p>We will be using a two-dimensional array to store the results of the solved sub-problems. We can uniquely identify a sub-problem from ‘currentIndex’ and ‘Sum1’ as ‘Sum2’ will always be the sum of the remaining numbers.</p><h4 id="Code-8"><a href="#Code-8" class="headerlink" title="Code"></a>Code</h4><p>Here is the code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PartitionSet</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            sum += num[i];</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(num.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(sum + <span class="number">1</span>, <span class="number">-1</span>));<span class="comment">// 注意这里是sum + 1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">canPartitionRecursive</span>(dp, num, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">canPartitionRecursive</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; dp,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; num,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">int</span> currentIndex,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">int</span> sum1,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">int</span> sum2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentIndex == num.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(sum1 - sum2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[currentIndex][sum1] == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> diff1 = <span class="built_in">canPartitionRecursive</span>(dp, num, currentIndex + <span class="number">1</span>,</span><br><span class="line">                                              sum1 + num[currentIndex], sum2);</span><br><span class="line">            <span class="keyword">int</span> diff2 = <span class="built_in">canPartitionRecursive</span>(dp, num, currentIndex + <span class="number">1</span>, sum1,</span><br><span class="line">                                              sum2 + num[currentIndex]);</span><br><span class="line">            dp[currentIndex][sum1] = <span class="built_in">min</span>(diff1, diff2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[currentIndex][sum1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; num = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    cout &lt;&lt; PartitionSet::<span class="built_in">canPartition</span>(num) &lt;&lt; endl;</span><br><span class="line">    num = vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; PartitionSet::<span class="built_in">canPartition</span>(num) &lt;&lt; endl;</span><br><span class="line">    num = vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">100</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    cout &lt;&lt; PartitionSet::<span class="built_in">canPartition</span>(num) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bottom-up-Dynamic-Programming-3"><a href="#Bottom-up-Dynamic-Programming-3" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><p>Let’s assume ‘S’ represents the total sum of all the numbers. So, in this problem, we are trying to find a subset whose sum is as close to ‘S/2’ as possible, because if we can partition the given set into two subsets of an equal sum, we get the minimum difference, i.e. zero. This transforms our problem to <em>Subset Sum</em>, where we try to find a subset whose sum is equal to a given number— ‘S/2’ in our case. If we can’t find such a subset, then we will take the subset which has the sum closest to ‘S/2’. This is easily possible, as we will be calculating all possible sums with every subset.</p><p>Essentially, we need to calculate all the possible sums up to ‘S/2’ for all numbers. So how can we populate the array <code>db[TotalNumbers][S/2+1]</code> in the bottom-up fashion?</p><p>For every possible sum ‘s’ (where 0 &lt;= s &lt;= S/2), we have two options:</p><ol><li>Exclude the number. In this case, we will see if we can get the sum ‘s’ from the subset excluding this number =&gt; <code>dp[index-1][s]</code></li><li>Include the number if its value is not more than ‘s’. In this case, we will see if we can find a subset to get the remaining sum =&gt; <code>dp[index-1][s-num[index]]</code></li></ol><p>If either of the two above scenarios is true, we can find a subset with a sum equal to ‘s’. We should dig into this before we can learn how to find the closest subset.</p><p>Let’s draw this visually, with the example input {1, 2, 3, 9}. Since the total sum is ‘15’, we will try to find a subset whose sum is equal to the half of it, i.e. ‘7’.</p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/4_2.png"></p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/4_3.png"></p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/4_4.png"></p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/4_5.png"></p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/4_6.png"></p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/4_7.png"></p><p>The above visualization tells us that it is not possible to find a subset whose sum is equal to ‘7’. So what is the closest subset we can find? We can find the subset if we start moving backwards in the last row from the bottom right corner to find the first ‘T’. The first “T” in the diagram above is the sum ‘6’, which means that we can find a subset whose sum is equal to ‘6’. This means the other set will have a sum of ‘9’ and the minimum difference will be ‘3’.</p><h4 id="Code-9"><a href="#Code-9" class="headerlink" title="Code"></a>Code</h4><p>Here is the code for our bottom-up dynamic programming approach:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PartitionSet</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            sum += num[i];</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">dp</span>(num.<span class="built_in">size</span>(), vector&lt;<span class="keyword">bool</span>&gt;(sum + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">int</span> n = num.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//第一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt;= sum / <span class="number">2</span>; s++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][s] = (num[<span class="number">0</span>] == s ? <span class="literal">true</span> : <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// process all subsets for all sums</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt;= sum / <span class="number">2</span>; s++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[i - <span class="number">1</span>][s]) &#123;</span><br><span class="line">                    dp[i][s] = dp[i - <span class="number">1</span>][s];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s &gt;= num[i]) &#123;</span><br><span class="line">                    dp[i][s] = dp[i - <span class="number">1</span>][s - num[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum1 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// find the lagest index in the last row which is true</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = sum / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[n - <span class="number">1</span>][i] == <span class="literal">true</span>) &#123;</span><br><span class="line">                sum1 = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum2 = sum - sum1;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(sum2 - sum1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">canPartitionRecursive</span><span class="params">(vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; dp,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; num,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">int</span> currentIndex,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">int</span> sum1,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">int</span> sum2)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; num = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    cout &lt;&lt; PartitionSet::<span class="built_in">canPartition</span>(num) &lt;&lt; endl;</span><br><span class="line">    num = vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; PartitionSet::<span class="built_in">canPartition</span>(num) &lt;&lt; endl;</span><br><span class="line">    num = vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">100</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    cout &lt;&lt; PartitionSet::<span class="built_in">canPartition</span>(num) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Time-and-Space-complexity-8"><a href="#Time-and-Space-complexity-8" class="headerlink" title="Time and Space complexity"></a>Time and Space complexity</h4><p>The above solution has the time and space complexity of <strong><em>O(N\</em>S)*</strong>, where ‘N’ represents total numbers and ‘S’ is the total sum of all the numbers.</p><h2 id="Problem-Challenge-1"><a href="#Problem-Challenge-1" class="headerlink" title="Problem Challenge 1"></a>Problem Challenge 1</h2><h3 id="Count-of-Subset-Sum-hard"><a href="#Count-of-Subset-Sum-hard" class="headerlink" title="Count of Subset Sum (hard)"></a>Count of Subset Sum (hard)</h3><p>Given a set of positive numbers, find the total number of subsets whose sum is equal to a given number ‘S’.</p><p><strong>Example 1:</strong> </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, S=<span class="number">4</span></span><br><span class="line"><span class="attribute">Output</span>: <span class="number">3</span></span><br><span class="line"><span class="attribute">The</span> given set has &#x27;<span class="number">3</span>&#x27; subsets whose sum is &#x27;<span class="number">4</span>&#x27;: &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">1</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="attribute">Note</span> that we have two similar sets &#123;<span class="number">1</span>, <span class="number">3</span>&#125;, because we have two &#x27;<span class="number">1</span>&#x27; in our input.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>&#125;, S=<span class="number">9</span></span><br><span class="line"><span class="attribute">Output</span>: <span class="number">3</span></span><br><span class="line"><span class="attribute">The</span> given set has &#x27;<span class="number">3</span>&#x27; subsets whose sum is &#x27;<span class="number">9</span>&#x27;: &#123;<span class="number">2</span>, <span class="number">7</span>&#125;, &#123;<span class="number">1</span>, <span class="number">7</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-1"><a href="#Try-it-yourself-1" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><p><strong>普通递归</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubsetSum</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countSubsets</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">countSubsetsRecursive</span>(num, <span class="number">0</span>, <span class="number">0</span>, sum, count);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countSubsetsRecursive</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; num,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">int</span> curSum,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">int</span> index,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">int</span> sum,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">int</span>&amp; count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (curSum == sum) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curSum &gt; sum) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (index == num.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">countSubsetsRecursive</span>(num, curSum + num[index], index + <span class="number">1</span>, sum,</span><br><span class="line">                                  count);</span><br><span class="line">            <span class="built_in">countSubsetsRecursive</span>(num, curSum, index + <span class="number">1</span>, sum, count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; num = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    cout &lt;&lt; SubsetSum::<span class="built_in">countSubsets</span>(num, <span class="number">4</span>) &lt;&lt; endl;</span><br><span class="line">    num = vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; SubsetSum::<span class="built_in">countSubsets</span>(num, <span class="number">9</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Basic-Solution-4"><a href="#Basic-Solution-4" class="headerlink" title="Basic Solution"></a>Basic Solution</h3><p>This problem follows the <strong>0/1 Knapsack pattern</strong> and is quite similar to <em>Subset Sum</em>. The only difference in this problem is that we need to count the number of subsets, whereas in <em>Subset Sum</em> we only wanted to know if a subset with the given sum existed.</p><p>A basic brute-force solution could be to try all subsets of the given numbers to count the subsets that have a sum equal to ‘S’. So our brute-force algorithm will look like:</p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/5_1.png"></p><h4 id="Code-10"><a href="#Code-10" class="headerlink" title="Code"></a>Code</h4><p>Here is the code for the brute-force solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubsetSum</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countSubsets</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">countSubsetsRecursive</span>(num, sum, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countSubsetsRecursive</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; num,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">int</span> sum,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (num.<span class="built_in">empty</span>() || currentIndex &gt;= num.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// recursive call after selecting the number at the currentIndex</span></span><br><span class="line">        <span class="comment">// if the number at currentIndex exceeds the sum. we shouldn&#x27;t process</span></span><br><span class="line">        <span class="comment">// this</span></span><br><span class="line">        <span class="keyword">int</span> sum1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (num[currentIndex] &lt;= sum) &#123;</span><br><span class="line">            sum1 = <span class="built_in">countSubsetsRecursive</span>(num, sum - num[currentIndex],</span><br><span class="line">                                         currentIndex + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum2 = <span class="built_in">countSubsetsRecursive</span>(num, sum, currentIndex + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum1 + sum2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; num = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    cout &lt;&lt; SubsetSum::<span class="built_in">countSubsets</span>(num, <span class="number">4</span>) &lt;&lt; endl;</span><br><span class="line">    num = vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; SubsetSum::<span class="built_in">countSubsets</span>(num, <span class="number">9</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Time-and-Space-complexity-9"><a href="#Time-and-Space-complexity-9" class="headerlink" title="Time and Space complexity"></a>Time and Space complexity</h4><p>The time complexity of the above algorithm is exponential <strong><em>O(2^n)</em></strong>, where ‘n’ represents the total number. The space complexity is <strong><em>O(n)</em></strong>, this memory is used to store the recursion stack.</p><h3 id="Top-down-Dynamic-Programming-with-Memoization-3"><a href="#Top-down-Dynamic-Programming-with-Memoization-3" class="headerlink" title="Top-down Dynamic Programming with Memoization"></a>Top-down Dynamic Programming with Memoization</h3><p>We can use memoization to overcome the overlapping sub-problems. We will be using a two-dimensional array to store the results of solved sub-problems. As mentioned above, we need to store results for every subset and for every possible sum.</p><h4 id="Code-11"><a href="#Code-11" class="headerlink" title="Code"></a>Code</h4><p>Here is the code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubsetSum</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countSubsets</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(num.<span class="built_in">size</span>(),</span><br><span class="line">                               vector&lt;<span class="keyword">int</span>&gt;(sum + <span class="number">1</span>, <span class="number">-1</span>));  <span class="comment">// 注意这里是sum + 1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">countSubsetsRecursive</span>(dp, num, sum, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countSubsetsRecursive</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; dp,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     vector&lt;<span class="keyword">int</span>&gt; num,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">int</span> sum,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (num.<span class="built_in">empty</span>() || currentIndex &gt;= num.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[currentIndex][sum] == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// recursive call after selecting the number at the currentIndex</span></span><br><span class="line">            <span class="comment">// if the number at currentIndex exceeds the sum. we shouldn&#x27;t</span></span><br><span class="line">            <span class="comment">// process this</span></span><br><span class="line">            <span class="keyword">int</span> sum1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (num[currentIndex] &lt;= sum) &#123;</span><br><span class="line">                sum1 = <span class="built_in">countSubsetsRecursive</span>(dp, num, sum - num[currentIndex],</span><br><span class="line">                                             currentIndex + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> sum2 = <span class="built_in">countSubsetsRecursive</span>(dp, num, sum, currentIndex + <span class="number">1</span>);</span><br><span class="line">            dp[currentIndex][sum] = sum1 + sum2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[currentIndex][sum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; num = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    cout &lt;&lt; SubsetSum::<span class="built_in">countSubsets</span>(num, <span class="number">4</span>) &lt;&lt; endl;</span><br><span class="line">    num = vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; SubsetSum::<span class="built_in">countSubsets</span>(num, <span class="number">9</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bottom-up-Dynamic-Programming-4"><a href="#Bottom-up-Dynamic-Programming-4" class="headerlink" title="Bottom-up Dynamic Programming"></a>Bottom-up Dynamic Programming</h3><p>We will try to find if we can make all possible sums with every subset to populate the array <code>db[TotalNumbers][S+1</code>].</p><p>So, at every step we have two options:</p><ol><li>Exclude the number. Count all the subsets without the given number up to the given sum =&gt; <code>dp[index-1][sum]</code></li><li>Include the number if its value is not more than the ‘sum’. In this case, we will count all the subsets to get the remaining sum =&gt; <code>dp[index-1][sum-num[index]]</code></li></ol><p>To find the total sets, we will add both of the above two values:</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="keyword">index</span>][<span class="keyword">sum</span>] = dp[<span class="keyword">index</span><span class="number">-1</span>][<span class="keyword">sum</span>] + dp[<span class="keyword">index</span><span class="number">-1</span>][<span class="keyword">sum</span>-num[<span class="keyword">index</span>]])</span><br></pre></td></tr></table></figure><p>Let’s start with our base case of size zero:</p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/5_2.png"></p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/5_3.png"></p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/5_4.png"></p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/5_5.png"></p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/5_6.png"></p><p><img src="/16-pattern-0-or-1-knapsack-dynamic-programming/index/5_7.png"></p><h4 id="Code-12"><a href="#Code-12" class="headerlink" title="Code"></a>Code</h4><p>Here is the code for our bottom-up dynamic programming approach:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubsetSum</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countSubsets</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = num.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n, vector&lt;<span class="keyword">int</span>&gt;(sum + <span class="number">1</span>, <span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// populate the sum=0 columns, as we will always have an empty set for</span></span><br><span class="line">        <span class="comment">// zero sum</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算第一行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sum; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = (num[<span class="number">0</span>] == i ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// process all aubsets for all sums</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt;= sum; s++) &#123;</span><br><span class="line">                <span class="comment">// exclude the number</span></span><br><span class="line">                dp[i][s] = dp[i - <span class="number">1</span>][s];</span><br><span class="line">                <span class="comment">// include the number, if it does not exceed the sum</span></span><br><span class="line">                <span class="keyword">if</span> (s &gt;= num[i]) &#123;</span><br><span class="line">                    dp[i][s] += dp[i - <span class="number">1</span>][s - num[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][sum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; num = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    cout &lt;&lt; SubsetSum::<span class="built_in">countSubsets</span>(num, <span class="number">4</span>) &lt;&lt; endl;</span><br><span class="line">    num = vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; SubsetSum::<span class="built_in">countSubsets</span>(num, <span class="number">9</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Time-and-Space-complexity-10"><a href="#Time-and-Space-complexity-10" class="headerlink" title="Time and Space complexity"></a>Time and Space complexity</h4><p>The above solution has the time and space complexity of <strong><em>O(N\</em>S)*</strong>, where ‘N’ represents total numbers and ‘S’ is the desired sum.</p><h3 id="Challenge-2"><a href="#Challenge-2" class="headerlink" title="Challenge"></a>Challenge</h3><p>Can we improve our bottom-up DP solution even further? Can you find an algorithm that has <strong><em>O(S)</em></strong> space complexity?</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubsetSum</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countSubsets</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = num.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(sum + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sum; i++) &#123;</span><br><span class="line">            dp[i] = (num[<span class="number">0</span>] == i ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// process all aubsets for all sums</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s = sum; s &gt;= <span class="number">0</span>; s--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s &gt;= num[i]) &#123;</span><br><span class="line">                    dp[s] += dp[s - num[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[sum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; num = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    cout &lt;&lt; SubsetSum::<span class="built_in">countSubsets</span>(num, <span class="number">4</span>) &lt;&lt; endl;</span><br><span class="line">    num = vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; SubsetSum::<span class="built_in">countSubsets</span>(num, <span class="number">9</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-Challenge-2"><a href="#Problem-Challenge-2" class="headerlink" title="Problem Challenge 2"></a>Problem Challenge 2</h2><h3 id="Target-Sum-hard"><a href="#Target-Sum-hard" class="headerlink" title="Target Sum (hard)"></a>Target Sum (hard)</h3><p>You are given a set of positive numbers and a target sum ‘S’. Each number should be assigned either a ‘+’ or ‘-’ sign. We need to find the total ways to assign symbols to make the sum of the numbers equal to the target ‘S’.</p><p><strong>Example 1:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, S=<span class="number">1</span></span><br><span class="line"><span class="attribute">Output</span>: <span class="number">3</span></span><br><span class="line"><span class="attribute">Explanation</span>: The given set has &#x27;<span class="number">3</span>&#x27; ways to make a sum of &#x27;<span class="number">1</span>&#x27;: &#123;+<span class="number">1</span>-<span class="number">1</span>-<span class="number">2</span>+<span class="number">3</span>&#125; &amp; &#123;-<span class="number">1</span>+<span class="number">1</span>-<span class="number">2</span>+<span class="number">3</span>&#125; &amp; &#123;+<span class="number">1</span>+<span class="number">1</span>+<span class="number">2</span>-<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>&#125;, S=<span class="number">9</span></span><br><span class="line"><span class="attribute">Output</span>: <span class="number">2</span></span><br><span class="line"><span class="attribute">Explanation</span>: The given set has &#x27;<span class="number">2</span>&#x27; ways to make a sum of &#x27;<span class="number">9</span>&#x27;: &#123;+<span class="number">1</span>+<span class="number">2</span>+<span class="number">7</span>-<span class="number">1</span>&#125; &amp; &#123;-<span class="number">1</span>+<span class="number">2</span>+<span class="number">7</span>+<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-2"><a href="#Try-it-yourself-2" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看解答，和解答的思路不一样</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TargetSum</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findTargetSubsets</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(num)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findTargetSubsetsRecursive</span>(nums, s, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findTargetSubsetsRecursive</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; num, <span class="keyword">int</span> sum, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == <span class="number">0</span> &amp;&amp; index == num.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; num.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findTargetSubsetsRecursive</span>(num, sum - num[index], index + <span class="number">1</span>) +</span><br><span class="line">               <span class="built_in">findTargetSubsetsRecursive</span>(num, sum + num[index], index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; num = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    cout &lt;&lt; TargetSum::<span class="built_in">findTargetSubsets</span>(num, <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    num = vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    cout &lt;&lt; TargetSum::<span class="built_in">findTargetSubsets</span>(num, <span class="number">9</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <strong>0/1 Knapsack pattern</strong> and can be converted into <em>Count of Subset Sum</em>. Let’s dig into this.</p><p>We are asked to find two subsets of the given numbers whose difference is equal to the given target ‘S’. Take the first example above. As we saw, one solution is {+1-1-2+3}. So, the two subsets we are asked to find are {1, 3} &amp; {1, 2} because,</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(1 + 3)</span> - <span class="comment">(1 + 2 )</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>Now, let’s say ‘Sum(s1)’ denotes the total sum of set ‘s1’, and ‘Sum(s2)’ denotes the total sum of set ‘s2’. So the required equation is:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="constructor">Sum(<span class="params">s1</span>)</span> - <span class="constructor">Sum(<span class="params">s2</span>)</span> = S</span><br></pre></td></tr></table></figure><p>This equation can be reduced to the subset sum problem. Let’s assume that ‘Sum(num)’ denotes the total sum of all the numbers, therefore:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="constructor">Sum(<span class="params">s1</span>)</span> + <span class="constructor">Sum(<span class="params">s2</span>)</span> = <span class="constructor">Sum(<span class="params">num</span>)</span></span><br></pre></td></tr></table></figure><p>Let’s add the above two equations:</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">=&gt; <span class="built_in">Sum</span>(<span class="symbol">s1</span>) - <span class="built_in">Sum</span>(<span class="symbol">s2</span>) + <span class="built_in">Sum</span>(<span class="symbol">s1</span>) + <span class="built_in">Sum</span>(<span class="symbol">s2</span>) = S + <span class="built_in">Sum</span>(num)</span><br><span class="line">=&gt; <span class="number">2</span> * <span class="built_in">Sum</span>(<span class="symbol">s1</span>) =  S + <span class="built_in">Sum</span>(num)</span><br><span class="line">=&gt; <span class="built_in">Sum</span>(<span class="symbol">s1</span>) = (S + <span class="built_in">Sum</span>(num)) / <span class="number">2</span></span><br></pre></td></tr></table></figure><p>Which means that one of the set ‘s1’ has a sum equal to <code>(S + Sum(num)) / 2</code>. This essentially converts our problem to: “Find the count of subsets of the given numbers whose sum is equal to <code>(S + Sum(num)) / 2</code>“</p><h4 id="Code-13"><a href="#Code-13" class="headerlink" title="Code"></a>Code</h4><p>Let’s take the dynamic programming code of <em>Count of Subset Sum</em> and extend it to solve this problem:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TargetSum</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findTargetSubsets</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> n : num) &#123;</span><br><span class="line">            totalSum += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if &#x27;s + totalSum&#x27; is odd, we cant find a subset with sum equal to &#x27;(s</span></span><br><span class="line">        <span class="comment">// + totalSum) / 2&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> (totalSum &lt; s || (s + totalSum) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">countSubsets</span>(num, (s + totalSum) / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countSubsets</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = num.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n, vector&lt;<span class="keyword">int</span>&gt;(sum + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算sum = 0的列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算第一行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; sum; s++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][s] = (num[<span class="number">0</span>] == s ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// process all subsets for all sum</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt;= sum; s++) &#123;</span><br><span class="line">                dp[i][s] = dp[i - <span class="number">1</span>][s];</span><br><span class="line">                <span class="keyword">if</span> (s &gt;= num[i]) &#123;</span><br><span class="line">                    dp[i][s] += dp[i - <span class="number">1</span>][s - num[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[num.<span class="built_in">size</span>() - <span class="number">1</span>][sum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; num = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    cout &lt;&lt; TargetSum::<span class="built_in">findTargetSubsets</span>(num, <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    num = vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    cout &lt;&lt; TargetSum::<span class="built_in">findTargetSubsets</span>(num, <span class="number">9</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Time-and-Space-complexity-11"><a href="#Time-and-Space-complexity-11" class="headerlink" title="Time and Space complexity"></a>Time and Space complexity</h4><p>The above solution has time and space complexity of <strong><em>O(N</em>S)*</strong>, where ‘N’ represents total numbers and ‘S’ is the desired sum.</p><p>We can further improve the solution to use only <strong><em>O(S)</em></strong> space.</p><h3 id="Space-Optimized-Solution"><a href="#Space-Optimized-Solution" class="headerlink" title="Space Optimized Solution"></a>Space Optimized Solution</h3><p>Here is the code for the space-optimized solution, using only a single array:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TargetSum</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findTargetSubsets</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> n : num) &#123;</span><br><span class="line">            totalSum += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if &#x27;s + totalSum&#x27; is odd, we cant find a subset with sum equal to &#x27;(s</span></span><br><span class="line">        <span class="comment">// + totalSum) / 2&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> (totalSum &lt; s || (s + totalSum) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">countSubsets</span>(num, (s + totalSum) / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countSubsets</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = num.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(sum + <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算第一行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; sum; s++) &#123;</span><br><span class="line">            dp[s] = (num[<span class="number">0</span>] == s ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// process all subsets for all sum</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s = sum; s &gt; <span class="number">0</span>; s--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s &gt;= num[i]) &#123;</span><br><span class="line">                    dp[s] += dp[s - num[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[sum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; num = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    cout &lt;&lt; TargetSum::<span class="built_in">findTargetSubsets</span>(num, <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    num = vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    cout &lt;&lt; TargetSum::<span class="built_in">findTargetSubsets</span>(num, <span class="number">9</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>15. Pattern K-way merge</title>
      <link href="/15-pattern-k-way-merge/index.html"/>
      <url>/15-pattern-k-way-merge/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>This pattern helps us solve problems that involve a list of sorted arrays.</p><p>Whenever we are given ‘K’ sorted arrays, we can use a <strong>Heap</strong> to efficiently perform a sorted traversal of all the elements of all arrays. We can push the smallest (first) element of each sorted array in a <strong>Min Heap</strong> to get the overall minimum. While inserting elements to the <strong>Min Heap</strong> we keep track of which array the element came from. We can, then, remove the top element from the heap to get the smallest element and push the next element from the same array, to which this smallest element belonged, to the heap. We can repeat this process to make a sorted traversal of all elements.</p><p>Let’s see this pattern in action.</p><h2 id="Merge-K-Sorted-Lists-medium"><a href="#Merge-K-Sorted-Lists-medium" class="headerlink" title="Merge K Sorted Lists (medium)"></a>Merge K Sorted Lists (medium)</h2><p>leetcode 23 </p><h3 id="Problem-Statemen"><a href="#Problem-Statemen" class="headerlink" title="Problem Statemen"></a>Problem Statemen</h3><p>Given an array of ‘K’ sorted LinkedLists, merge them into one sorted list.</p><p><strong>Example 1:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: L<span class="number">1</span>=[<span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>], L<span class="number">2</span>=[<span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>], L<span class="number">3</span>=[<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="attribute">Output</span>:<span class="meta"> [1, 2, 3, 3, 4, 6, 6, 7, 8]</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: L<span class="number">1</span>=[<span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>], L<span class="number">2</span>=[<span class="number">1</span>, <span class="number">7</span>]</span><br><span class="line"><span class="attribute">Output</span>:<span class="meta"> [1, 5, 7, 8, 9]</span></span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself"><a href="#Try-it-yourself" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 想到的是brute force</span></span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>A <strong>brute force</strong> solution could be to add all elements of the given ‘K’ lists to one list and sort it. If there are a total of ‘N’ elements in all the input lists, then the brute force solution will have a time complexity of <strong><em>O(N</em>logN)*</strong> as we will need to sort the merged list. Can we do better than this? How can we utilize the fact that the input lists are individually sorted?</p><p>If we have to find the smallest element of all the input lists, we have to compare only the smallest (i.e. the first) element of all the lists. Once we have the smallest element, we can put it in the merged list. Following a similar pattern, we can then find the next smallest element of all the lists to add it to the merged list.</p><p>The best data structure that comes to mind to find the smallest number among a set of ‘K’ numbers is a <strong><a href="https://en.wikipedia.org/wiki/Heap_(data_structure">Heap</a>)</strong>. Let’s see how can we use a heap to find a better algorithm.</p><ol><li>We can insert the first element of each array in a <strong>Min Heap</strong>.</li><li>After this, we can take out the smallest (top) element from the heap and add it to the merged list.</li><li>After removing the smallest element from the heap, we can insert the next element of the same list into the heap.</li><li>We can repeat steps 2 and 3 to populate the merged list in sorted order.</li></ol><p>Let’s take the Example-1 mentioned above to go through each step of our algorithm:</p><p>Given lists: <code>L1=[2, 6, 8]</code>, <code>L2=[3, 6, 7]</code>,<code>L3=[1, 3, 4]</code></p><ol><li>After inserting the 1st element of each list, the heap will have the following elements:</li></ol><p>​    <img src="/15-pattern-k-way-merge/index/1.png"></p><ol><li>We’ll take the top number from the heap, insert it into the merged list and add the next number in the heap.</li></ol><p>​    <img src="/15-pattern-k-way-merge/index/2.png"></p><ol><li><p>Again, we’ll take the top element of the heap, insert it into the merged list and add the next number to the heap.</p><p><img src="/15-pattern-k-way-merge/index/3.png"></p></li><li><p>Repeating the above step, take the top element of the heap, insert it into the merged list and add the next number to the heap. As there are two 3s in the heap, we can pick anyone but we need to take the next element from the corresponding list to insert in the heap.</p><p><img src="/15-pattern-k-way-merge/index/4.png"></p></li></ol><p>We’ll repeat the above step to populate our merged array.</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span>  self.value &lt; other.value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_lists</span>(<span class="params">lists</span>):</span></span><br><span class="line">    min_heap = []</span><br><span class="line">    <span class="keyword">for</span> root <span class="keyword">in</span> lists:</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            <span class="comment"># 这里pycharm可以自动根据root的值排序，但是leetcode不行，所以这种写法不能过leetcode</span></span><br><span class="line">            heappush(min_heap, root)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># take the smallest(top)element form the min-heap and add it to the result</span></span><br><span class="line">    <span class="comment"># if the top element has a next element add it to the heap</span></span><br><span class="line">    result_head, result_tail = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> min_heap:</span><br><span class="line">        node = heappop(min_heap)</span><br><span class="line">        <span class="keyword">if</span> result_head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            result_head = result_tail = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result_tail.<span class="built_in">next</span> = node</span><br><span class="line">            result_tail = result_tail.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> node.<span class="built_in">next</span>:</span><br><span class="line">            heappush(min_heap, node.<span class="built_in">next</span>)</span><br><span class="line">    <span class="keyword">return</span> result_head</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    l1 = ListNode(<span class="number">2</span>)</span><br><span class="line">    l1.<span class="built_in">next</span> = ListNode(<span class="number">6</span>)</span><br><span class="line">    l1.<span class="built_in">next</span>.<span class="built_in">next</span> = ListNode(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    l2 = ListNode(<span class="number">3</span>)</span><br><span class="line">    l2.<span class="built_in">next</span> = ListNode(<span class="number">6</span>)</span><br><span class="line">    l2.<span class="built_in">next</span>.<span class="built_in">next</span> = ListNode(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">    l3 = ListNode(<span class="number">1</span>)</span><br><span class="line">    l3.<span class="built_in">next</span> = ListNode(<span class="number">3</span>)</span><br><span class="line">    l3.<span class="built_in">next</span>.<span class="built_in">next</span> = ListNode(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    result = merge_lists([l1, l2, l3])</span><br><span class="line">    <span class="keyword">while</span> result:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">str</span>(result.value), end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        result = result.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"><span class="comment">#=====================================leetcode==========================================</span></span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.value &lt; other.value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_lists</span>(<span class="params">lists</span>):</span></span><br><span class="line">    min_heap = []</span><br><span class="line">    <span class="keyword">for</span> root <span class="keyword">in</span> lists:</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            heappush(min_heap, (root.value, root))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># take the smallest(top)element form the min-heap and add it to the result</span></span><br><span class="line">    <span class="comment"># if the top element has a next element add it to the heap</span></span><br><span class="line">    result_head, result_tail = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> min_heap:</span><br><span class="line">        node = heappop(min_heap)[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> result_head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            result_head = result_tail = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result_tail.<span class="built_in">next</span> = node</span><br><span class="line">            result_tail = result_tail.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> node.<span class="built_in">next</span>:</span><br><span class="line">            heappush(min_heap, (node.<span class="built_in">next</span>.value, node.<span class="built_in">next</span>))</span><br><span class="line">    <span class="keyword">return</span> result_head</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    l1 = ListNode(<span class="number">1</span>)</span><br><span class="line">    l1.<span class="built_in">next</span> = ListNode(<span class="number">4</span>)</span><br><span class="line">    l1.<span class="built_in">next</span>.<span class="built_in">next</span> = ListNode(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    l2 = ListNode(<span class="number">1</span>)</span><br><span class="line">    l2.<span class="built_in">next</span> = ListNode(<span class="number">3</span>)</span><br><span class="line">    l2.<span class="built_in">next</span>.<span class="built_in">next</span> = ListNode(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    l3 = ListNode(<span class="number">2</span>)</span><br><span class="line">    l3.<span class="built_in">next</span> = ListNode(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">    result = merge_lists([l1, l2, l3])</span><br><span class="line">    <span class="keyword">while</span> result:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">str</span>(result.value), end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        result = result.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity"><a href="#Time-complexity" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>Since we’ll be going through all the elements of all arrays and will be removing/adding one element to the heap in each step, the time complexity of the above algorithm will be <strong><em>O(N\</em>logK)*</strong>, where ‘N’ is the total number of elements in all the ‘K’ input arrays.</p><h4 id="Space-complexity"><a href="#Space-complexity" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity will be <strong><em>O(K)</em></strong> because, at any time, our min-heap will be storing one number from all the ‘K’ input arrays.</p><h2 id="Kth-Smallest-Number-in-M-Sorted-Lists-Medium"><a href="#Kth-Smallest-Number-in-M-Sorted-Lists-Medium" class="headerlink" title="Kth Smallest Number in M Sorted Lists (Medium)"></a>Kth Smallest Number in M Sorted Lists (Medium)</h2><p>leetcode 378</p><h3 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given ‘M’ sorted arrays, find the K’th smallest number among all the arrays.</p><p><strong>Example 1:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: L<span class="number">1</span>=[<span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>], L<span class="number">2</span>=[<span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>], L<span class="number">3</span>=[<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>], K=<span class="number">5</span></span><br><span class="line"><span class="attribute">Output</span>: <span class="number">4</span></span><br><span class="line"><span class="attribute">Explanation</span>: The <span class="number">5</span>th smallest number among <span class="literal">all</span> the arrays is <span class="number">4</span>, this can be verified from the merged </span><br><span class="line"><span class="attribute">list</span> of <span class="literal">all</span> the arrays:<span class="meta"> [1, 2, 3, 3, 4, 6, 6, 7, 8]</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: L<span class="number">1</span>=[<span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>], L<span class="number">2</span>=[<span class="number">1</span>, <span class="number">7</span>], K=<span class="number">3</span></span><br><span class="line"><span class="attribute">Output</span>: <span class="number">7</span></span><br><span class="line"><span class="attribute">Explanation</span>: The <span class="number">3</span>rd smallest number among <span class="literal">all</span> the arrays is <span class="number">7</span>.</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-1"><a href="#Try-it-yourself-1" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个也能过leetcode</span></span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_kth_smallest</span>(<span class="params">lists, k</span>):</span></span><br><span class="line">    <span class="comment"># 注意，这里和之前不一样，这里应该使用的是minheap,如果还是max_heap，那就相当于每个数组都要全部遍历，这样的时间复杂度会上去</span></span><br><span class="line">    min_heap = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lists)):</span><br><span class="line">        heappush(min_heap, (lists[i][<span class="number">0</span>], i, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> min_heap <span class="keyword">and</span> k:</span><br><span class="line">        num, list_index, index = heappop(min_heap)</span><br><span class="line">        k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        <span class="keyword">if</span> index != <span class="built_in">len</span>(lists[list_index]) - <span class="number">1</span>:</span><br><span class="line">            heappush(min_heap, (lists[list_index][index + <span class="number">1</span>], list_index, index + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = find_kth_smallest([[<span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>], [<span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>], [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]], <span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = find_kth_smallest([[<span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">1</span>, <span class="number">7</span>]], <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <strong>K-way merge</strong> pattern and we can follow a similar approach as discussed in <em>Merge K Sorted Lists</em>.</p><p>We can start merging all the arrays, but instead of inserting numbers into a merged list, we will keep count to see how many elements have been inserted in the merged list. Once that count is equal to ‘K’, we have found our required number.</p><p>A big difference from <em>Merge K Sorted Lists</em> is that in this problem, the input is a list of arrays compared to LinkedLists. This means that when we want to push the next number in the heap we need to know what the index of the current number in the current array was. To handle this, we will need to keep track of the array and the element indices.</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># solution这样写也没有问题</span></span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_kth_smallest</span>(<span class="params">lists, k</span>):</span></span><br><span class="line">    <span class="comment"># 注意，这里和之前不一样，这里应该使用的是minheap,如果还是max_heap，那就相当于每个数组都要全部遍历，这样的时间复杂度会上去</span></span><br><span class="line">    min_heap = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lists)):</span><br><span class="line">        heappush(min_heap, (lists[i][<span class="number">0</span>], lists[i], <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    num_count, num = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> min_heap <span class="keyword">and</span> k:</span><br><span class="line">        num, llist, index = heappop(min_heap)</span><br><span class="line">        num_count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> num_count == k:</span><br><span class="line">            <span class="comment"># 当然，这里也可以直接return num,在while循环外面的return num改成return 0也可以（参考上面我的写法）</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> index != <span class="built_in">len</span>(llist) - <span class="number">1</span>:</span><br><span class="line">            heappush(min_heap, (llist[index + <span class="number">1</span>], llist, index + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = find_kth_smallest([[<span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>], [<span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>], [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]], <span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = find_kth_smallest([[<span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">1</span>, <span class="number">7</span>]], <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-1"><a href="#Time-complexity-1" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>Since we’ll be going through at most ‘K’ elements among all the arrays, and we will remove/add one element in the heap in each step, the time complexity of the above algorithm will be O(K<em>logM)</em>O<em>(</em>K<em>∗</em>l<strong>o</strong>g<em>*M</em>) where ‘M’ is the total number of input arrays.</p><h4 id="Space-complexity-1"><a href="#Space-complexity-1" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity will be O(M)<em>O</em>(<em>M</em>) because, at any time, our min-heap will be storing one number from all the ‘M’ input arrays.</p><hr><h3 id="Similar-Problems"><a href="#Similar-Problems" class="headerlink" title="Similar Problems"></a>Similar Problems</h3><p><strong>Problem 1:</strong> Given ‘M’ sorted arrays, find the median number among all arrays.</p><p><strong>Solution:</strong> This problem is similar to our parent problem with K=Median. So if there are ‘N’ total numbers in all the arrays we need to find the K’th minimum number where <strong><em>K=N/2</em></strong>.</p><p><strong>Problem 2:</strong> Given a list of ‘K’ sorted arrays, merge them into one sorted list.</p><p><strong>Solution:</strong> This problem is similar to <em>Merge K Sorted Lists</em> except that the input is a list of arrays compared to <strong>LinkedLists</strong>. To handle this, we can use a similar approach as discussed in our parent problem by keeping a track of the array and the element indices.</p><h2 id="Kth-Smallest-Number-in-a-Sorted-Matrix-Hard"><a href="#Kth-Smallest-Number-in-a-Sorted-Matrix-Hard" class="headerlink" title="#Kth Smallest Number in a Sorted Matrix (Hard)"></a>#Kth Smallest Number in a Sorted Matrix (Hard)</h2><p>leetcode 378 和上一题一样</p><h3 id="Problem-Statement-1"><a href="#Problem-Statement-1" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given an <em>N\</em> N<em> matrix where <em>*each row and column</em></em> is sorted in ascending order, find the Kth smallest element in the matrix.</p><p><strong>Example 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: Matrix=<span class="comment">[</span></span><br><span class="line"><span class="comment">    <span class="comment">[2, 6, 8]</span>, </span></span><br><span class="line"><span class="comment">    <span class="comment">[3, 7, 10]</span>,</span></span><br><span class="line"><span class="comment">    <span class="comment">[5, 8, 11]</span></span></span><br><span class="line"><span class="comment">  ]</span>, </span><br><span class="line">  K=5</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: The 5th smallest number in the matrix <span class="keyword">is</span> 7.</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-2"><a href="#Try-it-yourself-2" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和上面一道题一摸一样</span></span><br></pre></td></tr></table></figure><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <strong>K-way merge</strong> pattern and can be easily converted to <em>Kth Smallest Number in M Sorted Lists</em>. As each row (or column) of the given matrix can be seen as a sorted list, we essentially need to find the Kth smallest number in ‘N’ sorted lists.</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和上面一道题一摸一样</span></span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_kth_smallest_in_sorted_matrix</span>(<span class="params">matrix, k</span>):</span></span><br><span class="line">    <span class="comment"># 注意，这里和之前不一样，这里应该使用的是minheap,如果还是max_heap，那就相当于每个数组都要全部遍历，这样的时间复杂度会上去</span></span><br><span class="line">    min_heap = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix)):</span><br><span class="line">        heappush(min_heap, (matrix[i][<span class="number">0</span>], matrix[i], <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    num_count, num = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> min_heap <span class="keyword">and</span> k:</span><br><span class="line">        num, llist, index = heappop(min_heap)</span><br><span class="line">        num_count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> num_count == k:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> index != <span class="built_in">len</span>(llist) - <span class="number">1</span>:</span><br><span class="line">            heappush(min_heap, (llist[index + <span class="number">1</span>], llist, index + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = find_kth_smallest_in_sorted_matrix([[<span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>], [<span class="number">3</span>, <span class="number">7</span>, <span class="number">10</span>], [<span class="number">5</span>, <span class="number">8</span>, <span class="number">11</span>]], <span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-2"><a href="#Time-complexity-2" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>First, we inserted at most ‘K’ or one element from each of the ‘N’ rows, which will take <strong><em>O(min(K, N))</em></strong>. Then we went through at most ‘K’ elements in the matrix and remove/add one element in the heap in each step. As we can’t have more than ‘N’ elements in the heap in any condition, therefore, the overall time complexity of the above algorithm will be <strong><em>O(min(K, N) + K\</em>logN)*</strong>.</p><h4 id="Space-complexity-2"><a href="#Space-complexity-2" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity will be <strong><em>O(N)</em></strong> because, in the worst case, our min-heap will be storing one number from each of the ‘N’ rows.</p><h3 id="An-Alternate-Solution"><a href="#An-Alternate-Solution" class="headerlink" title="An Alternate Solution"></a>An Alternate Solution</h3><p>Since each row and column of the matrix is sorted, is it possible to use <strong>Binary Search</strong> to find the Kth smallest number?</p><p>The biggest problem to use <strong>Binary Search</strong>, in this case, is that we don’t have a straightforward sorted array, instead, we have a matrix. As we remember, in <strong>Binary Search</strong>, we calculate the middle index of the search space (‘1’ to ‘N’) and see if our required number is pointed out by the middle index; if not we either search in the lower half or the upper half. In a sorted matrix, we can’t really find a middle. Even if we do consider some index as middle, it is not straightforward to find the search space containing numbers bigger or smaller than the number pointed out by the middle index.</p><p>An alternative could be to apply the <strong>Binary Search</strong> on the “number range” instead of the “index range”. As we know that the smallest number of our matrix is at the top left corner and the biggest number is at the bottom right corner. These two numbers can represent the “range” i.e., the <code>start</code> and the <code>end</code> for the <strong>Binary Search</strong>. Here is how our algorithm will work:</p><ol><li>Start the <strong>Binary Search</strong> with <code>start = matrix[0][0]</code> and <code>end = matrix[n-1][n-1]</code>.</li><li>Find <code>middle</code> of the <code>start</code> and the <code>end</code>. This <code>middle</code> number is NOT necessarily an element in the matrix.</li><li>Count all the numbers smaller than or equal to <code>middle</code> in the matrix. As the matrix is sorted, we can do this in O(N).</li><li>While counting, we can keep track of the “smallest number greater than the <code>middle</code>” (let’s call it <code>n1</code>) and at the same time the “biggest number less than or equal to the <code>middle</code>” (let’s call it <code>n2</code>). These two numbers will be used to adjust the “number range” for the <strong>Binary Search</strong> in the next iteration.</li><li>If the count is equal to ‘K’, <code>n1</code> will be our required number as it is the “biggest number less than or equal to the <code>middle</code>”, and is definitely present in the matrix.</li><li>If the count is less than ‘K’, we can update <code>start = n2</code> to search in the higher part of the matrix and if the count is greater than ‘K’, we can update <code>end = n1</code> to search in the lower part of the matrix in the next iteration.</li></ol><p>Here is the visual representation of our algorithm:</p><p><img src="/15-pattern-k-way-merge/index/5.png"></p><p><img src="/15-pattern-k-way-merge/index/6.png"></p><p><img src="/15-pattern-k-way-merge/index/7.png"></p><p>Here is what our algorithm will look like:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">from heapq <span class="keyword">import</span> *</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">find_kth_smallest_in_sorted_matrix</span><span class="params">(matrix, k)</span>:</span></span><br><span class="line"><span class="function">    n =</span> <span class="built_in">len</span>(matrix)</span><br><span class="line">    start, end = matrix[<span class="number">0</span>][<span class="number">0</span>], matrix[n - <span class="number">1</span>][n - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">while</span> start &lt;= end:</span><br><span class="line">        mid = (start + end) / <span class="number">2</span></span><br><span class="line">        smaller, larger = (matrix[<span class="number">0</span>][<span class="number">0</span>], matrix[n - <span class="number">1</span>][n - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        count, smaller, larger = <span class="built_in">count_less_equal</span>(matrix, mid, smaller, larger)</span><br><span class="line">        <span class="keyword">if</span> count == k:</span><br><span class="line">            <span class="keyword">return</span> smaller</span><br><span class="line">        <span class="keyword">if</span> count &lt; k:</span><br><span class="line">            start = larger</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            end = smaller</span><br><span class="line">    <span class="keyword">return</span> start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="built_in">count_less_equal</span>(matrix, mid, smaller, larger):</span><br><span class="line">    count, n = <span class="number">0</span>, <span class="built_in">len</span>(matrix)</span><br><span class="line">    row, col = n - <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> row &gt;= <span class="number">0</span> <span class="keyword">and</span> col &lt; n:</span><br><span class="line">        <span class="keyword">if</span> matrix[row][col] &gt; mid:</span><br><span class="line">            <span class="meta"># as matrix[row][col] is bigger than the mid, let<span class="meta-string">&#x27;s keep track of the</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">            # smallest number greater than the mid</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">            larger = min(larger, matrix[row][col])</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">            row -= 1</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        else:</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">            # as matrix[row][col] is less than or equal to the mid, let&#x27;</span>s keep track of the</span></span><br><span class="line">            <span class="meta"># biggest number less than or equal to the mid</span></span><br><span class="line">            smaller = <span class="built_in">max</span>(smaller, matrix[row][col])</span><br><span class="line">            count += row + <span class="number">1</span></span><br><span class="line">            col += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count, smaller, larger</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="built_in">main</span>():</span><br><span class="line">    res = <span class="built_in">find_kth_smallest_in_sorted_matrix</span>([[<span class="number">1</span>, <span class="number">4</span>], [<span class="number">2</span>, <span class="number">5</span>]], <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = <span class="built_in">find_kth_smallest_in_sorted_matrix</span>([[<span class="number">-5</span>]], <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = <span class="built_in">find_kth_smallest_in_sorted_matrix</span>([[<span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>], [<span class="number">3</span>, <span class="number">7</span>, <span class="number">10</span>], [<span class="number">5</span>, <span class="number">8</span>, <span class="number">11</span>]], <span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = <span class="built_in">find_kth_smallest_in_sorted_matrix</span>([[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">13</span>], [<span class="number">12</span>, <span class="number">13</span>, <span class="number">15</span>]], <span class="number">8</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">main</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-3"><a href="#Time-complexity-3" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The <strong>Binary Search</strong> could take <strong><em>O(log(max-min ))</em></strong> iterations where ‘max’ is the largest and ‘min’ is the smallest element in the matrix and in each iteration we take <strong><em>O(N)</em></strong> for counting, therefore, the overall time complexity of the algorithm will be <strong><em>O(N\</em>log(max-min))*</strong>.</p><h4 id="Space-complexity-3"><a href="#Space-complexity-3" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The algorithm runs in constant space <strong><em>O(1)</em></strong>.</p><h2 id="Smallest-Number-Range-Hard"><a href="#Smallest-Number-Range-Hard" class="headerlink" title="Smallest Number Range (Hard)"></a>Smallest Number Range (Hard)</h2><p>leetcode 632</p><h3 id="Problem-Statement-2"><a href="#Problem-Statement-2" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given ‘M’ sorted arrays, find the smallest range that includes at least one number from each of the ‘M’ lists.</p><p><strong>Example 1:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: L<span class="number">1</span>=[<span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>], L<span class="number">2</span>=[<span class="number">4</span>, <span class="number">12</span>], L<span class="number">3</span>=[<span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line"><span class="attribute">Output</span>:<span class="meta"> [4, 7]</span></span><br><span class="line"><span class="attribute">Explanation</span>: The range<span class="meta"> [4, 7] includes 5 from L1, 4 from L2 and 7 from L3.</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: L<span class="number">1</span>=[<span class="number">1</span>, <span class="number">9</span>], L<span class="number">2</span>=[<span class="number">4</span>, <span class="number">12</span>], L<span class="number">3</span>=[<span class="number">7</span>, <span class="number">10</span>, <span class="number">16</span>]</span><br><span class="line"><span class="attribute">Output</span>:<span class="meta"> [9, 12]</span></span><br><span class="line"><span class="attribute">Explanation</span>: The range<span class="meta"> [9, 12] includes 9 from L1, 12 from L2 and 10 from L3.</span></span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-3"><a href="#Try-it-yourself-3" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 思路和solution一致，但是没有想到while循环的条件</span></span><br></pre></td></tr></table></figure><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <strong>K-way merge</strong> pattern and we can follow a similar approach as discussed in <strong><em>Merge K Sorted Lists</em></strong>.</p><p>We can start by inserting the first number from all the arrays in a min-heap. We will keep track of the largest number that we have inserted in the heap (let’s call it <code>currentMaxNumber</code>).</p><p>In a loop, we’ll take the smallest (top) element from the min-heap and<code>currentMaxNumber</code> has the largest element that we inserted in the heap. If these two numbers give us a smaller range, we’ll update our range. Finally, if the array of the top element has more elements, we’ll insert the next element to the heap.</p><p>We can finish searching the minimum range as soon as an array is completed or, in other terms, the heap has less than ‘M’ elements.</p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_smallest_range</span>(<span class="params">lists</span>):</span></span><br><span class="line">    min_heap = []</span><br><span class="line">    range_start, range_end = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>), <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    max_num_in_heap = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> arr <span class="keyword">in</span> lists:</span><br><span class="line">        heappush(min_heap, (arr[<span class="number">0</span>], <span class="number">0</span>, arr))</span><br><span class="line">        max_num_in_heap = <span class="built_in">max</span>(max_num_in_heap, arr[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># take the smallest(top) element form the min heap, if it gives us smaller range, update the ranges</span></span><br><span class="line">    <span class="comment"># if the array of the top element has more elements, insert the next element in the heap</span></span><br><span class="line">    <span class="comment"># 思路一样，但是当时没有想到这个while循环的条件</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(min_heap) == <span class="built_in">len</span>(lists):</span><br><span class="line">        num, index, arr = heappop(min_heap)</span><br><span class="line">        <span class="keyword">if</span> range_end - range_start &gt; max_num_in_heap - num:</span><br><span class="line">            range_start = num</span><br><span class="line">            range_end = max_num_in_heap</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(arr) &gt; index + <span class="number">1</span>:</span><br><span class="line">            heappush(min_heap, (arr[index + <span class="number">1</span>], index + <span class="number">1</span>, arr))</span><br><span class="line">            max_num_in_heap = <span class="built_in">max</span>(max_num_in_heap, arr[index + <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [range_start, range_end]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = find_smallest_range([[<span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>], [<span class="number">4</span>, <span class="number">12</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span>]])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-4"><a href="#Time-complexity-4" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>Since, at most, we’ll be going through all the elements of all the arrays and will remove/add one element in the heap in each step, the time complexity of the above algorithm will be <strong><em>O(N\</em>logM)*</strong> where ‘N’ is the total number of elements in all the ‘M’ input arrays.</p><h4 id="Space-complexity-4"><a href="#Space-complexity-4" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity will be <strong><em>O(M)</em></strong> because, at any time, our min-heap will be store one number from all the ‘M’ input arrays.</p><h2 id="Problem-Challenge-1"><a href="#Problem-Challenge-1" class="headerlink" title="Problem Challenge 1"></a>Problem Challenge 1</h2><p><a href="https://leetcode.com/problems/find-k-pairs-with-smallest-sums/">373. Find K Pairs with Smallest Sums</a> 类似，都相反了相当于，但是用这个方法就会很慢，应该用上一题的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kSmallestPairs</span>(<span class="params">self, nums1, nums2, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans = []</span><br><span class="line">        heap = [(nums1[<span class="number">0</span>] + nums2[<span class="number">0</span>], <span class="number">0</span>, <span class="number">0</span>)]</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            _, i, j = heapq.heappop(heap)</span><br><span class="line">            ans.append([nums1[i], nums2[j]])</span><br><span class="line">            <span class="keyword">if</span> j + <span class="number">1</span> &lt; <span class="built_in">len</span>(nums2):</span><br><span class="line">                heapq.heappush(heap, (nums1[i] + nums2[j + <span class="number">1</span>], i, j + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> j == <span class="number">0</span> <span class="keyword">and</span> i + <span class="number">1</span> &lt; <span class="built_in">len</span>(nums1):</span><br><span class="line">                heapq.heappush(heap, (nums1[i + <span class="number">1</span>] + nums2[<span class="number">0</span>], i + <span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="K-Pairs-with-Largest-Sums-Hard"><a href="#K-Pairs-with-Largest-Sums-Hard" class="headerlink" title="K Pairs with Largest Sums (Hard)"></a>K Pairs with Largest Sums (Hard)</h3><p>Given two sorted arrays in descending order, find ‘K’ pairs with the largest sum where each pair consists of numbers from both the arrays.</p><p><strong>Example 1:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: L<span class="number">1</span>=[<span class="number">9</span>, <span class="number">8</span>, <span class="number">2</span>], L<span class="number">2</span>=[<span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>], K=<span class="number">3</span></span><br><span class="line"><span class="attribute">Output</span>:<span class="meta"> [9, 3], [9, 6], [8, 6] </span></span><br><span class="line"><span class="meta">Explanation: These 3 pairs have the largest sum. No other pair has a sum larger than any of these.</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: L<span class="number">1</span>=[<span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>], L<span class="number">2</span>=[<span class="number">2</span>, -<span class="number">1</span>], K=<span class="number">3</span></span><br><span class="line"><span class="attribute">Output</span>:<span class="meta"> [5, 2], [5, -1], [2, 2] </span></span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-4"><a href="#Try-it-yourself-4" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不会</span></span><br></pre></td></tr></table></figure><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <strong>K-way merge</strong> pattern and we can follow a similar approach as discussed in <strong><em>Merge K Sorted Lists</em></strong>.</p><p>We can go through all the numbers of the two input arrays to create pairs and initially insert them all in the heap until we have ‘K’ pairs in <strong>Min Heap</strong>. After that, if a pair is bigger than the top (smallest) pair in the heap, we can remove the smallest pair and insert this pair in the heap.</p><p>We can <strong>optimize</strong> our algorithms in two ways:</p><ol><li>Instead of iterating over all the numbers of both arrays, we can iterate only the first ‘K’ numbers from both arrays. Since the arrays are sorted in descending order, the pairs with the maximum sum will be constituted by the first ‘K’ numbers from both the arrays.</li><li>As soon as we encounter a pair with a sum that is smaller than the smallest (top) element of the heap, we don’t need to process the next elements of the array. Since the arrays are sorted in descending order, we won’t be able to find a pair with a higher sum moving forward.</li></ol><h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_k_largest_pairs</span>(<span class="params">nums1, nums2, k</span>):</span></span><br><span class="line">    min_heap = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">min</span>(k, <span class="built_in">len</span>(nums1))):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">min</span>(k, <span class="built_in">len</span>(nums2))):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(min_heap) &lt; k:</span><br><span class="line">                heappush(min_heap, (nums1[i] + nums2[j], i, j))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># if the sum of the two numbers from the two arrays is smaller than the smallest(top)</span></span><br><span class="line">                <span class="comment"># element of the heap, we can &#x27;break&quot; here. since the arrays are sorted in the</span></span><br><span class="line">                <span class="comment"># descending order, we&#x27;ll not be able to find a pair with a higher sum moving forward</span></span><br><span class="line">                <span class="comment"># solution是&lt;而不是&lt;=,但是&lt;=也能过</span></span><br><span class="line">                <span class="keyword">if</span> nums1[i] + nums2[j] &lt;= min_heap[<span class="number">0</span>][<span class="number">0</span>]:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># we have a pair with a larger sum, remove top and insert this pair in the heap</span></span><br><span class="line">                    heappop(min_heap)</span><br><span class="line">                    heappush(min_heap, (nums1[i] + nums2[j], i, j))</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> (num, i, j) <span class="keyword">in</span> min_heap:</span><br><span class="line">        result.append([nums1[i], nums2[j]])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = find_k_largest_pairs([<span class="number">9</span>, <span class="number">8</span>, <span class="number">2</span>], [<span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>], <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>14. Pattern Top _K_ Elements</title>
      <link href="/14-pattern-top-k-elements/index.html"/>
      <url>/14-pattern-top-k-elements/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Any problem that asks us to find the top/smallest/frequent ‘K’ elements among a given set falls under this pattern.</p><p>The best data structure that comes to mind to keep track of ‘K’ elements is <strong><a href="https://en.wikipedia.org/wiki/Heap_(data_structure">Heap</a>)</strong>. This pattern will make use of the Heap to solve multiple problems dealing with ‘K’ elements at a time from a set of given elements.</p><p>Let’s jump onto our first problem to develop an understanding of this pattern.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">做这种pattern的题目有三种方式</span><br><span class="line"><span class="comment"># 1. 先全部塞进去，最后在弹出指定数量作为答案，这样可以保证相同的排序条件，先进去的被取出来</span></span><br><span class="line"><span class="comment"># 2. 先塞进去指定数量，然后每满足条件就替换，如果排序条件已经存在（带比较的数的条件和heap[0]的条件一样），那就不会替换，这样</span></span><br><span class="line"><span class="comment">#    也可以保证答案中会优先包含先进去的数</span></span><br><span class="line"><span class="comment"># 3. 每塞进去一个就判断是不是已经超过了指定长度，如果超过了就弹出一个，这样就会导致相同的排序条件，会优先保留后进来的，这是我们不想要的。</span></span><br><span class="line"><span class="comment">#    所以这道题选择第一种和第二种是合理的</span></span><br></pre></td></tr></table></figure><h2 id="Top-‘K’-Numbers-easy"><a href="#Top-‘K’-Numbers-easy" class="headerlink" title="Top ‘K’ Numbers (easy)"></a>Top ‘K’ Numbers (easy)</h2><p>不在leetcode</p><h3 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given an unsorted array of numbers, find the ‘K’ largest numbers in it.</p><p>Note: For a detailed discussion about different approaches to solve this problem, take a look at <a href="https://www.educative.io/collection/page/5668639101419520/5671464854355968/4817079184130048">Kth Smallest Number</a>(这是Miscellaneous类别的，类别18）</p><p><strong>Example 1:</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="string">[3, 1, 5, 12, 2, 11]</span>, K = <span class="number">3</span></span><br><span class="line">Output: <span class="string">[5, 12, 11]</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="string">[5, 12, 11, -1, 12]</span>, K = <span class="number">3</span></span><br><span class="line">Output: <span class="string">[12, 11, 12]</span></span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself"><a href="#Try-it-yourself" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 见下</span></span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>A brute force solution could be to sort the array and return the largest K numbers. The time complexity of such an algorithm will be <strong><em>O(N\</em>logN)*</strong> as we need to use a sorting algorithm like <a href="https://en.wikipedia.org/wiki/Timsort">Timsort</a> if we use Java’s <code>Collection.sort()</code>. Can we do better than that?</p><p>The best data structure that comes to mind to keep track of top ‘K’ elements is <a href="https://en.wikipedia.org/wiki/Heap_(data_structure">Heap</a>). Let’s see if we can use a heap to find a better algorithm.</p><p>If we iterate through the array one element at a time and keep ‘K’ largest numbers in a heap such that each time we find a larger number than the smallest number in the heap, we do two things:</p><ol><li>Take out the smallest number from the heap, and</li><li>Insert the larger number into the heap.</li></ol><p>This will ensure that we always have ‘K’ largest numbers in the heap. The most efficient way to repeatedly find the smallest number among a set of numbers will be to use a min-heap. As we know, we can find the smallest number in a min-heap in constant time <strong><em>O(1)</em></strong>, since the smallest number is always at the root of the heap. Extracting the smallest number from a min-heap will take <strong><em>O(logN)</em></strong> (if the heap has ‘N’ elements) as the heap needs to readjust after the removal of an element.</p><p>Let’s take Example-1 to go through each step of our algorithm:</p><p>Given array: [3, 1, 5, 12, 2, 11], and K=3</p><ol><li>First, let’s insert ‘K’ elements in the min-heap.</li><li>After the insertion, the heap will have three numbers [3, 1, 5] with ‘1’ being the root as it is the smallest element.</li><li>We’ll iterate through the remaining numbers and perform the above-mentioned two steps if we find a number larger than the root of the heap.</li><li>The 4th number is ‘12’ which is larger than the root (which is ‘1’), so let’s take out ‘1’ and insert ‘12’. Now the heap will have [3, 5, 12] with ‘3’ being the root as it is the smallest element.</li><li>The 5th number is ‘2’ which is not bigger than the root of the heap (‘3’), so we can skip this as we already have top three numbers in the heap.</li><li>The last number is ‘11’ which is bigger than the root (which is ‘3’), so let’s take out ‘3’ and insert ‘11’. Finally, the heap has the largest three numbers: [5, 12, 11]</li></ol><p>As discussed above, it will take us <strong><em>O(logK)</em></strong> to extract the minimum number from the min-heap. So the overall time complexity of our algorithm will be <strong><em>O(K\</em>logK+(N-K)*logK)*</strong> since, first, we insert ‘K’ numbers in the heap and then iterate through the remaining numbers and at every step, in the worst case, we need to extract the minimum number and insert a new number in the heap. This algorithm is better than <strong><em>O(N\</em>logN)*</strong>.</p><p>Here is the visual representation of our algorithm:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这种写法比较冗余，不过可能时间比较节约，减少不必要的操作，直接全部往min_heap塞，一旦长度超过k,pop第一个最小的</span></span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_k_largest_num</span>(<span class="params">nums, k</span>):</span></span><br><span class="line">    <span class="comment"># 默认小顶堆</span></span><br><span class="line">    min_heap = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        heappush(min_heap, nums[i])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; min_heap[<span class="number">0</span>]:</span><br><span class="line">            heappop(min_heap)</span><br><span class="line">            heappush(min_heap, nums[i])</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> min_heap:</span><br><span class="line">        result.append(heappop(min_heap))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = find_k_largest_num([<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">11</span>], <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = find_k_largest_num([<span class="number">5</span>, <span class="number">12</span>, <span class="number">11</span>, -<span class="number">1</span>, <span class="number">12</span>], <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity"><a href="#Time-complexity" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>As discussed above, the time complexity of this algorithm is <strong><em>O(KlogK+(N-K)logK)</em></strong>, which is asymptotically equal to <strong><em>O(NlogK)</em></strong></p><h4 id="Space-complexity"><a href="#Space-complexity" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity will be <strong><em>O(K)</em></strong> since we need to store the top ‘K’ numbers in the heap.</p><h2 id="Kth-Smallest-Number-easy"><a href="#Kth-Smallest-Number-easy" class="headerlink" title="Kth Smallest Number (easy)"></a>Kth Smallest Number (easy)</h2><p>leetcode 215 <a href="https://leetcode.com/problems/kth-largest-element-in-an-array/">Kth Largest Element in an Array</a> 构造小顶堆</p><h3 id="Problem-Statement-1"><a href="#Problem-Statement-1" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given an unsorted array of numbers, find Kth smallest number in it.</p><p>Please note that it is the Kth smallest number in the sorted order, not the Kth distinct element.</p><p>Note: For a detailed discussion about different approaches to solve this problem, take a look at <strong><em>Kth Smallest Number</em></strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> [<span class="number">1</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">5</span>], K = <span class="number">3</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="number">5</span></span><br><span class="line"><span class="symbol">Explanation:</span> The <span class="number">3</span>rd smallest number <span class="built_in">is</span> <span class="comment">&#x27;5&#x27;, as the first two smaller numbers are [1, 2].</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Inpu<span class="variable">t:</span> [<span class="number">1</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">5</span>], K = <span class="number">4</span></span><br><span class="line">Outpu<span class="variable">t:</span> <span class="number">5</span></span><br><span class="line">Explanation: The <span class="number">4</span><span class="keyword">th</span> smallest <span class="keyword">number</span> <span class="keyword">is</span> <span class="string">&#x27;5&#x27;</span>, <span class="keyword">as</span> the <span class="keyword">first</span> three small numbers are [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>].</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> [<span class="number">5</span>, <span class="number">12</span>, <span class="number">11</span>, -<span class="number">1</span>, <span class="number">12</span>], K = <span class="number">3</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="number">11</span></span><br><span class="line"><span class="symbol">Explanation:</span> The <span class="number">3</span>rd smallest number <span class="built_in">is</span> <span class="comment">&#x27;11&#x27;, as the first two small numbers are [5, -1].</span></span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-1"><a href="#Try-it-yourself-1" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 见下</span></span><br></pre></td></tr></table></figure><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <em>Top ‘K’ Numbers</em> pattern but has two differences:</p><ol><li>Here we need to find the Kth <code>smallest</code> number, whereas in <em>Top ‘K’ Numbers</em> we were dealing with ‘K’ <code>largest</code> numbers.</li><li>In this problem, we need to find only one number (Kth smallest) compared to finding all ‘K’ largest numbers.</li></ol><p>We can follow the same approach as discussed in the ‘Top K Elements’ problem. To handle the first difference mentioned above, we can use a max-heap instead of a min-heap. As we know, the root is the biggest element in the max heap. So, since we want to keep track of the ‘K’ smallest numbers, we can compare every number with the root while iterating through all numbers, and if it is smaller than the root, we’ll take the root out and insert the smaller number.</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 这种写法比较冗余，不过可能时间比较节约，减少不必要的操作，直接全部往max_heap塞，一旦长度超过k,pop第一个最小的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_kth_smallest_num</span>(<span class="params">nums, k</span>):</span></span><br><span class="line">    <span class="comment"># 默认小顶堆，但是需要构造大顶堆</span></span><br><span class="line">    max_heap = []</span><br><span class="line">    <span class="comment"># put first k numbers in the max heap</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        heappush(max_heap, -nums[i])</span><br><span class="line">    <span class="comment"># go through the remaining numbers of the array, if the number from the array is smaller than the</span></span><br><span class="line">    <span class="comment"># top(biggest) number of the heap, remove the top number from heap and add the number from array</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; -max_heap[<span class="number">0</span>]:</span><br><span class="line">            heappop(max_heap)</span><br><span class="line">            heappush(max_heap, -nums[i])</span><br><span class="line">    <span class="comment"># the root of the heap has the kth smallest number</span></span><br><span class="line">    <span class="keyword">return</span> -max_heap[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = find_kth_smallest_num([<span class="number">1</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">5</span>], <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = find_kth_smallest_num([<span class="number">1</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">5</span>], <span class="number">4</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = find_kth_smallest_num([<span class="number">5</span>, <span class="number">12</span>, <span class="number">11</span>, -<span class="number">1</span>, <span class="number">12</span>], <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-1"><a href="#Time-complexity-1" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of this algorithm is <strong><em>O(KlogK+(N-K)logK)</em></strong>, which is asymptotically equal to <strong><em>O(N\</em>logK)*</strong></p><h4 id="Space-complexity-1"><a href="#Space-complexity-1" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity will be <strong><em>O(K)</em></strong> because we need to store ‘K’ smallest numbers in the heap.</p><h3 id="An-Alternate-Approach"><a href="#An-Alternate-Approach" class="headerlink" title="An Alternate Approach"></a>An Alternate Approach</h3><p>Alternatively, we can use a <strong>Min Heap</strong> to find the Kth smallest number. We can insert all the numbers in the min-heap and then extract the top ‘K’ numbers from the heap to find the Kth smallest number. Initializing the min-heap with all numbers will take <strong><em>O(N)</em></strong> and extracting ‘K’ numbers will take <strong><em>O(KlogN)</em></strong>. Overall, the time complexity of this algorithm will be <strong><em>O(N+KlogN)</em></strong> and the space complexity will be <strong><em>O(N)</em></strong>.</p><h2 id="‘K’-Closest-Points-to-the-Origin-easy"><a href="#‘K’-Closest-Points-to-the-Origin-easy" class="headerlink" title="‘K’ Closest Points to the Origin (easy)"></a>‘K’ Closest Points to the Origin (easy)</h2><p>leetcode 973 leetcode 没有Point class， 下面code给出了这种解答</p><h3 id="Problem-Statement-2"><a href="#Problem-Statement-2" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given an array of points in the a <strong>2D</strong> plane, find ‘K’ closest points to the origin.</p><p><strong>Example 1:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: points = <span class="string">[[1,2],[1,3]]</span>, K = <span class="number">1</span></span><br><span class="line">Output: <span class="string">[[1,2]]</span></span><br><span class="line">Explanation: The Euclidean distance between (<span class="number">1</span>, <span class="number">2</span>) <span class="keyword">and</span> the origin is <span class="built_in">sqrt</span>(<span class="number">5</span>).</span><br><span class="line">The Euclidean distance between (<span class="number">1</span>, <span class="number">3</span>) <span class="keyword">and</span> the origin is <span class="built_in">sqrt</span>(<span class="number">10</span>).</span><br><span class="line">Since <span class="built_in">sqrt</span>(<span class="number">5</span>) &lt; <span class="built_in">sqrt</span>(<span class="number">10</span>), therefore (<span class="number">1</span>, <span class="number">2</span>) is closer to the origin.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: point = <span class="string">[[1, 3], [3, 4], [2, -1]]</span>, K = <span class="number">2</span></span><br><span class="line">Output: <span class="string">[[1, 3], [2, -1]]</span></span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-2"><a href="#Try-it-yourself-2" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 见下</span></span><br></pre></td></tr></table></figure><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>The <a href="https://en.wikipedia.org/wiki/Euclidean_distance">Euclidean distance</a> of a point P(x,y) from the origin can be calculated through the following formula:</p><p>\sqrt{x^2 + y^2}√<em>x</em>2+<em>y</em>2</p><p>This problem follows the <strong><em>Top ‘K’ Numbers</em></strong> pattern. The only difference in this problem is that we need to find the closest point (to the origin) as compared to finding the largest numbers.</p><p>Following a similar approach, we can use a <strong>Max Heap</strong> to find ‘K’ points closest to the origin. While iterating through all points, if a point (say ‘P’) is closer to the origin than the top point of the max-heap, we will remove that top point from the heap and add ‘P’ to always keep the closest points in the heap.</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果要构造kth closest的point,也是构造大顶堆，只不过返回的时候返回第一个就可以</span></span><br><span class="line"><span class="comment"># 如果要构造kth farest的point, 就要构造小顶堆，返回的时候返回第一个就可以，越小的排在越前面，def __lt__(self, other)中就要改成return self.distance_from_origin() &lt; other.distance_from_origin()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="comment"># __lt__是less than, 而python默认返回的是小顶堆，会把__kt__认为确实小的放在小顶堆的前面，所以下面这样写，返回的是1，也就是认为</span></span><br><span class="line">        <span class="comment"># &quot;self.distance_from_origin() &gt; other.distance_from_origin()&quot;在__lt__返回的是True, 也就是修改逻辑，把越大的放在越前面</span></span><br><span class="line">        <span class="keyword">return</span> self.distance_from_origin() &gt; other.distance_from_origin()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distance_from_origin</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(self.x, <span class="number">2</span>) + <span class="built_in">pow</span>(self.y, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_point</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[&quot;</span> + <span class="built_in">str</span>(self.x) + <span class="string">&quot;,&quot;</span> + <span class="built_in">str</span>(self.y) + <span class="string">&quot;]&quot;</span>, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这种写法比较冗余，不过可能时间比较节约，减少不必要的操作，直接全部往max_heap塞，一旦长度超过k,pop第一个最小的</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_closest_points</span>(<span class="params">points, k</span>):</span></span><br><span class="line">    <span class="comment"># 小于heap中最远的就可以进入heap，所以heap[0]应该是最远的，所以构建max_heap而不是min_heap</span></span><br><span class="line">    max_heap = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        heappush(max_heap, points[i])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(points)):</span><br><span class="line">        <span class="keyword">if</span> points[i].distance_from_origin() &lt; max_heap[<span class="number">0</span>].distance_from_origin():</span><br><span class="line">            heappop(max_heap)</span><br><span class="line">            heappush(max_heap, points[i])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(max_heap)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = find_closest_points([Point(<span class="number">1</span>, <span class="number">3</span>), Point(<span class="number">3</span>, <span class="number">4</span>), Point(<span class="number">2</span>, -<span class="number">1</span>)], <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">        i.print_point()</span><br><span class="line">    <span class="comment"># print(res)</span></span><br><span class="line">    <span class="comment"># res = find_closest_points([1, 5, 12, 2, 11, 5], 4)</span></span><br><span class="line">    <span class="comment"># print(str(res))</span></span><br><span class="line">    <span class="comment"># res = find_closest_points([5, 12, 11, -1, 12], 3)</span></span><br><span class="line">    <span class="comment"># print(str(res))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment"># ==================================leetcode======================================</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distance_from_origin</span>(<span class="params">self, point</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(point[<span class="number">0</span>], <span class="number">2</span>) + <span class="built_in">pow</span>(point[<span class="number">1</span>], <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kClosest</span>(<span class="params">self, points, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type points: List[List[int]]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        max_heap = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            heappush(max_heap, (-self.distance_from_origin(points[i]), points[i]))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(points)):</span><br><span class="line">            <span class="keyword">if</span> self.distance_from_origin(points[i]) &lt; self.distance_from_origin(max_heap[<span class="number">0</span>][<span class="number">1</span>]):</span><br><span class="line">                heappop(max_heap)</span><br><span class="line">                heappush(max_heap, (-self.distance_from_origin(points[i]), points[i]))</span><br><span class="line">        res =[]</span><br><span class="line">        <span class="keyword">while</span> max_heap:</span><br><span class="line">            res.append(heappop(max_heap)[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-2"><a href="#Time-complexity-2" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of this algorithm is <strong><em>(N\</em>logK)*</strong> as we iterating all points and pushing them into the heap.</p><h4 id="Space-complexity-2"><a href="#Space-complexity-2" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity will be <strong><em>O(K)</em></strong> because we need to store ‘K’ point in the heap.</p><h2 id="Connect-Ropes-easy"><a href="#Connect-Ropes-easy" class="headerlink" title="Connect Ropes (easy)"></a>Connect Ropes (easy)</h2><p>不在leetcode</p><h3 id="Problem-Statement-3"><a href="#Problem-Statement-3" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given ‘N’ ropes with different lengths, we need to connect these ropes into one big rope with minimum cost. The cost of connecting two ropes is equal to the sum of their lengths.</p><p><strong>Example 1:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>:<span class="meta"> [1, 3, 11, 5]</span></span><br><span class="line"><span class="attribute">Output</span>: <span class="number">33</span></span><br><span class="line"><span class="attribute">Explanation</span>: First connect <span class="number">1</span>+<span class="number">3</span>(=<span class="number">4</span>), then <span class="number">4</span>+<span class="number">5</span>(=<span class="number">9</span>), and then <span class="number">9</span>+<span class="number">11</span>(=<span class="number">20</span>). So the total cost is <span class="number">33</span> (<span class="number">4</span>+<span class="number">9</span>+<span class="number">20</span>)</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>:<span class="meta"> [3, 4, 5, 6]</span></span><br><span class="line"><span class="attribute">Output</span>: <span class="number">36</span></span><br><span class="line"><span class="attribute">Explanation</span>: First connect <span class="number">3</span>+<span class="number">4</span>(=<span class="number">7</span>), then <span class="number">5</span>+<span class="number">6</span>(=<span class="number">11</span>), <span class="number">7</span>+<span class="number">11</span>(=<span class="number">18</span>). Total cost is <span class="number">36</span> (<span class="number">7</span>+<span class="number">11</span>+<span class="number">18</span>)</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>:<span class="meta"> [1, 3, 11, 5, 2]</span></span><br><span class="line"><span class="attribute">Output</span>: <span class="number">42</span></span><br><span class="line"><span class="attribute">Explanation</span>: First connect <span class="number">1</span>+<span class="number">2</span>(=<span class="number">3</span>), then <span class="number">3</span>+<span class="number">3</span>(=<span class="number">6</span>), <span class="number">6</span>+<span class="number">5</span>(=<span class="number">11</span>), <span class="number">11</span>+<span class="number">11</span>(=<span class="number">22</span>). Total cost is <span class="number">42</span> (<span class="number">3</span>+<span class="number">6</span>+<span class="number">11</span>+<span class="number">22</span>)</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-3"><a href="#Try-it-yourself-3" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 思路和solution一样，没有自己写了就</span></span><br></pre></td></tr></table></figure><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>In this problem, following a greedy approach to connect the smallest ropes first will ensure the lowest cost. We can use a <strong>Min Heap</strong> to find the smallest ropes following a similar approach as discussed in <em>Kth Smallest Number</em>. Once we connect two ropes, we need to insert the resultant rope back in the <strong>Min Heap</strong> so that we can connect it with the remaining ropes.</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min_cost_to_connect</span>(<span class="params">rope_length</span>):</span></span><br><span class="line">    min_heap = []</span><br><span class="line">    <span class="keyword">for</span> rope <span class="keyword">in</span> rope_length:</span><br><span class="line">        heappush(min_heap, rope)</span><br><span class="line">    result, temp = <span class="number">0</span>, <span class="number">0</span>  <span class="comment"># 在外面定义temp可以减少一点空间复杂度</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(min_heap) &gt; <span class="number">1</span>:</span><br><span class="line">        temp = heappop(min_heap) + heappop(min_heap)</span><br><span class="line">        result += temp</span><br><span class="line">        heappush(min_heap, temp)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = min_cost_to_connect([<span class="number">1</span>, <span class="number">3</span>, <span class="number">11</span>, <span class="number">5</span>])</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line">    res = min_cost_to_connect([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = min_cost_to_connect([<span class="number">1</span>, <span class="number">3</span>, <span class="number">11</span>, <span class="number">5</span>, <span class="number">2</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-3"><a href="#Time-complexity-3" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>Given ‘N’ ropes, we need <strong><em>O(N\</em>logN)*</strong> to insert all the ropes in the heap. In each step, while processing the heap, we take out two elements from the heap and insert one. This means we will have a total of ‘N’ steps, having a total time complexity of <strong><em>O(N\</em>logN)*</strong>.</p><h4 id="Space-complexity-3"><a href="#Space-complexity-3" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity will be <strong><em>O(N)</em></strong> because we need to store all the ropes in the heap.</p><h2 id="Top-‘K’-Frequent-Numbers-medium"><a href="#Top-‘K’-Frequent-Numbers-medium" class="headerlink" title="Top ‘K’ Frequent Numbers (medium)"></a>Top ‘K’ Frequent Numbers (medium)</h2><p>leetcode 347, leetcode保证了answer是unique的</p><h3 id="Problem-Statement-4"><a href="#Problem-Statement-4" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given an unsorted array of numbers, find the top ‘K’ frequently occurring numbers in it.</p><p><strong>Example 1:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input</span>: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">11</span>], <span class="symbol">K</span> = <span class="number">2</span></span><br><span class="line"><span class="symbol">Output</span>: [<span class="number">12</span>, <span class="number">11</span>]</span><br><span class="line"><span class="symbol">Explanation</span>: <span class="symbol">Both</span> <span class="string">&#x27;11&#x27;</span> and <span class="string">&#x27;12&#x27;</span> apeared twice.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input</span>: [<span class="number">5</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">11</span>], <span class="symbol">K</span> = <span class="number">2</span></span><br><span class="line"><span class="symbol">Output</span>: [<span class="number">11</span>, <span class="number">5</span>] or [<span class="number">11</span>, <span class="number">12</span>] or [<span class="number">11</span>, <span class="number">3</span>]</span><br><span class="line"><span class="symbol">Explanation</span>: <span class="symbol">Only</span> <span class="string">&#x27;11&#x27;</span> appeared twice, all other numbers appeared once.</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-4"><a href="#Try-it-yourself-4" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 思路和solution一样，没有自己写了就</span></span><br></pre></td></tr></table></figure><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows <em>Top ‘K’ Numbers</em>. The only difference is that in this problem, we need to find the most frequently occurring number compared to finding the largest numbers.</p><p>We can follow the same approach as discussed in the <strong>Top K Elements</strong> problem. However, in this problem, we first need to know the frequency of each number, for which we can use a <strong>HashMap</strong>. Once we have the frequency map, we can use a <strong>Min Heap</strong> to find the ‘K’ most frequently occurring number. In the <strong>Min Heap</strong>, instead of comparing numbers we will compare their frequencies in order to get frequently occurring numbers</p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_k_frequent_num</span>(<span class="params">nums, k</span>):</span></span><br><span class="line">    frequent_map = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="comment"># if num not in frequent_map:</span></span><br><span class="line">        <span class="comment">#     frequent_map[frequent_map] = 0</span></span><br><span class="line">        <span class="comment"># frequent_map[frequent_map]  += 1</span></span><br><span class="line">        <span class="comment"># 上面三行可以直接用下面这个代替</span></span><br><span class="line">        frequent_map[num] = frequent_map.get(num, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    min_map = []</span><br><span class="line">    <span class="comment"># 4.12 note: 建议使用方法1：先全部塞进去在去除前面的k个，理由见“&#x27;K&#x27; Closest Numbers”这道题，因为要是像这样写，答案就会不唯一，不过这道题的</span></span><br><span class="line">    <span class="comment">#  example中允许有不唯一的时候输出其中任何一个就可以，所以问题不大</span></span><br><span class="line">    <span class="keyword">for</span> num, frequency <span class="keyword">in</span> frequent_map.items():</span><br><span class="line">        heappush(min_map, (frequency, num))</span><br><span class="line">        <span class="comment"># 4.11 note:可以使用方法2：像之前一样，先push k 个，然后新的比heap[0]大的话，就替换heap[0]，但是在这个例子就比较麻烦</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(min_map) &gt; k:</span><br><span class="line">            heappop(min_map)</span><br><span class="line">    top_num = []</span><br><span class="line">    <span class="keyword">while</span> min_map:</span><br><span class="line">        top_num.append(heappop(min_map)[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> top_num</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = find_k_frequent_num([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">11</span>], <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line">    res = find_k_frequent_num([<span class="number">5</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">11</span>], <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-4"><a href="#Time-complexity-4" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of the above algorithm is <strong><em>O(N+N\</em>logK)*</strong>.</p><h4 id="Space-complexity-4"><a href="#Space-complexity-4" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity will be <strong><em>O(N)</em></strong>. Even though we are storing only ‘K’ numbers in the heap. For the frequency map, however, we need to store all the ‘N’ numbers.</p><h2 id="Frequency-Sort-medium"><a href="#Frequency-Sort-medium" class="headerlink" title="Frequency Sort (medium)"></a>Frequency Sort (medium)</h2><p>leetcode 451</p><h3 id="Problem-Statement-5"><a href="#Problem-Statement-5" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given a string, sort it based on the decreasing frequency of its characters.</p><p><strong>Example 1:</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Input</span>: &quot;Programming&quot;</span><br><span class="line">Output: &quot;rrggmmPiano&quot;</span><br><span class="line">Explanation: <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="keyword">and</span> <span class="string">&#x27;m&#x27;</span> appeared twice, so they need <span class="keyword">to</span> appear <span class="keyword">before</span> <span class="keyword">any</span> other <span class="type">character</span>.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> <span class="string">&quot;abcbab&quot;</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="string">&quot;bbbaac&quot;</span></span><br><span class="line"><span class="symbol">Explanation:</span> <span class="string">&#x27;b&#x27;</span> appeared three times, <span class="string">&#x27;a&#x27;</span> appeared twice, <span class="keyword">and</span> <span class="string">&#x27;c&#x27;</span> appeared only once.</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-5"><a href="#Try-it-yourself-5" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 思路和solution一样，没有自己写了就</span></span><br></pre></td></tr></table></figure><h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <strong>Top ‘K’ Elements</strong> pattern, and shares similarities with <em>Top ‘K’ Frequent Numbers</em>.</p><p>We can follow the same approach as discussed in the <em>Top ‘K’ Frequent Numbers</em> problem. First, we will find the frequencies of all characters, then use a max-heap to find the most occurring characters.</p><h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort_character_by_frequency</span>(<span class="params"><span class="built_in">str</span></span>):</span></span><br><span class="line">    frequent_map = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> <span class="built_in">str</span>:</span><br><span class="line">        frequent_map[char] = frequent_map.get(char, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    max_heap = []</span><br><span class="line">    <span class="comment"># 这个就是方法1， 先全部塞进去，这样就可以保证，相同的排序条件（这题中是频数），先出现的字母会依旧在前面</span></span><br><span class="line">    <span class="keyword">for</span> char, frequency <span class="keyword">in</span> frequent_map.items():</span><br><span class="line">        heappush(max_heap, (-frequency, char))</span><br><span class="line"></span><br><span class="line">    sorted_string = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> max_heap:</span><br><span class="line">        frequency, char = heappop(max_heap)</span><br><span class="line">        sorted_string += char * (-frequency)</span><br><span class="line">    <span class="keyword">return</span> sorted_string</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = sort_character_by_frequency(<span class="string">&quot;Programming&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = sort_character_by_frequency(<span class="string">&quot;abcbab&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-5"><a href="#Time-complexity-5" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of the above algorithm is <strong><em>O(D\</em>logD)*</strong> where ‘D’ is the number of distinct characters in the input string. This means, in the worst case, when all characters are unique the time complexity of the algorithm will be <strong><em>O(N\</em>logN)*</strong> where ‘N’ is the total number of characters in the string.</p><h4 id="Space-complexity-5"><a href="#Space-complexity-5" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity will be <strong><em>O(N)</em></strong>, as in the worst case, we need to store all the ‘N’ characters in the HashMap.</p><h2 id="Kth-Largest-Number-in-a-Stream-medium"><a href="#Kth-Largest-Number-in-a-Stream-medium" class="headerlink" title="Kth Largest Number in a Stream (medium)"></a>Kth Largest Number in a Stream (medium)</h2><p>leetcode 703 一样的代码，leetcode报错，感觉是leetcode内部问题</p><h3 id="Problem-Statement-6"><a href="#Problem-Statement-6" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Design a class to efficiently find the Kth largest element in a stream of numbers.</p><p>The class should have the following two things:</p><ol><li>The constructor of the class should accept an integer array containing initial numbers from the stream and an integer ‘K’.</li><li>The class should expose a function <code>add(int num)</code> which will store the given number and return the Kth largest number.</li></ol><p><strong>Example 1:</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Input</span>: [<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">11</span>], K = <span class="number">4</span></span><br><span class="line"><span class="number">1.</span> Calling <span class="keyword">add</span>(<span class="number">6</span>) should <span class="keyword">return</span> <span class="string">&#x27;5&#x27;</span>.</span><br><span class="line"><span class="number">2.</span> Calling <span class="keyword">add</span>(<span class="number">13</span>) should <span class="keyword">return</span> <span class="string">&#x27;6&#x27;</span>.</span><br><span class="line"><span class="number">2.</span> Calling <span class="keyword">add</span>(<span class="number">4</span>) should still <span class="keyword">return</span> <span class="string">&#x27;6&#x27;</span>.</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-6"><a href="#Try-it-yourself-6" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不知道怎么在他的代码框架下写</span></span><br></pre></td></tr></table></figure><h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <strong>Top ‘K’ Elements</strong> pattern and shares similarities with <em>Kth Smallest number</em>.</p><p>We can follow the same approach as discussed in the ‘Kth Smallest number’ problem. However, we will use a <strong>Min Heap</strong> (instead of a <strong>Max Heap</strong>) as we need to find the Kth largest number.</p><h3 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stream</span>:</span></span><br><span class="line">    min_heap = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">        <span class="comment"># todo write your code here</span></span><br><span class="line">        self.k = k</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            self.add(num)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, num</span>):</span></span><br><span class="line">        <span class="comment"># todo write your code here</span></span><br><span class="line">        heappush(self.min_heap, num)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.min_heap) &gt; self.k:</span><br><span class="line">            heappop(self.min_heap)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.min_heap[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    kth_largest_num = Stream([<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">11</span>], <span class="number">4</span>)</span><br><span class="line">    res = kth_largest_num.add(<span class="number">6</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = kth_largest_num.add(<span class="number">13</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = kth_largest_num.add(<span class="number">4</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-6"><a href="#Time-complexity-6" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of the <code>add()</code> function will be <strong><em>O(logK)</em></strong> since we are inserting the new number in the heap.</p><h4 id="Space-complexity-6"><a href="#Space-complexity-6" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity will be <strong><em>O(K)</em></strong> for storing numbers in the heap.</p><h2 id="‘K’-Closest-Numbers-medium"><a href="#‘K’-Closest-Numbers-medium" class="headerlink" title="‘K’ Closest Numbers (medium)"></a>‘K’ Closest Numbers (medium)</h2><p>leetcode 658</p><h3 id="Problem-Statement-7"><a href="#Problem-Statement-7" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given a sorted number array and two integers ‘K’ and ‘X’, find ‘K’ closest numbers to ‘X’ in the array. Return the numbers in the sorted order. ‘X’ is not necessarily present in the array.</p><p><strong>Example 1:</strong></p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Input</span>: [5, 6, 7, 8, 9], K = 3, <span class="meta">X</span> = 7</span><br><span class="line"><span class="meta">Output</span>: [6, 7, 8]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Input</span>: [2, 4, 5, 6, 9], K = 3, <span class="meta">X</span> = 6</span><br><span class="line"><span class="meta">Output</span>: [4, 5, 6]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Input</span>: [2, 4, 5, 6, 9], K = 3, <span class="meta">X</span> = 10</span><br><span class="line"><span class="meta">Output</span>: [5, 6, 9]</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-7"><a href="#Try-it-yourself-7" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我的思路是使用计算所有的数和X的距离，然后在heap里排序</span></span><br><span class="line"><span class="comment"># solution的思路可以学学</span></span><br></pre></td></tr></table></figure><h3 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <em>Top ‘K’ Numbers</em> pattern. The biggest difference in this problem is that we need to find the closest (to ‘X’) numbers compared to finding the overall largest numbers. Another difference is that the given array is sorted.</p><p>Utilizing a similar approach, we can find the numbers closest to ‘X’ through the following algorithm:</p><ol><li>Since the array is sorted, we can first find the number closest to ‘X’ through <strong>Binary Search</strong>. Let’s say that number is ‘Y’（Y不需要一定是最接近的，如果arr中不存在x,那么只要是x的左右邻居就可以）.</li><li>The ‘K’ closest numbers to ‘Y’ will be adjacent to ‘Y’ in the array. We can search in both directions of ‘Y’ to find the closest numbers.</li><li>We can use a heap to efficiently search for the closest numbers. We will take ‘K’ numbers in both directions of ‘Y’ and push them in a <strong>Min Heap</strong> sorted by their absolute difference from ‘X’. This will ensure that the numbers with the smallest difference from ‘X’ (i.e., closest to ‘X’) can be extracted easily from the <strong>Min Heap</strong>.</li><li>Finally, we will extract the top ‘K’ numbers from the <strong>Min Heap</strong> to find the required numbers.</li></ol><h3 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是看了solution自己写的（不是solution的代码）</span></span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_closest_element</span>(<span class="params">arr, k, x</span>):</span></span><br><span class="line">    index = binary_search(arr, x)  <span class="comment"># 如果找不到x的话，index不一定一定要是距离x最近的，因为会在index左右在取k的区间，一定会包含答案</span></span><br><span class="line">    low, high = index - k, index + k</span><br><span class="line">    low = <span class="built_in">max</span>(low, <span class="number">0</span>)</span><br><span class="line">    high = <span class="built_in">min</span>(high, <span class="built_in">len</span>(arr) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    max_heap = []</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(low, high + <span class="number">1</span>):</span><br><span class="line">        heappush(max_heap, (-<span class="built_in">abs</span>(arr[i] - x), arr[i]))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(max_heap) &gt; k:</span><br><span class="line">            heappop(max_heap)</span><br><span class="line">    <span class="keyword">while</span> max_heap:</span><br><span class="line">        result.append(heappop(max_heap)[<span class="number">1</span>])</span><br><span class="line">    result.sort()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">arr, target</span>):</span></span><br><span class="line">    start, end = <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> start &lt;= end:</span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> arr[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">if</span> arr[mid] &gt; target:</span><br><span class="line">            end = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            start = mid + <span class="number">1</span></span><br><span class="line">    <span class="comment"># 如果不存在这个的话，如果start != -1 and end != len(arr), 那么arr[end] &lt; target &lt; arr[start]</span></span><br><span class="line">    <span class="keyword">if</span> end &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> start</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = find_closest_element([<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], <span class="number">3</span>, <span class="number">7</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = find_closest_element([<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>], <span class="number">3</span>, <span class="number">6</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = find_closest_element([<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>], <span class="number">3</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    <span class="comment"># leetcode对于这个例子的答案是[1,2,3,4]而不是现在输出的[2,3,4,5]，所以需要改一下代码，见下</span></span><br><span class="line">    res = find_closest_element([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line">        </span><br><span class="line"><span class="comment"># ================================leetcode================================</span></span><br><span class="line"><span class="comment"># 修正的就是先全部都塞进去再看，做这种pattern的题目有三种方式</span></span><br><span class="line"><span class="comment"># 1. 先全部塞进去，最后在弹出指定数量作为答案，这样可以保证相同的排序条件，先进去的被取出来</span></span><br><span class="line"><span class="comment"># 2. 先塞进去指定数量，然后每满足条件就替换，如果排序条件已经存在（带比较的数的条件和heap[0]的条件一样），那就不会替换，这样</span></span><br><span class="line"><span class="comment">#    也可以保证答案中会优先包含先进去的数</span></span><br><span class="line"><span class="comment"># 3. 每塞进去一个就判断是不是已经超过了指定长度，如果超过了就弹出一个，这样就会导致相同的排序条件，会优先保留后进来的，这是我们不想要的。</span></span><br><span class="line"><span class="comment">#    所以这道题选择第一种和第二种是合理的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是solution的代码，可以过leetcode</span></span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_closest_element</span>(<span class="params">arr, k, x</span>):</span></span><br><span class="line">    index = binary_search(arr, x)  <span class="comment"># 如果找不到x的话，index不一定一定要是距离x最近的，因为会在index左右在取k的区间，一定会包含答案</span></span><br><span class="line">    low, high = index - k, index + k</span><br><span class="line">    low = <span class="built_in">max</span>(low, <span class="number">0</span>)</span><br><span class="line">    high = <span class="built_in">min</span>(high, <span class="built_in">len</span>(arr) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    min_heap = []</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(low, high + <span class="number">1</span>):</span><br><span class="line">        heappush(min_heap, (<span class="built_in">abs</span>(arr[i] - x), arr[i]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        result.append(heappop(min_heap)[<span class="number">1</span>])</span><br><span class="line">    result.sort()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">arr, target</span>):</span></span><br><span class="line">    start, end = <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> start &lt;= end:</span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> arr[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">if</span> arr[mid] &gt; target:</span><br><span class="line">            end = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            start = mid + <span class="number">1</span></span><br><span class="line">    <span class="comment"># 如果不存在这个的话，如果start != -1 and end != len(arr), 那么arr[end] &lt; target &lt; arr[start]</span></span><br><span class="line">    <span class="keyword">if</span> end &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> start</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = find_closest_element([<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], <span class="number">3</span>, <span class="number">7</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = find_closest_element([<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>], <span class="number">3</span>, <span class="number">6</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = find_closest_element([<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>], <span class="number">3</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = find_closest_element([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line">      </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-7"><a href="#Time-complexity-7" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of the above algorithm is <strong><em>O(logN + K\</em>logK)*</strong>. We need <strong><em>O(logN)</em></strong> for Binary Search and <strong><em>O(K\</em>logK)*</strong> to insert the numbers in the <strong>Min Heap</strong>, as well as to sort the output array.</p><h4 id="Space-complexity-7"><a href="#Space-complexity-7" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity will be <strong><em>O(K)</em></strong>, as we need to put a maximum of <strong><em>2K</em></strong> numbers in the heap.</p><h3 id="Alternate-Solution-using-Two-Pointers"><a href="#Alternate-Solution-using-Two-Pointers" class="headerlink" title="Alternate Solution using Two Pointers"></a>Alternate Solution using Two Pointers</h3><p>After finding the number closest to ‘X’ through <strong>Binary Search</strong>, we can use the <strong>Two Pointers</strong> approach to find the ‘K’ closest numbers. Let’s say the closest number is ‘Y’. We can have a <code>left</code> pointer to move back from ‘Y’ and a <code>right</code> pointer to move forward from ‘Y’. At any stage, whichever number pointed out by the <code>left</code> or the <code>right</code> pointer gives the smaller difference from ‘X’ will be added to our result list.</p><p>To keep the resultant list sorted we can use a <strong>Queue</strong>. So whenever we take the number pointed out by the <code>left</code> pointer, we will append it at the beginning of the list and whenever we take the number pointed out by the <code>right</code> pointer we will append it at the end of the list.</p><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_closest_element</span>(<span class="params">arr, k, x</span>):</span></span><br><span class="line">    result = deque()</span><br><span class="line">    index = binary_search(arr, x)</span><br><span class="line">    <span class="comment"># 如果不存在x,返回的index是x左边的那个数的index(index &gt;=0的时候)</span></span><br><span class="line">    <span class="comment"># 不然就是end，e.g. arr = [2,4,5,7], x = 1</span></span><br><span class="line">    left, right = index, index + <span class="number">1</span></span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        <span class="keyword">if</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; n:</span><br><span class="line">            diff1 = <span class="built_in">abs</span>(x - arr[left])</span><br><span class="line">            diff2 = <span class="built_in">abs</span>(x - arr[right])</span><br><span class="line">            <span class="keyword">if</span> diff1 &lt;= diff2: <span class="comment"># 这里的等于很重要，因为如果排序条件一样，优先返回左边的</span></span><br><span class="line">                result.appendleft(arr[left])</span><br><span class="line">                left -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append(arr[right])</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> left &gt;= <span class="number">0</span>: <span class="comment">#优先left</span></span><br><span class="line">            result.appendleft(arr[left])</span><br><span class="line">            left -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> right &lt; n:</span><br><span class="line">            result.append(arr[right])</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">arr, target</span>):</span></span><br><span class="line">    start, end = <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> start &lt;= end:</span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> arr[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">if</span> arr[mid] &gt; target:</span><br><span class="line">            end = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            start = mid + <span class="number">1</span></span><br><span class="line">    <span class="comment"># 如果不存在这个的话，如果start != -1 and end != len(arr), 那么arr[end] &lt; target &lt; arr[start]</span></span><br><span class="line">    <span class="keyword">if</span> end &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> start</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = find_closest_element([<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], <span class="number">3</span>, <span class="number">7</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = find_closest_element([<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>], <span class="number">3</span>, <span class="number">6</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = find_closest_element([<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>], <span class="number">3</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = find_closest_element([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-8"><a href="#Time-complexity-8" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of the above algorithm is <strong><em>O(logN + K)</em></strong>. We need <strong><em>O(logN)</em></strong> for Binary Search and <strong><em>O(K)</em></strong> for finding the ‘K’ closest numbers using the two pointers.</p><h4 id="Space-complexity-8"><a href="#Space-complexity-8" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>If we ignoring the space required for the output list, the algorithm runs in constant space <strong><em>O(1)</em></strong>.</p><h2 id="Maximum-Distinct-Elements-medium"><a href="#Maximum-Distinct-Elements-medium" class="headerlink" title="Maximum Distinct Elements (medium)"></a>Maximum Distinct Elements (medium)</h2><p>不在leetcode</p><h3 id="Problem-Statement-8"><a href="#Problem-Statement-8" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given an array of numbers and a number ‘K’, we need to remove ‘K’ numbers from the array such that we are left with maximum distinct numbers.</p><p><strong>Example 1:</strong></p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span>], <span class="keyword">and</span> K=<span class="number">2</span></span><br><span class="line">Output: <span class="number">3</span></span><br><span class="line">Explanation: We can <span class="keyword">remove</span> two occurrences <span class="keyword">of</span> <span class="number">3</span> <span class="keyword">to</span> be left <span class="keyword">with</span> <span class="number">3</span> <span class="keyword">distinct</span> numbers [<span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>], we have </span><br><span class="line"><span class="keyword">to</span> <span class="keyword">skip</span> <span class="number">5</span> because it <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">distinct</span> <span class="keyword">and</span> occurred twice. </span><br><span class="line">Another solution could be <span class="keyword">to</span> <span class="keyword">remove</span> one instance <span class="keyword">of</span> <span class="string">&#x27;5&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;3&#x27;</span> <span class="keyword">each</span> <span class="keyword">to</span> be left <span class="keyword">with</span> three </span><br><span class="line"><span class="keyword">distinct</span> numbers [<span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>], <span class="keyword">in</span> this <span class="keyword">case</span>, we have <span class="keyword">to</span> <span class="keyword">skip</span> <span class="number">3</span> because it occurred twice.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Input</span>: [3, 5, 12, 11, 12], and K=3</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: We can remove <span class="keyword">one</span> occurrence of 12, after <span class="keyword">which</span> all numbers will become <span class="keyword">distinct</span>. Then </span><br><span class="line">we can delete any <span class="keyword">two</span> numbers <span class="keyword">which</span> will leave <span class="keyword">us</span> 2 <span class="keyword">distinct</span> numbers <span class="keyword">in</span> the result.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1, 2, 3, 3, 3, 3, 4, 4, 5, 5, 5], <span class="keyword">and</span> <span class="attribute">K</span>=2</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: We can <span class="builtin-name">remove</span> one occurrence of <span class="string">&#x27;4&#x27;</span> <span class="keyword">to</span> <span class="builtin-name">get</span> three distinct numbers.</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-8"><a href="#Try-it-yourself-8" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 思路和solution一样,但是看了之后发现自己不太能实现</span></span><br></pre></td></tr></table></figure><h3 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <em>Top ‘K’ Numbers</em> pattern, and shares similarities with <em>Top ‘K’ Frequent Numbers</em>.</p><p>We can following a similar approach as discussed in <em>Top ‘K’ Frequent Numbers</em> problem:</p><ol><li>First, we will find the frequencies of all the numbers.</li><li>Then, push all numbers that are not distinct (i.e., have a frequency higher than one) in a <strong>Min Heap</strong> based on their frequencies. At the same time, we will keep a running count of all the distinct numbers.</li><li>Following a greedy approach, in a stepwise fashion, we will remove the least frequent number from the heap (i.e., the top element of the min-heap), and try to make it distinct. We will see if we can remove all occurrences of a number except one. If we can, we will increment our running count of distinct numbers. We have to also keep a count of how many removals we have done.</li><li>If after removing elements from the heap, we are still left with some deletions, we have to remove some distinct elements.</li></ol><h3 id="Code-7"><a href="#Code-7" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_max_distinct_elements</span>(<span class="params">nums, k</span>):</span></span><br><span class="line">    distinct_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; k:</span><br><span class="line">        <span class="keyword">return</span> distinct_count</span><br><span class="line">    frequency_map = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        frequency_map[num] = frequency_map.get(num, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    min_heap = []</span><br><span class="line">    <span class="keyword">for</span> num, frequency <span class="keyword">in</span> frequency_map.items():</span><br><span class="line">        <span class="keyword">if</span> frequency == <span class="number">1</span>:</span><br><span class="line">            distinct_count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            heappush(min_heap, (frequency, num))</span><br><span class="line">    <span class="keyword">while</span> k &gt; <span class="number">0</span> <span class="keyword">and</span> min_heap:</span><br><span class="line">        frequency, num = heappop(min_heap)</span><br><span class="line">        <span class="comment"># 题目要求是至多，所以这样写</span></span><br><span class="line">        k -= frequency - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; <span class="number">0</span>:</span><br><span class="line">            distinct_count += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 如果是至少，那就这样写</span></span><br><span class="line">        <span class="comment"># if frequency - 1 &lt;= k:</span></span><br><span class="line">        <span class="comment">#     k -= frequency - 1</span></span><br><span class="line">        <span class="comment">#     distinct_count += 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># if k &gt;0,this means we have to remove some distinct numbers</span></span><br><span class="line">    <span class="comment"># 这个想不到</span></span><br><span class="line">    <span class="keyword">if</span> k &gt; <span class="number">0</span>:</span><br><span class="line">        distinct_count -= k</span><br><span class="line">    <span class="keyword">return</span> distinct_count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = find_max_distinct_elements([<span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span>], <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = find_max_distinct_elements([<span class="number">3</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">12</span>], <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = find_max_distinct_elements([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>], <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-9"><a href="#Time-complexity-9" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>Since we will insert all numbers in a <strong>HashMap</strong> and a <strong>Min Heap</strong>, this will take <strong><em>O(N\</em>logN)*</strong> where ‘N’ is the total input numbers. While extracting numbers from the heap, in the worst case, we will need to take out ‘K’ numbers. This will happen when we have at least ‘K’ numbers with a frequency of two. Since the heap can have a maximum of ‘N/2’ numbers, therefore, extracting an element from the heap will take <strong><em>O(logN)</em></strong> and extracting ‘K’ numbers will take <strong><em>O(KlogN)</em></strong>. So overall, the time complexity of our algorithm will be <strong><em>O(N\</em>logN + KlogN)*</strong>.</p><p>We can optimize the above algorithm and only push ‘K’ elements in the heap, as in the worst case we will be extracting ‘K’ elements from the heap. This optimization will reduce the overall time complexity to <strong><em>O(N\</em>logK + KlogK)*</strong>.</p><h4 id="Space-complexity-9"><a href="#Space-complexity-9" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity will be <strong><em>O(N)</em></strong> as, in the worst case, we need to store all the ‘N’ characters in the <strong>HashMap</strong>.</p><h2 id="Sum-of-Elements-medium"><a href="#Sum-of-Elements-medium" class="headerlink" title="Sum of Elements (medium)"></a>Sum of Elements (medium)</h2><p>不在leetcode</p><h3 id="Problem-Statement-9"><a href="#Problem-Statement-9" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given an array, find the sum of all numbers between the K1’th and K2’th smallest elements of that array.</p><p><strong>Example 1:</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Inpu<span class="variable">t:</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">11</span>], <span class="built_in">and</span> K1=<span class="number">3</span>, K2=<span class="number">6</span></span><br><span class="line">Outpu<span class="variable">t:</span> <span class="number">23</span></span><br><span class="line">Explanation: The <span class="number">3</span>rd smallest <span class="keyword">number</span> <span class="keyword">is</span> <span class="number">5</span> <span class="built_in">and</span> <span class="number">6</span><span class="keyword">th</span> smallest <span class="keyword">number</span> <span class="number">15</span>. The sum of numbers coming</span><br><span class="line">between <span class="number">5</span> <span class="built_in">and</span> <span class="number">15</span> <span class="keyword">is</span> <span class="number">23</span> (<span class="number">11</span>+<span class="number">12</span>).</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Inpu<span class="variable">t:</span> [<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>], <span class="built_in">and</span> K1=<span class="number">1</span>, K2=<span class="number">4</span></span><br><span class="line">Outpu<span class="variable">t:</span> <span class="number">12</span></span><br><span class="line">Explanation: The sum of the numbers between the <span class="number">1</span><span class="keyword">st</span> smallest <span class="keyword">number</span> (<span class="number">3</span>) <span class="built_in">and</span> the <span class="number">4</span><span class="keyword">th</span> smallest </span><br><span class="line"><span class="keyword">number</span> (<span class="number">8</span>) <span class="keyword">is</span> <span class="number">12</span> (<span class="number">5</span>+<span class="number">7</span>).</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-9"><a href="#Try-it-yourself-9" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 直观想到的就是直接sort排序，时间复杂度也是nlogn</span><br></pre></td></tr></table></figure><h3 id="Solution-9"><a href="#Solution-9" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <em>Top ‘K’ Numbers</em> pattern, and shares similarities with <em>Kth Smallest Number</em>.</p><p>We can find the sum of all numbers coming between the K1’th and K2’th smallest numbers in the following steps:</p><ol><li>First, insert all numbers in a min-heap.</li><li>Remove the first <code>K1</code> smallest numbers from the min-heap.</li><li>Now take the next <code>K2-K1-1</code> numbers out of the heap and add them. This sum will be our required output.</li></ol><h3 id="Code-8"><a href="#Code-8" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_sum_of_elements</span>(<span class="params">nums, k1, k2</span>):</span></span><br><span class="line">    min_heap = []</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        heappush(min_heap, num)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k1):</span><br><span class="line">        heappop(min_heap)</span><br><span class="line">    element_sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k2 - k1 - <span class="number">1</span>):</span><br><span class="line">        element_sum += heappop(min_heap)</span><br><span class="line">    <span class="keyword">return</span> element_sum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = find_sum_of_elements([<span class="number">1</span>, <span class="number">3</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">11</span>], <span class="number">3</span>, <span class="number">6</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = find_sum_of_elements([<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>], <span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-10"><a href="#Time-complexity-10" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>Since we need to put all the numbers in a min-heap, the time complexity of the above algorithm will be <strong><em>O(N\</em>logN)*</strong> where ‘N’ is the total input numbers.</p><h4 id="Space-complexity-10"><a href="#Space-complexity-10" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity will be <strong><em>O(N)</em></strong>, as we need to store all the ‘N’ numbers in the heap.</p><h3 id="Alternate-Solution"><a href="#Alternate-Solution" class="headerlink" title="Alternate Solution"></a>Alternate Solution</h3><p>We can iterate the array and use a max-heap to keep track of the top K2 numbers. We can, then, add the top <code>K2-K1-1</code> numbers in the max-heap to find the sum of all numbers coming between the K1’th and K2’th smallest numbers. Here is what the algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_sum_of_elements</span>(<span class="params">nums, k1, k2</span>):</span></span><br><span class="line">    max_heap = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k2 - <span class="number">1</span>):</span><br><span class="line">        heappush(max_heap, -nums[i])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k2 - <span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; -max_heap[<span class="number">0</span>]:</span><br><span class="line">            heappop(max_heap)</span><br><span class="line">            heappush(max_heap, -nums[i])</span><br><span class="line">    element_sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k2 - k1 - <span class="number">1</span>):</span><br><span class="line">        element_sum += -heappop(max_heap)</span><br><span class="line">    <span class="keyword">return</span> element_sum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = find_sum_of_elements([<span class="number">1</span>, <span class="number">3</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">11</span>], <span class="number">3</span>, <span class="number">6</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = find_sum_of_elements([<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>], <span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-11"><a href="#Time-complexity-11" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>Since we need to put only the top K2 numbers in the max-heap at any time, the time complexity of the above algorithm will be <strong><em>O(N\</em>logK2)*</strong>.</p><h4 id="Space-complexity-11"><a href="#Space-complexity-11" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity will be <strong><em>O(K2)</em></strong>, as we need to store the smallest ‘K2’ numbers in the heap.</p><h2 id="Rearrange-String-hard"><a href="#Rearrange-String-hard" class="headerlink" title="*Rearrange String (hard)"></a>*Rearrange String (hard)</h2><p>leetcode 767</p><h3 id="Problem-Statement-10"><a href="#Problem-Statement-10" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given a string, find if its letters can be rearranged in such a way that no two same characters come next to each other.</p><p><strong>Example 1:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> <span class="string">&quot;aappp&quot;</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="string">&quot;papap&quot;</span></span><br><span class="line"><span class="symbol">Explanation:</span> <span class="keyword">In</span> <span class="string">&quot;papap&quot;</span>, none <span class="keyword">of</span> the repeating characters come <span class="keyword">next</span> <span class="keyword">to</span> <span class="keyword">each</span> other.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> <span class="string">&quot;Programming&quot;</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="string">&quot;rgmrgmPiano&quot;</span> <span class="built_in">or</span> <span class="string">&quot;gmringmrPoa&quot;</span> <span class="built_in">or</span> <span class="string">&quot;gmrPagimnor&quot;</span>, etc.</span><br><span class="line"><span class="symbol">Explanation:</span> None <span class="keyword">of</span> the repeating characters come <span class="keyword">next</span> <span class="keyword">to</span> <span class="keyword">each</span> other.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> <span class="string">&quot;aapa&quot;</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="symbol">Explanation:</span> <span class="keyword">In</span> all arrangements of <span class="string">&quot;aapa&quot;</span>, atleast two <span class="string">&#x27;a&#x27;</span> will come together e.g., <span class="string">&quot;apaa&quot;</span>, <span class="string">&quot;paaa&quot;</span>.</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-10"><a href="#Try-it-yourself-10" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不会</span></span><br></pre></td></tr></table></figure><h3 id="Solution-10"><a href="#Solution-10" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <em>Top ‘K’ Numbers</em> pattern. We can follow a greedy approach to find an arrangement of the given string where no two same characters come next to each other.</p><p>We can work in a stepwise fashion to create a string with all characters from the input string. Following a greedy approach, we should first append the most frequent characters to the output strings, for which we can use a <strong>Max Heap</strong>. By appending the most frequent character first, we have the best chance to find a string where no two same characters come next to each other.</p><p>So in each step, we should append one occurrence of the highest frequency character to the output string. We will not put this character back in the heap to ensure that no two same characters are adjacent to each other. In the next step, we should process the next most frequent character from the heap in the same way and then, at the end of this step, insert the character from the previous step back to the heap after decrementing its frequency.</p><p>Following this algorithm, if we can append all the characters from the input string to the output string, we would have successfully found an arrangement of the given string where no two same characters appeared adjacent to each other.</p><h3 id="Code-9"><a href="#Code-9" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rearrange_string</span>(<span class="params">s</span>):</span></span><br><span class="line">    frequency_map = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">        frequency_map[char] = frequency_map.get(char, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    max_heap = []</span><br><span class="line">    <span class="keyword">for</span> char, frequency <span class="keyword">in</span> frequency_map.items():</span><br><span class="line">        heappush(max_heap, (-frequency, char))</span><br><span class="line">    result_string = <span class="string">&quot;&quot;</span></span><br><span class="line">    previous_node = (<span class="number">0</span>, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">while</span> max_heap:</span><br><span class="line">        frequency, char = heappop(max_heap)</span><br><span class="line">        result_string += char</span><br><span class="line">        frequency += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> previous_node[<span class="number">0</span>] &lt; <span class="number">0</span>:</span><br><span class="line">            heappush(max_heap, previous_node)</span><br><span class="line">        previous_node = (frequency, char)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result_string <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="built_in">len</span>(result_string) <span class="keyword">else</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = rearrange_string(<span class="string">&quot;aappp&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = rearrange_string(<span class="string">&quot;Programming&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = rearrange_string(<span class="string">&quot;aapa&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-12"><a href="#Time-complexity-12" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of the above algorithm is <strong><em>O(N\</em>logN)*</strong> where ‘N’ is the number of characters in the input string.</p><h4 id="Space-complexity-12"><a href="#Space-complexity-12" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity will be <strong><em>O(N)</em></strong>, as in the worst case, we need to store all the ‘N’ characters in the <strong>HashMap</strong>.</p><h2 id="Problem-Challenge-1"><a href="#Problem-Challenge-1" class="headerlink" title="Problem Challenge 1"></a>Problem Challenge 1</h2><p>leetcode 会员</p><h3 id="Rearrange-String-K-Distance-Apart-hard"><a href="#Rearrange-String-K-Distance-Apart-hard" class="headerlink" title="Rearrange String K Distance Apart (hard)"></a>Rearrange String K Distance Apart (hard)</h3><p>Given a string and a number ‘K’, find if the string can be rearranged such that the same characters are at least ‘K’ distance apart from each other.</p><p><strong>Example 1:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: <span class="string">&quot;mmpp&quot;</span>, K=<span class="number">2</span></span><br><span class="line"><span class="attribute">Output</span>: <span class="string">&quot;mpmp&quot;</span> or <span class="string">&quot;pmpm&quot;</span></span><br><span class="line"><span class="attribute">Explanation</span>: <span class="literal">All</span> same characters are <span class="number">2</span> distance apart.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> <span class="string">&quot;Programming&quot;</span>, K=<span class="number">3</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="string">&quot;rgmPrgmiano&quot;</span> <span class="keyword">or </span><span class="string">&quot;gmringmrPoa&quot;</span> <span class="keyword">or </span><span class="string">&quot;gmrPagimnor&quot;</span> <span class="keyword">and </span>a few more</span><br><span class="line"><span class="symbol">Explanation:</span> All same characters are <span class="number">3</span> <span class="keyword">distance </span>apart.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: <span class="string">&quot;aab&quot;</span>, K=<span class="number">2</span></span><br><span class="line"><span class="attribute">Output</span>: <span class="string">&quot;aba&quot;</span></span><br><span class="line"><span class="attribute">Explanation</span>: <span class="literal">All</span> same characters are <span class="number">2</span> distance apart.</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> <span class="string">&quot;aappa&quot;</span>, K=<span class="number">3</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="symbol">Explanation:</span> We cannot find an arrangement <span class="keyword">of</span> the <span class="type">string</span> <span class="keyword">where</span> any two <span class="comment">&#x27;a&#x27; are 3 distance apart.</span></span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-11"><a href="#Try-it-yourself-11" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 想法和solution一样</span></span><br></pre></td></tr></table></figure><h3 id="Solution-11"><a href="#Solution-11" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <em>Top ‘K’ Numbers</em> pattern and is quite similar to <em>Rearrange String</em>. The only difference is that in the ‘Rearrange String’ the same characters need not be adjacent i.e., they should be at least ‘2’ distance apart (in other words, there should be at least one character between two same characters), while in the current problem, the same characters should be ‘K’ distance apart.</p><p>Following a similar approach, since we were inserting a character back in the heap in the next iteration, in this problem, we will re-insert the character after ‘K’ iterations. We can keep track of previous characters in a queue to insert them back in the heap after ‘K’ iterations.</p><h3 id="Code-10"><a href="#Code-10" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rearrange_string</span>(<span class="params">s, k</span>):</span></span><br><span class="line">    <span class="keyword">if</span> k &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    frequency_map = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">        frequency_map[char] = frequency_map.get(char, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    max_heap = []</span><br><span class="line">    <span class="keyword">for</span> char, frequency <span class="keyword">in</span> frequency_map.items():</span><br><span class="line">        heappush(max_heap, (-frequency, char))</span><br><span class="line">    result_string = <span class="string">&quot;&quot;</span></span><br><span class="line">    previous_node_queue = deque()</span><br><span class="line">    <span class="keyword">while</span> max_heap:</span><br><span class="line">        frequency, char = heappop(max_heap)</span><br><span class="line">        result_string += char</span><br><span class="line">        frequency += <span class="number">1</span></span><br><span class="line">        previous_node_queue.append((frequency, char))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(previous_node_queue) == k:</span><br><span class="line">            previous_node = previous_node_queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> previous_node[<span class="number">0</span>] &lt; <span class="number">0</span>:</span><br><span class="line">                heappush(max_heap, previous_node)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result_string <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="built_in">len</span>(result_string) <span class="keyword">else</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = rearrange_string(<span class="string">&quot;Programming&quot;</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = rearrange_string(<span class="string">&quot;mmpp&quot;</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = rearrange_string(<span class="string">&quot;aab&quot;</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = rearrange_string(<span class="string">&quot;aapa&quot;</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-13"><a href="#Time-complexity-13" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of the above algorithm is <strong><em>O(N\</em>logN)*</strong> where ‘N’ is the number of characters in the input string.</p><h4 id="Space-complexity-13"><a href="#Space-complexity-13" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity will be <strong><em>O(N)</em></strong>, as in the worst case, we need to store all the ‘N’ characters in the HashMap.</p><h2 id="Problem-Challenge-2"><a href="#Problem-Challenge-2" class="headerlink" title="#Problem Challenge 2"></a>#Problem Challenge 2</h2><p>leetcode 621</p><h3 id="Scheduling-Tasks-hard"><a href="#Scheduling-Tasks-hard" class="headerlink" title="Scheduling Tasks (hard)"></a>Scheduling Tasks (hard)</h3><p>You are given a list of tasks that need to be run, in any order, on a server. Each task will take one CPU interval to execute but once a task has finished, it has a cooling period during which it can’t be run again. If the cooling period for all tasks is ‘K’ intervals, find the minimum number of CPU intervals that the server needs to finish all tasks.</p><p>If at any time the server can’t execute any task then it must stay idle.</p><p><strong>Example 1:</strong></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [a, a, a, b, c, c], K=<span class="number">2</span></span><br><span class="line">Output: <span class="number">7</span></span><br><span class="line">E<span class="function"><span class="title">xplanation</span>: a -&gt;</span> <span class="function"><span class="title">c</span> -&gt;</span> <span class="function"><span class="title">b</span> -&gt;</span> <span class="function"><span class="title">a</span> -&gt;</span> <span class="function"><span class="title">c</span> -&gt;</span> <span class="function"><span class="title">idle</span> -&gt;</span> a</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [a, b, a], K=<span class="number">3</span></span><br><span class="line">Output: <span class="number">5</span></span><br><span class="line">E<span class="function"><span class="title">xplanation</span>: a -&gt;</span> <span class="function"><span class="title">b</span> -&gt;</span> <span class="function"><span class="title">idle</span> -&gt;</span> <span class="function"><span class="title">idle</span> -&gt;</span> a</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-12"><a href="#Try-it-yourself-12" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不会，自己的想法没有做出来</span></span><br></pre></td></tr></table></figure><h3 id="Solution-12"><a href="#Solution-12" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <em>Top ‘K’ Elements</em> pattern and is quite similar to <em>Rearrange String K Distance Apart</em>. We need to rearrange tasks such that same tasks are ‘K’ distance apart.</p><p>Following a similar approach, we will use a <strong>Max Heap</strong> to execute the highest frequency task first. After executing a task we decrease its frequency and put it in a waiting list. In each iteration, we will try to execute as many as <code>k+1</code> tasks. For the next iteration, we will put all the waiting tasks back in the <strong>Max Heap</strong>. If, for any iteration, we are not able to execute <code>k+1</code> tasks, the CPU has to remain idle for the remaining time in the next iteration.</p><h3 id="Code-11"><a href="#Code-11" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">schedule_tasks</span>(<span class="params">tasks, k</span>):</span></span><br><span class="line">    interval_count = <span class="number">0</span></span><br><span class="line">    frequency_map = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> tasks:</span><br><span class="line">        frequency_map[task] = frequency_map.get(task, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    max_heap = []</span><br><span class="line">    <span class="keyword">for</span> task, frequency <span class="keyword">in</span> frequency_map.items():</span><br><span class="line">        heappush(max_heap, (-frequency, task))</span><br><span class="line">    previous_node_queue = deque()</span><br><span class="line">    <span class="keyword">while</span> max_heap:</span><br><span class="line">        n = k + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span> <span class="keyword">and</span> max_heap:</span><br><span class="line">            frequency, task = heappop(max_heap)</span><br><span class="line">            interval_count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> -frequency &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># decrement the frequency and add to the waitlist</span></span><br><span class="line">                previous_node_queue.append((frequency + <span class="number">1</span>, task))</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> previous_node_queue <span class="keyword">and</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            interval_count += n</span><br><span class="line">        <span class="keyword">while</span> previous_node_queue:</span><br><span class="line">            heappush(max_heap, previous_node_queue.popleft())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> interval_count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = schedule_tasks([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = schedule_tasks([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>], <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-14"><a href="#Time-complexity-14" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of the above algorithm is <strong><em>O(N\</em>logN)*</strong> where ‘N’ is the number of tasks. Our <code>while loop</code> will iterate once for each occurrence of the task in the input (i.e. ‘N’) and in each iteration we will remove a task from the heap which will take <strong><em>O(logN)</em></strong> time. Hence the overall time complexity of our algorithm is <strong><em>O(N\</em>logN)*</strong>.</p><h4 id="Space-complexity-14"><a href="#Space-complexity-14" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity will be <strong><em>O(N)</em></strong>, as in the worst case, we need to store all the ‘N’ tasks in the <strong>HashMap</strong>.</p><h2 id="Problem-Challenge-3"><a href="#Problem-Challenge-3" class="headerlink" title="Problem Challenge 3"></a>Problem Challenge 3</h2><p>leetcode 895</p><h3 id="Frequency-Stack-hard"><a href="#Frequency-Stack-hard" class="headerlink" title="Frequency Stack (hard)"></a>Frequency Stack (hard)</h3><p>Design a class that simulates a Stack data structure, implementing the following two operations:</p><ol><li><code>push(int num)</code>: Pushes the number ‘num’ on the stack.</li><li><code>pop()</code>: Returns the most frequent number in the stack. If there is a tie, return the number which was pushed later.</li></ol><p><strong>Example:</strong></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">After following <span class="keyword">push</span> operations: <span class="keyword">push</span>(<span class="number">1</span>), <span class="keyword">push</span>(<span class="number">2</span>), <span class="keyword">push</span>(<span class="number">3</span>), <span class="keyword">push</span>(<span class="number">2</span>), <span class="keyword">push</span>(<span class="number">1</span>), <span class="keyword">push</span>(<span class="number">2</span>), <span class="keyword">push</span>(<span class="number">5</span>)</span><br><span class="line"> </span><br><span class="line"><span class="number">1</span>. <span class="keyword">pop</span>() should <span class="keyword">return</span> <span class="number">2</span>, as it is the most frequent number</span><br><span class="line"><span class="number">2</span>. <span class="keyword">Next</span> <span class="keyword">pop</span>() should <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span>. <span class="keyword">Next</span> <span class="keyword">pop</span>() should <span class="keyword">return</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-13"><a href="#Try-it-yourself-13" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 见下</span></span><br></pre></td></tr></table></figure><h3 id="Solution-13"><a href="#Solution-13" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <em>Top ‘K’ Elements</em> pattern, and shares similarities with <em>Top ‘K’ Frequent Numbers</em>.</p><p>We can use a <strong>Max Heap</strong> to store the numbers. Instead of comparing the numbers we will compare their frequencies so that the root of the heap is always the most frequently occurring number. There are two issues that need to be resolved though:</p><ol><li>How can we keep track of the frequencies of numbers in the heap? When we are pushing a new number to the <strong>Max Heap</strong>, we don’t know how many times the number has already appeared in the <strong>Max Heap</strong>. To resolve this, we will maintain a <strong>HashMap</strong> to store the current frequency of each number. Thus whenever we push a new number in the heap, we will increment its frequency in the HashMap and when we pop, we will decrement its frequency.</li><li>If two numbers have the same frequency, we will need to return the number which was pushed later while popping. To resolve this, we need to attach a sequence number to every number to know which number came first.</li></ol><p>In short, we will keep three things with every number that we push to the heap:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="built_in">number</span><span class="comment"> // value of the number</span></span><br><span class="line"><span class="number">2.</span> frequency<span class="comment"> // current frequency of the number when it was pushed to the heap</span></span><br><span class="line"><span class="number">3.</span> sequenceNumber<span class="comment"> // a sequence number, to know what number came first</span></span><br></pre></td></tr></table></figure><h3 id="Code-12"><a href="#Code-12" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要注意的是，再pop之后，已经再heap中的三元组中的frequency_map[num]的值还是旧的，但是没有问题，因为再占中的顺序不会改变</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num, frequency, sequence_number</span>):</span></span><br><span class="line">        self.num = num</span><br><span class="line">        self.frequency = frequency</span><br><span class="line">        self.sequence_number = sequence_number</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.frequency != other.frequency:</span><br><span class="line">            <span class="keyword">return</span> self.frequency &gt; other.frequency</span><br><span class="line">        <span class="keyword">return</span> self.sequence_number &gt; other.sequence_number</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrequencyStack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.sequence_number = <span class="number">0</span></span><br><span class="line">        self.max_heap = []</span><br><span class="line">        self.frequency_map = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, num</span>):</span></span><br><span class="line">        self.frequency_map[num] = self.frequency_map.get(num, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        heappush(self.max_heap, Element(num, self.frequency_map[num], self.sequence_number))</span><br><span class="line">        self.sequence_number += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        num = heappop(self.max_heap).num</span><br><span class="line">        <span class="keyword">if</span> self.frequency_map[num] &gt; <span class="number">1</span>:</span><br><span class="line">            self.frequency_map[num] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">del</span> self.frequency_map[num]</span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    stack = FrequencyStack()</span><br><span class="line">    stack.push(<span class="number">1</span>)</span><br><span class="line">    stack.push(<span class="number">2</span>)</span><br><span class="line">    stack.push(<span class="number">3</span>)</span><br><span class="line">    stack.push(<span class="number">2</span>)</span><br><span class="line">    stack.push(<span class="number">1</span>)</span><br><span class="line">    stack.push(<span class="number">2</span>)</span><br><span class="line">    stack.push(<span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span>(stack.pop())</span><br><span class="line">    <span class="built_in">print</span>(stack.pop())</span><br><span class="line">    <span class="built_in">print</span>(stack.pop())</span><br><span class="line">    <span class="built_in">print</span>(stack.pop())</span><br><span class="line">    <span class="built_in">print</span>(stack.pop())</span><br><span class="line">    <span class="built_in">print</span>(stack.pop())</span><br><span class="line">    <span class="built_in">print</span>(stack.pop())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"><span class="comment">#=======================leetcode=========================</span></span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrequencyStack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.sequence_number = <span class="number">0</span></span><br><span class="line">        self.max_heap = []</span><br><span class="line">        self.frequency_map = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, num</span>):</span></span><br><span class="line">        self.frequency_map[num] = self.frequency_map.get(num, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        heappush(self.max_heap, (-self.frequency_map[num], -self.sequence_number, num))</span><br><span class="line">        self.sequence_number += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        num = heappop(self.max_heap)[<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">if</span> self.frequency_map[num] &gt; <span class="number">1</span>:</span><br><span class="line">            self.frequency_map[num] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">del</span> self.frequency_map[num]</span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    stack = FrequencyStack()</span><br><span class="line">    stack.push(<span class="number">1</span>)</span><br><span class="line">    stack.push(<span class="number">2</span>)</span><br><span class="line">    stack.push(<span class="number">3</span>)</span><br><span class="line">    stack.push(<span class="number">2</span>)</span><br><span class="line">    stack.push(<span class="number">1</span>)</span><br><span class="line">    stack.push(<span class="number">2</span>)</span><br><span class="line">    stack.push(<span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span>(stack.pop())</span><br><span class="line">    <span class="built_in">print</span>(stack.pop())</span><br><span class="line">    <span class="built_in">print</span>(stack.pop())</span><br><span class="line">    <span class="built_in">print</span>(stack.pop())</span><br><span class="line">    <span class="built_in">print</span>(stack.pop())</span><br><span class="line">    <span class="built_in">print</span>(stack.pop())</span><br><span class="line">    <span class="built_in">print</span>(stack.pop())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>13. Pattern Bitwise XOR</title>
      <link href="/13-pattern-bitwise-xor/index.html"/>
      <url>/13-pattern-bitwise-xor/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>再看这篇文章之前可以看一下<a href="https://zhuanlan.zhihu.com/p/43826007">这个知乎</a></p><p>XOR is a logical bitwise operator that returns 0 (false) if both bits are the same and returns 1 (true) otherwise. In other words, it only returns 1 if exactly one bit is set to 1 out of the two bits in comparison.</p><p><img src="/13-pattern-bitwise-xor/index/1.png"></p><p>It is surprising to know the approaches that the XOR operator enables us to solve certain problems. For example, let’s take a look at the following problem:</p><blockquote><p>Given an array of n-1 integers in the range from 1 to n, find the one number that is missing from the array.</p></blockquote><p><strong>Example:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span></span><br><span class="line"><span class="attribute">Answer</span>: <span class="number">3</span></span><br></pre></td></tr></table></figure><p>A straight forward approach to solve this problem can be:</p><ol><li>Find the sum of all integers from 1 to n; let’s call it <code>s1</code>.</li><li>Subtract all the numbers in the input array from <code>s1</code>; this will give us the missing number.</li></ol><p>Another approach is introduced in <em>6. Pattern Cyclic Sort\3. Find the Missing Number (easy)</em>.</p><p>This is what the algorithm will look like:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MissingNumber</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMissingNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= arr.<span class="built_in">size</span>() + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : arr) &#123;</span><br><span class="line">            sum -= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1 = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Missing number is: &quot;</span> &lt;&lt; MissingNumber::<span class="built_in">findMissingNumber</span>(v1);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Time &amp; Space complexity:</strong> The time complexity of the above algorithm is <strong><em>O(n)</em></strong> and the space complexity is <strong><em>O(1)</em></strong>.</p><h3 id="What-could-go-wrong-with-the-above-algorithm"><a href="#What-could-go-wrong-with-the-above-algorithm" class="headerlink" title="What could go wrong with the above algorithm?"></a>What could go wrong with the above algorithm?</h3><blockquote><p>While finding the sum of numbers from 1 to <em>n</em>, we can get integer overflow when <em>n</em> is large.</p></blockquote><p>How can we avoid this? Can XOR help us here?</p><p>Remember the important property of XOR that it returns 0 if both the bits in comparison are the same. In other words, XOR of a number with itself will always result in 0. This means that if we XOR all the numbers in the input array with all numbers from the range 1 to <em>n</em> then each number in the input is going to get zeroed out except the missing number. Following are the set of steps to find the missing number using XOR:</p><ol><li>XOR all the numbers from 1 to <em>n</em>, let’s call it <code>x1</code>.</li><li>XOR all the numbers in the input array, let’s call it <code>x2</code>.</li><li>The missing number can be found by <code>x1 XOR x2</code>.</li></ol><p>Here is what the algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_missing_num</span>(<span class="params">arr</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(arr) + <span class="number">1</span></span><br><span class="line">    <span class="comment"># x1 presents XOR of all values from 1 to n</span></span><br><span class="line">    x1 = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        x1 ^= i</span><br><span class="line">    <span class="comment"># x2 presents XOR of all values in arr</span></span><br><span class="line">    x2 = arr[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">        x2 ^= arr[i]</span><br><span class="line">    <span class="comment"># 下面这种更好</span></span><br><span class="line">    <span class="comment"># x2 = 0</span></span><br><span class="line">    <span class="comment"># for i in arr:</span></span><br><span class="line">    <span class="comment">#     x2 ^= i</span></span><br><span class="line">    <span class="keyword">return</span> x1 ^ x2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = find_missing_num([<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Time &amp; Space complexity:</strong> The time complexity of the above algorithm is O(n)<em>O</em>(<em>n</em>) and the space complexity is O(1)<em>O</em>(1). The time and space complexities are the same as that of the previous solution but, in this algorithm, we will not have any integer overflow problem.</p><h3 id="Important-properties-of-XOR-to-remember"><a href="#Important-properties-of-XOR-to-remember" class="headerlink" title="Important properties of XOR to remember"></a>Important properties of XOR to remember</h3><p>Following are some important properties of XOR to remember:</p><ul><li>Taking XOR of a number with itself returns 0, e.g.,<ul><li>1 ^ 1 = 0</li><li>29 ^ 29 = 0</li></ul></li><li>Taking XOR of a number with 0 returns the same number, e.g.,<ul><li>1 ^ 0 = 1</li><li>31 ^ 0 = 31</li></ul></li><li>XOR is Associative &amp; Commutative, which means:<ul><li>(a ^ b) ^ c = a ^ (b ^ c)</li><li>a ^ b = b ^ a</li></ul></li></ul><p>In the following chapters, we will apply the XOR pattern to solve some interesting problems.</p><h2 id="Single-Number-easy"><a href="#Single-Number-easy" class="headerlink" title="Single Number (easy)"></a>Single Number (easy)</h2><h3 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>In a non-empty array of integers, every number appears twice except for one, find that single number.</p><p><strong>Example 1:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line"><span class="attribute">Output</span>: <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: <span class="number">7</span>, <span class="number">9</span>, <span class="number">7</span></span><br><span class="line"><span class="attribute">Output</span>: <span class="number">9</span></span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself"><a href="#Try-it-yourself" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_single_num</span>(<span class="params">arr</span>):</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> arr:</span><br><span class="line">        res ^= num</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = find_single_num([<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = find_single_num([<span class="number">7</span>, <span class="number">9</span>, <span class="number">7</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>One straight forward solution can be to use a <strong>HashMap</strong> kind of data structure and iterate through the input:</p><ul><li>If number is already present in <strong>HashMap</strong>, remove it.</li><li>If number is not present in <strong>HashMap</strong>, add it.</li><li>In the end, only number left in the <strong>HashMap</strong> is our required single number.</li></ul><p><strong>Time and space complexity</strong> Time Complexity of the above solution will be <strong><em>O(n)</em></strong> and space complexity will also be <strong><em>O(n)</em></strong>.</p><p>Can we do better than this using the <strong>XOR Pattern</strong>?</p><h4 id="Solution-with-XOR"><a href="#Solution-with-XOR" class="headerlink" title="Solution with XOR"></a>Solution with XOR</h4><p>Recall the following two properties of XOR:</p><ul><li>It returns zero if we take XOR of two same numbers.</li><li>It returns the same number if we XOR with zero.</li></ul><p>So we can XOR all the numbers in the input; duplicate numbers will zero out each other and we will be left with the single number.</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同上</span></span><br></pre></td></tr></table></figure><h4 id="Time-Complexity"><a href="#Time-Complexity" class="headerlink" title="Time Complexity"></a>Time Complexity</h4><p>Time complexity of this solution is <strong><em>O(n)</em></strong> as we iterate through all numbers of the input once.</p><h4 id="Space-Complexity"><a href="#Space-Complexity" class="headerlink" title="Space Complexity"></a>Space Complexity</h4><p>The algorithm runs in constant space <strong><em>O(1)</em></strong>.</p><h2 id="Two-Single-Numbers-medium"><a href="#Two-Single-Numbers-medium" class="headerlink" title="*Two Single Numbers (medium)"></a>*Two Single Numbers (medium)</h2><h3 id="Problem-Statement-1"><a href="#Problem-Statement-1" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>In a non-empty array of numbers, every number appears exactly twice except two numbers that appear only once. Find the two numbers that appear only once.</p><p><strong>Example 1:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>:<span class="meta"> [1, 4, 2, 1, 3, 5, 6, 2, 3, 5]</span></span><br><span class="line"><span class="attribute">Output</span>:<span class="meta"> [4, 6]</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>:<span class="meta"> [2, 1, 3, 2]</span></span><br><span class="line"><span class="attribute">Output</span>:<span class="meta"> [1, 3]</span></span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-1"><a href="#Try-it-yourself-1" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 看solution写的</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_single_num</span>(<span class="params">arr</span>):</span></span><br><span class="line">    n1xn2 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> arr:</span><br><span class="line">        n1xn2 ^= num</span><br><span class="line">    rightmostSetBit = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> rightmostSetBit &amp; n1xn2 == <span class="number">0</span>:</span><br><span class="line">        rightmostSetBit = rightmostSetBit &lt;&lt; <span class="number">1</span></span><br><span class="line">    num1, num2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> arr:</span><br><span class="line">        <span class="keyword">if</span> rightmostSetBit &amp; num == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># the bit is set</span></span><br><span class="line">            num1 ^= num</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># the bit is not set</span></span><br><span class="line">            num2 ^= num</span><br><span class="line">    <span class="keyword">return</span> [num1, num2]</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = find_single_num([<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = find_single_num([<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>This problem is quite similar to <em>Single Number</em>, the only difference is that, in this problem, we have two single numbers instead of one. Can we still use XOR to solve this problem?</p><p>Let’s assume <code>num1</code> and <code>num2</code> are the two single numbers. If we do XOR of all elements of the given array, we will be left with XOR of <code>num1</code> and <code>num2</code> as all other numbers will cancel each other because all of them appeared twice. Let’s call this XOR <code>n1xn2</code>. Now that we have XOR of <code>num1</code> and <code>num2</code>, how can we find these two single numbers?</p><p>As we know that <code>num1</code> and <code>num2</code> are two different numbers, therefore, they should have at least one bit different between them. If a bit in <code>n1xn2</code> is ‘1’, this means that <code>num1</code> and <code>num2</code> have different bits in that place, as we know that we can get ‘1’ only when we do XOR of two different bits, i.e.,</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span><span class="keyword">XOR</span> <span class="number">0</span> = <span class="number">0</span> <span class="keyword">XOR</span> <span class="number">1</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>We can take any bit which is ‘1’ in <code>n1xn2</code> and partition all numbers in the given array into two groups based on that bit. One group will have all those numbers with that bit set to ‘0’ and the other with the bit set to ‘1’. This will ensure that <code>num1</code> will be in one group and <code>num2</code> will be in the other. We can take XOR of all numbers in each group separately to get <code>num1</code> and <code>num2</code>, as all other numbers in each group will cancel each other. Here are the steps of our algorithm:</p><ol><li>Taking XOR of all numbers in the given array will give us XOR of <code>num1</code> and <code>num2</code>, calling this XOR as <code>n1xn2</code>.</li><li>Find any bit which is set in <code>n1xn2</code>. We can take the rightmost bit which is ‘1’. Let’s call this <code>rightmostSetBit</code>.</li><li>Iterate through all numbers of the input array to partition them into two groups based on <code>rightmostSetBit</code>. Take XOR of all numbers in both the groups separately. Both these XORs are our required numbers.</li></ol><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同上</span></span><br></pre></td></tr></table></figure><h4 id="Time-Complexity-1"><a href="#Time-Complexity-1" class="headerlink" title="Time Complexity"></a>Time Complexity</h4><p>The time complexity of this solution is <strong><em>O(n)</em></strong> where ‘n’ is the number of elements in the input array.</p><h4 id="Space-Complexity-1"><a href="#Space-Complexity-1" class="headerlink" title="Space Complexity"></a>Space Complexity</h4><p>The algorithm runs in constant space <strong><em>O(1)</em></strong>.</p><h2 id="Complement-of-Base-10-Number-medium"><a href="#Complement-of-Base-10-Number-medium" class="headerlink" title="*Complement of Base 10 Number (medium)"></a>*Complement of Base 10 Number (medium)</h2><p>leetcode 1009,leetcode的条件是&gt;=0的integer 不是这里的positive</p><h3 id="Problem-Statement-2"><a href="#Problem-Statement-2" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Every non-negative integer N has a binary representation, for example, 8 can be represented as “1000” in binary and 7 as “0111” in binary.</p><p>The complement of a binary representation is the number in binary that we get when we change every 1 to a 0 and every 0 to a 1. For example, the binary complement of “1010” is “0101”.</p><p>For a given <strong>positive number</strong> N in base-10, return the complement of its binary representation as a base-10 integer.</p><p><strong>Example 1:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> <span class="number">8</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="number">7</span></span><br><span class="line"><span class="symbol">Explanation:</span> <span class="number">8</span> <span class="built_in">is</span> <span class="number">1000</span> <span class="keyword">in</span> <span class="keyword">binary</span>, its complement <span class="built_in">is</span> <span class="number">0111</span> <span class="keyword">in</span> <span class="keyword">binary</span>, which <span class="built_in">is</span> <span class="number">7</span> <span class="keyword">in</span> base-<span class="number">10</span>.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> <span class="number">10</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="number">5</span></span><br><span class="line"><span class="symbol">Explanation:</span> <span class="number">10</span> <span class="built_in">is</span> <span class="number">1010</span> <span class="keyword">in</span> <span class="keyword">binary</span>, its complement <span class="built_in">is</span> <span class="number">0101</span> <span class="keyword">in</span> <span class="keyword">binary</span>, which <span class="built_in">is</span> <span class="number">5</span> <span class="keyword">in</span> base-<span class="number">10</span>.</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-2"><a href="#Try-it-yourself-2" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_bitwise_complement</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="comment"># 这个计算位数的查的，chatgpt写的</span></span><br><span class="line">    length = <span class="built_in">len</span>(<span class="built_in">bin</span>(num).lstrip(<span class="string">&#x27;-0b&#x27;</span>))</span><br><span class="line">    bit = <span class="number">1</span></span><br><span class="line">    times = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> times &lt; length:</span><br><span class="line">        num = num ^ bit</span><br><span class="line">        bit = bit &lt;&lt; <span class="number">1</span></span><br><span class="line">        times += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = cal_bitwise_complement(<span class="number">8</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = cal_bitwise_complement(<span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>Recall the following properties of XOR:</p><ol><li>It will return 1 if we take XOR of two different bits i.e. <code>1^0 = 0^1 = 1</code>.</li><li>It will return 0 if we take XOR of two same bits i.e. <code>0^0 = 1^1 = 0</code>. In other words, XOR of two same numbers is 0.</li><li>It returns the same number if we XOR with 0.</li></ol><p>From the above-mentioned first property, we can conclude that XOR of a number with its complement will result in a number that has all of its bits set to 1. For example, the binary complement of “101” is “010”; and if we take XOR of these two numbers, we will get a number with all bits set to 1, i.e., <code>101 ^ 010 = 111</code></p><p>We can write this fact in the following equation:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">number</span><span class="regexp"> ^</span> complement = all_bits_set</span><br></pre></td></tr></table></figure><p>Let’s add ‘number’ on both sides:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">number</span><span class="regexp"> ^</span> number<span class="regexp"> ^</span> complement = number<span class="regexp"> ^</span> all_bits_set</span><br></pre></td></tr></table></figure><p>From the above-mentioned second property:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span>^ complement = number ^ all_bits_set</span><br></pre></td></tr></table></figure><p>From the above-mentioned third property:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">complement</span> = number ^ all_bits_set</span><br></pre></td></tr></table></figure><p>We can use the above fact to find the complement of any number.</p><p><strong>How do we calculate ‘all_bits_set’?</strong> One way to calculate <code>all_bits_set</code> will be to first count the bits required to store the given number. We can then use the fact that for a number which is a complete power of ‘2’ i.e., it can be written as pow(2, n), if we subtract ‘1’ from such a number, we get a number which has ‘n’ least significant bits set to ‘1’. For example, ‘4’ which is a complete power of ‘2’, and ‘3’ (which is one less than 4) has a binary representation of ‘11’ i.e., it has ‘2’ least significant bits set to ‘1’.</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和我的解法类似，但是计算bit_count的方法不一样，计算完count_bit之后的方法也不一样，我是一位一位去XOR， code是整体的XOR</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_bitwise_complement</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="comment"># count number of total bits in num</span></span><br><span class="line">    bit_count, n = <span class="number">0</span>, num</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        bit_count += <span class="number">1</span></span><br><span class="line">        n = n &gt;&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># for a number which is a complete power of &#x27;2’i.e., it can be written as pow(2, n), if we</span></span><br><span class="line">    <span class="comment"># subtract &#x27;1’ from such a number, we get a number which has &#x27;n&#x27; least significant bits set to &#x27;1&#x27;.</span></span><br><span class="line">    <span class="comment"># For example, &#x27;4’ which is a complete power of &#x27;2&#x27;, and &#x27;3’(which is one less than 4) has a binary</span></span><br><span class="line">    <span class="comment"># representation of &#x27;11&#x27;i.e., it has &#x27;2&#x27;least significant bits set to &#x27;1&#x27;</span></span><br><span class="line">    all_bit_set = <span class="built_in">pow</span>(<span class="number">2</span>, bit_count) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> num ^ all_bit_set</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = cal_bitwise_complement(<span class="number">8</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = cal_bitwise_complement(<span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-Complexity-2"><a href="#Time-Complexity-2" class="headerlink" title="Time Complexity"></a>Time Complexity</h4><p>Time complexity of this solution is <strong><em>O(b)</em></strong> where ‘b’ is the number of bits required to store the given number.</p><h4 id="Space-Complexity-2"><a href="#Space-Complexity-2" class="headerlink" title="Space Complexity"></a>Space Complexity</h4><p>Space complexity of this solution is <strong><em>O(1)</em></strong></p><h2 id="Problem-Challenge-1"><a href="#Problem-Challenge-1" class="headerlink" title="#Problem Challenge 1"></a>#Problem Challenge 1</h2><p>leetcode 832</p><h3 id="Problem-Statement-3"><a href="#Problem-Statement-3" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given a binary matrix representing an image, we want to flip the image horizontally, then invert it.</p><p>To flip an image horizontally means that each row of the image is reversed. For example, flipping [0, 1, 1] horizontally results in [1, 1, 0].</p><p>To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0. For example, inverting [1, 1, 0] results in [0, 0, 1].</p><p><strong>Example 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="comment">[</span></span><br><span class="line"><span class="comment">  <span class="comment">[1,0,1]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[1,1,1]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[0,1,1]</span></span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line">Output: <span class="comment">[</span></span><br><span class="line"><span class="comment">  <span class="comment">[0,1,0]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[0,0,0]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[0,0,1]</span></span></span><br><span class="line"><span class="comment">]</span></span><br></pre></td></tr></table></figure><p><strong>Explanation</strong>: First reverse each row: <code>[[1,0,1],[1,1,1],[1,1,0]]</code>. Then, invert the image: <code>[[0,1,0],[0,0,0],[0,0,1]]</code></p><p><strong>Example 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="comment">[</span></span><br><span class="line"><span class="comment">  <span class="comment">[1,1,0,0]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[1,0,0,1]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[0,1,1,1]</span>, </span></span><br><span class="line"><span class="comment">  <span class="comment">[1,0,1,0]</span></span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line">Output: <span class="comment">[</span></span><br><span class="line"><span class="comment">  <span class="comment">[1,1,0,0]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[0,1,1,0]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[0,0,0,1]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[1,0,1,0]</span></span></span><br><span class="line"><span class="comment">]</span></span><br></pre></td></tr></table></figure><p><strong>Explanation</strong>: First reverse each row: <code>[[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]</code>. Then invert the image: <code>[[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</code></p><h3 id="Try-it-yourself-3"><a href="#Try-it-yourself-3" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 看solution写的</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flip_an_invert_image</span>(<span class="params">matrix</span>):</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> matrix:</span><br><span class="line">        C = <span class="built_in">len</span>(row)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>((C + <span class="number">1</span>) // <span class="number">2</span>):</span><br><span class="line">            row[i], row[C - i - <span class="number">1</span>] = row[C - i - <span class="number">1</span>] ^ <span class="number">1</span>, row[i] ^ <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> matrix</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = flip_an_invert_image([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = flip_an_invert_image([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><ul><li><strong>Flip</strong>: We can flip the image in place by replacing <em>ith</em> element from left with the <em>ith</em> element from the right.</li><li><strong>Invert</strong>: We can take XOR of each element with 1. If it is 1 then it will become 0 and if it is 0 then it will become 1.</li></ul><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同上</span></span><br></pre></td></tr></table></figure><h4 id="Time-Complexity-3"><a href="#Time-Complexity-3" class="headerlink" title="Time Complexity"></a>Time Complexity</h4><p>The time complexity of this solution is <strong><em>O(n)</em></strong>as we iterate through all elements of the input.</p><h4 id="Space-Complexity-3"><a href="#Space-Complexity-3" class="headerlink" title="Space Complexity"></a>Space Complexity</h4><p>The space complexity of this solution is <strong><em>O(1)</em></strong>.</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>12. Pattern Modified Binary Search</title>
      <link href="/12-pattern-modified-binary-search/index.html"/>
      <url>/12-pattern-modified-binary-search/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>As we know, whenever we are given a sorted <strong>Array</strong> or <strong>LinkedList</strong> or <strong>Matrix</strong>, and we are asked to find a certain element, the best algorithm we can use is the <a href="https://en.wikipedia.org/wiki/Binary_search_algorithm">Binary Search</a>.</p><p>This pattern describes an efficient way to handle all problems involving <strong>Binary Search</strong>. We will go through a set of problems that will help us build an understanding of this pattern so that we can apply this technique to other problems we might come across in the interviews.</p><p>Let’s start with our first problem.</p><h2 id="Order-agnostic-Binary-Search-easy"><a href="#Order-agnostic-Binary-Search-easy" class="headerlink" title="Order-agnostic Binary Search (easy)"></a>Order-agnostic Binary Search (easy)</h2><p>leetcode 704</p><h3 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given a sorted array of numbers, find if a given number ‘key’ is present in the array. Though we know that the array is sorted, we don’t know if it’s sorted in ascending or descending order. You should assume that the array can have duplicates.</p><p>Write a function to return the index of the ‘key’ if it is present in the array, otherwise return -1.</p><p><strong>Example 1:</strong></p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Input</span>: [4, 6, 10], <span class="meta">key</span> = 10</span><br><span class="line"><span class="meta">Output</span>: 2</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Input</span>: [1, 2, 3, 4, 5, 6, 7], <span class="meta">key</span> = 5</span><br><span class="line"><span class="meta">Output</span>: 4</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Input</span>: [10, 6, 4], <span class="meta">key</span> = 10</span><br><span class="line"><span class="meta">Output</span>: 0</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Input</span>: [10, 6, 4], <span class="meta">key</span> = 4</span><br><span class="line"><span class="meta">Output</span>: 2</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself"><a href="#Try-it-yourself" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">arr, key</span>):</span></span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    end = <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    is_ascending = arr[start] &lt;= arr[end]</span><br><span class="line">    <span class="keyword">while</span> start &lt;= end:</span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> key == arr[mid]:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">if</span> is_ascending:</span><br><span class="line">            <span class="keyword">if</span> key &lt; arr[mid]:</span><br><span class="line">                end = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> key &lt; arr[mid]:</span><br><span class="line">                start = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = binary_search([<span class="number">4</span>, <span class="number">6</span>, <span class="number">10</span>], <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = binary_search([<span class="number">10</span>, <span class="number">6</span>, <span class="number">4</span>], <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>To make things simple, let’s first solve this problem assuming that the input array is sorted in ascending order. Here are the set of steps for <strong>Binary Search</strong>:</p><ol><li>Let’s assume <code>start</code> is pointing to the first index and <code>end</code> is pointing to the last index of the input array (let’s call it <code>arr</code>). This means:</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> end = arr.length - <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ol><li>First, we will find the <code>middle</code> of <code>start</code> and <code>end</code>. An easy way to find the middle would be: middle=(start+end)/2. For <strong>Java and C++</strong>, this equation will work for most cases, but when <code>start</code> or <code>end</code> is large, this equation will give us the wrong result due to integer overflow. Imagine that <code>start</code> is equal to the maximum range of an integer (e.g. for Java: <code>int start = Integer.MAX_VALUE</code>). Now adding anything to <code>start</code> will result in an integer overflow. Since we need to add both the numbers first to evaluate our equation, an overflow might occur. The safest way to find the middle of two numbers without getting an overflow is as follows:</li></ol><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">middle</span>  = <span class="built_in">start</span> + (<span class="keyword">end</span>-<span class="built_in">start</span>)/<span class="number">2</span></span><br></pre></td></tr></table></figure><blockquote><p>The above discussion is not relevant for <strong>Python</strong>, as we don’t have the integer overflow problem in pure Python.</p></blockquote><ol><li><p>Next, we will see if the ‘key’ is equal to the number at index <code>middle</code>. If it is equal we return <code>middle</code> as the required index.</p></li><li><p>If ‘key’ is not equal to number at index</p></li></ol>   <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">middle</span></span><br></pre></td></tr></table></figure><p>   , we have to check two things:</p><ul><li>If <code>key &lt; arr[middle]</code>, then we can conclude that the <code>key</code> will be smaller than all the numbers after index <code>middle</code> as the array is sorted in the ascending order. Hence, we can reduce our search to <code>end = mid - 1</code>.</li><li>If <code>key &gt; arr[middle]</code>, then we can conclude that the <code>key</code> will be greater than all numbers before index <code>middle</code> as the array is sorted in the ascending order. Hence, we can reduce our search to <code>start = mid + 1</code>.</li></ul><ol><li>We will repeat steps 2-4 with new ranges of <code>start</code> to <code>end</code>. If at any time <code>start</code> becomes greater than <code>end</code>, this means that we can’t find the ‘key’ in the input array and we must return ‘-1’.</li></ol><p>Here is the visual representation of <strong>Binary Search</strong> for the Example-2:</p><p><img src="/12-pattern-modified-binary-search/index/1.png"></p><p>If the array is sorted in the descending order, we have to update the step 4 above as:</p><ul><li>If <code>key &gt; arr[middle]</code>, then we can conclude that the <code>key</code> will be greater than all numbers after index <code>middle</code> as the array is sorted in the descending order. Hence, we can reduce our search to <code>end = mid - 1</code>.</li><li>If <code>key &lt; arr[middle]</code>, then we can conclude that the <code>key</code> will be smaller than all the numbers before index <code>middle</code> as the array is sorted in the descending order. Hence, we can reduce our search to <code>start = mid + 1</code>.</li></ul><p>Finally, how can we figure out the sort order of the input array? We can compare the numbers pointed out by <code>start</code> and <code>end</code> index to find the sort order. If <code>arr[start] &lt; arr[end]</code>, it means that the numbers are sorted in ascending order otherwise they are sorted in the descending order.</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和我的思路一样，这里就不在赘述了</span></span><br></pre></td></tr></table></figure><h4 id="Time-complexity"><a href="#Time-complexity" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>Since, we are reducing the search range by half at every step, this means that the time complexity of our algorithm will be <strong><em>O(logN)</em></strong> where ‘N’ is the total elements in the given array.</p><h4 id="Space-complexity"><a href="#Space-complexity" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The algorithm runs in constant space <strong><em>O(1)</em></strong>.</p><h2 id="Ceiling-of-a-Number-medium"><a href="#Ceiling-of-a-Number-medium" class="headerlink" title="Ceiling of a Number (medium)"></a>Ceiling of a Number (medium)</h2><p>不在leetcode</p><h3 id="Problem-Statement-1"><a href="#Problem-Statement-1" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given an array of numbers sorted in an ascending order, find the ceiling of a given number ‘key’. The ceiling of the ‘key’ will be the smallest element in the given array greater than or equal to the ‘key’.</p><p>Write a function to return the index of the ceiling of the ‘key’. If there isn’t any ceiling return -1.</p><p><strong>Example 1:</strong></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [4, 6, 10], <span class="keyword">key</span> = <span class="number">6</span></span><br><span class="line">Output: <span class="number">1</span></span><br><span class="line">Explanation: The smallest <span class="keyword">number</span> greater than <span class="keyword">or</span> equal <span class="keyword">to</span> <span class="string">&#x27;6&#x27;</span> <span class="keyword">is</span> <span class="string">&#x27;6&#x27;</span> <span class="keyword">having</span> <span class="keyword">index</span> <span class="string">&#x27;1&#x27;</span>.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1, 3, 8, 10, <span class="number">15</span>], <span class="keyword">key</span> = <span class="number">12</span></span><br><span class="line">Output: <span class="number">4</span></span><br><span class="line">Explanation: The smallest <span class="keyword">number</span> greater than <span class="keyword">or</span> equal <span class="keyword">to</span> <span class="string">&#x27;12&#x27;</span> <span class="keyword">is</span> <span class="string">&#x27;15&#x27;</span> <span class="keyword">having</span> <span class="keyword">index</span> <span class="string">&#x27;4&#x27;</span>.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> [<span class="number">4</span>, <span class="number">6</span>, <span class="number">10</span>], <span class="keyword">key</span> = <span class="number">17</span></span><br><span class="line"><span class="symbol">Output:</span> -<span class="number">1</span></span><br><span class="line"><span class="symbol">Explanation:</span> There <span class="built_in">is</span> no number greater than <span class="built_in">or</span> equal <span class="keyword">to</span> <span class="comment">&#x27;17&#x27; in the given array.</span></span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [4, 6, 10], <span class="keyword">key</span> = <span class="number">-1</span></span><br><span class="line">Output: <span class="number">0</span></span><br><span class="line">Explanation: The smallest <span class="keyword">number</span> greater than <span class="keyword">or</span> equal <span class="keyword">to</span> <span class="string">&#x27;-1&#x27;</span> <span class="keyword">is</span> <span class="string">&#x27;4&#x27;</span> <span class="keyword">having</span> <span class="keyword">index</span> <span class="string">&#x27;0&#x27;</span>.</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-1"><a href="#Try-it-yourself-1" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果不存在key,那么推出循环的时候arr[start] &gt; key &gt; arr[end]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_ceiling_of_a_num</span>(<span class="params">arr, key</span>):</span></span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    end = <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    mid = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> start &lt;= end:</span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> key == arr[mid]:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">if</span> key &lt; arr[mid]:</span><br><span class="line">            end = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            start = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> arr[mid] &gt; key:</span><br><span class="line">        <span class="keyword">return</span> mid</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> mid + <span class="number">1</span> <span class="keyword">if</span> mid &lt; <span class="built_in">len</span>(arr) - <span class="number">1</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = search_ceiling_of_a_num([<span class="number">4</span>, <span class="number">6</span>, <span class="number">10</span>], <span class="number">6</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = search_ceiling_of_a_num([<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">15</span>], <span class="number">12</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = search_ceiling_of_a_num([<span class="number">4</span>, <span class="number">6</span>, <span class="number">10</span>], <span class="number">17</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = search_ceiling_of_a_num([<span class="number">4</span>, <span class="number">6</span>, <span class="number">10</span>], -<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <strong>Binary Search</strong> pattern. Since Binary Search helps us find a number in a sorted array efficiently, we can use a modified version of the Binary Search to find the ceiling of a number.</p><p>We can use a similar approach as discussed in <em>Order-agnostic Binary Search</em>. We will try to search for the ‘key’ in the given array. If we find the ‘key’, we return its index as the ceiling. If we can’t find the ‘key’, the next big number will be pointed out by the index <code>start</code>. Consider Example-2 mentioned above:</p><p><img src="/12-pattern-modified-binary-search/index/2.png"></p><p>Since we are always adjusting our range to find the ‘key’, when we exit the loop, the start of our range will point to the smallest number greater than the ‘key’ as shown in the above picture.</p><p>We can add a check in the beginning to see if the ‘key’ is bigger than the biggest number in the input array. If so, we can return ‘-1’.</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_ceiling_of_a_num</span>(<span class="params">arr, key</span>):</span></span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    end = <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> key &gt; arr[-<span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> start &lt;= end:</span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> key == arr[mid]:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">if</span> key &lt; arr[mid]:</span><br><span class="line">            end = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            start = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = search_ceiling_of_a_num([<span class="number">4</span>, <span class="number">6</span>, <span class="number">10</span>], <span class="number">6</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = search_ceiling_of_a_num([<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">15</span>], <span class="number">12</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = search_ceiling_of_a_num([<span class="number">4</span>, <span class="number">6</span>, <span class="number">10</span>], <span class="number">17</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = search_ceiling_of_a_num([<span class="number">4</span>, <span class="number">6</span>, <span class="number">10</span>], -<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-1"><a href="#Time-complexity-1" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>Since we are reducing the search range by half at every step, this means that the time complexity of our algorithm will be <strong><em>O(logN)</em></strong> where ‘N’ is the total elements in the given array.</p><h4 id="Space-complexity-1"><a href="#Space-complexity-1" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The algorithm runs in constant space <strong><em>O(1)</em></strong>.</p><hr><h3 id="Similar-Problems"><a href="#Similar-Problems" class="headerlink" title="Similar Problems"></a>Similar Problems</h3><h4 id="Problem-1"><a href="#Problem-1" class="headerlink" title="Problem 1"></a>Problem 1</h4><p>Given an array of numbers sorted in ascending order, find the floor of a given number ‘key’. The floor of the ‘key’ will be the biggest element in the given array smaller than or equal to the ‘key’</p><p>Write a function to return the index of the floor of the ‘key’. If there isn’t a floor, return -1.</p><p><strong>Example 1:</strong></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [4, 6, 10], <span class="keyword">key</span> = <span class="number">6</span></span><br><span class="line">Output: <span class="number">1</span></span><br><span class="line">Explanation: The biggest <span class="keyword">number</span> smaller than <span class="keyword">or</span> equal <span class="keyword">to</span> <span class="string">&#x27;6&#x27;</span> <span class="keyword">is</span> <span class="string">&#x27;6&#x27;</span> <span class="keyword">having</span> <span class="keyword">index</span> <span class="string">&#x27;1&#x27;</span>.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1, 3, 8, 10, <span class="number">15</span>], <span class="keyword">key</span> = <span class="number">12</span></span><br><span class="line">Output: <span class="number">3</span></span><br><span class="line">Explanation: The biggest <span class="keyword">number</span> smaller than <span class="keyword">or</span> equal <span class="keyword">to</span> <span class="string">&#x27;12&#x27;</span> <span class="keyword">is</span> <span class="string">&#x27;10&#x27;</span> <span class="keyword">having</span> <span class="keyword">index</span> <span class="string">&#x27;3&#x27;</span>.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [4, 6, 10], <span class="keyword">key</span> = <span class="number">17</span></span><br><span class="line">Output: <span class="number">2</span></span><br><span class="line">Explanation: The biggest <span class="keyword">number</span> smaller than <span class="keyword">or</span> equal <span class="keyword">to</span> <span class="string">&#x27;17&#x27;</span> <span class="keyword">is</span> <span class="string">&#x27;10&#x27;</span> <span class="keyword">having</span> <span class="keyword">index</span> <span class="string">&#x27;2&#x27;</span>.</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> [<span class="number">4</span>, <span class="number">6</span>, <span class="number">10</span>], <span class="keyword">key</span> = -<span class="number">1</span></span><br><span class="line"><span class="symbol">Output:</span> -<span class="number">1</span></span><br><span class="line"><span class="symbol">Explanation:</span> There <span class="built_in">is</span> no number smaller than <span class="built_in">or</span> equal <span class="keyword">to</span> <span class="comment">&#x27;-1&#x27; in the given array.</span></span><br></pre></td></tr></table></figure><h4 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h4><p>The code is quite similar to the above solution; only the highlighted lines have changed:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_ceiling_of_a_num</span>(<span class="params">arr, key</span>):</span></span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    end = <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> key &lt; arr[<span class="number">0</span>]:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> start &lt;= end:</span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> key == arr[mid]:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">if</span> key &lt; arr[mid]:</span><br><span class="line">            end = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            start = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = search_ceiling_of_a_num([<span class="number">4</span>, <span class="number">6</span>, <span class="number">10</span>], <span class="number">6</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = search_ceiling_of_a_num([<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">15</span>], <span class="number">12</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = search_ceiling_of_a_num([<span class="number">4</span>, <span class="number">6</span>, <span class="number">10</span>], <span class="number">17</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = search_ceiling_of_a_num([<span class="number">4</span>, <span class="number">6</span>, <span class="number">10</span>], -<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Next-Letter-medium"><a href="#Next-Letter-medium" class="headerlink" title="Next Letter (medium)"></a>Next Letter (medium)</h2><p>leetcode 744</p><h3 id="Problem-Statement-2"><a href="#Problem-Statement-2" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given an array of lowercase letters sorted in ascending order, find the <strong>smallest letter</strong> in the given array <strong>greater than a given ‘key’</strong>.</p><p>Assume the given array is a <strong>circular list</strong>, which means that the last letter is assumed to be connected with the first letter. This also means that the smallest letter in the given array is greater than the last letter of the array and is also the first letter of the array.</p><p>Write a function to return the next letter of the given ‘key’.</p><p><strong>Example 1:</strong></p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Input</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;h&#x27;</span>], <span class="meta">key</span> = <span class="string">&#x27;f&#x27;</span></span><br><span class="line"><span class="meta">Output</span>: <span class="string">&#x27;h&#x27;</span></span><br><span class="line">Explanation: The smallest letter greater than <span class="string">&#x27;f&#x27;</span> is <span class="string">&#x27;h&#x27;</span> <span class="meta">in</span> the given <span class="meta">array</span>.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;h&#x27;</span>], key = <span class="string">&#x27;b&#x27;</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="string">&#x27;c&#x27;</span></span><br><span class="line"><span class="symbol">Explanation:</span> The smallest letter greater than <span class="string">&#x27;b&#x27;</span> is <span class="string">&#x27;c&#x27;</span>.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Input</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;h&#x27;</span>], key = <span class="string">&#x27;m&#x27;</span></span><br><span class="line">Output: <span class="string">&#x27;a&#x27;</span></span><br><span class="line">Explanation: <span class="keyword">As</span> the <span class="keyword">array</span> <span class="keyword">is</span> assumed <span class="keyword">to</span> be circular, the smallest letter greater than <span class="string">&#x27;m&#x27;</span> <span class="keyword">is</span> <span class="string">&#x27;a&#x27;</span>.</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Input</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;h&#x27;</span>], key = <span class="string">&#x27;h&#x27;</span></span><br><span class="line">Output: <span class="string">&#x27;a&#x27;</span></span><br><span class="line">Explanation: <span class="keyword">As</span> the <span class="keyword">array</span> <span class="keyword">is</span> assumed <span class="keyword">to</span> be circular, the smallest letter greater than <span class="string">&#x27;h&#x27;</span> <span class="keyword">is</span> <span class="string">&#x27;a&#x27;</span>.</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-2"><a href="#Try-it-yourself-2" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_next_letter</span>(<span class="params">letters, key</span>):</span></span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    end = <span class="built_in">len</span>(letters) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> key &gt;= letters[-<span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">return</span> letters[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">while</span> start &lt;= end:</span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> key == letters[mid]:</span><br><span class="line">            <span class="keyword">if</span> mid == <span class="built_in">len</span>(letters) - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> letters[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">return</span> letters[mid + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> key &lt; letters[mid]:</span><br><span class="line">            end = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            start = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> letters[start]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = search_next_letter([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;h&#x27;</span>], <span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = search_next_letter([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;h&#x27;</span>], <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = search_next_letter([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;h&#x27;</span>], <span class="string">&#x27;m&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = search_next_letter([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;h&#x27;</span>], <span class="string">&#x27;h&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>The problem follows the <strong>Binary Search</strong> pattern. Since <strong>Binary Search</strong> helps us find an element in a sorted array efficiently, we can use a modified version of it to find the next letter.</p><p>We can use a similar approach as discussed in <em>Ceiling of a Number</em>. There are a couple of differences though:</p><ol><li>The array is considered circular, which means if the ‘key’ is bigger than the last letter of the array or if it is smaller than the first letter of the array, the key’s next letter will be the first letter of the array.</li><li>The other difference is that we have to find the next biggest letter which can’t be equal to the ‘key’. This means that we will ignore the case where <code>key == arr[middle]</code>. To handle this case, we can update our start range to <code>start = middle +1</code>.</li></ol><p>In the end, instead of returning the element pointed out by <code>start</code>, we have to return the letter pointed out by <code>start % array_length</code>. This is needed because of point 2 discussed above. Imagine that the last letter of the array is equal to the ‘key’. In that case, we have to return the first letter of the input array.</p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like; the most important changes are in the highlighted lines:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和code不一样  但是过了leetcode</span></span><br><span class="line"><span class="comment"># 如果存在多个key,那么推出循环的时候letters[start] = key &gt; letters[end]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_next_letter</span>(<span class="params">letters, key</span>):</span></span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    end = <span class="built_in">len</span>(letters) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> key &gt;= letters[-<span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">return</span> letters[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">while</span> start &lt;= end:</span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> key &lt; letters[mid]:</span><br><span class="line">            end = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># key &gt;= leters[mid]</span></span><br><span class="line">            <span class="comment"># 要是把key == letters[mid] 单独提出来，像我上面写的，会有问题</span></span><br><span class="line">            <span class="comment"># 比如这个例子[&quot;e&quot;, &quot;e&quot;, &quot;e&quot;, &quot;e&quot;, &quot;e&quot;, &quot;e&quot;, &quot;n&quot;, &quot;n&quot;, &quot;n&quot;, &quot;n&quot;], &#x27;e&#x27;</span></span><br><span class="line">            start = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> letters[start]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = search_next_letter([<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;h&#x27;</span>], <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = search_next_letter([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;h&#x27;</span>], <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = search_next_letter([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;h&#x27;</span>], <span class="string">&#x27;m&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = search_next_letter([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;h&#x27;</span>], <span class="string">&#x27;h&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = search_next_letter([<span class="string">&quot;e&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;n&quot;</span>, <span class="string">&quot;n&quot;</span>, <span class="string">&quot;n&quot;</span>, <span class="string">&quot;n&quot;</span>], <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-2"><a href="#Time-complexity-2" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>Since, we are reducing the search range by half at every step, this means that the time complexity of our algorithm will be <strong><em>O(logN)</em></strong> where ‘N’ is the total elements in the given array.</p><h4 id="Space-complexity-2"><a href="#Space-complexity-2" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The algorithm runs in constant space <strong><em>O(1)</em></strong>.</p><h2 id="Number-Range-medium"><a href="#Number-Range-medium" class="headerlink" title="#Number Range (medium)"></a>#Number Range (medium)</h2><p>leetcode 34</p><h3 id="Problem-Statement-3"><a href="#Problem-Statement-3" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given an array of numbers sorted in ascending order, find the range of a given number ‘key’. The range of the ‘key’ will be the first and last position of the ‘key’ in the array.</p><p>Write a function to return the range of the ‘key’. If the ‘key’ is not present return [-1, -1].</p><p><strong>Example 1:</strong></p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Input</span>: [4, 6, 6, 6, 9], <span class="meta">key</span> = 6</span><br><span class="line"><span class="meta">Output</span>: [1, 3]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Input</span>: [1, 3, 8, 10, 15], <span class="meta">key</span> = 10</span><br><span class="line"><span class="meta">Output</span>: [3, 3]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Input</span>: [1, 3, 8, 10, 15], <span class="meta">key</span> = 12</span><br><span class="line"><span class="meta">Output</span>: [-1, -1]</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-3"><a href="#Try-it-yourself-3" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个方法找不到正确的range_start,但是range_end是正确的</span></span><br><span class="line"><span class="comment"># 如果存在多个key,那么推出循环的时候letters[start] = key &gt; letters[end]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_range</span>(<span class="params">arr, key</span>):</span></span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    end = <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    find = <span class="literal">False</span></span><br><span class="line">    range_start, range_end = -<span class="number">1</span>, -<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> start &lt;= end:</span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> key &lt; arr[mid]:</span><br><span class="line">            end = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> key == arr[mid]:</span><br><span class="line">                find = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">if</span> range_start == -<span class="number">1</span>:</span><br><span class="line">                    range_start = mid</span><br><span class="line">            start = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> find:</span><br><span class="line">        <span class="keyword">return</span> [range_start, end]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = find_range([<span class="number">4</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">9</span>], <span class="number">6</span>)</span><br><span class="line">    <span class="built_in">print</span>((res))</span><br><span class="line">    res = find_range([<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">15</span>], <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>((res))</span><br><span class="line">    res = find_range([<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">15</span>], <span class="number">12</span>)</span><br><span class="line">    <span class="built_in">print</span>((res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>The problem follows the <strong>Binary Search</strong> pattern. Since Binary Search helps us find a number in a sorted array efficiently, we can use a modified version of the Binary Search to find the first and the last position of a number.</p><p>We can use a similar approach as discussed in <em>Order-agnostic Binary Search</em>. We will try to search for the ‘key’ in the given array; if the ‘key’ is found (i.e. <code>key == arr[middle</code>) we have two options:</p><ol><li>When trying to find the first position of the ‘key’, we can update <code>end = middle - 1</code> to see if the key is present before <code>middle</code>.</li><li>When trying to find the last position of the ‘key’, we can update <code>start = middle + 1</code> to see if the key is present after <code>middle</code>.</li></ol><p>In both cases, we will keep track of the last position where we found the ‘key’. These positions will be the required range.</p><h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_range</span>(<span class="params">arr, key</span>):</span></span><br><span class="line">    result = [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">    result[<span class="number">0</span>] = binary_search(arr, key, <span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">if</span> result[<span class="number">0</span>] != -<span class="number">1</span>:</span><br><span class="line">        result[<span class="number">1</span>] = binary_search(arr, key, <span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">arr, key, findMaxIndex</span>):</span></span><br><span class="line">    key_index = -<span class="number">1</span></span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    end = <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> start &lt;= end:</span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> key == arr[mid]:</span><br><span class="line">            key_index = mid</span><br><span class="line">            <span class="keyword">if</span> findMaxIndex:</span><br><span class="line">                start = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> key &lt; arr[mid]:</span><br><span class="line">            end = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            start = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> key_index</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = find_range([<span class="number">4</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">9</span>], <span class="number">6</span>)</span><br><span class="line">    <span class="built_in">print</span>((res))</span><br><span class="line">    res = find_range([<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">15</span>], <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>((res))</span><br><span class="line">    res = find_range([<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">15</span>], <span class="number">12</span>)</span><br><span class="line">    <span class="built_in">print</span>((res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-3"><a href="#Time-complexity-3" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>Since, we are reducing the search range by half at every step, this means that the time complexity of our algorithm will be <strong><em>O(logN)</em></strong> where ‘N’ is the total elements in the given array.</p><h4 id="Space-complexity-3"><a href="#Space-complexity-3" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The algorithm runs in constant space <strong><em>O(1)</em></strong>.</p><h2 id="Search-in-a-Sorted-Infinite-Array-medium"><a href="#Search-in-a-Sorted-Infinite-Array-medium" class="headerlink" title="#Search in a Sorted Infinite Array (medium)"></a>#Search in a Sorted Infinite Array (medium)</h2><p>leetcode 会员</p><h3 id="Problem-Statement-4"><a href="#Problem-Statement-4" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given an infinite sorted array (or an array with unknown size), find if a given number ‘key’ is present in the array. Write a function to return the index of the ‘key’ if it is present in the array, otherwise return -1.</p><p>Since it is not possible to define an array with infinite (unknown) size, you will be provided with an interface <code>ArrayReader</code> to read elements of the array. ArrayReader.get(index) will return the number at index; if the array’s size is smaller than the index, it will return <code>Integer.MAX_VALUE</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> [<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">22</span>, <span class="number">24</span>, <span class="number">26</span>, <span class="number">28</span>, <span class="number">30</span>], <span class="keyword">key</span> = <span class="number">16</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="number">6</span></span><br><span class="line"><span class="symbol">Explanation:</span> The <span class="keyword">key</span> <span class="built_in">is</span> present at index <span class="comment">&#x27;6&#x27; in the array.</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> [<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">22</span>, <span class="number">24</span>, <span class="number">26</span>, <span class="number">28</span>, <span class="number">30</span>], <span class="keyword">key</span> = <span class="number">11</span></span><br><span class="line"><span class="symbol">Output:</span> -<span class="number">1</span></span><br><span class="line"><span class="symbol">Explanation:</span> The <span class="keyword">key</span> <span class="built_in">is</span> <span class="built_in">not</span> present <span class="keyword">in</span> the array.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">15</span>], <span class="keyword">key</span> = <span class="number">15</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">Explanation:</span> The <span class="keyword">key</span> <span class="built_in">is</span> present at index <span class="comment">&#x27;4&#x27; in the array.</span></span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">15</span>], <span class="keyword">key</span> = <span class="number">200</span></span><br><span class="line"><span class="symbol">Output:</span> -<span class="number">1</span></span><br><span class="line"><span class="symbol">Explanation:</span> The <span class="keyword">key</span> <span class="built_in">is</span> <span class="built_in">not</span> present <span class="keyword">in</span> the array.</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-4"><a href="#Try-it-yourself-4" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我的想法是使用O(n)的时间复杂度，也就是一个一个读取，然后遍历</span></span><br></pre></td></tr></table></figure><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><p>The problem follows the <strong>Binary Search</strong> pattern. Since Binary Search helps us find a number in a sorted array efficiently, we can use a modified version of the Binary Search to find the ‘key’ in an infinite sorted array.</p><p>The only issue with applying binary search in this problem is that we don’t know the bounds of the array. To handle this situation, we will first find the proper bounds of the array where we can perform a binary search.</p><p>An efficient way to find the proper bounds is to start at the beginning of the array with the bound’s size as ‘1’ and exponentially increase the bound’s size (i.e., double it) until we find the bounds that can have the key.</p><p>Consider Example-1 mentioned above:</p><p><img src="/12-pattern-modified-binary-search/index/3.png"></p><p>Once we have searchable bounds we can apply the binary search.</p><h3 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayReader</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, arr</span>):</span></span><br><span class="line">        self.arr = arr</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="keyword">if</span> index &gt;= <span class="built_in">len</span>(self.arr):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.arr[index]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_in_infinite_array</span>(<span class="params">reader, key</span>):</span></span><br><span class="line">    <span class="comment"># find the proper bounds first</span></span><br><span class="line">    start, end = <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> reader.get(end) &lt; key:</span><br><span class="line">        new_start = end + <span class="number">1</span></span><br><span class="line">        end += (end - start + <span class="number">1</span>) * <span class="number">2</span></span><br><span class="line">        start = new_start</span><br><span class="line">    <span class="keyword">return</span> binary_search(reader, key, start, end)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">reader, key, start, end</span>):</span></span><br><span class="line">    <span class="keyword">while</span> start &lt;= end:</span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> reader.get(mid) == key:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> reader.get(mid) &gt; key:</span><br><span class="line">            end = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            start = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    reader = ArrayReader([<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">22</span>, <span class="number">24</span>, <span class="number">26</span>, <span class="number">28</span>, <span class="number">30</span>])</span><br><span class="line">    res = search_in_infinite_array(reader, <span class="number">16</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    reader = ArrayReader([<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">22</span>, <span class="number">24</span>, <span class="number">26</span>, <span class="number">28</span>, <span class="number">30</span>])</span><br><span class="line">    res = search_in_infinite_array(reader, <span class="number">11</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    reader = ArrayReader([<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">15</span>])</span><br><span class="line">    res = search_in_infinite_array(reader, <span class="number">15</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    reader = ArrayReader([<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">15</span>])</span><br><span class="line">    res = search_in_infinite_array(reader, <span class="number">200</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-4"><a href="#Time-complexity-4" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>There are two parts of the algorithm. In the first part, we keep increasing the bound’s size exponentially (double it every time) while searching for the proper bounds. Therefore, this step will take <strong><em>O(logN)</em></strong> assuming that the array will have maximum ‘N’ numbers. In the second step, we perform the binary search which will take <strong><em>O(logN)</em></strong>, so the overall time complexity of our algorithm will be <strong><em>O(logN + logN)</em></strong> which is asymptotically equivalent to <strong><em>O(logN)</em></strong>.</p><h4 id="Space-complexity-4"><a href="#Space-complexity-4" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The algorithm runs in constant space <strong><em>O(1)</em></strong>.</p><h2 id="Minimum-Difference-Element-medium"><a href="#Minimum-Difference-Element-medium" class="headerlink" title="Minimum Difference Element (medium)"></a>Minimum Difference Element (medium)</h2><p>不在leetcode</p><h3 id="Problem-Statement-5"><a href="#Problem-Statement-5" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given an array of numbers sorted in ascending order, find the element in the array that has the minimum difference with the given ‘key’.</p><p><strong>Example 1:</strong></p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [4, 6, 10], key = 7</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: The difference between the key &#x27;7&#x27;<span class="built_in"> and </span>&#x27;6&#x27; is minimum than any other number in the<span class="built_in"> array </span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Input</span>: [4, 6, 10], <span class="meta">key</span> = 4</span><br><span class="line"><span class="meta">Output</span>: 4</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Input</span>: [1, 3, 8, 10, 15], <span class="meta">key</span> = 12</span><br><span class="line"><span class="meta">Output</span>: 10</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Input</span>: [4, 6, 10], <span class="meta">key</span> = 17</span><br><span class="line"><span class="meta">Output</span>: 10</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-5"><a href="#Try-it-yourself-5" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_min_diff_element</span>(<span class="params">nums, key</span>):</span></span><br><span class="line">    <span class="keyword">if</span> key &lt;= nums[<span class="number">0</span>]:</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> key &gt;= nums[-<span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">return</span> nums[-<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 下面是solution写法 但是我的写法也可以</span></span><br><span class="line">    <span class="comment"># n = len(nums)</span></span><br><span class="line">    <span class="comment"># if key &gt;= nums[n - 1]:</span></span><br><span class="line">    <span class="comment">#     return nums[n - 1]</span></span><br><span class="line">    start, end = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> start &lt;= end:</span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == key:</span><br><span class="line">            <span class="keyword">return</span> nums[mid]</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; key:</span><br><span class="line">            end = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            start = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">abs</span>(nums[start] - key) &lt; <span class="built_in">abs</span>(nums[end] - key):</span><br><span class="line">        <span class="keyword">return</span> nums[start]</span><br><span class="line">    <span class="keyword">return</span> nums[end]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = search_min_diff_element([<span class="number">4</span>, <span class="number">6</span>, <span class="number">10</span>], <span class="number">7</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = search_min_diff_element([<span class="number">4</span>, <span class="number">6</span>, <span class="number">10</span>], <span class="number">4</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = search_min_diff_element([<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">15</span>], <span class="number">12</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = search_min_diff_element([<span class="number">4</span>, <span class="number">6</span>, <span class="number">10</span>], <span class="number">17</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><p>The problem follows the <strong>Binary Search</strong> pattern. Since Binary Search helps us find a number in a sorted array efficiently, we can use a modified version of the Binary Search to find the number that has the minimum difference with the given ‘key’.</p><p>We can use a similar approach as discussed in <em>Order-agnostic Binary Search</em>. We will try to search for the ‘key’ in the given array. If we find the ‘key’ we will return it as the minimum difference number. If we can’t find the ‘key’, (at the end of the loop) we can find the differences between the ‘key’ and the numbers pointed out by indices <code>start</code> and <code>end</code>, as these two numbers will be closest to the ‘key’. The number that gives minimum difference will be our required number.</p><h3 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和我写的一样</span></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-5"><a href="#Time-complexity-5" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>Since, we are reducing the search range by half at every step, this means the time complexity of our algorithm will be <strong><em>O(logN)</em></strong> where ‘N’ is the total elements in the given array.</p><h4 id="Space-complexity-5"><a href="#Space-complexity-5" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The algorithm runs in constant space <strong><em>O(1)</em></strong>.</p><h2 id="Bitonic-Array-Maximum-easy"><a href="#Bitonic-Array-Maximum-easy" class="headerlink" title="#Bitonic Array Maximum (easy)"></a>#Bitonic Array Maximum (easy)</h2><p>leetcode 852</p><h3 id="Problem-Statement-6"><a href="#Problem-Statement-6" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Find the maximum value in a given Bitonic array. An array is considered bitonic if it is monotonically increasing and then monotonically decreasing. Monotonically increasing or decreasing means that for any index <code>i</code> in the array <code>arr[i] != arr[i+1]</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1, 3, 8, 12, 4, 2]</span><br><span class="line">Output: 12</span><br><span class="line">Explanation: The maximum number in the input bitonic<span class="built_in"> array </span>is &#x27;12&#x27;.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>:<span class="meta"> [3, 8, 3, 1]</span></span><br><span class="line"><span class="attribute">Output</span>: <span class="number">8</span></span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>:<span class="meta"> [1, 3, 8, 12]</span></span><br><span class="line"><span class="attribute">Output</span>: <span class="number">12</span></span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>:<span class="meta"> [10, 9, 8]</span></span><br><span class="line"><span class="attribute">Output</span>: <span class="number">10</span></span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-6"><a href="#Try-it-yourself-6" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 只会使用<span class="built_in">O</span>(n)复杂度计算，也就是直接遍历</span><br></pre></td></tr></table></figure><h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h3><p>A bitonic array is a sorted array; the only difference is that its first part is sorted in ascending order and the second part is sorted in descending order. We can use a similar approach as discussed in <em>Order-agnostic Binary Search</em>. Since no two consecutive numbers are same (as the array is monotonically increasing or decreasing), whenever we calculate the <code>middle</code>, we can compare the numbers pointed out by the index <code>middle</code> and <code>middle+1</code> to find if we are in the ascending or the descending part. So:</p><ol><li>If <code>arr[middle] &gt; arr[middle + 1]</code>, we are in the second (descending) part of the bitonic array. Therefore, our required number could either be pointed out by <code>middle</code> or will be before <code>middle</code>. This means we will be doing: <code>end = middle</code>.</li><li>If <code>arr[middle] &lt;= arr[middle + 1]</code>, we are in the first (ascending) part of the bitonic array. Therefore, the required number will be after <code>middle</code>. This means we will be doing: <code>start = middle + 1</code>.</li></ol><p>We can break when <code>start == end</code>. Due to the two points mentioned above, both <code>start</code> and <code>end</code> will be pointing at the maximum number of the bitonic array.</p><h3 id="Code-7"><a href="#Code-7" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_max_in_bitonic_array</span>(<span class="params">nums</span>):</span></span><br><span class="line">    start, end = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="comment"># 注意这里是&lt;,而不是&lt;=,不然会死循环</span></span><br><span class="line">    <span class="keyword">while</span> start &lt; end:</span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; nums[mid + <span class="number">1</span>]:</span><br><span class="line">            end = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            start = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> nums[start]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = find_max_in_bitonic_array([<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">2</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = find_max_in_bitonic_array([<span class="number">3</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = find_max_in_bitonic_array([<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">12</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = find_max_in_bitonic_array([<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-6"><a href="#Time-complexity-6" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>Since we are reducing the search range by half at every step, this means that the time complexity of our algorithm will be <strong><em>O(logN)</em></strong> where ‘N’ is the total elements in the given array.</p><h4 id="Space-complexity-6"><a href="#Space-complexity-6" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The algorithm runs in constant space <strong><em>O(1)</em></strong>.</p><h2 id="Problem-Challenge-1"><a href="#Problem-Challenge-1" class="headerlink" title="Problem Challenge 1"></a>Problem Challenge 1</h2><p>不在leetcode</p><h3 id="Search-Bitonic-Array-medium"><a href="#Search-Bitonic-Array-medium" class="headerlink" title="Search Bitonic Array (medium)"></a>Search Bitonic Array (medium)</h3><p>Given a Bitonic array, find if a given ‘key’ is present in it. An array is considered bitonic if it is monotonically increasing and then monotonically decreasing. Monotonically increasing or decreasing means that for any index <code>i</code> in the array <code>arr[i] != arr[i+1]</code>.</p><p>Write a function to return the index of the ‘key’. If the ‘key’ is not present, return -1.</p><p><strong>Example 1:</strong></p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Input</span>: [1, 3, 8, 4, 3], <span class="meta">key</span>=4</span><br><span class="line"><span class="meta">Output</span>: 3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Input</span>: [3, 8, 3, 1], <span class="meta">key</span>=8</span><br><span class="line"><span class="meta">Output</span>: 1</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Input</span>: [1, 3, 8, 12], <span class="meta">key</span>=12</span><br><span class="line"><span class="meta">Output</span>: 3</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Input</span>: [10, 9, 8], <span class="meta">key</span>=10</span><br><span class="line"><span class="meta">Output</span>: 0</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-7"><a href="#Try-it-yourself-7" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_bitonic_array</span>(<span class="params">nums, key</span>):</span></span><br><span class="line">    max_index = find_max(nums)</span><br><span class="line">    key_index = binary_search(nums, key, <span class="number">0</span>, max_index)</span><br><span class="line">    <span class="keyword">if</span> key_index != -<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> key_index</span><br><span class="line">    <span class="keyword">return</span> binary_search(nums, key, max_index + <span class="number">1</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_max</span>(<span class="params">nums</span>):</span></span><br><span class="line">    start, end = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> start &lt; end:</span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; nums[mid + <span class="number">1</span>]:</span><br><span class="line">            end = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            start = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">nums, key, start, end</span>):</span></span><br><span class="line">    <span class="keyword">while</span> start &lt;= end:</span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> key == nums[mid]:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; key:</span><br><span class="line">            start = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            end = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = search_bitonic_array([<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">3</span>], <span class="number">4</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = search_bitonic_array([<span class="number">3</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>], <span class="number">8</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = search_bitonic_array([<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">12</span>], <span class="number">12</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = search_bitonic_array([<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>], <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = search_bitonic_array([<span class="number">3</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">16</span>], <span class="number">16</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h3><p>The problem follows the <strong>Binary Search</strong> pattern. Since Binary Search helps us efficiently find a number in a sorted array we can use a modified version of the Binary Search to find the ‘key’ in the bitonic array.</p><p>Here is how we can search in a bitonic array:</p><ol><li>First, we can find the index of the maximum value of the bitonic array, similar to <em>Bitonic Array Maximum</em>. Let’s call the index of the maximum number <code>maxIndex</code>.</li><li>Now, we can break the array into two sub-arrays:<ul><li>Array from index ‘0’ to <code>maxIndex</code>, sorted in ascending order.</li><li>Array from index <code>maxIndex+1</code> to <code>array_length-1</code>, sorted in descending order.</li></ul></li><li>We can then call <strong>Binary Search</strong> separately in these two arrays to search the ‘key’. We can use the same <em>Order-agnostic Binary Search</em> for searching.</li></ol><h3 id="Code-8"><a href="#Code-8" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_bitonic_array</span>(<span class="params">nums, key</span>):</span></span><br><span class="line">    max_index = find_max(nums)</span><br><span class="line">    key_index = binary_search(nums, key, <span class="number">0</span>, max_index)</span><br><span class="line">    <span class="keyword">if</span> key_index != -<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> key_index</span><br><span class="line">    <span class="comment"># max_index + 1 也可以，如果没有右边的区间，就会返回-1</span></span><br><span class="line">    <span class="keyword">return</span> binary_search(nums, key, max_index + <span class="number">1</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_max</span>(<span class="params">nums</span>):</span></span><br><span class="line">    start, end = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> start &lt; end:</span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; nums[mid + <span class="number">1</span>]:</span><br><span class="line">            end = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            start = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">nums, key, start, end</span>):</span></span><br><span class="line">    <span class="keyword">while</span> start &lt;= end:</span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> key == nums[mid]:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; key:</span><br><span class="line">            start = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            end = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = search_bitonic_array([<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">3</span>], <span class="number">4</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = search_bitonic_array([<span class="number">3</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>], <span class="number">8</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = search_bitonic_array([<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">12</span>], <span class="number">12</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = search_bitonic_array([<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>], <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = search_bitonic_array([<span class="number">3</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">16</span>], <span class="number">16</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-7"><a href="#Time-complexity-7" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>Since we are reducing the search range by half at every step, this means that the time complexity of our algorithm will be <strong><em>O(logN)</em></strong> where ‘N’ is the total elements in the given array.</p><h4 id="Space-complexity-7"><a href="#Space-complexity-7" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The algorithm runs in constant space <strong><em>O(1)</em></strong>.</p><h2 id="Problem-Challenge-2"><a href="#Problem-Challenge-2" class="headerlink" title="Problem Challenge 2"></a>Problem Challenge 2</h2><p>leetcode 33</p><h3 id="Search-in-Rotated-Array-medium"><a href="#Search-in-Rotated-Array-medium" class="headerlink" title="Search in Rotated Array (medium)"></a>Search in Rotated Array (medium)</h3><p>Given an array of numbers which is sorted in ascending order and also rotated by some arbitrary number, find if a given ‘key’ is present in it.</p><p>Write a function to return the index of the ‘key’ in the rotated array. If the ‘key’ is not present, return -1. <strong>You can assume that the given array does not have any duplicates.</strong></p><p><strong>Example 1:</strong></p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [10, 15, 1, 3, 8], key = 15</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: &#x27;15&#x27; is present in the<span class="built_in"> array </span>at index &#x27;1&#x27;.</span><br></pre></td></tr></table></figure><p><img src="/12-pattern-modified-binary-search/index/4.png"></p><p><strong>Example 2:</strong></p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [4, 5, 7, 9, 10, -1, 2], key = 10</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: &#x27;10&#x27; is present in the<span class="built_in"> array </span>at index &#x27;4&#x27;.</span><br></pre></td></tr></table></figure><p><img src="/12-pattern-modified-binary-search/index/5.png"></p><h3 id="Try-it-yourself-8"><a href="#Try-it-yourself-8" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h3><p>The problem follows the <strong>Binary Search</strong> pattern. We can use a similar approach as discussed in <em>Order-agnostic Binary Search</em> and modify it similar to <em>Search Bitonic Array</em> to search for the ‘key’ in the rotated array.</p><p>After calculating the <code>middle</code>, we can compare the numbers at indices <code>start</code> and <code>middle</code>. This will give us two options:</p><ol><li>If <code>arr[start] &lt;= arr[middle]</code>, the numbers from <code>start</code> to <code>middle</code> are sorted in ascending order.</li><li>Else, the numbers from <code>middle+1</code> to <code>end</code> are sorted in ascending order.</li></ol><p>Once we know which part of the array is sorted, it is easy to adjust our ranges. For example, if option-1 is true, we have two choices:</p><ol><li>By comparing the ‘key’ with the numbers at index <code>start</code> and <code>middle</code> we can easily find out if the ‘key’ lies between indices <code>start</code> and <code>middle</code>; if it does, we can skip the second part =&gt; <code>end = middle -1</code>.</li><li>Else, we can skip the first part =&gt; <code>start = middle + 1</code>.</li></ol><p>Let’s visually see this with the above-mentioned Example-2:</p><p><img src="/12-pattern-modified-binary-search/index/6.png"></p><h3 id="Code-9"><a href="#Code-9" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_rotated_array</span>(<span class="params">nums, key</span>):</span></span><br><span class="line">    start, end = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> start &lt;= end:</span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == key:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="comment"># 注意 虽然题目中说没有重复的数字，但是这里还是&lt;= 不然这个用例失败：[3,1] key = 1</span></span><br><span class="line">        <span class="keyword">if</span> nums[start] &lt;= nums[mid]: <span class="comment"># 左边升序</span></span><br><span class="line">            <span class="keyword">if</span> nums[start] &lt;= key &lt; nums[mid]:</span><br><span class="line">                end = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 右边降序</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; key &lt;= nums[end]:</span><br><span class="line">                start = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = search_rotated_array([<span class="number">10</span>, <span class="number">15</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>], <span class="number">15</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = search_rotated_array([<span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, -<span class="number">1</span>, <span class="number">2</span>], <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-8"><a href="#Time-complexity-8" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>Since we are reducing the search range by half at every step, this means that the time complexity of our algorithm will be <strong><em>O(logN)</em></strong> where ‘N’ is the total elements in the given array.</p><h4 id="Space-complexity-8"><a href="#Space-complexity-8" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The algorithm runs in constant space <strong><em>O(1)</em></strong>.</p><h3 id="Similar-Problems-1"><a href="#Similar-Problems-1" class="headerlink" title="Similar Problems"></a>Similar Problems</h3><h4 id="Problem-1-1"><a href="#Problem-1-1" class="headerlink" title="Problem 1"></a>Problem 1</h4><p>How do we search in a sorted and rotated array that also has duplicates?</p><p>The code above will fail in the following example!</p><p><strong>Example 1:</strong></p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [3, 7, 3, 3, 3], key = 7</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: &#x27;7&#x27; is present in the<span class="built_in"> array </span>at index &#x27;1&#x27;.</span><br></pre></td></tr></table></figure><p><img src="/12-pattern-modified-binary-search/index/7.png"></p><h4 id="Solution-9"><a href="#Solution-9" class="headerlink" title="Solution"></a>Solution</h4><p>The only problematic scenario is when the numbers at indices <code>start</code>, <code>middle</code>, and <code>end</code> are the same, as in this case, we can’t decide which part of the array is sorted. In such a case, the best we can do is to skip one number from both ends: <code>start = start + 1</code> &amp; <code>end = end - 1</code>.</p><h4 id="Code-10"><a href="#Code-10" class="headerlink" title="Code"></a>Code</h4><p>The code is quite similar to the above solution. Only the highlighted lines have changed:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_rotated_array</span>(<span class="params">nums, key</span>):</span></span><br><span class="line">    start, end = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> start &lt;= end:</span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == key:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="comment"># this is the only difference from the previous solution</span></span><br><span class="line">        <span class="comment"># if numbers at indices start, mid, and end are same, we can&#x27;t choose a side</span></span><br><span class="line">        <span class="comment"># the best we can do is to skip one number from both ends as key != arr[mid]</span></span><br><span class="line">        <span class="keyword">if</span> nums[start] == nums[mid] <span class="keyword">and</span> nums[mid] == nums[end]:</span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line">            end -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 注意 虽然题目中说没有重复的数字，但是这里还是&lt;= 不然这个用例失败：[3,1] key = 1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[start] &lt;= nums[mid]:  <span class="comment"># 左边升序</span></span><br><span class="line">            <span class="keyword">if</span> nums[start] &lt;= key &lt; nums[mid]:</span><br><span class="line">                end = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 右边降序</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; key &lt;= nums[end]:</span><br><span class="line">                start = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = search_rotated_array([<span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>], <span class="number">7</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-9"><a href="#Time-complexity-9" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>This algorithm will run most of the times in <strong><em>O(logN)</em></strong>. However, since we only skip two numbers in case of duplicates instead of half of the numbers, the worst case time complexity will become <strong><em>O(N)</em></strong>.</p><h4 id="Space-complexity-9"><a href="#Space-complexity-9" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The algorithm runs in constant space <strong><em>O(1)</em></strong>.</p><h2 id="Problem-Challenge-3"><a href="#Problem-Challenge-3" class="headerlink" title="Problem Challenge 3"></a>Problem Challenge 3</h2><p>leetcode 153</p><h3 id="Rotation-Count-medium"><a href="#Rotation-Count-medium" class="headerlink" title="Rotation Count (medium)"></a>Rotation Count (medium)</h3><p>Given an array of numbers which is sorted in ascending order and is rotated ‘k’ times around a pivot, find ‘k’.</p><p><strong>You can assume that the array does not have any duplicates.</strong></p><p><strong>Example 1:</strong></p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [10, 15, 1, 3, 8]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The<span class="built_in"> array </span>has been rotated 2 times.</span><br></pre></td></tr></table></figure><p><img src="/12-pattern-modified-binary-search/index/8.png"></p><p><strong>Example 2:</strong></p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [4, 5, 7, 9, 10, -1, 2]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The<span class="built_in"> array </span>has been rotated 5 times.</span><br></pre></td></tr></table></figure><p><img src="/12-pattern-modified-binary-search/index/9.png"></p><p><strong>Example 3:</strong></p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1, 3, 8, 10]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The<span class="built_in"> array </span>has been<span class="built_in"> not </span>been rotated.</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-9"><a href="#Try-it-yourself-9" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不会</span></span><br></pre></td></tr></table></figure><h3 id="Solution-10"><a href="#Solution-10" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <strong>Binary Search</strong> pattern. We can use a similar strategy as discussed in <a href="https://www.educative.io/collection/page/5668639101419520/5671464854355968/5141325911425024/">Search in Rotated Array</a>.</p><p>In this problem, actually, we are asked to find the index of the minimum element. The number of times the minimum element is moved to the right will be equal to the number of rotations. An interesting fact about the minimum element is that it is the only element in the given array which is smaller than its previous element. Since the array is sorted in ascending order, all other elements are bigger than their previous element.</p><p>After calculating the <code>middle</code>, we can compare the number at index <code>middle</code> with its previous and next number. This will give us two options:</p><ol><li>If <code>arr[middle] &gt; arr[middle + 1]</code>, then the element at <code>middle + 1</code> is the smallest.</li><li>If <code>arr[middle - 1] &gt; arr[middle]</code>, then the element at <code>middle</code> is the smallest.</li></ol><p>To adjust the ranges we can follow the same approach as discussed in <em>Search in Rotated Array</em>. Comparing the numbers at indices <code>start</code> and <code>middle</code> will give us two options:</p><ol><li>If <code>arr[start] &lt; arr[middle]</code>, the numbers from <code>start</code> to <code>middle</code> are sorted.</li><li>Else, the numbers from <code>middle + 1</code> to <code>end</code> are sorted.</li></ol><h3 id="Code-11"><a href="#Code-11" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_rotations</span>(<span class="params">nums</span>):</span></span><br><span class="line">    start, end = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> start &lt;= end:</span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        <span class="comment"># if mid is greater than the next element</span></span><br><span class="line">        <span class="keyword">if</span> mid &lt; end <span class="keyword">and</span> nums[mid] &gt; nums[mid + <span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> mid + <span class="number">1</span></span><br><span class="line">        <span class="comment"># if mid is smaller than the previous element</span></span><br><span class="line">        <span class="keyword">if</span> mid &gt; start <span class="keyword">and</span> nums[mid] &lt; nums[mid - <span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">if</span> nums[start] &lt;= nums[mid]:  <span class="comment"># left side is sorted, so pivot is on the right side</span></span><br><span class="line">            start = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># right side is sorted, so pivot is on the left side</span></span><br><span class="line">            end = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = count_rotations([<span class="number">10</span>, <span class="number">15</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = count_rotations([<span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, -<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = count_rotations([<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">10</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-10"><a href="#Time-complexity-10" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>Since we are reducing the search range by half at every step, this means that the time complexity of our algorithm will be <strong><em>O(logN)</em></strong> where ‘N’ is the total elements in the given array.</p><h4 id="Space-complexity-10"><a href="#Space-complexity-10" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The algorithm runs in constant space <strong><em>O(1)</em></strong>.</p><h3 id="Similar-Problems-2"><a href="#Similar-Problems-2" class="headerlink" title="Similar Problems"></a>Similar Problems</h3><h4 id="Problem-1-2"><a href="#Problem-1-2" class="headerlink" title="Problem 1"></a>Problem 1</h4><p>How do we find the rotation count of a sorted and rotated array that has duplicates too?</p><p>The above code will fail on the following example!</p><p><strong>Example 1:</strong></p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [3, 3, 7, 3]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The<span class="built_in"> array </span>has been rotated 3 times</span><br></pre></td></tr></table></figure><p><strong>Solution</strong><br>We can follow the same approach as discussed in <em>Search in Rotated Array</em>. The only difference is that before incrementing <code>start</code> or decrementing <code>end</code>, we will check if either of them is the smallest number.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_rotations</span>(<span class="params">nums</span>):</span></span><br><span class="line">    start, end = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> start &lt;= end:</span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        <span class="comment"># if mid is greater than the next element</span></span><br><span class="line">        <span class="keyword">if</span> mid &lt; end <span class="keyword">and</span> nums[mid] &gt; nums[mid + <span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> mid + <span class="number">1</span></span><br><span class="line">        <span class="comment"># if mid is smaller than the previous element</span></span><br><span class="line">        <span class="keyword">if</span> mid &gt; start <span class="keyword">and</span> nums[mid] &lt; nums[mid - <span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="comment"># this is the only difference from the previous solution</span></span><br><span class="line">        <span class="comment"># if numbers at indices start, mid, and end are same, we can&#x27;t choose a side</span></span><br><span class="line">        <span class="comment"># the best we can do is to skip one number from both ends if they are not the smallest number</span></span><br><span class="line">        <span class="keyword">if</span> nums[start] == nums[mid] <span class="keyword">and</span> nums[mid] == nums[end]:</span><br><span class="line">            <span class="keyword">if</span> nums[start] &gt; nums[start + <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> start + <span class="number">1</span></span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[end] &lt; nums[end - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> end</span><br><span class="line">            end -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[start] &lt;= nums[mid]:  <span class="comment"># left side is sorted, so pivot is on the right side</span></span><br><span class="line">            start = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># right side is sorted, so pivot is on the left side</span></span><br><span class="line">            end = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = count_rotations([<span class="number">3</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-11"><a href="#Time-complexity-11" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>This algorithm will run in <strong><em>O(logN)</em></strong> most of the times, but since we only skip two numbers in case of duplicates instead of the half of the numbers, therefore the worst case time complexity will become <strong><em>O(N)</em></strong>.</p><h4 id="Space-complexity-11"><a href="#Space-complexity-11" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The algorithm runs in constant space <strong><em>O(1)</em></strong>.</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>11. Pattern Subsets</title>
      <link href="/11-pattern-subsets/index.html"/>
      <url>/11-pattern-subsets/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>A huge number of coding interview problems involve dealing with <a href="https://en.wikipedia.org/wiki/Permutation">Permutations</a> and <a href="https://en.wikipedia.org/wiki/Combination">Combinations</a> of a given set of elements. This pattern describes an efficient <strong>Breadth First Search (BFS)</strong> approach to handle all these problems.</p><p>Let’s jump onto our first problem to develop an understanding of this pattern.</p><h2 id="Subsets-easy"><a href="#Subsets-easy" class="headerlink" title="*Subsets (easy)"></a>*Subsets (easy)</h2><p>leetcode 78</p><h3 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given a set with <strong>distinct</strong> elements, find all of its distinct subsets.</p><p><strong>Example 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="comment">[1, 3]</span></span><br><span class="line">Output: <span class="comment">[]</span>, <span class="comment">[1]</span>, <span class="comment">[3]</span>, <span class="comment">[1,3]</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="comment">[1, 5, 3]</span></span><br><span class="line">Output: <span class="comment">[]</span>, <span class="comment">[1]</span>, <span class="comment">[5]</span>, <span class="comment">[3]</span>, <span class="comment">[1,5]</span>, <span class="comment">[1,3]</span>, <span class="comment">[5,3]</span>, <span class="comment">[1,5,3]</span></span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself"><a href="#Try-it-yourself" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 这是看了solution写的</span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interval</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, start, end</span>):</span></span><br><span class="line">        self.start = start</span><br><span class="line">        self.end = end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_subsets</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="comment"># subsets = [[]] 这一句等于下面这两句</span></span><br><span class="line">    subsets = []</span><br><span class="line">    subsets.append([])</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        n = <span class="built_in">len</span>(subsets)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 这里的list很重要，这样才是重新复制了一个</span></span><br><span class="line">            tmp = <span class="built_in">list</span>(subsets[i])</span><br><span class="line">            tmp.append(num)</span><br><span class="line">            subsets.append(tmp)</span><br><span class="line">    <span class="keyword">return</span> subsets</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = find_subsets([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = find_subsets([<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>To generate all subsets of the given set, we can use the <strong>Breadth First Search (BFS)</strong> approach. We can start with an empty set, iterate through all numbers one-by-one, and add them to existing sets to create new subsets.</p><p>Let’s take the example-2 mentioned above to go through each step of our algorithm:</p><p>Given set: [1, 5, 3]</p><ol><li>Start with an empty set: [[]]</li><li>Add the first number (1) to all the existing subsets to create new subsets: [[], <strong>[1]]</strong>;</li><li>Add the second number (5) to all the existing subsets: [[], [1], <strong>[5], [1,5]</strong>];</li><li>Add the third number (3) to all the existing subsets: [[], [1], [5], [1,5], <strong>[3], [1,3], [5,3], [1,5,3]</strong>].</li></ol><p>Here is the visual representation of the above steps:</p><p><img src="/11-pattern-subsets/index/1.png"></p><p>Since the input set has distinct elements, the above steps will ensure that we will not have any duplicate subsets.</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如上</span></span><br></pre></td></tr></table></figure><h4 id="Time-complexity"><a href="#Time-complexity" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>Since, in each step, the number of subsets doubles as we add each element to all the existing subsets, the time complexity of the above algorithm is <strong><em>O(2^N)</em></strong>, where ‘N’ is the total number of elements in the input set. This also means that, in the end, we will have a total of <strong><em>O(2^N)</em></strong> subsets.</p><h4 id="Space-complexity"><a href="#Space-complexity" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>All the additional space used by our algorithm is for the output list. Since we will have a total of <strong><em>O(2^N)</em></strong> subsets, the space complexity of our algorithm is also <strong><em>O(2^N)</em></strong>.</p><h2 id="Subsets-With-Duplicates-easy"><a href="#Subsets-With-Duplicates-easy" class="headerlink" title="Subsets With Duplicates (easy)"></a>Subsets With Duplicates (easy)</h2><p>leetcode 90</p><h3 id="Problem-Statement-1"><a href="#Problem-Statement-1" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given a set of numbers that <strong>might contain duplicates</strong>, find all of its <strong>distinct</strong> subsets.</p><p><strong>Example 1:l9</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="comment">[1, 3, 3]</span></span><br><span class="line">Output: <span class="comment">[]</span>, <span class="comment">[1]</span>, <span class="comment">[3]</span>, <span class="comment">[1,3]</span>, <span class="comment">[3,3]</span>, <span class="comment">[1,3,3]</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="comment">[1, 5, 3, 3]</span></span><br><span class="line">Output: <span class="comment">[]</span>, <span class="comment">[1]</span>, <span class="comment">[5]</span>, <span class="comment">[3]</span>, <span class="comment">[1,5]</span>, <span class="comment">[1,3]</span>, <span class="comment">[5,3]</span>, <span class="comment">[1,5,3]</span>, <span class="comment">[3,3]</span>, <span class="comment">[1,3,3]</span>, <span class="comment">[3,3,5]</span>, <span class="comment">[1,5,3,3]</span> </span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-1"><a href="#Try-it-yourself-1" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 看了solution写的，测试用例过了，但是是有点问题的</span></span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interval</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, start, end</span>):</span></span><br><span class="line">        self.start = start</span><br><span class="line">        self.end = end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_subsets</span>(<span class="params">nums</span>):</span></span><br><span class="line">    nums.sort()</span><br><span class="line">    <span class="comment"># subsets = [[]] 这一句等于下面这两句</span></span><br><span class="line">    subsets = []</span><br><span class="line">    subsets.append([])</span><br><span class="line">    previous_stop_len = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        n = <span class="built_in">len</span>(subsets)</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(previous_stop_len, <span class="built_in">len</span>(subsets)):</span><br><span class="line">                <span class="comment"># 这里的list很重要，这样才是重新复制了一个</span></span><br><span class="line">                tmp = <span class="built_in">list</span>(subsets[j])</span><br><span class="line">                tmp.append(nums[i])</span><br><span class="line">                subsets.append(tmp)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="comment"># 这里的list很重要，这样才是重新复制了一个</span></span><br><span class="line">                tmp = <span class="built_in">list</span>(subsets[j])</span><br><span class="line">                tmp.append(nums[i])</span><br><span class="line">                subsets.append(tmp)</span><br><span class="line">        previous_stop_len = n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> subsets</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = find_subsets([<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = find_subsets([<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <em>Subsets</em> pattern and we can follow a similar <strong>Breadth First Search (BFS)</strong> approach. The only additional thing we need to do is handle duplicates. Since the given set can have duplicate numbers, if we follow the same approach discussed in <em>Subsets</em>, we will end up with duplicate subsets, which is not acceptable. To handle this, we will do two extra things:</p><ol><li>Sort all numbers of the given set. This will ensure that all duplicate numbers are next to each other.</li><li>Follow the same BFS approach but whenever we are about to process a duplicate (i.e., when the current and the previous numbers are same), instead of adding the current number (which is a duplicate) to all the existing subsets, only add it to the subsets which were created in the previous step.</li></ol><p>Let’s take Example-2 mentioned above to go through each step of our algorithm:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Given <span class="keyword">se</span><span class="variable">t:</span> [<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span>]  </span><br><span class="line">Sorted <span class="keyword">se</span><span class="variable">t:</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><ol><li>Start with an empty set: [[]]</li><li>Add the first number (1) to all the existing subsets to create new subsets: [[], [1]];</li><li>Add the second number (3) to all the existing subsets: [[], [1], [3], [1,3]].</li><li>The next number (3) is a duplicate. If we add it to all existing subsets we will get:</li></ol><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">[<span class="comment">[]</span>, <span class="comment">[1]</span>, <span class="comment">[3]</span>, <span class="comment">[1,3]</span>, <span class="comment">[3]</span>, <span class="comment">[1,3]</span>, <span class="comment">[3,3]</span>, <span class="comment">[1,3,3]</span>]</span></span><br><span class="line">We got two duplicate subsets: <span class="comment">[3]</span>, <span class="comment">[1,3]</span>  </span><br><span class="line">Whereas we only needed the new subsets: <span class="comment">[3,3]</span>, <span class="comment">[1,3,3]</span>  </span><br></pre></td></tr></table></figure><p>To handle this instead of adding (3) to all the existing subsets, we only add it to the new subsets which were created in the previous (3rd) step:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[], [<span class="number">1</span>], [<span class="number">3</span>], [<span class="number">1</span>,<span class="number">3</span>], [<span class="number">3</span>,<span class="number">3</span>], [<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>]]</span><br></pre></td></tr></table></figure><ol><li>Finally, add the forth number (5) to all the existing subsets: [[], [1], [3], [1,3], [3,3], [1,3,3], [5], [1,5], [3,5], [1,3,5], [3,3,5], [1,3,3,5]]</li></ol><p>Here is the visual representation of the above steps: </p><p><img src="/11-pattern-subsets/index/2.png"></p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interval</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, start, end</span>):</span></span><br><span class="line">        self.start = start</span><br><span class="line">        self.end = end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_subsets</span>(<span class="params">nums</span>):</span></span><br><span class="line">    nums.sort()</span><br><span class="line">    subsets = []</span><br><span class="line">    subsets.append([])</span><br><span class="line">    start_index, end_index = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        start_index = <span class="number">0</span>  <span class="comment"># 每次都要重置</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">            start_index = end_index</span><br><span class="line">        end_index = <span class="built_in">len</span>(subsets)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(start_index, end_index):</span><br><span class="line">            <span class="comment"># 这里的list很重要，这样才是重新复制了一个</span></span><br><span class="line">            tmp = <span class="built_in">list</span>(subsets[j])</span><br><span class="line">            tmp.append(nums[i])</span><br><span class="line">            subsets.append(tmp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> subsets</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = find_subsets([<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = find_subsets([<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-1"><a href="#Time-complexity-1" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>Since, in each step, the number of subsets could double (if not duplicate) as we add each element to all the existing subsets, the time complexity of the above algorithm is <strong><em>O(2^N)</em></strong>, where ‘N’ is the total number of elements in the input set. This also means that, in the end, we will have a total of <strong><em>O(2^N)</em></strong> subsets at the most.</p><h4 id="Space-complexity-1"><a href="#Space-complexity-1" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>All the additional space used by our algorithm is for the output list. Since at most we will have a total of <strong><em>O(2^N)</em></strong> subsets, the space complexity of our algorithm is also <strong><em>O(2^N)</em></strong>.</p><h2 id="Permutations-medium"><a href="#Permutations-medium" class="headerlink" title="*Permutations (medium)"></a>*Permutations (medium)</h2><p>leetcode 46</p><h3 id="Problem-Statement-2"><a href="#Problem-Statement-2" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given a set of <strong>distinct</strong> numbers, find all of its permutations.</p><p><strong>Permutation</strong> is defined as the re-arranging of the elements of the set. For example, {1, 2, 3} has the following six permutations:</p><ol><li>{1, 2, 3}</li><li>{1, 3, 2}</li><li>{2, 1, 3}</li><li>{2, 3, 1}</li><li>{3, 1, 2}</li><li>{3, 2, 1}</li></ol><p>If a set has ‘n’ distinct elements it will have n!<em>n</em>! permutations.</p><p><strong>Example 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="comment">[1,3,5]</span></span><br><span class="line">Output: <span class="comment">[1,3,5]</span>, <span class="comment">[1,5,3]</span>, <span class="comment">[3,1,5]</span>, <span class="comment">[3,5,1]</span>, <span class="comment">[5,1,3]</span>, <span class="comment">[5,3,1]</span></span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-2"><a href="#Try-it-yourself-2" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 看了solution写的，觉得的solution code有可以优化的地方</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interval</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, start, end</span>):</span></span><br><span class="line">        self.start = start</span><br><span class="line">        self.end = end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_permutations</span>(<span class="params">nums</span>):</span></span><br><span class="line">    permutations = deque()</span><br><span class="line">    permutations.append([])</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        n = <span class="built_in">len</span>(permutations)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            old_permutation = permutations.popleft()</span><br><span class="line">            <span class="comment"># 这里的+1要记得写上，不然会有问题</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(old_permutation) + <span class="number">1</span>):</span><br><span class="line">                new_permutation = <span class="built_in">list</span>(old_permutation)</span><br><span class="line">                new_permutation.insert(j, num)</span><br><span class="line">                permutations.append(new_permutation)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(permutations)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = find_permutations([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <em>Subsets</em> pattern and we can follow a similar <strong>Breadth First Search (BFS)</strong> approach. However, unlike <em>Subsets</em>, every permutation must contain all the numbers.</p><p>Let’s take the example-1 mentioned above to generate all the permutations. Following a BFS approach, we will consider one number at a time:</p><ol><li>If the given set is empty then we have only an empty permutation set: []</li><li>Let’s add the first element (1), the permutations will be: [1]</li><li>Let’s add the second element (3), the permutations will be: [3,1], [1,3]</li><li>Let’s add the third element (5), the permutations will be: [5,3,1], [3,5,1], [3,1,5], [5,1,3], [1,5,3], [1,3,5]</li></ol><p>Let’s analyze the permutations in the 3rd and 4th step. How can we generate permutations in the 4th step from the permutations of the 3rd step?</p><p>If we look closely, we will realize that when we add a new number (5), we take each permutation of the previous step and insert the new number in every position to generate the new permutations. For example, inserting ‘5’ in different positions of [3,1] will give us the following permutations:</p><ol><li>Inserting ‘5’ before ‘3’: [5,3,1]</li><li>Inserting ‘5’ between ‘3’ and ‘1’: [3,5,1]</li><li>Inserting ‘5’ after ‘1’: [3,1,5]</li></ol><p>Here is the visual representation of this algorithm:</p><p><img src="/11-pattern-subsets/index/3.png"></p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interval</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, start, end</span>):</span></span><br><span class="line">        self.start = start</span><br><span class="line">        self.end = end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_permutations</span>(<span class="params">nums</span>):</span></span><br><span class="line">    nums_length = <span class="built_in">len</span>(nums)</span><br><span class="line">    result = []</span><br><span class="line">    permutations = deque()</span><br><span class="line">    permutations.append([])</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        n = <span class="built_in">len</span>(permutations)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            old_permutation = permutations.popleft()</span><br><span class="line">            <span class="comment"># 这里的+1要记得写上，不然会有问题</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(old_permutation) + <span class="number">1</span>):</span><br><span class="line">                new_permutation = <span class="built_in">list</span>(old_permutation)</span><br><span class="line">                new_permutation.insert(j, num)</span><br><span class="line">                <span class="comment"># 这里如果直接放到permutations里面，最后返回的时候，permutations里的就是答案</span></span><br><span class="line">                <span class="comment"># 所以其实没有必要再用一个result,这样可以节约空间复杂度</span></span><br><span class="line">                <span class="comment"># 改进之后就是上面我写的，也过了leetcode</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(new_permutation) == nums_length:</span><br><span class="line">                    result.append(new_permutation)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    permutations.append(new_permutation)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(permutations)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = find_permutations([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-2"><a href="#Time-complexity-2" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>We know that there are a total of N!<em>N</em>! permutations of a set with ‘N’ numbers. In the algorithm above, we are iterating through all of these permutations with the help of the two ‘for’ loops. In each iteration, we go through all the current permutations to insert a new number in them on line 17 (line 23 for C++ solution). To insert a number into a permutation of size ‘N’ will take <strong><em>O(N)</em></strong>, which makes the overall time complexity of our algorithm <strong><em>O(N\</em>N!)*</strong>.</p><h4 id="Space-complexity-2"><a href="#Space-complexity-2" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>All the additional space used by our algorithm is for the result list and the queue to store the intermediate permutations. If you see closely, at any time, we don’t have more than N!<em>N</em>! permutations between the result list and the queue. Therefore the overall space complexity to store N!<em>N</em>! permutations each containing N<em>N</em> elements will be <strong><em>O(N\</em>N!)*</strong>.</p><h3 id="Recursive-Solution"><a href="#Recursive-Solution" class="headerlink" title="Recursive Solution"></a>Recursive Solution</h3><p>Here is the recursive algorithm following a similar approach:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Permutations</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">findPermutations</span>(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; currentPermutation;</span><br><span class="line">        <span class="built_in">generatePermutationsRecursive</span>(nums, <span class="number">0</span>, currentPermutation, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generatePermutationsRecursive</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; nums,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="keyword">int</span> index,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              vector&lt;<span class="keyword">int</span>&gt;&amp; currentPermutation,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(currentPermutation);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= currentPermutation.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                vector&lt;<span class="keyword">int</span>&gt; <span class="built_in">newPermutation</span>(currentPermutation);</span><br><span class="line">                newPermutation.<span class="built_in">insert</span>(newPermutation.<span class="built_in">begin</span>() + i, nums[index]);</span><br><span class="line">                <span class="built_in">generatePermutationsRecursive</span>(nums, index + <span class="number">1</span>, newPermutation,</span><br><span class="line">                                              result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result =</span><br><span class="line">        Permutations::<span class="built_in">findPermutations</span>(vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Here are all the permutations: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> vec : result) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : vec) &#123;</span><br><span class="line">            cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="String-Permutations-by-changing-case-medium"><a href="#String-Permutations-by-changing-case-medium" class="headerlink" title="String Permutations by changing case (medium)"></a>String Permutations by changing case (medium)</h2><p>leetcode 784</p><h3 id="Problem-Statement-3"><a href="#Problem-Statement-3" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given a string, find all of its permutations preserving the character sequence but changing case.</p><p><strong>Example 1:</strong></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> <span class="string">&quot;ad52&quot;</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="string">&quot;ad52&quot;</span>, <span class="string">&quot;Ad52&quot;</span>, <span class="string">&quot;aD52&quot;</span>, <span class="string">&quot;AD52&quot;</span> </span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> <span class="string">&quot;ab7c&quot;</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="string">&quot;ab7c&quot;</span>, <span class="string">&quot;Ab7c&quot;</span>, <span class="string">&quot;aB7c&quot;</span>, <span class="string">&quot;AB7c&quot;</span>, <span class="string">&quot;ab7C&quot;</span>, <span class="string">&quot;Ab7C&quot;</span>, <span class="string">&quot;aB7C&quot;</span>, <span class="string">&quot;AB7C&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-3"><a href="#Try-it-yourself-3" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 看solution写的</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interval</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, start, end</span>):</span></span><br><span class="line">        self.start = start</span><br><span class="line">        self.end = end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_letter_case_string_permutation</span>(<span class="params">string</span>):</span></span><br><span class="line">    permutations = [string]  <span class="comment"># 下面两句等于这句</span></span><br><span class="line">    <span class="comment"># permutations = []</span></span><br><span class="line">    <span class="comment"># permutations.append(string)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(string)):</span><br><span class="line">        <span class="keyword">if</span> string[i].isalpha():</span><br><span class="line">            n = <span class="built_in">len</span>(permutations)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                new_string = <span class="built_in">list</span>(permutations[j])</span><br><span class="line">                new_string[i] = new_string[i].swapcase()</span><br><span class="line">                permutations.append(<span class="string">&quot;&quot;</span>.join(new_string))</span><br><span class="line">                <span class="comment"># 原来打算这么写，但是python中不允许str[i] = char这样修改,TypeError: &#x27;str&#x27; object does not support item assignment</span></span><br><span class="line">                <span class="comment"># python没有字符的概念print(type(&#x27;1&#x27;)) =&gt; &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line">                <span class="comment"># new_string = permutations[j]</span></span><br><span class="line">                <span class="comment"># new_string[i] = new_string[i].swapcase()</span></span><br><span class="line">                <span class="comment"># permutations.append(new_string)</span></span><br><span class="line">    <span class="keyword">return</span> permutations</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = find_letter_case_string_permutation(<span class="string">&quot;ad52&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = find_letter_case_string_permutation(<span class="string">&quot;ab7c&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <em>Subsets</em> pattern and can be mapped to <em>Permutations</em>.</p><p>Let’s take Example-2 mentioned above to generate all the permutations. Following a <strong>BFS</strong> approach, we will consider one character at a time. Since we need to preserve the character sequence, we can start with the actual string and process each character (i.e., make it upper-case or lower-case) one by one:</p><ol><li>Starting with the actual string: <code>&quot;ab7c&quot;</code></li><li>Processing the first character (‘a’), we will get two permutations: <code>&quot;ab7c&quot;, &quot;Ab7c&quot;</code></li><li>Processing the second character (‘b’), we will get four permutations: <code>&quot;ab7c&quot;, &quot;Ab7c&quot;, &quot;aB7c&quot;, &quot;AB7c&quot;</code></li><li>Since the third character is a digit, we can skip it.</li><li>Processing the fourth character (‘c’), we will get a total of eight permutations: <code>&quot;ab7c&quot;, &quot;Ab7c&quot;, &quot;aB7c&quot;, &quot;AB7c&quot;, &quot;ab7C&quot;, &quot;Ab7C&quot;, &quot;aB7C&quot;, &quot;AB7C&quot;</code></li></ol><p>Let’s analyze the permutations in the 3rd and the 5th step. How can we generate the permutations in the 5th step from the permutations in the 3rd step?</p><p>If we look closely, we will realize that in the 5th step, when we processed the new character (‘c’), we took all the permutations of the previous step (3rd) and changed the case of the letter (‘c’) in them to create four new permutations.</p><p>Here is the visual representation of this algorithm:</p><p><img src="/11-pattern-subsets/index/4.png"></p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 见上</span></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-3"><a href="#Time-complexity-3" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>Since we can have <strong><em>2^N</em></strong> permutations at the most and while processing each permutation we convert it into a character array, the overall time complexity of the algorithm will be <strong><em>O(N\</em>2^N)*</strong>.</p><h4 id="Space-complexity-3"><a href="#Space-complexity-3" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>All the additional space used by our algorithm is for the output list. Since we can have a total of <strong><em>O(2^N)</em></strong> permutations, the space complexity of our algorithm is <strong><em>O(N\</em>2^N)*</strong>.</p><h2 id="Balanced-Parentheses-hard"><a href="#Balanced-Parentheses-hard" class="headerlink" title="*Balanced Parentheses (hard)"></a>*Balanced Parentheses (hard)</h2><p>不在leetcode</p><h3 id="Problem-Statement-4"><a href="#Problem-Statement-4" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>For a given number ‘N’, write a function to generate all combination of ‘N’ pairs of balanced parentheses.</p><p><strong>Example 1:</strong></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> N=<span class="number">2</span></span><br><span class="line"><span class="symbol">Output:</span> (()), ()()</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> N=<span class="number">3</span></span><br><span class="line"><span class="symbol">Output:</span> ((())), (()()), (())(), ()(()), ()()()</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-4"><a href="#Try-it-yourself-4" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 看了solution写的，过了测试用例</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParenthesesString</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, <span class="built_in">str</span>, open_count, close_count</span>):</span></span><br><span class="line">        self.<span class="built_in">str</span> = <span class="built_in">str</span></span><br><span class="line">        self.open_count = open_count</span><br><span class="line">        self.close_count = close_count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_valid_parentheses</span>(<span class="params">num</span>):</span></span><br><span class="line">    result = []</span><br><span class="line">    queue = deque()</span><br><span class="line">    queue.append(ParenthesesString(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        poped = queue.popleft()</span><br><span class="line">        <span class="comment"># solution优化了条件</span></span><br><span class="line">        <span class="keyword">if</span> poped.open_count == num <span class="keyword">and</span> poped.close_count == num:</span><br><span class="line">            result.append(poped.<span class="built_in">str</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> poped.open_count == <span class="number">0</span> <span class="keyword">or</span> poped.close_count &lt;= poped.open_count &lt; num:</span><br><span class="line">            queue.append(ParenthesesString(poped.<span class="built_in">str</span> + <span class="string">&quot;(&quot;</span>, poped.open_count + <span class="number">1</span>, poped.close_count))</span><br><span class="line">        <span class="keyword">if</span> poped.close_count &lt; poped.open_count:</span><br><span class="line">            queue.append(ParenthesesString(poped.<span class="built_in">str</span> + <span class="string">&quot;)&quot;</span>, poped.open_count, poped.close_count + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = generate_valid_parentheses(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = generate_valid_parentheses(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <em>Subsets</em> pattern and can be mapped to <em>Permutations</em>. We can follow a similar BFS approach.</p><p>Let’s take Example-2 mentioned above to generate all the combinations of balanced parentheses. Following a BFS approach, we will keep adding open parentheses <code>(</code> or close parentheses <code>)</code>. At each step we need to keep two things in mind:</p><ul><li>We can’t add more than ‘N’ open parenthesis.</li><li>To keep the parentheses balanced, we can add a close parenthesis <code>)</code> only when we have already added enough open parenthesis <code>(</code>. For this, we can keep a count of open and close parenthesis with every combination.</li></ul><p>Following this guideline, let’s generate parentheses </p><p>for N=3:</p><ol><li>Start with an empty combination: “”</li><li>At every step, let’s take all combinations of the previous step and add <code>(</code> or <code>)</code> keeping the above-mentioned two rules in mind.</li><li>For the empty combination, we can add <code>(</code> since the count of open parenthesis will be less than ‘N’. We can’t add <code>)</code> as we don’t have an equivalent open parenthesis, so our list of combinations will now be: “(”</li><li>For the next iteration, let’s take all combinations of the previous set. For “(” we can add another <code>(</code> to it since the count of open parenthesis will be less than ‘N’. We can also add <code>)</code> as we do have an equivalent open parenthesis, so our list of combinations will be: “((”, “()”</li><li>In the next iteration, for the first combination “((”, we can add another <code>(</code> to it as the count of open parenthesis will be less than ‘N’, we can also add <code>)</code> as we do have an equivalent open parenthesis. This gives us two new combinations: “(((” and “(()”. For the second combination “()”, we can add another <code>(</code> to it since the count of open parenthesis will be less than ‘N’. We can’t add <code>)</code> as we don’t have an equivalent open parenthesis, so our list of combinations will be: “(((”, “(()”, ()(“</li><li>Following the same approach, next we will get the following list of combinations: “((()”, “(()(”, “(())”, “()((”, “()()”</li><li>Next we will get: “((())”, “(()()”, “(())(”, “()(()”, “()()(”</li><li>Finally, we will have the following combinations of balanced parentheses: “((()))”, “(()())”, “(())()”, “()(())”, “()()()”</li><li>We can’t add more parentheses to any of the combinations, so we stop here.</li></ol><p>Here is the visual representation of this algorithm:</p><p><img src="/11-pattern-subsets/index/5.png"></p><h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParenthesesString</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, <span class="built_in">str</span>, open_count, close_count</span>):</span></span><br><span class="line">        self.<span class="built_in">str</span> = <span class="built_in">str</span></span><br><span class="line">        self.open_count = open_count</span><br><span class="line">        self.close_count = close_count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_valid_parentheses</span>(<span class="params">num</span>):</span></span><br><span class="line">    result = []</span><br><span class="line">    queue = deque()</span><br><span class="line">    queue.append(ParenthesesString(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        poped = queue.popleft()</span><br><span class="line">        <span class="comment"># 优化了条件</span></span><br><span class="line">        <span class="keyword">if</span> poped.open_count == num <span class="keyword">and</span> poped.close_count == num:</span><br><span class="line">            result.append(poped.<span class="built_in">str</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> poped.open_count &lt; num:</span><br><span class="line">            queue.append(ParenthesesString(poped.<span class="built_in">str</span> + <span class="string">&quot;(&quot;</span>, poped.open_count + <span class="number">1</span>, poped.close_count))</span><br><span class="line">        <span class="keyword">if</span> poped.close_count &lt; poped.open_count:</span><br><span class="line">            queue.append(ParenthesesString(poped.<span class="built_in">str</span> + <span class="string">&quot;)&quot;</span>, poped.open_count, poped.close_count + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = generate_valid_parentheses(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = generate_valid_parentheses(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-4"><a href="#Time-complexity-4" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>Let’s try to estimate how many combinations we can have for ‘N’ pairs of balanced parentheses. If we don’t care for the ordering - <em>that <code>)</code> can only come after <code>(</code></em> - then we have two options for every position, i.e., either put open parentheses or close parentheses. This means we can have a maximum of <strong><em>2^N</em></strong> combinations. Because of the ordering, the actual number will be less than <strong><em>2^N</em></strong>.</p><p>If you see the visual representation of Example-2 closely you will realize that, in the worst case, it is equivalent to a binary tree, where each node will have two children. This means that we will have <strong><em>2^N</em></strong> leaf nodes and <strong><em>2^N-1</em></strong> intermediate nodes. So the total number of elements pushed to the queue will be <strong><em>2^N + 2^N-1</em></strong>, which is asymptotically equivalent to <strong><em>O(2^N)</em></strong>. While processing each element, we do need to concatenate the current string with <code>(</code> or <code>)</code>. This operation will take <strong><em>O(N)</em></strong>, so the overall time complexity of our algorithm will be <strong><em>O(N</em>2^N)*</strong>. This is not completely accurate but reasonable enough to be presented in the interview.</p><p>The actual time complexity <strong><em>O(4n/√n</em>)*</strong> is bounded by the <a href="https://en.wikipedia.org/wiki/Catalan_number">Catalan number</a> and is beyond the scope of a coding interview. See more details <a href="https://en.wikipedia.org/wiki/Central_binomial_coefficient">here</a>.</p><h4 id="Space-complexity-4"><a href="#Space-complexity-4" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>All the additional space used by our algorithm is for the output list. Since we can’t have more than <strong><em>O(2^N)</em></strong> combinations, the space complexity of our algorithm is <strong><em>O(N \</em>2^N)*</strong>.</p><h3 id="Recursive-Solution-1"><a href="#Recursive-Solution-1" class="headerlink" title="Recursive Solution"></a>Recursive Solution</h3><p>Here is the recursive algorithm following a similar approach:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_valid_parentheses</span>(<span class="params">num</span>):</span></span><br><span class="line">    result = []</span><br><span class="line">    parentheses_string = <span class="string">&quot;&quot;</span></span><br><span class="line">    generate_valid_parentheses_recursive(num, <span class="number">0</span>, <span class="number">0</span>, parentheses_string, result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_valid_parentheses_recursive</span>(<span class="params">num, open_count, close_count, parentheses_string, result</span>):</span></span><br><span class="line">    <span class="keyword">if</span> open_count == num <span class="keyword">and</span> close_count == num:</span><br><span class="line">        result.append(parentheses_string)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> open_count &lt; num:</span><br><span class="line">            generate_valid_parentheses_recursive(num, open_count + <span class="number">1</span>, close_count, parentheses_string + <span class="string">&quot;(&quot;</span>,</span><br><span class="line">                                                 result)</span><br><span class="line">        <span class="keyword">if</span> open_count &gt; close_count:</span><br><span class="line">            generate_valid_parentheses_recursive(num, open_count, close_count + <span class="number">1</span>, parentheses_string + <span class="string">&quot;)&quot;</span>,</span><br><span class="line">                                                 result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = generate_valid_parentheses(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = generate_valid_parentheses(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Unique-Generalized-Abbreviations-hard"><a href="#Unique-Generalized-Abbreviations-hard" class="headerlink" title="#Unique Generalized Abbreviations (hard)"></a>#Unique Generalized Abbreviations (hard)</h2><p>leetcode 320 会员</p><h3 id="Problem-Statement-5"><a href="#Problem-Statement-5" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given a word, write a function to generate all of its unique generalized abbreviations.</p><p>Generalized abbreviation of a word can be generated by replacing each substring of the word by the count of characters in the substring. Take the example of “ab” which has four substrings: “”, “a”, “b”, and “ab”. After replacing these substrings in the actual word by the count of characters we get all the generalized abbreviations: “ab”, “1b”, “a1”, and “2”.</p><p><strong>Example 1:</strong></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> <span class="string">&quot;BAT&quot;</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="string">&quot;BAT&quot;</span>, <span class="string">&quot;BA1&quot;</span>, <span class="string">&quot;B1T&quot;</span>, <span class="string">&quot;B2&quot;</span>, <span class="string">&quot;1AT&quot;</span>, <span class="string">&quot;1A1&quot;</span>, <span class="string">&quot;2T&quot;</span>, <span class="string">&quot;3&quot;</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> <span class="string">&quot;code&quot;</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="string">&quot;code&quot;</span>, <span class="string">&quot;cod1&quot;</span>, <span class="string">&quot;co1e&quot;</span>, <span class="string">&quot;co2&quot;</span>, <span class="string">&quot;c1de&quot;</span>, <span class="string">&quot;c1d1&quot;</span>, <span class="string">&quot;c2e&quot;</span>, <span class="string">&quot;c3&quot;</span>, <span class="string">&quot;1ode&quot;</span>, <span class="string">&quot;1od1&quot;</span>, <span class="string">&quot;1o1e&quot;</span>, <span class="string">&quot;1o2&quot;</span>, </span><br><span class="line"><span class="string">&quot;2de&quot;</span>, <span class="string">&quot;2d1&quot;</span>, <span class="string">&quot;3e&quot;</span>, <span class="string">&quot;4&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-5"><a href="#Try-it-yourself-5" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 看了解答的思路写的，可以再求字集的时候同时处理空格，减少一次遍历处理的结果</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbbreviatedWord</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, <span class="built_in">str</span>, index, count</span>):</span></span><br><span class="line">        self.<span class="built_in">str</span> = <span class="built_in">str</span></span><br><span class="line">        self.index = index  <span class="comment"># 表示遍历到单词的index</span></span><br><span class="line">        self.count = count  <span class="comment"># 表示到目前为止有几个单词被压缩了并且还没有被处理为数字的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_generalized_abbreviation</span>(<span class="params">word</span>):</span></span><br><span class="line">    word_len = <span class="built_in">len</span>(word)</span><br><span class="line">    queue = deque()</span><br><span class="line">    queue.append(AbbreviatedWord(<span class="string">&#x27;&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        poped = queue.popleft()</span><br><span class="line">        <span class="keyword">if</span> poped.index == word_len:</span><br><span class="line">            <span class="keyword">if</span> poped.count != <span class="number">0</span>:</span><br><span class="line">                poped.<span class="built_in">str</span> += <span class="built_in">str</span>(poped.count)</span><br><span class="line">            res.append(poped.<span class="built_in">str</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            queue.append(AbbreviatedWord(poped.<span class="built_in">str</span>, poped.index + <span class="number">1</span>, poped.count + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> poped.count != <span class="number">0</span>:</span><br><span class="line">                poped.<span class="built_in">str</span> += <span class="built_in">str</span>(poped.count)</span><br><span class="line">                poped.count = <span class="number">0</span></span><br><span class="line">            queue.append(AbbreviatedWord(poped.<span class="built_in">str</span> + word[poped.index], poped.index + <span class="number">1</span>, poped.count))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = generate_generalized_abbreviation(<span class="string">&quot;BAT&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = generate_generalized_abbreviation(<span class="string">&quot;code&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <em>Subsets</em> pattern and can be mapped to <em>Balanced Parentheses</em>. We can follow a similar BFS approach.</p><p>Let’s take Example-1 mentioned above to generate all unique generalized abbreviations. Following a BFS approach, we will abbreviate one character at a time. At each step we have two options:</p><ul><li>Abbreviate the current character, or</li><li>Add the current character to the output and skip abbreviation.</li></ul><p>Following these two rules, let’s abbreviate <code>BAT</code>:</p><ol><li>Start with an empty word: “”</li><li>At every step, we will take all the combinations from the previous step and apply the two abbreviation rules to the next character.</li><li>Take the empty word from the previous step and add the first character to it. We can either abbreviate the character or add it (by skipping abbreviation). This gives us two new words: <code>_</code>, <code>B</code>.</li><li>In the next iteration, let’s add the second character. Applying the two rules on <code>_</code> will give us <code>_ _</code> and <code>1A</code>. Applying the above rules to the other combination <code>B</code> gives us <code>B_</code> and <code>BA</code>.</li><li>The next iteration will give us: <code>_ _ _</code>, <code>2T</code>, <code>1A_</code>, <code>1AT</code>, <code>B _ _</code>, <code>B1T</code>, <code>BA_</code>, <code>BAT</code></li><li>The final iteration will give us:<code>3</code>, <code>2T</code>, <code>1A1</code>, <code>1AT</code>, <code>B2</code>, <code>B1T</code>, <code>BA1</code>, <code>BAT</code></li></ol><p>Here is the visual representation of this algorithm:</p><p><img src="/11-pattern-subsets/index/6.png"></p><h3 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同上</span></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-5"><a href="#Time-complexity-5" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>Since we had two options for each character, we will have a maximum of <strong><em>2^N</em></strong> combinations. If you see the visual representation of Example-1 closely you will realize that it is equivalent to a binary tree, where each node has two children. This means that we will have <strong><em>2^N</em></strong> leaf nodes and <strong><em>2^N-1</em></strong> intermediate nodes, so the total number of elements pushed to the queue will be <strong><em>2^N + 2^N-1</em></strong>, which is asymptotically equivalent to <strong><em>O(2^N)</em></strong>. While processing each element, we do need to concatenate the current string with a character. This operation will take <strong><em>O(N)</em></strong>, so the overall time complexity of our algorithm will be <strong><em>O(N\</em>2^N)*</strong>.</p><h4 id="Space-complexity-5"><a href="#Space-complexity-5" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>All the additional space used by our algorithm is for the output list. Since we can’t have more than <strong><em>O(2^N)</em></strong> combinations, the space complexity of our algorithm is <strong><em>O(N</em>2^N)*</strong>.</p><h3 id="Recursive-Solution-2"><a href="#Recursive-Solution-2" class="headerlink" title="Recursive Solution"></a>Recursive Solution</h3><p>Here is the recursive algorithm following a similar approach:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_generalized_abbreviation</span>(<span class="params">word</span>):</span></span><br><span class="line">    result = []</span><br><span class="line">    generate_generalized_abbreviation_recursive(word, <span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_generalized_abbreviation_recursive</span>(<span class="params">word, ab_word, index, count, result</span>):</span></span><br><span class="line">    <span class="keyword">if</span> index == <span class="built_in">len</span>(word):</span><br><span class="line">        <span class="keyword">if</span> count != <span class="number">0</span>:</span><br><span class="line">            ab_word += <span class="built_in">str</span>(count)</span><br><span class="line">        result.append(ab_word)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        generate_generalized_abbreviation_recursive(word, ab_word, index + <span class="number">1</span>, count + <span class="number">1</span>, result)</span><br><span class="line">        <span class="keyword">if</span> count != <span class="number">0</span>:</span><br><span class="line">            ab_word += <span class="built_in">str</span>(count)</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">        generate_generalized_abbreviation_recursive(word, ab_word + <span class="built_in">str</span>(word[index]), index + <span class="number">1</span>, count, result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = generate_generalized_abbreviation(<span class="string">&quot;BAT&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = generate_generalized_abbreviation(<span class="string">&quot;code&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Problem-Challenge-1"><a href="#Problem-Challenge-1" class="headerlink" title="*Problem Challenge 1"></a>*Problem Challenge 1</h2><p>leetcode 不在</p><h3 id="Evaluate-Expression-hard"><a href="#Evaluate-Expression-hard" class="headerlink" title="Evaluate Expression (hard)"></a>Evaluate Expression (hard)</h3><p>Given an expression containing digits and operations (+, -, *), find all possible ways in which the expression can be evaluated by grouping the numbers and operators using parentheses.</p><p><strong>Example 1:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: <span class="string">&quot;1+2*3&quot;</span></span><br><span class="line"><span class="attribute">Output</span>: <span class="number">7</span>, <span class="number">9</span></span><br><span class="line"><span class="attribute">Explanation</span>: <span class="number">1</span>+(<span class="number">2</span>*<span class="number">3</span>) =&gt; <span class="number">7</span> and (<span class="number">1</span>+<span class="number">2</span>)*<span class="number">3</span> =&gt; <span class="number">9</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: <span class="string">&quot;2*3-4-5&quot;</span></span><br><span class="line"><span class="attribute">Output</span>: <span class="number">8</span>, -<span class="number">12</span>, <span class="number">7</span>, -<span class="number">7</span>, -<span class="number">3</span> </span><br><span class="line"><span class="attribute">Explanation</span>: <span class="number">2</span>*(<span class="number">3</span>-(<span class="number">4</span>-<span class="number">5</span>)) =&gt; <span class="number">8</span>, <span class="number">2</span>*(<span class="number">3</span>-<span class="number">4</span>-<span class="number">5</span>) =&gt; -<span class="number">12</span>, <span class="number">2</span>*<span class="number">3</span>-(<span class="number">4</span>-<span class="number">5</span>) =&gt; <span class="number">7</span>, <span class="number">2</span>*(<span class="number">3</span>-<span class="number">4</span>)-<span class="number">5</span> =&gt; -<span class="number">7</span>, (<span class="number">2</span>*<span class="number">3</span>)-<span class="number">4</span>-<span class="number">5</span> =&gt; -<span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-6"><a href="#Try-it-yourself-6" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不会</span></span><br></pre></td></tr></table></figure><h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <em>Subsets</em> pattern and can be mapped to <em>Balanced Parentheses</em>. We can follow a similar BFS approach.</p><p>Let’s take Example-1 mentioned above to generate different ways to evaluate the expression.</p><ol><li>We can iterate through the expression character-by-character.</li><li>we can break the expression into two halves whenever we get an operator (+, -, *).</li><li>The two parts can be calculated by recursively calling the function.</li><li>Once we have the evaluation results from the left and right halves, we can combine them to produce all results.</li></ol><h3 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evalaute_expression</span>(<span class="params"><span class="built_in">str</span></span>):</span></span><br><span class="line">    result = evalaute_expression_rec(<span class="built_in">str</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evalaute_expression_rec</span>(<span class="params"><span class="built_in">str</span></span>):</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;*&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">str</span> <span class="keyword">and</span> <span class="string">&quot;+&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">str</span> <span class="keyword">and</span> <span class="string">&quot;-&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">int</span>(<span class="built_in">str</span>)]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">str</span>)):</span><br><span class="line">            char = <span class="built_in">str</span>[i]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> char.isdigit():</span><br><span class="line">                left_parts = evalaute_expression_rec(<span class="built_in">str</span>[:i])</span><br><span class="line">                right_parts = evalaute_expression_rec(<span class="built_in">str</span>[i + <span class="number">1</span>:])</span><br><span class="line">                <span class="keyword">for</span> lp <span class="keyword">in</span> left_parts:</span><br><span class="line">                    <span class="keyword">for</span> rp <span class="keyword">in</span> right_parts:</span><br><span class="line">                        <span class="keyword">if</span> char == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                            result.append(lp + rp)</span><br><span class="line">                        <span class="keyword">elif</span> char == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                            result.append(lp - rp)</span><br><span class="line">                        <span class="keyword">elif</span> char == <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                            result.append(lp * rp)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = evalaute_expression(<span class="string">&quot;1+2*3&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = evalaute_expression(<span class="string">&quot;2*3-4-5&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-6"><a href="#Time-complexity-6" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of this algorithm will be exponential and will be similar to <em>Balanced Parentheses</em>. Estimated time complexity will be <strong><em>O(N\</em>2^N)*</strong> but the actual time complexity <strong><em>O(4n/√n)</em></strong> is bounded by the <a href="https://en.wikipedia.org/wiki/Catalan_number">Catalan number</a> and is beyond the scope of a coding interview. See more details <a href="https://en.wikipedia.org/wiki/Central_binomial_coefficient">here</a>.</p><h4 id="Space-complexity-6"><a href="#Space-complexity-6" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity of this algorithm will also be exponential, estimated at <strong><em>O(2^N)</em></strong> though the actual will be <strong><em>O(4n/√n)</em></strong>.</p><h3 id="Memoized-version"><a href="#Memoized-version" class="headerlink" title="Memoized version"></a>Memoized version</h3><p>The problem has overlapping subproblems, as our recursive calls can be evaluating the same sub-expression multiple times. To resolve this, we can use memoization and store the intermediate results in a <strong>HashMap</strong>. In each function call, we can check our map to see if we have already evaluated this sub-expression before. Here is the memoized version of our algorithm; please see highlighted changes:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evalaute_expression</span>(<span class="params"><span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> evalaute_expression_rec(&#123;&#125;, <span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evalaute_expression_rec</span>(<span class="params"><span class="built_in">map</span>, <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">str</span> <span class="keyword">in</span> <span class="built_in">map</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span>[<span class="built_in">str</span>]</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;*&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">str</span> <span class="keyword">and</span> <span class="string">&quot;+&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">str</span> <span class="keyword">and</span> <span class="string">&quot;-&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">int</span>(<span class="built_in">str</span>)]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">str</span>)):</span><br><span class="line">            char = <span class="built_in">str</span>[i]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> char.isdigit():</span><br><span class="line">                left_parts = evalaute_expression_rec(<span class="built_in">map</span>, <span class="built_in">str</span>[:i])</span><br><span class="line">                right_parts = evalaute_expression_rec(<span class="built_in">map</span>, <span class="built_in">str</span>[i + <span class="number">1</span>:])</span><br><span class="line">                <span class="keyword">for</span> lp <span class="keyword">in</span> left_parts:</span><br><span class="line">                    <span class="keyword">for</span> rp <span class="keyword">in</span> right_parts:</span><br><span class="line">                        <span class="keyword">if</span> char == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                            result.append(lp + rp)</span><br><span class="line">                        <span class="keyword">elif</span> char == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                            result.append(lp - rp)</span><br><span class="line">                        <span class="keyword">elif</span> char == <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                            result.append(lp * rp)</span><br><span class="line">    <span class="built_in">map</span>[<span class="built_in">str</span>] = result</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = evalaute_expression(<span class="string">&quot;1+2*3&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = evalaute_expression(<span class="string">&quot;2*3-4-5&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Problem-Challenge-2"><a href="#Problem-Challenge-2" class="headerlink" title="Problem Challenge 2"></a>Problem Challenge 2</h2><p>leetcode 96 使用这个方法会爆内存</p><p>leetcode 95</p><h3 id="Structurally-Unique-Binary-Search-Trees-hard"><a href="#Structurally-Unique-Binary-Search-Trees-hard" class="headerlink" title="Structurally Unique Binary Search Trees (hard)"></a>Structurally Unique Binary Search Trees (hard)</h3><p>Given a number ‘n’, write a function to return all structurally unique Binary Search Trees (BST) that can store values 1 to ‘n’?</p><p><strong>Example 1:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: <span class="number">2</span></span><br><span class="line"><span class="attribute">Output</span>: <span class="number">2</span></span><br><span class="line"><span class="attribute">Explanation</span>: Here are <span class="literal">all</span> the structurally unique BSTs storing <span class="literal">all</span> numbers from <span class="number">1</span> to <span class="number">2</span>:</span><br></pre></td></tr></table></figure><p><img src="/11-pattern-subsets/index/7.png"></p><p><strong>Example 2:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: <span class="number">3</span></span><br><span class="line"><span class="attribute">Output</span>: <span class="number">5</span></span><br><span class="line"><span class="attribute">Explanation</span>: Here are <span class="literal">all</span> the structurally unique BSTs storing <span class="literal">all</span> numbers from <span class="number">1</span> to <span class="number">3</span>:</span><br></pre></td></tr></table></figure><p><img src="/11-pattern-subsets/index/8.png"></p><h3 id="Try-it-yourself-7"><a href="#Try-it-yourself-7" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <em>Subsets</em> pattern and is quite similar to <em>Evaluate Expression</em>. Following a similar approach, we can iterate from 1 to ‘n’ and consider each number as the root of a tree. All smaller numbers will make up the left sub-tree and bigger numbers will make up the right sub-tree. We will make recursive calls for the left and right sub-trees</p><h3 id="Code-7"><a href="#Code-7" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_unique_trees</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">return</span> find_unique_trees_recursive(<span class="number">1</span>, n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_unique_trees_recursive</span>(<span class="params">start, end</span>):</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="comment"># base condition, return None for an empty sub-tree</span></span><br><span class="line">    <span class="comment"># consider n = 1, in this case we will have start = end = 1, this means we should have only one tree</span></span><br><span class="line">    <span class="comment"># we will have two recursive calls, find_unique_trees_recursive(1,0) &amp; (2,1)</span></span><br><span class="line">    <span class="comment"># both of these should return None for the left and right branch</span></span><br><span class="line">    <span class="keyword">if</span> start &gt; end:</span><br><span class="line">        result.append(<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, end + <span class="number">1</span>):</span><br><span class="line">        left_part = find_unique_trees_recursive(start, i - <span class="number">1</span>)</span><br><span class="line">        right_part = find_unique_trees_recursive(i + <span class="number">1</span>, end)</span><br><span class="line">        <span class="keyword">for</span> left <span class="keyword">in</span> left_part:</span><br><span class="line">            <span class="keyword">for</span> right <span class="keyword">in</span> right_part:</span><br><span class="line">                root = TreeNode(i)</span><br><span class="line">                root.left = left</span><br><span class="line">                root.right = right</span><br><span class="line">                result.append(root)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = find_unique_trees(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = find_unique_trees(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-7"><a href="#Time-complexity-7" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of this algorithm will be exponential and will be similar to <em>Balanced Parentheses</em>. Estimated time complexity will be <strong><em>O(n\</em>2^n)*</strong> but the actual time complexity <strong><em>O(4n/√n)</em></strong>  is bounded by the <a href="https://en.wikipedia.org/wiki/Catalan_number">Catalan number</a> and is beyond the scope of a coding interview. See more details <a href="https://en.wikipedia.org/wiki/Central_binomial_coefficient">here</a>.</p><h4 id="Space-complexity-7"><a href="#Space-complexity-7" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity of this algorithm will be exponential too, estimated at <strong><em>O(2^n)</em></strong>, but the actual will be <strong><em>O(4n/√n)</em></strong>.</p><h3 id="Memoized-version-1"><a href="#Memoized-version-1" class="headerlink" title="Memoized version"></a>Memoized version</h3><p>Since our algorithm has overlapping subproblems, can we use memoization to improve it? We could, but every time we return the result of a subproblem from the cache, we have to clone the result list because these trees will be used as the left or right child of a tree. This cloning is equivalent to reconstructing the trees, therefore, the overall time complexity of the memoized algorithm will also be the same.</p><h2 id="Problem-Challenge-3"><a href="#Problem-Challenge-3" class="headerlink" title="Problem Challenge 3"></a>Problem Challenge 3</h2><p>leetcode 96</p><h3 id="Count-of-Structurally-Unique-Binary-Search-Trees-hard"><a href="#Count-of-Structurally-Unique-Binary-Search-Trees-hard" class="headerlink" title="Count of Structurally Unique Binary Search Trees (hard)"></a>Count of Structurally Unique Binary Search Trees (hard)</h3><p>Given a number ‘n’, write a function to return the count of structurally unique Binary Search Trees (BST) that can store values 1 to ‘n’.</p><p><strong>Example 1:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: <span class="number">2</span></span><br><span class="line"><span class="attribute">Output</span>: <span class="number">2</span></span><br><span class="line"><span class="attribute">Explanation</span>: As we saw in the previous problem, there are <span class="number">2</span> unique BSTs storing numbers from <span class="number">1</span>-<span class="number">2</span>.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: <span class="number">3</span></span><br><span class="line"><span class="attribute">Output</span>: <span class="number">5</span></span><br><span class="line"><span class="attribute">Explanation</span>: There will be <span class="number">5</span> unique BSTs that can store numbers from <span class="number">1</span> to <span class="number">5</span>.</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-8"><a href="#Try-it-yourself-8" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这道题和上道题有一点区别，这道题只是要求返回个数就可以。</span></span><br><span class="line"><span class="comment">// 上一道题还要求返回对应的结构</span></span><br><span class="line"><span class="comment">// 这道题用上面一道题目的代码也是完全可以的,但是会空间超限</span></span><br><span class="line"><span class="comment">// 最后返回的数组的大小就是答案</span></span><br></pre></td></tr></table></figure><h3 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h3><p>This problem is similar to <em>Structurally Unique Binary Search Trees</em>. Following a similar approach, we can iterate from 1 to ‘n’ and consider each number as the root of a tree and make two recursive calls to count the number of left and right sub-trees.</p><h3 id="Code-8"><a href="#Code-8" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_trees</span>(<span class="params">n</span>):</span></span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="comment"># base condition, return None for an empty sub-tree</span></span><br><span class="line">    <span class="comment"># consider n = 1, in this case we will have start = end = 1, this means we should have only one tree</span></span><br><span class="line">    <span class="comment"># we will have two recursive calls, find_unique_trees_recursive(1,0) &amp; (2,1)</span></span><br><span class="line">    <span class="comment"># both of these should return None for the left and right branch</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        left_part = count_trees(i - <span class="number">1</span>)</span><br><span class="line">        right_part = count_trees(n - i)</span><br><span class="line">        result += left_part * right_part</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = count_trees(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = count_trees(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-8"><a href="#Time-complexity-8" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of this algorithm will be exponential and will be similar to <em>Balanced Parentheses</em>. Estimated time complexity will be O(n<em>2^n)</em>O<em>(</em>n<em>∗2</em>n<em>) but the actual time complexity </em>O(4n/√n)* is bounded by the <a href="https://en.wikipedia.org/wiki/Catalan_number">Catalan number</a> and is beyond the scope of a coding interview. See more details <a href="https://en.wikipedia.org/wiki/Central_binomial_coefficient">here</a>.</p><h4 id="Space-complexity-8"><a href="#Space-complexity-8" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity of this algorithm will be exponential too, estimated <strong><em>O(2^n)</em></strong> but the actual will be <strong><em>O(4n/√n)</em></strong>.</p><h3 id="Memoized-version-2"><a href="#Memoized-version-2" class="headerlink" title="Memoized version"></a>Memoized version</h3><p>Our algorithm has overlapping subproblems as our recursive call will be evaluating the same sub-expression multiple times. To resolve this, we can use memoization and store the intermediate results in a <strong>HashMap</strong>. In each function call, we can check our map to see if we have already evaluated this sub-expression before. Here is the memoized version of our algorithm, please see highlighted changes:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_trees</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> count_trees_recursive(&#123;&#125;, n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_trees_recursive</span>(<span class="params"><span class="built_in">map</span>, n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> <span class="built_in">map</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span>[n]</span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="comment"># base condition, return None for an empty sub-tree</span></span><br><span class="line">    <span class="comment"># consider n = 1, in this case we will have start = end = 1, this means we should have only one tree</span></span><br><span class="line">    <span class="comment"># we will have two recursive calls, find_unique_trees_recursive(1,0) &amp; (2,1)</span></span><br><span class="line">    <span class="comment"># both of these should return None for the left and right branch</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        left_part = count_trees_recursive(<span class="built_in">map</span>, i - <span class="number">1</span>)</span><br><span class="line">        right_part = count_trees_recursive(<span class="built_in">map</span>, n - i)</span><br><span class="line">        result += left_part * right_part</span><br><span class="line">    <span class="built_in">map</span>[n] = result</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = count_trees(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = count_trees(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>10. Pattern Two Heaps</title>
      <link href="/10-pattern-two-heaps/index.html"/>
      <url>/10-pattern-two-heaps/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In many problems, where we are given a set of elements such that we can divide them into two parts. To solve the problem, we are interested in knowing the smallest element in one part and the biggest element in the other part. This pattern is an efficient approach to solve such problems.</p><p>This pattern uses two <strong>Heaps</strong> to solve these problems; A <strong>Min Heap</strong> to find the smallest element and a <strong>Max Heap</strong> to find the biggest element.</p><p>Let’s jump onto our first problem to see this pattern in action.</p><h2 id="Find-the-Median-of-a-Number-Stream-medium"><a href="#Find-the-Median-of-a-Number-Stream-medium" class="headerlink" title="Find the Median of a Number Stream (medium)"></a>Find the Median of a Number Stream (medium)</h2><p>leetcode 295</p><h3 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Design a class to calculate the median of a number stream. The class should have the following two methods:</p><ol><li><code>insertNum(int num)</code>: stores the number in the class</li><li><code>findMedian()</code>: returns the median of all numbers inserted in the class</li></ol><p>If the count of numbers inserted in the class is even, the median will be the average of the middle two numbers.</p><p><strong>Example 1:</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> insertNum(<span class="number">3</span>)</span><br><span class="line"><span class="number">2.</span> insertNum(<span class="number">1</span>)</span><br><span class="line"><span class="number">3.</span> findMedian<span class="function"><span class="params">()</span> -&gt;</span> output: <span class="number">2</span></span><br><span class="line"><span class="number">4.</span> insertNum(<span class="number">5</span>)</span><br><span class="line"><span class="number">5.</span> findMedian<span class="function"><span class="params">()</span> -&gt;</span> output: <span class="number">3</span></span><br><span class="line"><span class="number">6.</span> insertNum(<span class="number">4</span>)</span><br><span class="line"><span class="number">7.</span> findMedian<span class="function"><span class="params">()</span> -&gt;</span> output: <span class="number">3.5</span></span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself"><a href="#Try-it-yourself" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不会</span></span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>As we know, the median is the middle value in an ordered integer list. So a brute force solution could be to maintain a sorted list of all numbers inserted in the class so that we can efficiently return the median whenever required. Inserting a number in a sorted list will take O(N) time if there are ‘N’ numbers in the list. This insertion will be similar to the <a href="https://en.wikipedia.org/wiki/Insertion_sort">Insertion sort</a>. Can we do better than this? Can we utilize the fact that we don’t need the fully sorted list - we are only interested in finding the middle element?</p><p>Assume ‘x’ is the median of a list. This means that half of the numbers in the list will be smaller than (or equal to) ‘x’ and half will be greater than (or equal to) ‘x’. This leads us to an approach where we can divide the list into two halves: one half to store all the smaller numbers (let’s call it <code>smallNumList</code>) and one half to store the larger numbers (let’s call it <code>largNumList</code>). The median of all the numbers will either be the largest number in the <code>smallNumList</code> or the smallest number in the <code>largNumList</code>. If the total number of elements is even, the median will be the average of these two numbers.</p><p>The best data structure that comes to mind to find the smallest or largest number among a list of numbers is a <a href="https://en.wikipedia.org/wiki/Heap_(data_structure">Heap</a>). Let’s see how we can use a heap to find a better algorithm.</p><ol><li>We can store the first half of numbers (i.e., <code>smallNumList</code>) in a <strong>Max Heap</strong>. We should use a <strong>Max Heap</strong> as we are interested in knowing the largest number in the first half.</li><li>We can store the second half of numbers (i.e., <code>largeNumList</code>) in a <strong>Min Heap</strong>, as we are interested in knowing the smallest number in the second half.</li><li>Inserting a number in a heap will take O(logN), which is better than the brute force approach.</li><li>At any time, the median of the current list of numbers can be calculated from the top element of the two heaps.</li></ol><p>Let’s take the Example-1 mentioned above to go through each step of our algorithm:</p><ol><li><p><code>insertNum(3)</code>: We can insert a number in the <strong>Max Heap</strong> (i.e. first half) if the number is smaller than the top (largest) number of the heap. After every insertion, we will balance the number of elements in both heaps, so that they have an equal number of elements. If the count of numbers is odd, let’s decide to have more numbers in max-heap than the <strong>Min Heap</strong>.</p><p><img src="/10-pattern-two-heaps/index/1.png"></p></li><li><p><code>insertNum(1)</code>: As ‘1’ is smaller than ‘3’, let’s insert it into the <strong>Max Heap</strong>.</p><p><img src="/10-pattern-two-heaps/index/2.png"></p><p>Now, we have two elements in the <strong>Max Heap</strong> and no elements in <strong>Min Heap</strong>. Let’s take the largest element from the <strong>Max Heap</strong> and insert it into the <strong>Min Heap</strong>, to balance the number of elements in both heaps.</p><p><img src="/10-pattern-two-heaps/index/3.png"></p></li><li><p><code>findMedian()</code>: As we have an even number of elements, the median will be the average of the top element of both the heaps -&gt; (1+3)/2 = 2.0(1+3)/2=2.0</p></li><li><p><code>insertNum(5)</code>: As ‘5’ is greater than the top element of the <strong>Max Heap</strong>, we can insert it into the <strong>Min Heap</strong>. After the insertion, the total count of elements will be odd. As we had decided to have more numbers in the <strong>Max Heap</strong> than the <strong>Min Heap</strong>, we can take the top (smallest) number from the <strong>Min Heap</strong> and insert it into the <strong>Max Heap</strong>.</p><p><img src="/10-pattern-two-heaps/index/4.png"></p></li><li><p><code>findMedian()</code>: Since we have an odd number of elements, the median will be the top element of <strong>Max Heap</strong> -&gt; 3. An odd number of elements also means that the <strong>Max Heap</strong> will have one extra element than the <strong>Min Heap</strong>.</p></li><li><p><code>insertNum(4)</code>: Insert ‘4’ into <strong>Min Heap</strong>.</p><p><img src="/10-pattern-two-heaps/index/5.png"></p></li><li><p><code>findMedian()</code>: As we have an even number of elements, the median will be the average of the top element of both the heaps -&gt; (3+4)/2 = 3.5(3+4)/2=3.5</p></li></ol><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianOfAStream</span>:</span></span><br><span class="line">    maxHeap = []  <span class="comment"># 存储小的一半的数字</span></span><br><span class="line">    minHeap = []  <span class="comment"># 存储大的一半的数字</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_num</span>(<span class="params">self, num</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.maxHeap <span class="keyword">or</span> -self.maxHeap[<span class="number">0</span>] &gt;= num:</span><br><span class="line">            <span class="comment"># heapq默认是小顶堆，所以要实现大顶堆的时候，就要取反</span></span><br><span class="line">            heappush(self.maxHeap, -num)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            heappush(self.minHeap, num)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># maxheap的个数和minheap的个数最多相差1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.maxHeap) &gt; <span class="built_in">len</span>(self.minHeap) + <span class="number">1</span>:</span><br><span class="line">            heappush(self.minHeap, -heappop(self.maxHeap))</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(self.minHeap) &gt; <span class="built_in">len</span>(self.maxHeap):</span><br><span class="line">            heappush(self.maxHeap, -heappop(self.minHeap))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_median</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.maxHeap) == <span class="built_in">len</span>(self.minHeap):</span><br><span class="line">            <span class="keyword">return</span> (-self.maxHeap[<span class="number">0</span>] + self.minHeap[<span class="number">0</span>]) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> -self.maxHeap[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    median_of_stream = MedianOfAStream()</span><br><span class="line">    median_of_stream.insert_num(<span class="number">3</span>)</span><br><span class="line">    median_of_stream.insert_num(<span class="number">1</span>)</span><br><span class="line">    res = median_of_stream.find_median()</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    median_of_stream.insert_num(<span class="number">5</span>)</span><br><span class="line">    res = median_of_stream.find_median()</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    median_of_stream.insert_num(<span class="number">4</span>)</span><br><span class="line">    res = median_of_stream.find_median()</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity"><a href="#Time-complexity" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of the <code>insertNum()</code> will be <strong><em>O(logN)</em></strong> due to the insertion in the heap. The time complexity of the <code>findMedian()</code> will be <strong><em>O(1)</em></strong> as we can find the median from the top elements of the heaps.</p><h4 id="Space-complexity"><a href="#Space-complexity" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity will be <strong><em>O(N)</em></strong> because, as at any time, we will be storing all the numbers.</p><h2 id="Sliding-Window-Median-hard"><a href="#Sliding-Window-Median-hard" class="headerlink" title="*Sliding Window Median (hard)"></a>*Sliding Window Median (hard)</h2><p>leetcode 480</p><h3 id="Problem-Statement-1"><a href="#Problem-Statement-1" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given an array of numbers and a number ‘k’, find the median of all the ‘k’ sized sub-arrays (or windows) of the array.</p><p><strong>Example 1:</strong></p><p>Input: nums=[1, 2, -1, 3, 5], k = 2<br>Output: [1.5, 0.5, 1.0, 4.0]<br>Explanation: Lets consider all windows of size ‘2’:</p><ul><li>[1, 2, -1, 3, 5] -&gt; median is 1.5</li><li>[1, 2, -1, 3, 5] -&gt; median is 0.5</li><li>[1, 2, -1, 3, 5] -&gt; median is 1.0</li><li>[1, 2, -1, 3, 5] -&gt; median is 4.0</li></ul><p><strong>Example 2:</strong></p><p>Input: nums=[1, 2, -1, 3, 5], k = 3<br>Output: [1.0, 2.0, 3.0]<br>Explanation: Lets consider all windows of size ‘3’:</p><ul><li>[1, 2, -1, 3, 5] -&gt; median is 1.0</li><li>[1, 2, -1, 3, 5] -&gt; median is 2.0</li><li>[1, 2, -1, 3, 5] -&gt; median is 3.0</li></ul><h3 id="Try-it-yourself-1"><a href="#Try-it-yourself-1" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只会排序窗口然后取mediam</span></span><br></pre></td></tr></table></figure><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <strong>Two Heaps</strong> pattern and share similarities with <strong><em>Find the Median of a Number Stream</em></strong>. We can follow a similar approach of maintaining a max-heap and a min-heap for the list of numbers to find their median.</p><p>The only difference is that we need to keep track of a sliding window of ‘k’ numbers. This means, in each iteration, when we insert a new number in the heaps, we need to remove one number from the heaps which is going out of the sliding window. After the removal, we need to rebalance the heaps in the same way that we did while inserting.</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SlidingWindowMedian</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.maxHeap = []  <span class="comment"># 存储小的一半的数字</span></span><br><span class="line">        self.minHeap = []  <span class="comment"># 存储大的一半的数字</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_sliding_window_median</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.maxHeap <span class="keyword">or</span> nums[i] &lt;= -self.maxHeap[<span class="number">0</span>]:</span><br><span class="line">                heappush(self.maxHeap, -nums[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                heappush(self.minHeap, nums[i])</span><br><span class="line">            self.balance_heaps()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> i + <span class="number">1</span> - k &gt;= <span class="number">0</span>:  <span class="comment"># 有至少k个元素了</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(self.maxHeap) == <span class="built_in">len</span>(self.minHeap):</span><br><span class="line">                    result.append((-self.maxHeap[<span class="number">0</span>] + self.minHeap[<span class="number">0</span>]) / <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    result.append(-self.maxHeap[<span class="number">0</span>])</span><br><span class="line">                remove_element = nums[i + <span class="number">1</span> - k]</span><br><span class="line">                <span class="keyword">if</span> remove_element &lt;= -self.maxHeap[<span class="number">0</span>]:</span><br><span class="line">                    self.remove(self.maxHeap, -remove_element)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.remove(self.minHeap, remove_element)</span><br><span class="line">                self.balance_heaps()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">balance_heaps</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># maxheap的个数和minheap的个数最多相差1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.maxHeap) &gt; <span class="built_in">len</span>(self.minHeap) + <span class="number">1</span>:</span><br><span class="line">            heappush(self.minHeap, -heappop(self.maxHeap))</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(self.minHeap) &gt; <span class="built_in">len</span>(self.maxHeap):</span><br><span class="line">            heappush(self.maxHeap, -heappop(self.minHeap))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, heap, remove_element</span>):</span></span><br><span class="line">        idx = heap.index(remove_element)</span><br><span class="line">        <span class="comment"># heap[idx] = heap[0]</span></span><br><span class="line">        <span class="comment"># heap.pop()</span></span><br><span class="line">        heap[idx] = heap[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">del</span> heap[-<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 使用heapify这是O(n)，如果你希望你可以在O(log(n))中做同样的事情，使用_siftup / _siftdown</span></span><br><span class="line">        <span class="keyword">if</span> idx &lt; <span class="built_in">len</span>(heap):</span><br><span class="line">            heapq._siftup(heap, idx)</span><br><span class="line">            heapq._siftdown(heap, <span class="number">0</span>, idx)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    sliding_window_median = SlidingWindowMedian()</span><br><span class="line">    res = sliding_window_median.find_sliding_window_median([<span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>], <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = sliding_window_median.find_sliding_window_median([<span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>], <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-1"><a href="#Time-complexity-1" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of our algorithm is <strong><em>O(N\</em>K)*</strong> where ‘N’ is the total number of elements in the input array and ‘K’ is the size of the sliding window. This is due to the fact that we are going through all the ‘N’ numbers and, while doing so, we are doing two things:</p><ol><li>Inserting/removing numbers from heaps of size ‘K’. This will take <strong><em>O(logK)</em></strong></li><li>Removing the element going out of the sliding window. This will take <strong><em>O(K)</em></strong> as we will be searching this element in an array of size ‘K’ (i.e., a heap).</li></ol><h4 id="Space-complexity-1"><a href="#Space-complexity-1" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>Ignoring the space needed for the output array, the space complexity will be <strong><em>O(K)</em></strong> because, at any time, we will be storing all the numbers within the sliding window.</p><h2 id="Maximize-Capital-hard"><a href="#Maximize-Capital-hard" class="headerlink" title="Maximize Capital (hard)"></a>Maximize Capital (hard)</h2><p>leetcode 502</p><h3 id="Problem-Statement-2"><a href="#Problem-Statement-2" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given a set of investment projects with their respective profits, we need to find the <strong>most profitable projects</strong>. We are given an initial capital and are allowed to invest only in a fixed number of projects. Our goal is to choose projects that give us the maximum profit.</p><p>We can start an investment project only when we have the required capital. Once a project is selected, we can assume that its profit has become our capital.</p><p><strong>Example 1:</strong></p><p><strong>Input:</strong> Project Capitals=[0,1,2], Project Profits=[1,2,3], Initial Capital=1, Number of Projects=2<br><strong>Output:</strong> 6<br><strong>Explanation:</strong></p><ol><li>With initial capital of ‘1’, we will start the second project which will give us profit of ‘2’. Once we selected our first project, our total capital will become 3 (profit + initial capital).</li><li>With ‘3’ capital, we will select the third project, which will give us ‘3’ profit.</li></ol><p>After the completion of the two projects, our total capital will be 6 (1+2+3).</p><p><strong>Example 2:</strong></p><p><strong>Input:</strong> Project Capitals=[0,1,2,3], Project Profits=[1,2,3,5], Initial Capital=0, Number of Projects=3<br><strong>Output:</strong> 8<br><strong>Explanation:</strong></p><ol><li>With ‘0’ capital, we can only select the first project, bringing out capital to 1.</li><li>Next, we will select the second project, which will bring our capital to 3.</li><li>Next, we will select the fourth project, giving us a profit of 5.</li></ol><p>After selecting the three projects, our total capital will be 8 (1+2+5).</p><h3 id="Try-it-yourself-2"><a href="#Try-it-yourself-2" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按照solution写的 用例过了,但是是有问题的</span></span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_max_capital</span>(<span class="params">capital, profits, project_num, initial_capital</span>):</span></span><br><span class="line">    min_capital_heap = []</span><br><span class="line">    max_profit_heap = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(profits)):</span><br><span class="line">        <span class="comment"># 默认小顶堆，而且按照第一个元素排列</span></span><br><span class="line">        heappush(min_capital_heap, (capital[i], i))</span><br><span class="line">    available_capital = initial_capital</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(project_num):</span><br><span class="line">        <span class="keyword">while</span> min_capital_heap <span class="keyword">and</span> min_capital_heap[<span class="number">0</span>][<span class="number">0</span>] &lt;= available_capital:</span><br><span class="line">            capital, index = heappop(min_capital_heap)</span><br><span class="line">            heappush(max_profit_heap, (-profits[index], index))</span><br><span class="line"></span><br><span class="line">        available_capital += -heappop(max_profit_heap)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> available_capital</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = find_max_capital([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = find_max_capital([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>], <span class="number">3</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>While selecting projects we have two constraints:</p><ol><li>We can select a project only when we have the required capital.</li><li>There is a maximum limit on how many projects we can select.</li></ol><p>Since we don’t have any constraint on time, we should choose a project, among the projects for which we have enough capital, which gives us a maximum profit. Following this greedy approach will give us the best solution.</p><p>While selecting a project, we will do two things:</p><ol><li>Find all the projects that we can choose with the available capital.</li><li>From the list of projects in the 1st step, choose the project that gives us a maximum profit.</li></ol><p>We can follow the <strong>Two Heaps</strong> approach similar to <strong><em>Find the Median of a Number Stream</em></strong>. Here are the steps of our algorithm:</p><ol><li>Add all project capitals to a min-heap, so that we can select a project with the smallest capital requirement.</li><li>Go through the top projects of the min-heap and filter the projects that can be completed within our available capital. Insert the profits of all these projects into a max-heap, so that we can choose a project with the maximum profit.</li><li>Finally, select the top project of the max-heap for investment.</li><li>Repeat the 2nd and 3rd steps for the required number of projects.</li></ol><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_max_capital</span>(<span class="params">capital, profits, project_num, initial_capital</span>):</span></span><br><span class="line">    min_capital_heap = []</span><br><span class="line">    max_profit_heap = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(profits)):</span><br><span class="line">        <span class="comment"># heapq默认创建小顶堆，而且按照第一个元素排列</span></span><br><span class="line">        heappush(min_capital_heap, (capital[i], i))</span><br><span class="line">    available_capital = initial_capital</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(project_num):</span><br><span class="line">        <span class="keyword">while</span> min_capital_heap <span class="keyword">and</span> min_capital_heap[<span class="number">0</span>][<span class="number">0</span>] &lt;= available_capital:</span><br><span class="line">            capital, index = heappop(min_capital_heap)</span><br><span class="line">            <span class="comment"># push相反数来实现大顶堆</span></span><br><span class="line">            heappush(max_profit_heap, (-profits[index], index))</span><br><span class="line">        <span class="comment"># 如果没有可以负担得起的项目，那就break，不然下面的会报错</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> max_profit_heap:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        available_capital += -heappop(max_profit_heap)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> available_capital</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = find_max_capital([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = find_max_capital([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>], <span class="number">3</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-2"><a href="#Time-complexity-2" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>Since, at the most, all the projects will be pushed to both the heaps once, the time complexity of our algorithm is <strong><em>O(NlogN + KlogN)</em></strong>, where ‘N’ is the total number of projects and ‘K’ is the number of projects we are selecting.</p><h4 id="Space-complexity-2"><a href="#Space-complexity-2" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity will be <strong><em>O(N)</em></strong> because we will be storing all the projects in the heaps.</p><h2 id="Problem-Challenge-1"><a href="#Problem-Challenge-1" class="headerlink" title="Problem Challenge 1"></a>Problem Challenge 1</h2><p>leetcode 436</p><h3 id="Next-Interval-hard"><a href="#Next-Interval-hard" class="headerlink" title="Next Interval (hard)"></a>Next Interval (hard)</h3><p>Given an array of intervals, find the next interval of each interval. In a list of intervals, for an interval ‘i’ its next interval ‘j’ will have the smallest ‘start’ greater than or equal to the ‘end’ of ‘i’.</p><p>Write a function to return an array containing indices of the next interval of each input interval. If there is no next interval of a given interval, return -1. It is given that none of the intervals have the same start point.</p><p><strong>Example 1:</strong></p><blockquote><p><strong>Input:</strong> Intervals [[2,3], [3,4], [5,6]]<br><strong>Output:</strong> [1, 2, -1]<br><strong>Explanation:</strong> The next interval of [2,3] is [3,4] having index ‘1’. Similarly, the next interval of [3,4] is [5,6] having index ‘2’. There is no next interval for [5,6] hence we have ‘-1’.</p></blockquote><p><strong>Example 2:</strong></p><blockquote><p><strong>Input:</strong> Intervals [[3,4], [1,5], [4,6]]<br><strong>Output:</strong> [2, -1, -1]<br><strong>Explanation:</strong> The next interval of [3,4] is [4,6] which has index ‘2’. There is no next interval for [1,5] and [4,6].</p></blockquote><h3 id="Try-it-yourself-3"><a href="#Try-it-yourself-3" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不会</span></span><br></pre></td></tr></table></figure><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>A brute force solution could be to take one interval at a time and go through all the other intervals to find the next interval. This algorithm will take <strong><em>O(N^2)</em></strong> where ‘N’ is the total number of intervals. Can we do better than that?</p><p>We can utilize the <strong>Two Heaps</strong> approach. We can push all intervals into two heaps: one heap to sort the intervals on maximum start time (let’s call it <code>maxStartHeap</code>) and the other on maximum end time (let’s call it <code>maxEndHeap</code>). We can then iterate through all intervals of the `maxEndHeap’ to find their next interval. Our algorithm will have the following steps:</p><ol><li>Take out the top (having highest end) interval from the <code>maxEndHeap</code> to find its next interval. Let’s call this interval <code>topEnd</code>.</li><li>Find an interval in the <code>maxStartHeap</code> with the closest start greater than or equal to the start of <code>topEnd</code>. Since <code>maxStartHeap</code> is sorted by ‘start’ of intervals, it is easy to find the interval with the highest ‘start’. Let’s call this interval <code>topStart</code>.</li><li>Add the index of <code>topStart</code> in the result array as the next interval of <code>topEnd</code>. If we can’t find the next interval, add ‘-1’ in the result array.</li><li>Put the <code>topStart</code> back in the <code>maxStartHeap</code>, as it could be the next interval of other intervals.</li><li>Repeat the steps 1-4 until we have no intervals left in <code>maxEndHeap</code>.</li></ol><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interval</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, start, end</span>):</span></span><br><span class="line">        self.start = start</span><br><span class="line">        self.end = end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_next_interval</span>(<span class="params">intervals</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(intervals)</span><br><span class="line">    max_start_heap = []</span><br><span class="line">    max_end_heap = []</span><br><span class="line">    result = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">for</span> end_index <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        heappush(max_start_heap, (-intervals[end_index].start, end_index))</span><br><span class="line">        heappush(max_end_heap, (-intervals[end_index].end, end_index))</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># let&#x27;s find the next interval of the interval which has the highest &quot;end&quot;</span></span><br><span class="line">        top_end, end_index = heappop(max_end_heap)</span><br><span class="line">        result[end_index] = -<span class="number">1</span>  <span class="comment"># default to be -1</span></span><br><span class="line">        <span class="keyword">if</span> -max_start_heap[<span class="number">0</span>][<span class="number">0</span>] &gt;= -top_end:</span><br><span class="line">            top_start, start_index = heappop(max_start_heap)</span><br><span class="line">            <span class="comment"># find the interval that has the closest start</span></span><br><span class="line">            <span class="keyword">while</span> max_start_heap <span class="keyword">and</span> -max_start_heap[<span class="number">0</span>][<span class="number">0</span>] &gt;= -top_end:</span><br><span class="line">                top_start, start_index = heappop(max_start_heap)</span><br><span class="line">            result[end_index] = start_index</span><br><span class="line">            <span class="comment"># put the interval back as it could be the next interval of another intervals</span></span><br><span class="line">            heappush(max_start_heap, (top_start, start_index))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = find_next_interval([Interval(<span class="number">2</span>, <span class="number">3</span>), Interval(<span class="number">3</span>, <span class="number">4</span>), Interval(<span class="number">5</span>, <span class="number">6</span>)])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = find_next_interval([Interval(<span class="number">3</span>, <span class="number">4</span>), Interval(<span class="number">1</span>, <span class="number">5</span>), Interval(<span class="number">4</span>, <span class="number">6</span>)])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 看了solution之后受启发，把两个heap都作为小顶堆，也过了leetcode436</span></span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interval</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, start, end</span>):</span></span><br><span class="line">        self.start = start</span><br><span class="line">        self.end = end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_next_interval</span>(<span class="params">intervals</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(intervals)</span><br><span class="line">    min_start_heap = []</span><br><span class="line">    min_end_heap = []</span><br><span class="line">    result = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">for</span> end_index <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        heappush(min_start_heap, (intervals[end_index].start, end_index))</span><br><span class="line">        heappush(min_end_heap, (intervals[end_index].end, end_index))</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        top_end, end_index = heappop(min_end_heap)</span><br><span class="line">        result[end_index] = -<span class="number">1</span>  <span class="comment"># default to be -1</span></span><br><span class="line">        <span class="keyword">while</span> min_start_heap <span class="keyword">and</span> min_start_heap[<span class="number">0</span>][<span class="number">0</span>] &lt; top_end:</span><br><span class="line">            heappop(min_start_heap)</span><br><span class="line">        <span class="keyword">if</span> min_start_heap:</span><br><span class="line">            top_start, start_index = heappop(min_start_heap)</span><br><span class="line">            result[end_index] = start_index</span><br><span class="line">            heappush(min_start_heap, (top_start, start_index))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = find_next_interval([Interval(<span class="number">2</span>, <span class="number">3</span>), Interval(<span class="number">3</span>, <span class="number">4</span>), Interval(<span class="number">5</span>, <span class="number">6</span>)])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = find_next_interval([Interval(<span class="number">3</span>, <span class="number">4</span>), Interval(<span class="number">1</span>, <span class="number">5</span>), Interval(<span class="number">4</span>, <span class="number">6</span>)])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-3"><a href="#Time-complexity-3" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of our algorithm will be <strong><em>O(NlogN)</em></strong>, where ‘N’ is the total number of intervals.</p><h4 id="Space-complexity-3"><a href="#Space-complexity-3" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity will be <strong><em>O(N)</em></strong> because we will be storing all the intervals in the heaps.</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>9. Pattern Tree Depth First Search</title>
      <link href="/9-pattern-tree-depth-first-search/index.html"/>
      <url>/9-pattern-tree-depth-first-search/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>This pattern is based on the <strong>Depth First Search (DFS)</strong> technique to traverse a tree.</p><p>We will be using recursion (or we can also use a stack for the iterative approach) to keep track of all the previous (parent) nodes while traversing. This also means that the space complexity of the algorithm will be O(H)<em>O</em>(<em>H</em>), where ‘H’ is the maximum height of the tree.</p><p>Let’s jump onto our first problem to understand this pattern.</p><h2 id="Binary-Tree-Path-Sum-easy"><a href="#Binary-Tree-Path-Sum-easy" class="headerlink" title="*Binary Tree Path Sum (easy)"></a>*Binary Tree Path Sum (easy)</h2><p>leetcode 112</p><h3 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given a binary tree and a number ‘S’, find if the tree has a path from root-to-leaf such that the sum of all the node values of that path equals ‘S’.</p><p><img src="/9-pattern-tree-depth-first-search/index/1.png"></p><p><img src="/9-pattern-tree-depth-first-search/index/2.png"></p><h3 id="Try-it-yourself"><a href="#Try-it-yourself" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>As we are trying to search for a root-to-leaf path, we can use the <strong>Depth First Search (DFS)</strong> technique to solve this problem.</p><p>To recursively traverse a binary tree in a DFS fashion, we can start from the root and at every step, make two recursive calls one for the left and one for the right child.</p><p>Here are the steps for our Binary Tree Path Sum problem:</p><ol><li>Start DFS with the root of the tree.</li><li>If the current node is not a leaf node, do two things:<ul><li>Subtract the value of the current node from the given number to get a new sum =&gt; <code>S = S - node.value</code></li><li>Make two recursive calls for both the children of the current node with the new number calculated in the previous step.</li></ul></li><li>At every step, see if the current node being visited is a leaf node and if its value is equal to the given number ‘S’. If both these conditions are true, we have found the required root-to-leaf path, therefore return <code>true</code>.</li><li>If the current node is a leaf but its value is not equal to the given number ‘S’, return false.</li></ol><p>Let’s take the example-2 mentioned above to visually see our algorithm:</p><p><img src="/9-pattern-tree-depth-first-search/index/3.png"></p><p><img src="/9-pattern-tree-depth-first-search/index/4.png"></p><p><img src="/9-pattern-tree-depth-first-search/index/5.png"></p><p><img src="/9-pattern-tree-depth-first-search/index/6.png"></p><p><img src="/9-pattern-tree-depth-first-search/index/7.png"></p><p><img src="/9-pattern-tree-depth-first-search/index/8.png"></p><p><img src="/9-pattern-tree-depth-first-search/index/9.png"></p><p><img src="/9-pattern-tree-depth-first-search/index/10.png"></p><p><img src="/9-pattern-tree-depth-first-search/index/11.png"></p><p><img src="/9-pattern-tree-depth-first-search/index/12.png"></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left, self.right = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_tree</span>(<span class="params">self</span>):</span></span><br><span class="line">        current = self</span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(current.val) + <span class="string">&quot; &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">has_path</span>(<span class="params">root, <span class="built_in">sum</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">sum</span> - root.val == <span class="number">0</span> <span class="keyword">and</span> root.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> root.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> has_path(root.left, <span class="built_in">sum</span> - root.val) <span class="keyword">or</span> has_path(root.right, <span class="built_in">sum</span> - root.val)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    root = TreeNode(<span class="number">12</span>)</span><br><span class="line">    root.left = TreeNode(<span class="number">7</span>)</span><br><span class="line">    root.right = TreeNode(<span class="number">1</span>)</span><br><span class="line">    root.left.left = TreeNode(<span class="number">9</span>)</span><br><span class="line">    root.right.left = TreeNode(<span class="number">10</span>)</span><br><span class="line">    root.right.right = TreeNode(<span class="number">5</span>)</span><br><span class="line">    res = has_path(root, <span class="number">23</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = has_path(root, <span class="number">16</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity"><a href="#Time-complexity" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of the above algorithm is <strong><em>O(N)</em></strong>, where ‘N’ is the total number of nodes in the tree. This is due to the fact that we traverse each node once.</p><h4 id="Space-complexity"><a href="#Space-complexity" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity of the above algorithm will be <strong><em>O(N)</em></strong> in the worst case. This space will be used to store the recursion stack. The worst case will happen when the given tree is a linked list (i.e., every node has only one child).</p><h2 id="All-Paths-for-a-Sum-medium"><a href="#All-Paths-for-a-Sum-medium" class="headerlink" title="*All Paths for a Sum (medium)"></a>*All Paths for a Sum (medium)</h2><p>leetcode 113</p><h3 id="Problem-Statement-1"><a href="#Problem-Statement-1" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given a binary tree and a number ‘S’, find all paths from root-to-leaf such that the sum of all the node values of each path equals ‘S’.</p><p><img src="/9-pattern-tree-depth-first-search/index/13.png"></p><p><img src="/9-pattern-tree-depth-first-search/index/14.png"></p><h3 id="Try-it-yourself-1"><a href="#Try-it-yourself-1" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <em>Binary Tree Path Sum</em> pattern. We can follow the same <strong>DFS</strong> approach. There will be two differences:</p><ol><li>Every time we find a root-to-leaf path, we will store it in a list.</li><li>We will traverse all paths and will not stop processing after finding the first path.</li></ol><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left, self.right = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_tree</span>(<span class="params">self</span>):</span></span><br><span class="line">        current = self</span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(current.val) + <span class="string">&quot; &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_paths</span>(<span class="params">root, <span class="built_in">sum</span></span>):</span></span><br><span class="line">    all_path = []</span><br><span class="line">    find_paths_recrsive(root, <span class="built_in">sum</span>, [], all_path)</span><br><span class="line">    <span class="keyword">return</span> all_path</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_paths_recrsive</span>(<span class="params">root, <span class="built_in">sum</span>, current_path, all_path</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 原来以为这个if加了可以剪枝，还想着solution里怎么没有加，然后在leetcode提提交了之后出错了“[-2,null,-3]”。因为节点的值可能是负数。</span></span><br><span class="line">    <span class="comment"># if sum &lt; root.val:</span></span><br><span class="line">    <span class="comment">#     return</span></span><br><span class="line">    current_path.append(root.val)</span><br><span class="line">    <span class="keyword">if</span> root.val == <span class="built_in">sum</span> <span class="keyword">and</span> root.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> root.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 注意这里一定要是list(current_path)或者重新定义一个变量</span></span><br><span class="line">        all_path.append(<span class="built_in">list</span>(current_path))</span><br><span class="line">    find_paths_recrsive(root.left, <span class="built_in">sum</span> - root.val, current_path, all_path)</span><br><span class="line">    find_paths_recrsive(root.right, <span class="built_in">sum</span> - root.val, current_path, all_path)</span><br><span class="line">    <span class="comment"># 这句话没有加</span></span><br><span class="line">    <span class="keyword">del</span> current_path[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    root = TreeNode(<span class="number">12</span>)</span><br><span class="line">    root.left = TreeNode(<span class="number">7</span>)</span><br><span class="line">    root.right = TreeNode(<span class="number">1</span>)</span><br><span class="line">    root.left.left = TreeNode(<span class="number">4</span>)</span><br><span class="line">    root.right.left = TreeNode(<span class="number">10</span>)</span><br><span class="line">    root.right.right = TreeNode(<span class="number">5</span>)</span><br><span class="line">    res = find_paths(root, <span class="number">23</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-1"><a href="#Time-complexity-1" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of the above algorithm is <strong><em>O(N^2)</em></strong>, where ‘N’ is the total number of nodes in the tree. This is due to the fact that we traverse each node once (which will take <strong><em>O(N)</em></strong>), and for every leaf node we might have to store its path which will take <strong><em>O(N)</em></strong>.</p><p>We can calculate a tighter time complexity of <strong><em>O(NlogN)</em></strong> from the space complexity discussion below.</p><h4 id="Space-complexity-1"><a href="#Space-complexity-1" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>If we ignore the space required for the <code>allPaths</code> list, the space complexity of the above algorithm will be <strong><em>O(N)</em></strong> in the worst case. This space will be used to store the recursion stack. The worst case will happen when the given tree is a linked list (i.e., every node has only one child).</p><p>How can we estimate the space used for the <code>allPaths</code> array? Take the example of the following balanced tree:</p><p><img src="/9-pattern-tree-depth-first-search/index/15.png"></p><p>Here we have seven nodes (i.e., <code>N = 7</code>). Since, for binary trees, there exists only one path to reach any leaf node, we can easily say that total root-to-leaf paths in a binary tree can’t be more than the number of leaves. As we know that there can’t be more than <strong><em>N/2</em></strong> leaves in a binary tree, therefore the maximum number of elements in <code>allPaths</code> will be <strong><em>O(N/2) = O(N)</em></strong>. Now, each of these paths can have many nodes in them. For a balanced binary tree (like above), each leaf node will be at maximum depth. As we know that the depth (or height) of a balanced binary tree is <strong><em>O(logN)</em></strong> we can say that, at the most, each path can have <strong><em>logN</em></strong> nodes in it. This means that the total size of the allPaths list will be <strong><em>O(N</em>\logN)*</strong>. If the tree is not balanced, we will still have the same worst-case space complexity.</p><p>From the above discussion, we can conclude that the overall space complexity of our algorithm is <strong><em>O(N</em>logN)*</strong>.</p><p>Also from the above discussion, since for each leaf node, in the worst case, we have to copy <strong><em>log(N)</em></strong> nodes to store its path, therefore the time complexity of our algorithm will also be <strong><em>O(N\</em>logN)*</strong>.</p><h3 id="Similar-Problems"><a href="#Similar-Problems" class="headerlink" title="Similar Problems"></a>Similar Problems</h3><p><strong>Problem 1:</strong> Given a binary tree, return all root-to-leaf paths.</p><p><em>Solution:</em> We can follow a similar approach. We just need to remove the “check for the path sum”.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">    TreeNode* left = <span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode* right = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">        left = right = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FindAllTreePaths</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">findPath</span>(TreeNode* root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; allPaths;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; currentPath;</span><br><span class="line">        <span class="built_in">findPathsRecursive</span>(root, sum, currentPath, allPaths);</span><br><span class="line">        <span class="keyword">return</span> allPaths;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findPathsRecursive</span><span class="params">(TreeNode* currentNode, <span class="keyword">int</span> sum,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   vector&lt;<span class="keyword">int</span>&gt;&amp; currentPath,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; allPaths)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentNode == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// add the current node to the path</span></span><br><span class="line">        currentPath.<span class="built_in">push_back</span>(currentNode-&gt;val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if the current node is a leaf and its values is equals to sum</span></span><br><span class="line">        <span class="comment">// save the current path</span></span><br><span class="line">        <span class="keyword">if</span> (currentNode-&gt;left == <span class="literal">nullptr</span> &amp;&amp; currentNode-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            allPaths.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt;(currentPath));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">findPathsRecursive</span>(currentNode-&gt;left, sum - currentNode-&gt;val,</span><br><span class="line">                               currentPath, allPaths);</span><br><span class="line">            <span class="built_in">findPathsRecursive</span>(currentNode-&gt;right, sum - currentNode-&gt;val,</span><br><span class="line">                               currentPath, allPaths);</span><br><span class="line">        &#125;</span><br><span class="line">        currentPath.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">12</span>);</span><br><span class="line">    root-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">7</span>);</span><br><span class="line">    root-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line">    root-&gt;left-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">4</span>);</span><br><span class="line">    root-&gt;right-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">10</span>);</span><br><span class="line">    root-&gt;right-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">23</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result = FindAllTreePaths::<span class="built_in">findPath</span>(root, sum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> vec : result) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : vec) &#123;</span><br><span class="line">            cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Problem 2:</strong> Given a binary tree, find the root-to-leaf path with the maximum sum.</p><p><em>Solution:</em> We need to find the path with the maximum sum. As we traverse all paths, we can keep track of the path with the maximum sum.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">    TreeNode* left = <span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode* right = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">        left = right = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FindAllTreePaths</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">findPath</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; MaxSumPath;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; currentPath;</span><br><span class="line">        <span class="keyword">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> currentSum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">findPathsRecursive</span>(root, currentSum, maxSum, currentPath, MaxSumPath);</span><br><span class="line">        <span class="keyword">return</span> MaxSumPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findPathsRecursive</span><span class="params">(TreeNode* currentNode, <span class="keyword">int</span>&amp; currentSum,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">int</span>&amp; maxSum, vector&lt;<span class="keyword">int</span>&gt;&amp; currentPath,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; MaxSumPath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentNode == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        currentPath.<span class="built_in">push_back</span>(currentNode-&gt;val);</span><br><span class="line">        currentSum += currentNode-&gt;val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentNode-&gt;left == <span class="literal">nullptr</span> &amp;&amp; currentNode-&gt;right == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">            currentSum &gt;= maxSum) &#123;</span><br><span class="line">            MaxSumPath.<span class="built_in">push_back</span>(currentPath);</span><br><span class="line">            maxSum = currentSum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">findPathsRecursive</span>(currentNode-&gt;left, currentSum, maxSum,</span><br><span class="line">                               currentPath, MaxSumPath);</span><br><span class="line">            <span class="built_in">findPathsRecursive</span>(currentNode-&gt;right, currentSum, maxSum,</span><br><span class="line">                               currentPath, MaxSumPath);</span><br><span class="line">        &#125;</span><br><span class="line">        currentSum -= currentPath[currentPath.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">        currentPath.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">12</span>);</span><br><span class="line">    root-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">7</span>);</span><br><span class="line">    root-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line">    root-&gt;left-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">4</span>);</span><br><span class="line">    root-&gt;right-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">10</span>);</span><br><span class="line">    root-&gt;right-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">23</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result = FindAllTreePaths::<span class="built_in">findPath</span>(root);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> vec : result) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : vec) &#123;</span><br><span class="line">            cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Sum-of-Path-Numbers-medium"><a href="#Sum-of-Path-Numbers-medium" class="headerlink" title="Sum of Path Numbers (medium)"></a>Sum of Path Numbers (medium)</h2><p>leetcode 129</p><h3 id="Problem-Statement-2"><a href="#Problem-Statement-2" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given a binary tree where each node can only have a digit (0-9) value, each root-to-leaf path will represent a number. Find the total sum of all the numbers represented by all paths.</p><p><img src="/9-pattern-tree-depth-first-search/index/16.png"></p><p><img src="/9-pattern-tree-depth-first-search/index/17.png"></p><h3 id="Try-it-yourself-2"><a href="#Try-it-yourself-2" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和solution不一样</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left, self.right = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_tree</span>(<span class="params">self</span>):</span></span><br><span class="line">        current = self</span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(current.val) + <span class="string">&quot; &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_paths</span>(<span class="params">root</span>):</span></span><br><span class="line">    all_nums = []</span><br><span class="line">    find_sum_of_path_numbers(root, <span class="number">0</span>, all_nums)</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> all_nums:</span><br><span class="line">        res += i</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_sum_of_path_numbers</span>(<span class="params">root, current_num, all_nums</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    current_num = current_num * <span class="number">10</span> + root.val</span><br><span class="line">    <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> root.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        all_nums.append(current_num)</span><br><span class="line">    find_sum_of_path_numbers(root.left, current_num, all_nums)</span><br><span class="line">    find_sum_of_path_numbers(root.right, current_num, all_nums)</span><br><span class="line">    current_num = (current_num - root.val) / <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    root = TreeNode(<span class="number">1</span>)</span><br><span class="line">    root.left = TreeNode(<span class="number">7</span>)</span><br><span class="line">    root.right = TreeNode(<span class="number">9</span>)</span><br><span class="line">    root.right.left = TreeNode(<span class="number">2</span>)</span><br><span class="line">    root.right.right = TreeNode(<span class="number">9</span>)</span><br><span class="line">    res = find_paths(root)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <strong><em>Binary Tree Path Sum</em></strong> pattern. We can follow the same <strong>DFS</strong> approach. The additional thing we need to do is to keep track of the number representing the current path.</p><p>How do we calculate the path number for a node? Taking the first example mentioned above, say we are at node ‘7’. As we know, the path number for this node is ‘17’, which was calculated by: <code>1 * 10 + 7 =&gt; 17</code>. We will follow the same approach to calculate the path number of each node.</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left, self.right = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_tree</span>(<span class="params">self</span>):</span></span><br><span class="line">        current = self</span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(current.val) + <span class="string">&quot; &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_paths</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">return</span> find_sum_of_path_numbers(root, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_sum_of_path_numbers</span>(<span class="params">root, path_sum</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    path_sum = path_sum * <span class="number">10</span> + root.val</span><br><span class="line">    <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> root.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> path_sum</span><br><span class="line">    <span class="comment"># 这样就用除队列的操作</span></span><br><span class="line">    <span class="keyword">return</span> find_sum_of_path_numbers(root.left, path_sum) + find_sum_of_path_numbers(root.right, path_sum)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    root = TreeNode(<span class="number">1</span>)</span><br><span class="line">    root.left = TreeNode(<span class="number">7</span>)</span><br><span class="line">    root.right = TreeNode(<span class="number">9</span>)</span><br><span class="line">    root.right.left = TreeNode(<span class="number">2</span>)</span><br><span class="line">    root.right.right = TreeNode(<span class="number">9</span>)</span><br><span class="line">    res = find_paths(root)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-2"><a href="#Time-complexity-2" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of the above algorithm is <strong><em>O(N)</em></strong>, where ‘N’ is the total number of nodes in the tree. This is due to the fact that we traverse each node once.</p><h4 id="Space-complexity-2"><a href="#Space-complexity-2" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity of the above algorithm will be <strong><em>O(N)</em></strong> in the worst case. This space will be used to store the recursion stack. The worst case will happen when the given tree is a linked list (i.e., every node has only one child).</p><h2 id="Path-With-Given-Sequence-medium"><a href="#Path-With-Given-Sequence-medium" class="headerlink" title="*Path With Given Sequence (medium)"></a>*Path With Given Sequence (medium)</h2><p>不在leetcode</p><h3 id="Problem-Statement-3"><a href="#Problem-Statement-3" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given a binary tree and a number sequence, find if the sequence is present as a <strong>root-to-leaf</strong> path in the given tree.</p><p><img src="/9-pattern-tree-depth-first-search/index/18.png"></p><p><img src="/9-pattern-tree-depth-first-search/index/19.png"></p><h3 id="Try-it-yourself-3"><a href="#Try-it-yourself-3" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和solution不一样 但是过了测试用例，但是是有问题的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left, self.right = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_tree</span>(<span class="params">self</span>):</span></span><br><span class="line">        current = self</span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(current.val) + <span class="string">&quot; &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_path</span>(<span class="params">root, sequence</span>):</span></span><br><span class="line">    <span class="keyword">return</span> find_path_recursive(root, sequence, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_path_recursive</span>(<span class="params">root, sequence, index</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> sequence[index] == root.val:</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> index == <span class="built_in">len</span>(sequence) <span class="keyword">and</span> root.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> root.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> find_path_recursive(root.left, sequence, index) <span class="keyword">or</span> find_path_recursive(root.right, sequence, index)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    root = TreeNode(<span class="number">1</span>)</span><br><span class="line">    root.left = TreeNode(<span class="number">0</span>)</span><br><span class="line">    root.right = TreeNode(<span class="number">1</span>)</span><br><span class="line">    root.left.left = TreeNode(<span class="number">1</span>)</span><br><span class="line">    root.right.left = TreeNode(<span class="number">6</span>)</span><br><span class="line">    root.right.right = TreeNode(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    res = find_path(root, [<span class="number">1</span>, <span class="number">0</span>, <span class="number">7</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = find_path(root, [<span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <em>Binary Tree Path Sum</em> pattern. We can follow the same <strong>DFS</strong> approach and additionally, track the element of the given sequence that we should match with the current node. Also, we can return <code>false</code> as soon as we find a mismatch between the sequence and the node value.</p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left, self.right = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_tree</span>(<span class="params">self</span>):</span></span><br><span class="line">        current = self</span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(current.val) + <span class="string">&quot; &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_path</span>(<span class="params">root, sequence</span>):</span></span><br><span class="line">    <span class="keyword">return</span> find_path_recursive(root, sequence, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_path_recursive</span>(<span class="params">root, sequence, index</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    seq_len = <span class="built_in">len</span>(sequence)</span><br><span class="line">    <span class="comment"># 注意这里的index &gt;= seq_len, 如果是[1,1],那么包含这个路径，但是不是完全路径，这个时候如果不加这个条件就会IndexError</span></span><br><span class="line">    <span class="keyword">if</span> index &gt;= seq_len <span class="keyword">or</span> sequence[index] != root.val:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> index == <span class="built_in">len</span>(sequence) - <span class="number">1</span> <span class="keyword">and</span> root.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> root.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> find_path_recursive(root.left, sequence, index + <span class="number">1</span>) <span class="keyword">or</span> find_path_recursive(root.right, sequence, index + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    root = TreeNode(<span class="number">1</span>)</span><br><span class="line">    root.left = TreeNode(<span class="number">0</span>)</span><br><span class="line">    root.right = TreeNode(<span class="number">1</span>)</span><br><span class="line">    root.left.left = TreeNode(<span class="number">1</span>)</span><br><span class="line">    root.right.left = TreeNode(<span class="number">6</span>)</span><br><span class="line">    root.right.right = TreeNode(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    res = find_path(root, [<span class="number">1</span>, <span class="number">0</span>, <span class="number">7</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line">    res = find_path(root, [<span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-3"><a href="#Time-complexity-3" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of the above algorithm is <strong><em>O(N)</em></strong>, where ‘N’ is the total number of nodes in the tree. This is due to the fact that we traverse each node once.</p><h4 id="Space-complexity-3"><a href="#Space-complexity-3" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity of the above algorithm will be <strong><em>O(N)</em></strong> in the worst case. This space will be used to store the recursion stack. The worst case will happen when the given tree is a linked list (i.e., every node has only one child).</p><h2 id="Count-Paths-for-a-Sum-medium"><a href="#Count-Paths-for-a-Sum-medium" class="headerlink" title="*Count Paths for a Sum (medium)"></a>*Count Paths for a Sum (medium)</h2><p>不在leetcode</p><h3 id="Problem-Statement-4"><a href="#Problem-Statement-4" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given a binary tree and a number ‘S’, find all paths in the tree such that the sum of all the node values of each path equals ‘S’. Please note that the paths can start or end at any node but all paths must follow direction from parent to child (top to bottom).</p><p><img src="/9-pattern-tree-depth-first-search/index/20.png"></p><p><img src="/9-pattern-tree-depth-first-search/index/21.png"></p><h3 id="Try-it-yourself-4"><a href="#Try-it-yourself-4" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试用例可以过，思想就是，对于每一个节点都使用递归计算，可能也会TLE，具体详见下一题“problem challenge 1&quot;</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left, self.right = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_tree</span>(<span class="params">self</span>):</span></span><br><span class="line">        current = self</span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(current.val) + <span class="string">&quot; &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_paths</span>(<span class="params">root, target_sum</span>):</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    queue = deque()</span><br><span class="line">    queue.append(root)</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        current_node = queue.popleft()</span><br><span class="line">        res += count_paths_recursive(current_node, target_sum)</span><br><span class="line">        <span class="keyword">if</span> current_node.left:</span><br><span class="line">            queue.append(current_node.left)</span><br><span class="line">        <span class="keyword">if</span> current_node.right:</span><br><span class="line">            queue.append(current_node.right)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_paths_recursive</span>(<span class="params">root, target_sum</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> root.val == target_sum:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count_paths_recursive(root.left, target_sum - root.val) + count_paths_recursive(root.right,</span><br><span class="line">                                                                                           target_sum - root.val)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    root = TreeNode(<span class="number">12</span>)</span><br><span class="line">    root.left = TreeNode(<span class="number">7</span>)</span><br><span class="line">    root.right = TreeNode(<span class="number">1</span>)</span><br><span class="line">    root.left.left = TreeNode(<span class="number">4</span>)</span><br><span class="line">    root.right.left = TreeNode(<span class="number">10</span>)</span><br><span class="line">    root.right.right = TreeNode(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    res = count_paths(root, <span class="number">11</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <em>Binary Tree Path Sum</em> pattern. We can follow the same <strong>DFS</strong> approach. But there will be four differences:</p><ol><li>We will keep track of the current path in a list which will be passed to every recursive call.</li><li>Whenever we traverse a node we will do two things:<ul><li>Add the current node to the current path.</li><li>As we added a new node to the current path, we should find the sums of all sub-paths ending at the current node. If the sum of any sub-path is equal to ‘S’ we will increment our path count.</li></ul></li><li>We will traverse all paths and will not stop processing after finding the first path.</li><li>Remove the current node from the current path before returning from the function. This is needed to <strong>Backtrack</strong> while we are going up the recursive call stack to process other paths.</li></ol><h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left, self.right = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_tree</span>(<span class="params">self</span>):</span></span><br><span class="line">        current = self</span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(current.val) + <span class="string">&quot; &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_paths</span>(<span class="params">root, target_sum</span>):</span></span><br><span class="line">    <span class="keyword">return</span> count_paths_recursive(root, target_sum, [])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_paths_recursive</span>(<span class="params">root, target_sum, current_path</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    current_path.append(root)</span><br><span class="line">    path_count, path_sum = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(current_path) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        path_sum += current_path[i].val</span><br><span class="line">        <span class="keyword">if</span> path_sum == target_sum:</span><br><span class="line">            path_count += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 把下面四行揭开注释，最后一个return注释，就是solution的解法，其实是一样的</span></span><br><span class="line">    <span class="comment"># path_count += count_paths_recursive(root.left, target_sum, current_path)</span></span><br><span class="line">    <span class="comment"># path_count += count_paths_recursive(root.right, target_sum, current_path)</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># del current_path[-1]</span></span><br><span class="line">    <span class="comment"># return path_count</span></span><br><span class="line">    <span class="keyword">return</span> path_count + count_paths_recursive(root.left, target_sum, current_path) + count_paths_recursive(root.right, target_sum,</span><br><span class="line">                                                                                              current_path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    root = TreeNode(<span class="number">12</span>)</span><br><span class="line">    root.left = TreeNode(<span class="number">7</span>)</span><br><span class="line">    root.right = TreeNode(<span class="number">1</span>)</span><br><span class="line">    root.left.left = TreeNode(<span class="number">4</span>)</span><br><span class="line">    root.right.left = TreeNode(<span class="number">10</span>)</span><br><span class="line">    root.right.right = TreeNode(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    res = count_paths(root, <span class="number">11</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-4"><a href="#Time-complexity-4" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of the above algorithm is <strong><em>O(N^2)</em></strong> in the worst case, where ‘N’ is the total number of nodes in the tree. This is due to the fact that we traverse each node once, but for every node, we iterate the current path. The current path, in the worst case, can be <strong><em>O(N)</em></strong> (in the case of a skewed tree). But, if the tree is balanced, then the current path will be equal to the height of the tree, i.e., <strong><em>O(logN)</em></strong>. So the best case of our algorithm will be <strong><em>O(NlogN)</em></strong>.</p><h4 id="Space-complexity-4"><a href="#Space-complexity-4" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity of the above algorithm will be <strong><em>O(N)</em></strong>. This space will be used to store the recursion stack. The worst case will happen when the given tree is a linked list (i.e., every node has only one child). We also need <strong><em>O(N)</em></strong> space for storing the <code>currentPath</code> in the worst case.</p><p>Overall space complexity of our algorithm is <strong><em>O(N)</em></strong>.</p><h2 id="Problem-Challenge-1"><a href="#Problem-Challenge-1" class="headerlink" title="*Problem Challenge 1"></a>*Problem Challenge 1</h2><p>leetcode 543,有一点不一样，大致相同</p><h3 id="Tree-Diameter-medium"><a href="#Tree-Diameter-medium" class="headerlink" title="Tree Diameter (medium)"></a>Tree Diameter (medium)</h3><p>Given a binary tree, find the length of its diameter. The diameter of a tree is the number of nodes on the <strong>longest path between any two leaf nodes</strong>. The diameter of a tree may or may not pass through the root.</p><p>Note: You can always assume that there are at least two leaf nodes in the given tree.</p><p><img src="/9-pattern-tree-depth-first-search/index/22.png"></p><p><img src="/9-pattern-tree-depth-first-search/index/23.png"></p><h3 id="Try-it-yourself-5"><a href="#Try-it-yourself-5" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here: TLE</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用例跑过了,但是数据量较大的话会TLE,参考leetcode 54324/03/19提交的两次</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left, self.right = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_tree</span>(<span class="params">self</span>):</span></span><br><span class="line">        current = self</span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(current.val) + <span class="string">&quot; &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_diameter</span>(<span class="params">root</span>):</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    queue = deque()</span><br><span class="line">    queue.append(root)</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        current_node = queue.popleft()</span><br><span class="line">        res = <span class="built_in">max</span>(res, calculate_height(current_node.left) + calculate_height(current_node.right) + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> current_node.left:</span><br><span class="line">            queue.append(current_node.left)</span><br><span class="line">        <span class="keyword">if</span> current_node.right:</span><br><span class="line">            queue.append(current_node.right)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_height</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> root.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(calculate_height(root.left), calculate_height(root.right)) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    root = TreeNode(<span class="number">1</span>)</span><br><span class="line">    root.left = TreeNode(<span class="number">2</span>)</span><br><span class="line">    root.right = TreeNode(<span class="number">3</span>)</span><br><span class="line">    root.right.left = TreeNode(<span class="number">5</span>)</span><br><span class="line">    root.right.right = TreeNode(<span class="number">6</span>)</span><br><span class="line">    root.right.left.left = TreeNode(<span class="number">7</span>)</span><br><span class="line">    root.right.left.right = TreeNode(<span class="number">8</span>)</span><br><span class="line">    root.right.left.right.left = TreeNode(<span class="number">10</span>)</span><br><span class="line">    root.right.right.left = TreeNode(<span class="number">9</span>)</span><br><span class="line">    root.right.right.left.left = TreeNode(<span class="number">11</span>)</span><br><span class="line">    res = find_diameter(root)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <em>Binary Tree Path Sum</em> pattern. We can follow the same <strong>DFS</strong> approach. There will be a few differences:</p><ol><li>At every step, we need to find the height of both children of the current node. For this, we will make two recursive calls similar to <strong>DFS</strong>.</li><li>The height of the current node will be equal to the maximum of the heights of its left or right children, plus ‘1’ for the current node.</li><li>The tree diameter at the current node will be equal to the height of the left child plus the height of the right child plus ‘1’ for the current node: <code>diameter = leftTreeHeight + rightTreeHeight + 1</code>. To find the overall tree diameter, we will use a class level variable. This variable will store the maximum diameter of all the nodes visited so far, hence, eventually, it will have the final tree diameter.</li></ol><h3 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和我的思路一样 但是实现不一样，这个最优，不会时间超限</span></span><br><span class="line"><span class="comment"># solution的写法还和下面的不太一样，我使用使用了res[0]包装了返回值，使得在递归的时候是引用传递，soltion是直接写了一个类，把返回值作为类的熟悉，类似”problem chanllege 2&quot;</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left, self.right = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_tree</span>(<span class="params">self</span>):</span></span><br><span class="line">        current = self</span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(current.val) + <span class="string">&quot; &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_diameter</span>(<span class="params">root</span>):</span></span><br><span class="line">    res = [<span class="number">0</span>]</span><br><span class="line">    calculate_height(root, res)</span><br><span class="line">    <span class="keyword">return</span> res[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_height</span>(<span class="params">root, diameter</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    left_height = calculate_height(root.left, diameter)</span><br><span class="line">    right_height = calculate_height(root.right, diameter)</span><br><span class="line"></span><br><span class="line">    loacl_diameter = left_height + right_height + <span class="number">1</span></span><br><span class="line">    diameter[<span class="number">0</span>] = <span class="built_in">max</span>(diameter[<span class="number">0</span>], loacl_diameter)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(left_height, right_height) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    root = TreeNode(<span class="number">1</span>)</span><br><span class="line">    root.left = TreeNode(<span class="number">2</span>)</span><br><span class="line">    root.right = TreeNode(<span class="number">3</span>)</span><br><span class="line">    root.right.left = TreeNode(<span class="number">5</span>)</span><br><span class="line">    root.right.right = TreeNode(<span class="number">6</span>)</span><br><span class="line">    root.right.left.left = TreeNode(<span class="number">7</span>)</span><br><span class="line">    root.right.left.right = TreeNode(<span class="number">8</span>)</span><br><span class="line">    root.right.left.right.left = TreeNode(<span class="number">10</span>)</span><br><span class="line">    root.right.right.left = TreeNode(<span class="number">9</span>)</span><br><span class="line">    root.right.right.left.left = TreeNode(<span class="number">11</span>)</span><br><span class="line">    res = find_diameter(root)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 改进，不适用res[0]</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left, self.right = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_tree</span>(<span class="params">self</span>):</span></span><br><span class="line">        current = self</span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(current.val) + <span class="string">&quot; &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_diameter</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        self.diameter = <span class="number">0</span></span><br><span class="line">        self.calculate_height(root)</span><br><span class="line">        <span class="keyword">return</span> self.diameter</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate_height</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left_height = self.calculate_height(root.left)</span><br><span class="line">        right_height = self.calculate_height(root.right)</span><br><span class="line"></span><br><span class="line">        loacl_diameter = left_height + right_height + <span class="number">1</span></span><br><span class="line">        self.diameter = <span class="built_in">max</span>(self.diameter, loacl_diameter)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left_height, right_height) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    solution = Solution()</span><br><span class="line">    root = TreeNode(<span class="number">1</span>)</span><br><span class="line">    root.left = TreeNode(<span class="number">2</span>)</span><br><span class="line">    root.right = TreeNode(<span class="number">3</span>)</span><br><span class="line">    root.right.left = TreeNode(<span class="number">5</span>)</span><br><span class="line">    root.right.right = TreeNode(<span class="number">6</span>)</span><br><span class="line">    root.right.left.left = TreeNode(<span class="number">7</span>)</span><br><span class="line">    root.right.left.right = TreeNode(<span class="number">8</span>)</span><br><span class="line">    root.right.left.right.left = TreeNode(<span class="number">10</span>)</span><br><span class="line">    root.right.right.left = TreeNode(<span class="number">9</span>)</span><br><span class="line">    root.right.right.left.left = TreeNode(<span class="number">11</span>)</span><br><span class="line">    res = solution.find_diameter(root)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-5"><a href="#Time-complexity-5" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of the above algorithm is <em>O(N)</em>, where ‘N’ is the total number of nodes in the tree. This is due to the fact that we traverse each node once.</p><h4 id="Space-complexity-5"><a href="#Space-complexity-5" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity of the above algorithm will be <em>O(N)</em> in the worst case. This space will be used to store the recursion stack. The worst case will happen when the given tree is a linked list (i.e., every node has only one child).</p><h2 id="Problem-Challenge-2"><a href="#Problem-Challenge-2" class="headerlink" title="*Problem Challenge 2"></a>*Problem Challenge 2</h2><p>leetcode 124</p><h3 id="Path-with-Maximum-Sum-hard"><a href="#Path-with-Maximum-Sum-hard" class="headerlink" title="Path with Maximum Sum (hard)"></a>Path with Maximum Sum (hard)</h3><p>Find the path with the maximum sum in a given binary tree. Write a function that returns the maximum sum. A path can be defined as a <strong>sequence of nodes between any two nodes</strong> and doesn’t necessarily pass through the root.</p><p><img src="/9-pattern-tree-depth-first-search/index/24.png"></p><p><img src="/9-pattern-tree-depth-first-search/index/25.png"></p><h3 id="Try-it-yourself-6"><a href="#Try-it-yourself-6" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不全对，看solution</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left, self.right = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_tree</span>(<span class="params">self</span>):</span></span><br><span class="line">        current = self</span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(current.val) + <span class="string">&quot; &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaximunPathSum</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_max_path_sum</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        self.global_max_sum = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">        self.find_max_path_sum_recursive(root)</span><br><span class="line">        <span class="keyword">return</span> self.global_max_sum</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_max_path_sum_recursive</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left_sum = self.find_max_path_sum_recursive(root.left)</span><br><span class="line">        right_sum = self.find_max_path_sum_recursive(root.right)</span><br><span class="line">        self.global_max_sum = <span class="built_in">max</span>(self.global_max_sum, left_sum + right_sum + root.val)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left_sum, right_sum) + root.val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    max_path_sum = MaximunPathSum()</span><br><span class="line">    root = TreeNode(<span class="number">1</span>)</span><br><span class="line">    root.left = TreeNode(<span class="number">2</span>)</span><br><span class="line">    root.right = TreeNode(<span class="number">3</span>)</span><br><span class="line">    root.left.left = TreeNode(<span class="number">1</span>)</span><br><span class="line">    root.left.right = TreeNode(<span class="number">3</span>)</span><br><span class="line">    root.right.left = TreeNode(<span class="number">5</span>)</span><br><span class="line">    root.right.right = TreeNode(<span class="number">6</span>)</span><br><span class="line">    root.right.left.left = TreeNode(<span class="number">7</span>)</span><br><span class="line">    root.right.left.right = TreeNode(<span class="number">8</span>)</span><br><span class="line">    root.right.right.left = TreeNode(<span class="number">9</span>)</span><br><span class="line">    res = max_path_sum.find_max_path_sum(root)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <em>Binary Tree Path Sum pattern</em> and shares the algorithmic logic with <em>Tree Diameter</em>. We can follow the same <strong>DFS</strong> approach. The only difference will be to ignore the paths with negative sums. Since we need to find the overall maximum sum, we should ignore any path which has an overall negative sum.</p><h3 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like, the most important changes are in the highlighted lines:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left, self.right = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_tree</span>(<span class="params">self</span>):</span></span><br><span class="line">        current = self</span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(current.val) + <span class="string">&quot; &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaximunPathSum</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_max_path_sum</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        self.global_max_sum = -math.inf</span><br><span class="line">        self.find_max_path_sum_recursive(root)</span><br><span class="line">        <span class="keyword">return</span> self.global_max_sum</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_max_path_sum_recursive</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left_sum = self.find_max_path_sum_recursive(root.left)</span><br><span class="line">        right_sum = self.find_max_path_sum_recursive(root.right)</span><br><span class="line">        <span class="comment"># 忽略掉那些最后的值是负数的路径, 这个是自己没有想到的</span></span><br><span class="line">        <span class="comment"># 这也是唯一和我的代码不同的</span></span><br><span class="line">        <span class="comment"># 加上这句话就是满足题目任意节点之间的路径</span></span><br><span class="line">        <span class="comment"># 不加上就是任意叶节点之间的路径</span></span><br><span class="line">        left_sum = <span class="built_in">max</span>(left_sum, <span class="number">0</span>);</span><br><span class="line">        right_sum = <span class="built_in">max</span>(right_sum, <span class="number">0</span>);</span><br><span class="line">        self.global_max_sum = <span class="built_in">max</span>(self.global_max_sum, left_sum + right_sum + root.val)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left_sum, right_sum) + root.val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    max_path_sum = MaximunPathSum()</span><br><span class="line">    root = TreeNode(<span class="number">1</span>)</span><br><span class="line">    root.left = TreeNode(<span class="number">2</span>)</span><br><span class="line">    root.right = TreeNode(<span class="number">3</span>)</span><br><span class="line">    root.left.left = TreeNode(<span class="number">1</span>)</span><br><span class="line">    root.left.right = TreeNode(<span class="number">3</span>)</span><br><span class="line">    root.right.left = TreeNode(<span class="number">5</span>)</span><br><span class="line">    root.right.right = TreeNode(<span class="number">6</span>)</span><br><span class="line">    root.right.left.left = TreeNode(<span class="number">7</span>)</span><br><span class="line">    root.right.left.right = TreeNode(<span class="number">8</span>)</span><br><span class="line">    root.right.right.left = TreeNode(<span class="number">9</span>)</span><br><span class="line">    res = max_path_sum.find_max_path_sum(root)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-6"><a href="#Time-complexity-6" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of the above algorithm is <em>O(N)</em>, where ‘N’ is the total number of nodes in the tree. This is due to the fact that we traverse each node once.</p><h4 id="Space-complexity-6"><a href="#Space-complexity-6" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity of the above algorithm will be <em>O(N)</em> in the worst case. This space will be used to store the recursion stack. The worst case will happen when the given tree is a linked list (i.e., every node has only one child).</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8. Pattern Tree Breadth First Search</title>
      <link href="/8-pattern-tree-breadth-first-search/index.html"/>
      <url>/8-pattern-tree-breadth-first-search/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>This pattern is based on the <strong>Breadth First Search (BFS)</strong> technique to traverse a tree.</p><p>Any problem involving the traversal of a tree in a level-by-level order can be efficiently solved using this approach. We will use a <strong>Queue</strong> to keep track of all the nodes of a level before we jump onto the next level. This also means that the <strong>space complexity</strong> of the algorithm will be <strong><em>O(W)</em></strong>, where ‘W’ is the maximum number of nodes on any level.</p><p>Let’s jump onto our first problem to understand this pattern.</p><h2 id="Binary-Tree-Level-Order-Traversal-easy"><a href="#Binary-Tree-Level-Order-Traversal-easy" class="headerlink" title="Binary Tree Level Order Traversal (easy)"></a>Binary Tree Level Order Traversal (easy)</h2><p>leetcode 102</p><h3 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given a binary tree, populate an array to represent its level-by-level traversal. You should populate the values of all <strong>nodes of each level from left to right</strong> in separate sub-arrays.</p><p><strong>Example 1:</strong></p><p><img src="/8-pattern-tree-breadth-first-search/index/1.png"></p><p><strong>Example 2:</strong></p><p><img src="/8-pattern-tree-breadth-first-search/index/2.png"></p><h3 id="Try-it-yourself"><a href="#Try-it-yourself" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left, self.right = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">root</span>):</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    queue = deque()</span><br><span class="line">    queue.append(root)</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        level_size = <span class="built_in">len</span>(queue)</span><br><span class="line">        current_level = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(level_size):</span><br><span class="line">            current_node = queue.popleft()</span><br><span class="line">            current_level.append(current_node.val)</span><br><span class="line">            <span class="keyword">if</span> current_node.left:</span><br><span class="line">                queue.append(current_node.left)</span><br><span class="line">            <span class="keyword">if</span> current_node.right:</span><br><span class="line">                queue.append(current_node.right)</span><br><span class="line">        result.append(current_level)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    root = TreeNode(<span class="number">12</span>)</span><br><span class="line">    root.left = TreeNode(<span class="number">7</span>)</span><br><span class="line">    root.right = TreeNode(<span class="number">1</span>)</span><br><span class="line">    root.left.left = TreeNode(<span class="number">9</span>)</span><br><span class="line">    root.right.left = TreeNode(<span class="number">10</span>)</span><br><span class="line">    root.right.right = TreeNode(<span class="number">5</span>)</span><br><span class="line">    res = traverse(root)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>Since we need to traverse all nodes of each level before moving onto the next level, we can use the <strong>Breadth First Search (BFS)</strong> technique to solve this problem.</p><p>We can use a Queue to efficiently traverse in BFS fashion. Here are the steps of our algorithm:</p><ol><li>Start by pushing the <code>root</code> node to the queue.</li><li>Keep iterating until the queue is empty.</li><li>In each iteration, first count the elements in the queue (let’s call it <code>levelSize</code>). We will have these many nodes in the current level.</li><li>Next, remove <code>levelSize</code> nodes from the queue and push their <code>value</code> in an array to represent the current level.</li><li>After removing each node from the queue, insert both of its children into the queue.</li><li>If the queue is not empty, repeat from step 3 for the next level.</li></ol><p>Let’s take the example-2 mentioned above to visually represent our algorithm:</p><p><img src="/8-pattern-tree-breadth-first-search/index/3.png"></p><p><img src="/8-pattern-tree-breadth-first-search/index/4.png"></p><p><img src="/8-pattern-tree-breadth-first-search/index/5.png"></p><p><img src="/8-pattern-tree-breadth-first-search/index/6.png"></p><p><img src="/8-pattern-tree-breadth-first-search/index/7.png"></p><p><img src="/8-pattern-tree-breadth-first-search/index/8.png"></p><p><img src="/8-pattern-tree-breadth-first-search/index/9.png"></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和我写的一样，这里不在赘述</span></span><br></pre></td></tr></table></figure><h4 id="Time-complexity"><a href="#Time-complexity" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of the above algorithm is <strong><em>O(N)</em></strong>, where ‘N’ is the total number of nodes in the tree. This is due to the fact that we traverse each node once.</p><h4 id="Space-complexity"><a href="#Space-complexity" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity of the above algorithm will be <strong><em>O(N)</em></strong> as we need to return a list containing the level order traversal. We will also need <strong><em>O(N)</em></strong> space for the queue. Since we can have a maximum of <strong><em>N/2</em></strong> nodes at any level (this could happen only at the lowest level), therefore we will need <strong>O(N)</strong> space to store them in the queue.</p><h2 id="Reverse-Level-Order-Traversal-easy"><a href="#Reverse-Level-Order-Traversal-easy" class="headerlink" title="Reverse Level Order Traversal (easy)"></a>Reverse Level Order Traversal (easy)</h2><p>leetcode 107</p><h3 id="Problem-Statement-1"><a href="#Problem-Statement-1" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given a binary tree, populate an array to represent its level-by-level traversal in reverse order, i.e., the <strong>lowest level comes first</strong>. You should populate the values of all nodes in each level from left to right in separate sub-arrays.</p><p><strong>Example 1:</strong></p><p><img src="/8-pattern-tree-breadth-first-search/index/10.png"></p><p><strong>Example 2:</strong></p><p><img src="/8-pattern-tree-breadth-first-search/index/11.png"></p><h3 id="Try-it-yourself-1"><a href="#Try-it-yourself-1" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 看了solution写的</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left, self.right = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="comment"># 这里修改了</span></span><br><span class="line">    result = deque()</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    queue = deque()</span><br><span class="line">    queue.append(root)</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        level_size = <span class="built_in">len</span>(queue)</span><br><span class="line">        current_level = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(level_size):</span><br><span class="line">            current_node = queue.popleft()</span><br><span class="line">            current_level.append(current_node.val)</span><br><span class="line">            <span class="keyword">if</span> current_node.left:</span><br><span class="line">                queue.append(current_node.left)</span><br><span class="line">            <span class="keyword">if</span> current_node.right:</span><br><span class="line">                queue.append(current_node.right)</span><br><span class="line">        <span class="comment"># 这里修改了</span></span><br><span class="line">        result.appendleft(current_level)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    root = TreeNode(<span class="number">12</span>)</span><br><span class="line">    root.left = TreeNode(<span class="number">7</span>)</span><br><span class="line">    root.right = TreeNode(<span class="number">1</span>)</span><br><span class="line">    root.left.left = TreeNode(<span class="number">9</span>)</span><br><span class="line">    root.right.left = TreeNode(<span class="number">10</span>)</span><br><span class="line">    root.right.right = TreeNode(<span class="number">5</span>)</span><br><span class="line">    res = traverse(root)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <em>Binary Tree Level Order Traversal</em> pattern. We can follow the same <strong>BFS</strong> approach. The only difference will be that instead of appending the current level at the end, we will append the current level at the beginning of the result list.</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like; only the highlighted lines have changed. Please note that, for <strong>Java</strong>, we will use a <code>LinkedList</code> instead of an <code>ArrayList</code> for our result list. As in the case of <code>ArrayList</code>, appending an element at the beginning means shifting all the existing elements. Since we need to append the level array at the beginning of the result list, a <code>LinkedList</code> will be better, as this shifting of elements is not required in a <code>LinkedList</code>. Similarly, we will use a double-ended queue (deque) for <strong>Python</strong>, <strong>C++</strong>, and <strong>JavaScript</strong>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上面的就是solution 这里就不在赘述了</span></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-1"><a href="#Time-complexity-1" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of the above algorithm is <strong><em>O(N)</em></strong>, where ‘N’ is the total number of nodes in the tree. This is due to the fact that we traverse each node once.</p><h4 id="Space-complexity-1"><a href="#Space-complexity-1" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity of the above algorithm will be <strong><em>O(N)</em></strong> as we need to return a list containing the level order traversal. We will also need <strong><em>O(N)</em></strong> space for the queue. Since we can have a maximum of <strong>N/2</strong> <em>nodes</em> at any level (this could happen only at the lowest level), therefore we will need <strong><em>O(N)</em></strong> space to store them in the queue.</p><h2 id="Zigzag-Traversal-medium"><a href="#Zigzag-Traversal-medium" class="headerlink" title="Zigzag Traversal (medium)"></a>Zigzag Traversal (medium)</h2><p>leetcode 103</p><h3 id="Problem-Statement-2"><a href="#Problem-Statement-2" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given a binary tree, populate an array to represent its zigzag level order traversal. You should populate the values of all <strong>nodes of the first level from left to right</strong>, then <strong>right to left for the next level</strong> and keep alternating in the same manner for the following levels.</p><p><strong>Example 1:</strong></p><p><img src="/8-pattern-tree-breadth-first-search/index/12.png"></p><p><strong>Example 2:</strong></p><p><img src="/8-pattern-tree-breadth-first-search/index/13.png"></p><h3 id="Try-it-yourself-2"><a href="#Try-it-yourself-2" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 答案中没有&lt;algorithm&gt; 这个类，所以严格来说不是很规范</span></span><br><span class="line"><span class="comment">// 可以看看答案的方法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span> <span class="comment">//用于使用sort , reverse</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">    TreeNode* left = <span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode* right = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">        left = right = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LevelOederTraversal</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">traverse</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; queue;</span><br><span class="line">        queue.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> levelSize = queue.<span class="built_in">size</span>();  <span class="comment">// 使用迭代的方法，计算迭代次数</span></span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; currentLevel;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; levelSize; i++) &#123;</span><br><span class="line">                TreeNode* currentNode = queue.<span class="built_in">front</span>();</span><br><span class="line">                queue.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// add the node to the curent level</span></span><br><span class="line">                currentLevel.<span class="built_in">push_back</span>(currentNode-&gt;val);</span><br><span class="line">                <span class="comment">// insert the children of the current node in the queue</span></span><br><span class="line">                <span class="keyword">if</span> (currentNode-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    queue.<span class="built_in">push</span>(currentNode-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (currentNode-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    queue.<span class="built_in">push</span>(currentNode-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">push_back</span>(currentLevel); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.<span class="built_in">size</span>();  i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">reverse</span>(result[i].<span class="built_in">begin</span>(), result[i].<span class="built_in">end</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">12</span>);</span><br><span class="line">    root-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">7</span>);</span><br><span class="line">    root-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line">    root-&gt;left-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">9</span>);</span><br><span class="line">    root-&gt;right-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">10</span>);</span><br><span class="line">    root-&gt;right-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">5</span>);</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result = LevelOederTraversal::<span class="built_in">traverse</span>(root);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Level order traversal: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> vec : result) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : vec) &#123;</span><br><span class="line">            cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <em>Binary Tree Level Order Traversal</em> pattern. We can follow the same <strong>BFS</strong> approach. The only additional step we have to keep in mind is to alternate the level order traversal, which means that for every other level, we will traverse similar to <em>Reverse Level Order Traversal</em>.</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like, only the highlighted lines have changed:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不在赘述</span></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-2"><a href="#Time-complexity-2" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of the above algorithm is <strong><em>O(N)</em></strong>, where ‘N’ is the total number of nodes in the tree. This is due to the fact that we traverse each node once.</p><h4 id="Space-complexity-2"><a href="#Space-complexity-2" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity of the above algorithm will be <strong><em>O(N)</em></strong> as we need to return a list containing the level order traversal. We will also need <strong><em>O(N)</em></strong> space for the queue. Since we can have a maximum of <strong><em>N/2</em></strong> nodes at any level (this could happen only at the lowest level), therefore we will need <strong><em>O(N)</em></strong> space to store them in the queue.</p><h2 id="Level-Averages-in-a-Binary-Tree-easy"><a href="#Level-Averages-in-a-Binary-Tree-easy" class="headerlink" title="Level Averages in a Binary Tree (easy)"></a>Level Averages in a Binary Tree (easy)</h2><p>leetcode 637</p><h3 id="Problem-Statement-3"><a href="#Problem-Statement-3" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given a binary tree, populate an array to represent the <strong>averages of all of its levels</strong>.</p><p><strong>Example 1:</strong></p><p><img src="/8-pattern-tree-breadth-first-search/index/14.png"></p><p><strong>Example 2:</strong></p><p><img src="/8-pattern-tree-breadth-first-search/index/15.png"></p><h3 id="Try-it-yourself-3"><a href="#Try-it-yourself-3" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left, self.right = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_level_average</span>(<span class="params">root</span>):</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    queue = deque()</span><br><span class="line">    queue.append(root)</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        level_size = <span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="comment"># 这里修改</span></span><br><span class="line">        level_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(level_size):</span><br><span class="line">            current_node = queue.popleft()</span><br><span class="line">            level_sum += current_node.val</span><br><span class="line">            <span class="keyword">if</span> current_node.left:</span><br><span class="line">                queue.append(current_node.left)</span><br><span class="line">            <span class="keyword">if</span> current_node.right:</span><br><span class="line">                queue.append(current_node.right)</span><br><span class="line">        <span class="comment"># 这里修改了</span></span><br><span class="line">        result.append(level_sum / level_size)</span><br><span class="line">        <span class="comment"># result.append(level_sum / float(level_size)) 在leetcode需要这么写</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    root = TreeNode(<span class="number">12</span>)</span><br><span class="line">    root.left = TreeNode(<span class="number">7</span>)</span><br><span class="line">    root.right = TreeNode(<span class="number">1</span>)</span><br><span class="line">    root.left.left = TreeNode(<span class="number">9</span>)</span><br><span class="line">    root.left.right = TreeNode(<span class="number">2</span>)</span><br><span class="line">    root.right.left = TreeNode(<span class="number">10</span>)</span><br><span class="line">    root.right.right = TreeNode(<span class="number">5</span>)</span><br><span class="line">    root.right.left.left = TreeNode(<span class="number">20</span>)</span><br><span class="line">    root.right.left.right = TreeNode(<span class="number">17</span>)</span><br><span class="line">    res = find_level_average(root)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <em>Binary Tree Level Order Traversal</em> pattern. We can follow the same <strong>BFS</strong> approach. The only difference will be that instead of keeping track of all nodes of a level, we will only track the running sum of the values of all nodes in each level. In the end, we will append the average of the current level to the result array.</p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like; only the highlighted lines have changed:67u</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和我的思路一样，这里就不再赘述了</span></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-3"><a href="#Time-complexity-3" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of the above algorithm is <strong><em>O(N)</em></strong>, where ‘N’ is the total number of nodes in the tree. This is due to the fact that we traverse each node once.</p><h4 id="Space-complexity-3"><a href="#Space-complexity-3" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity of the above algorithm will be <strong><em>O(N)</em></strong> which is required for the queue. Since we can have a maximum of N/2<em>N</em>/2 nodes at any level (this could happen only at the lowest level), therefore we will need <strong><em>O(N)</em></strong> space to store them in the queue.</p><hr><h3 id="Similar-Problems"><a href="#Similar-Problems" class="headerlink" title="Similar Problems"></a>Similar Problems</h3><p><strong>Problem 1:</strong> Find the largest value on each level of a binary tree.</p><p><strong>Solution:</strong> We will follow a similar approach, but instead of having a running sum we will track the maximum value of each level.</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">max</span>Value = <span class="keyword">max</span>(<span class="keyword">max</span>Value, currentNode.val)</span><br></pre></td></tr></table></figure><h2 id="Minimum-Depth-of-a-Binary-Tree-easy"><a href="#Minimum-Depth-of-a-Binary-Tree-easy" class="headerlink" title="Minimum Depth of a Binary Tree (easy)"></a>Minimum Depth of a Binary Tree (easy)</h2><p>leetcode 111</p><h3 id="Problem-Statement-4"><a href="#Problem-Statement-4" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Find the minimum depth of a binary tree. The minimum depth is the number of nodes along the <strong>shortest path from the root node to the nearest leaf node</strong>.</p><p><strong>Example 1:</strong></p><p><img src="/8-pattern-tree-breadth-first-search/index/16.png"></p><p><strong>Example 2:</strong></p><p><img src="/8-pattern-tree-breadth-first-search/index/17.png"></p><h3 id="Try-it-yourself-4"><a href="#Try-it-yourself-4" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <em>Binary Tree Level Order Traversal</em> pattern. We can follow the same <strong>BFS</strong> approach. The only difference will be, instead of keeping track of all the nodes in a level, we will only track the depth of the tree. As soon as we find our first leaf node, that level will represent the minimum depth of the tree.</p><h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like, only the highlighted lines have changed:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">from collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    def __init__(self, val):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left, self.right = None, None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="built_in">find_min_depth</span>(root):</span><br><span class="line">    <span class="keyword">if</span> root is None:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    queue = <span class="built_in">deque</span>()</span><br><span class="line">    queue.<span class="built_in">append</span>(root)</span><br><span class="line">    # 这里修改</span><br><span class="line">    min_depth = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        min_depth += <span class="number">1</span></span><br><span class="line">        level_size = <span class="built_in">len</span>(queue)</span><br><span class="line">        level_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(level_size):</span><br><span class="line">            current_node = queue.<span class="built_in">popleft</span>()</span><br><span class="line">            level_sum += current_node.val</span><br><span class="line">            # 加上这个</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> current_node.left <span class="keyword">and</span> <span class="keyword">not</span> current_node.right:</span><br><span class="line">                <span class="keyword">return</span> min_depth</span><br><span class="line">            <span class="keyword">if</span> current_node.left:</span><br><span class="line">                queue.<span class="built_in">append</span>(current_node.left)</span><br><span class="line">            <span class="keyword">if</span> current_node.right:</span><br><span class="line">                queue.<span class="built_in">append</span>(current_node.right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="built_in">main</span>():</span><br><span class="line">    root = <span class="built_in">TreeNode</span>(<span class="number">12</span>)</span><br><span class="line">    root.left = <span class="built_in">TreeNode</span>(<span class="number">7</span>)</span><br><span class="line">    root.right = <span class="built_in">TreeNode</span>(<span class="number">1</span>)</span><br><span class="line">    root.left.left = <span class="built_in">TreeNode</span>(<span class="number">9</span>)</span><br><span class="line">    root.left.right = <span class="built_in">TreeNode</span>(<span class="number">2</span>)</span><br><span class="line">    root.right.left = <span class="built_in">TreeNode</span>(<span class="number">10</span>)</span><br><span class="line">    root.right.right = <span class="built_in">TreeNode</span>(<span class="number">5</span>)</span><br><span class="line">    root.right.left.left = <span class="built_in">TreeNode</span>(<span class="number">20</span>)</span><br><span class="line">    root.right.left.right = <span class="built_in">TreeNode</span>(<span class="number">17</span>)</span><br><span class="line">    res = <span class="built_in">find_min_depth</span>(root)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">main</span>()</span><br></pre></td></tr></table></figure><h4 id="Time-complexity-4"><a href="#Time-complexity-4" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of the above algorithm is <strong><em>O(N)</em></strong>, where ‘N’ is the total number of nodes in the tree. This is due to the fact that we traverse each node once.</p><h4 id="Space-complexity-4"><a href="#Space-complexity-4" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity of the above algorithm will be <strong><em>O(N)</em></strong> which is required for the queue. Since we can have a maximum of <strong><em>N/2</em></strong> nodes at any level (this could happen only at the lowest level), therefore we will need <strong><em>O(N)</em></strong> space to store them in the queue.</p><hr><h3 id="Similar-Problems-1"><a href="#Similar-Problems-1" class="headerlink" title="Similar Problems"></a>Similar Problems</h3><p><strong>Problem 1:</strong> Given a binary tree, find its maximum depth (or height).</p><p><strong>Solution:</strong> We will follow a similar approach. Instead of returning as soon as we find a leaf node, we will keep traversing for all the levels, incrementing <code>maximumDepth</code> each time we complete a level. Here is what the code will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left, self.right = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    queue = deque()</span><br><span class="line">    queue.append(root)</span><br><span class="line">    <span class="comment"># 这里修改</span></span><br><span class="line">    max_depth = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        max_depth += <span class="number">1</span></span><br><span class="line">        level_size = <span class="built_in">len</span>(queue)</span><br><span class="line">        level_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(level_size):</span><br><span class="line">            current_node = queue.popleft()</span><br><span class="line">            level_sum += current_node.val</span><br><span class="line">            <span class="keyword">if</span> current_node.left:</span><br><span class="line">                queue.append(current_node.left)</span><br><span class="line">            <span class="keyword">if</span> current_node.right:</span><br><span class="line">                queue.append(current_node.right)</span><br><span class="line">    <span class="keyword">return</span> max_depth</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    root = TreeNode(<span class="number">12</span>)</span><br><span class="line">    root.left = TreeNode(<span class="number">7</span>)</span><br><span class="line">    root.right = TreeNode(<span class="number">1</span>)</span><br><span class="line">    root.left.left = TreeNode(<span class="number">9</span>)</span><br><span class="line">    root.left.right = TreeNode(<span class="number">2</span>)</span><br><span class="line">    root.right.left = TreeNode(<span class="number">10</span>)</span><br><span class="line">    root.right.right = TreeNode(<span class="number">5</span>)</span><br><span class="line">    root.right.left.left = TreeNode(<span class="number">20</span>)</span><br><span class="line">    root.right.left.right = TreeNode(<span class="number">17</span>)</span><br><span class="line">    res = traverse(root)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Level-Order-Successor-easy"><a href="#Level-Order-Successor-easy" class="headerlink" title="Level Order Successor (easy)"></a>Level Order Successor (easy)</h2><p>不在leetcode</p><h3 id="Problem-Statement-5"><a href="#Problem-Statement-5" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given a binary tree and a node, find the level order successor of the given node in the tree. The level order successor is the node that appears right after the given node in the level order traversal.</p><p><strong>Example 1:</strong></p><p><img src="/8-pattern-tree-breadth-first-search/index/18.png"></p><p><strong>Example 2:</strong></p><p><img src="/8-pattern-tree-breadth-first-search/index/19.png"></p><p><strong>Example 3:</strong></p><p><img src="/8-pattern-tree-breadth-first-search/index/20.png"></p><h3 id="Try-it-yourself-5"><a href="#Try-it-yourself-5" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以看看solution的代码，有点不一样</span></span><br><span class="line"><span class="comment"># 看写在本题最后的一段文字</span></span><br></pre></td></tr></table></figure><h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <em>Binary Tree Level Order Traversal</em> pattern. We can follow the same <strong>BFS</strong> approach. The only difference will be that we will not keep track of all the levels. Instead we will keep inserting child nodes to the queue. As soon as we find the given node, we will return the next node from the queue as the level order successor.</p><h3 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like; most of the changes are in the highlighted lines:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是官方solution，但是这个方法有个局限就是所有的值都要唯一</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left, self.right = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_successor</span>(<span class="params">root,val</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    queue = deque()</span><br><span class="line">    queue.append(root)</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        current_node = queue.popleft()</span><br><span class="line">        <span class="keyword">if</span> current_node.left:</span><br><span class="line">            queue.append(current_node.left)</span><br><span class="line">        <span class="keyword">if</span> current_node.right:</span><br><span class="line">            queue.append(current_node.right)</span><br><span class="line">        <span class="comment"># 注意要先放进去元素之后在判断</span></span><br><span class="line">        <span class="keyword">if</span> current_node.val == val:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> queue[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    root = TreeNode(<span class="number">12</span>)</span><br><span class="line">    root.left = TreeNode(<span class="number">7</span>)</span><br><span class="line">    root.right = TreeNode(<span class="number">1</span>)</span><br><span class="line">    root.left.left = TreeNode(<span class="number">9</span>)</span><br><span class="line">    root.right.left = TreeNode(<span class="number">10</span>)</span><br><span class="line">    root.right.right = TreeNode(<span class="number">5</span>)</span><br><span class="line">    res = find_successor(root, <span class="number">12</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res.val))</span><br><span class="line">    res = find_successor(root, <span class="number">9</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res.val))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-5"><a href="#Time-complexity-5" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of the above algorithm is <strong><em>O(N)</em></strong>, where ‘N’ is the total number of nodes in the tree. This is due to the fact that we traverse each node once.</p><h4 id="Space-complexity-5"><a href="#Space-complexity-5" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity of the above algorithm will be <strong><em>O(N)</em></strong> which is required for the queue. Since we can have a maximum of <strong><em>N/2</em></strong> nodes at any level (this could happen only at the lowest level), therefore we will need <strong><em>O(N)</em></strong> space to store them in the queue.</p><p>这里在遍历的时候就没有使用<code>LevelSize</code>这个变量,也就没有了<code>While</code>中还嵌套<code>for</code>这个循环，之前的题目中使用这个循环的意义是，由于之前的题目要求广度优先遍历的时候，输出要把一个层次中的放在一起，所以需要知道个数，再使用<code>for</code>循环遍历。如果题目要求没有这个，只要求输出广度优先遍历的结果，只要就不需要使用<code>for</code>循环，只要<code>while(!queue.empty())</code>有就够了。就像这个题目所写的一样。</p><h2 id="Connect-Level-Order-Siblings-medium"><a href="#Connect-Level-Order-Siblings-medium" class="headerlink" title="Connect Level Order Siblings (medium)"></a>Connect Level Order Siblings (medium)</h2><p>leetcode 116(完全二叉树),117</p><h3 id="Problem-Statement-6"><a href="#Problem-Statement-6" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given a binary tree, connect each node with its level order successor. The last node of each level should point to a <code>null</code> node.</p><p><strong>Example 1:</strong></p><p><img src="/8-pattern-tree-breadth-first-search/index/21.png"></p><p><strong>Example 2:</strong></p><p><img src="/8-pattern-tree-breadth-first-search/index/22.png"></p><h3 id="Try-it-yourself-6"><a href="#Try-it-yourself-6" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <em>Binary Tree Level Order Traversal</em> pattern. We can follow the same <strong>BFS</strong> approach. The only difference is that while traversing a level we will remember the previous node to connect it with the current node.</p><h3 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like; only the highlighted lines have changed:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left, self.right, self.<span class="built_in">next</span> = <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_level_order</span>(<span class="params">self</span>):</span></span><br><span class="line">        nextLevelRoot = self</span><br><span class="line">        <span class="keyword">while</span> nextLevelRoot:</span><br><span class="line">            current = nextLevelRoot</span><br><span class="line">            nextLevelRoot = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">while</span> current:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> nextLevelRoot:</span><br><span class="line">                    <span class="keyword">if</span> current.left:</span><br><span class="line">                        nextLevelRoot = current.left</span><br><span class="line">                    <span class="keyword">elif</span> current.right:</span><br><span class="line">                        nextLevelRoot = current.right</span><br><span class="line">                <span class="built_in">print</span>(current.val, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">                current = current.<span class="built_in">next</span></span><br><span class="line">            <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect_level_order_siblings</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    queue = deque()</span><br><span class="line">    queue.append(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        level_size = <span class="built_in">len</span>(queue)</span><br><span class="line">        previous = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(level_size):</span><br><span class="line">            current_node = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> previous:</span><br><span class="line">                previous.<span class="built_in">next</span> = current_node</span><br><span class="line">            previous = current_node</span><br><span class="line">            <span class="keyword">if</span> current_node.left:</span><br><span class="line">                queue.append(current_node.left)</span><br><span class="line">            <span class="keyword">if</span> current_node.right:</span><br><span class="line">                queue.append(current_node.right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    root = TreeNode(<span class="number">12</span>)</span><br><span class="line">    root.left = TreeNode(<span class="number">7</span>)</span><br><span class="line">    root.right = TreeNode(<span class="number">1</span>)</span><br><span class="line">    root.left.left = TreeNode(<span class="number">9</span>)</span><br><span class="line">    root.right.left = TreeNode(<span class="number">10</span>)</span><br><span class="line">    root.right.right = TreeNode(<span class="number">5</span>)</span><br><span class="line">    connect_level_order_siblings(root)</span><br><span class="line">    root.print_level_order()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-6"><a href="#Time-complexity-6" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of the above algorithm is <strong><em>O(N)</em></strong>, where ‘N’ is the total number of nodes in the tree. This is due to the fact that we traverse each node once.</p><h4 id="Space-complexity-6"><a href="#Space-complexity-6" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity of the above algorithm will be <strong><em>O(N)</em></strong>, which is required for the queue. Since we can have a maximum of <strong><em>N/2</em></strong> nodes at any level (this could happen only at the lowest level), therefore we will need <strong><em>O(N)</em></strong> space to store them in the queue.</p><h2 id="Problem-Challenge-1"><a href="#Problem-Challenge-1" class="headerlink" title="Problem Challenge 1"></a>Problem Challenge 1</h2><p>不在leetcode</p><h3 id="Connect-All-Level-Order-Siblings-medium"><a href="#Connect-All-Level-Order-Siblings-medium" class="headerlink" title="Connect All Level Order Siblings (medium)"></a>Connect All Level Order Siblings (medium)</h3><p>Given a binary tree, connect each node with its level order successor. The last node of each level should point to the first node of the next level.</p><p><img src="/8-pattern-tree-breadth-first-search/index/23.png"></p><p><img src="/8-pattern-tree-breadth-first-search/index/24.png"></p><h3 id="Try-it-yourself-7"><a href="#Try-it-yourself-7" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <em>Binary Tree Level Order Traversal</em> pattern. We can follow the same <strong>BFS</strong> approach. The only difference will be that while traversing we will remember (irrespective of the level) the previous node to connect it with the current node.</p><h3 id="Code-7"><a href="#Code-7" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like; only the highlighted lines have changed:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"># 比较简单的还是</span><br><span class="line">from collections import deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, val):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left, self.right, self.next = None, None, None</span><br><span class="line"></span><br><span class="line">    def print_tree(self):</span><br><span class="line">        current = self</span><br><span class="line">        while current:</span><br><span class="line">            print(str(current.val) + &quot; &quot;, end=&quot;&quot;)</span><br><span class="line">            current = current.next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def connect_level_order_siblings(root):</span><br><span class="line">    if root is None:</span><br><span class="line">        return root</span><br><span class="line">    queue = deque()</span><br><span class="line">    queue.append(root)</span><br><span class="line">    previous = None</span><br><span class="line">    while queue:</span><br><span class="line">        current_node = queue.popleft()</span><br><span class="line">        if previous:</span><br><span class="line">            previous.next = current_node</span><br><span class="line">        previous = current_node</span><br><span class="line">        if current_node.left:</span><br><span class="line">            queue.append(current_node.left)</span><br><span class="line">        if current_node.right:</span><br><span class="line">            queue.append(current_node.right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    root = TreeNode(12)</span><br><span class="line">    root.left = TreeNode(7)</span><br><span class="line">    root.right = TreeNode(1)</span><br><span class="line">    root.left.left = TreeNode(9)</span><br><span class="line">    root.right.left = TreeNode(10)</span><br><span class="line">    root.right.right = TreeNode(5)</span><br><span class="line">    connect_level_order_siblings(root)</span><br><span class="line">    root.print_tree()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-7"><a href="#Time-complexity-7" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of the above algorithm is <strong><em>O(N)</em></strong>, where ‘N’ is the total number of nodes in the tree. This is due to the fact that we traverse each node once.</p><h4 id="Space-complexity-7"><a href="#Space-complexity-7" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity of the above algorithm will be <strong><em>O(N)</em></strong> which is required for the queue. Since we can have a maximum of <strong><em>N/2</em></strong> nodes at any level (this could happen only at the lowest level), therefore we will need <strong><em>O(N)</em></strong> space to store them in the queue.</p><h2 id="Problem-Challenge-2"><a href="#Problem-Challenge-2" class="headerlink" title="Problem Challenge 2"></a>Problem Challenge 2</h2><p>leetcode 199</p><h3 id="Right-View-of-a-Binary-Tree-easy"><a href="#Right-View-of-a-Binary-Tree-easy" class="headerlink" title="Right View of a Binary Tree (easy)"></a>Right View of a Binary Tree (easy)</h3><p>Given a binary tree, return an array containing nodes in its right view. The right view of a binary tree is the set of <strong>nodes visible when the tree is seen from the right side</strong>.</p><p><img src="/8-pattern-tree-breadth-first-search/index/25.png"></p><p><img src="/8-pattern-tree-breadth-first-search/index/26.png"></p><h3 id="Try-it-yourself-8"><a href="#Try-it-yourself-8" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left, self.right, self.<span class="built_in">next</span> = <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_tree</span>(<span class="params">self</span>):</span></span><br><span class="line">        current = self</span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(current.val) + <span class="string">&quot; &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tree_right_view</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    queue = deque()</span><br><span class="line">    queue.append(root)</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        level_size = <span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(level_size):</span><br><span class="line">            current_node = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> i == level_size - <span class="number">1</span>:</span><br><span class="line">                res.append(current_node.val)</span><br><span class="line">            <span class="keyword">if</span> current_node.left:</span><br><span class="line">                queue.append(current_node.left)</span><br><span class="line">            <span class="keyword">if</span> current_node.right:</span><br><span class="line">                queue.append(current_node.right)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    root = TreeNode(<span class="number">12</span>)</span><br><span class="line">    root.left = TreeNode(<span class="number">7</span>)</span><br><span class="line">    root.right = TreeNode(<span class="number">1</span>)</span><br><span class="line">    root.left.left = TreeNode(<span class="number">9</span>)</span><br><span class="line">    root.right.left = TreeNode(<span class="number">10</span>)</span><br><span class="line">    root.right.right = TreeNode(<span class="number">5</span>)</span><br><span class="line">    root.right.right.left = TreeNode(<span class="number">3</span>)</span><br><span class="line">    res = tree_right_view(root)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <em>Binary Tree Level Order Traversal</em> pattern. We can follow the same <strong>BFS</strong> approach. The only additional thing we will be do is to append the last node of each level to the result array.</p><h3 id="Code-8"><a href="#Code-8" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like; only the highlighted lines have changed:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和我的想法一样，这里就不再赘述了</span></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-8"><a href="#Time-complexity-8" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of the above algorithm is <strong><em>O(N)</em></strong>, where ‘N’ is the total number of nodes in the tree. This is due to the fact that we traverse each node once.</p><h4 id="Space-complexity-8"><a href="#Space-complexity-8" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity of the above algorithm will be <strong><em>O(N)</em></strong> as we need to return a list containing the level order traversal. We will also need <strong><em>O(N)</em></strong> space for the queue. Since we can have a maximum of <strong><em>N/2</em></strong> nodes at any level (this could happen only at the lowest level), therefore we will need <strong><em>O(N)</em></strong> space to store them in the queue.</p><hr><h3 id="Similar-Questions"><a href="#Similar-Questions" class="headerlink" title="Similar Questions"></a>Similar Questions</h3><p><strong>Problem 1:</strong> Given a binary tree, return an array containing nodes in its left view. The left view of a binary tree is the set of nodes visible when the tree is seen from the left side.</p><p><strong>Solution:</strong> We will be following a similar approach, but instead of appending the last element of each level we will be appending the first element of each level to the output array.</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>7. Pattern In-place Reversal of a LinkedList</title>
      <link href="/7-pattern-in-place-reversal-of-a-linkedlist/index.html"/>
      <url>/7-pattern-in-place-reversal-of-a-linkedlist/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In a lot of problems, we are asked to reverse the links between a set of nodes of a <strong>LinkedList</strong>. Often, the constraint is that we need to do this in-place, i.e., using the existing node objects and without using extra memory.</p><p><strong>In-place Reversal of a LinkedList</strong> pattern describes an efficient way to solve the above problem. In the following chapters, we will solve a bunch of problems using this pattern.</p><p>Let’s jump on to our first problem to understand this pattern.</p><h2 id="Reverse-a-LinkedList-easy"><a href="#Reverse-a-LinkedList-easy" class="headerlink" title="Reverse a LinkedList (easy)"></a>Reverse a LinkedList (easy)</h2><p>leetcode 206    </p><h3 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given the head of a Singly LinkedList, reverse the LinkedList. Write a function to return the new head of the reversed LinkedList.</p><p><img src="/7-pattern-in-place-reversal-of-a-linkedlist/index/1.png"></p><h3 id="Try-it-yourself"><a href="#Try-it-yourself" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_list</span>(<span class="params">self</span>):</span></span><br><span class="line">        temp = self</span><br><span class="line">        <span class="keyword">while</span> temp <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(temp.value, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">            temp = temp.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">head</span>):</span></span><br><span class="line">    previous = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">next</span> = head.<span class="built_in">next</span></span><br><span class="line">        head.<span class="built_in">next</span> = previous</span><br><span class="line">        previous = head</span><br><span class="line">        head = <span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> previous</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    head = Node(<span class="number">2</span>)</span><br><span class="line">    head.<span class="built_in">next</span> = Node(<span class="number">4</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">6</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">8</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">10</span>)</span><br><span class="line">    res = reverse(head)</span><br><span class="line">    res.print_list()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>To reverse a LinkedList, we need to reverse one node at a time. We will start with a variable <code>current</code> which will initially point to the head of the LinkedList and a variable <code>previous</code> which will point to the previous node that we have processed; initially <code>previous</code> will point to <code>null</code>.</p><p>In a stepwise manner, we will reverse the <code>current</code> node by pointing it to the <code>previous</code> before moving on to the next node. Also, we will update the <code>previous</code> to always point to the previous node that we have processed. Here is the visual representation of our algorithm:</p><p><img src="/7-pattern-in-place-reversal-of-a-linkedlist/index/2.png"></p><p><img src="/7-pattern-in-place-reversal-of-a-linkedlist/index/3.png"></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和我写的一样，这里就不在赘述</span></span><br></pre></td></tr></table></figure><h4 id="Time-complexity"><a href="#Time-complexity" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of our algorithm will be <strong><em>O(N)</em></strong> where ‘N’ is the total number of nodes in the LinkedList.</p><h4 id="Space-complexity"><a href="#Space-complexity" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>We only used constant space, therefore, the space complexity of our algorithm is <strong><em>O(1)</em></strong>.</p><h2 id="Reverse-a-Sub-list-medium"><a href="#Reverse-a-Sub-list-medium" class="headerlink" title="*Reverse a Sub-list (medium)"></a>*Reverse a Sub-list (medium)</h2><p>leetcode 92,看similar question</p><h3 id="Problem-Statement-1"><a href="#Problem-Statement-1" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given the head of a LinkedList and two positions ‘p’ and ‘q’, reverse the LinkedList from position ‘p’ to ‘q’.</p><p><img src="/7-pattern-in-place-reversal-of-a-linkedlist/index/4.png"></p><h3 id="Try-it-yourself-1"><a href="#Try-it-yourself-1" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例过了,但是不对</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_list</span>(<span class="params">self</span>):</span></span><br><span class="line">        temp = self</span><br><span class="line">        <span class="keyword">while</span> temp <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(temp.value, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">            temp = temp.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">head, p, q</span>):</span></span><br><span class="line">    <span class="comment"># 这个if一开始没有写</span></span><br><span class="line">    <span class="keyword">if</span> p == q:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    previous, current = <span class="literal">None</span>, head</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(p - <span class="number">1</span>):</span><br><span class="line">        previous = current</span><br><span class="line">        current = current.<span class="built_in">next</span></span><br><span class="line">    node_before_p = previous</span><br><span class="line">    node_p = current</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(p, q + <span class="number">1</span>):</span><br><span class="line">        <span class="built_in">next</span> = current.<span class="built_in">next</span></span><br><span class="line">        current.<span class="built_in">next</span> = previous</span><br><span class="line">        previous = current</span><br><span class="line">        current = <span class="built_in">next</span></span><br><span class="line">    <span class="comment"># 这个if else一开始也没有写，这是为了防止p等于1的情况</span></span><br><span class="line">    <span class="keyword">if</span> node_before_p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        node_before_p.<span class="built_in">next</span> = previous</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        head = previous</span><br><span class="line">    node_p.<span class="built_in">next</span> = current</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    head = Node(<span class="number">1</span>)</span><br><span class="line">    head.<span class="built_in">next</span> = Node(<span class="number">2</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">3</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">4</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">5</span>)</span><br><span class="line">    res = reverse(head, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">    res.print_list()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>The problem follows the <strong>In-place Reversal of a LinkedList</strong> pattern. We can use a similar approach as discussed in <em>Reverse a LinkedList</em>. Here are the steps we need to follow:</p><ol><li>Skip the first <code>p-1</code> nodes, to reach the node at position <code>p</code>.</li><li>Remember the node at position <code>p-1</code> to be used later to connect with the reversed sub-list.</li><li>Next, reverse the nodes from <code>p</code> to <code>q</code> using the same approach discussed in <em>Reverse a LinkedList</em>.</li><li>Connect the <code>p-1</code> and <code>q+1</code> nodes to the reversed sub-list.</li><li>思路和我的是一样的，比较好奇他是怎么解决P == 1的情况的</li></ol><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和我写的一样，这里就不再赘述</span></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-1"><a href="#Time-complexity-1" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of our algorithm will be <strong><em>O(N)</em></strong> where ‘N’ is the total number of nodes in the LinkedList.</p><h4 id="Space-complexity-1"><a href="#Space-complexity-1" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>We only used constant space, therefore, the space complexity of our algorithm is <strong><em>O(1)</em></strong>.</p><hr><h3 id="Similar-Questions"><a href="#Similar-Questions" class="headerlink" title="Similar Questions"></a>Similar Questions</h3><p><strong>Problem 1:</strong> Reverse the first ‘k’ elements of a given LinkedList.</p><p><strong>Solution:</strong> This problem can be easily converted to our parent problem; to reverse the first ‘k’ nodes of the list, we need to pass <code>p=1</code> and <code>q=k</code>.</p><p><strong>Problem 2:</strong> Given a LinkedList with ‘n’ nodes, reverse it based on its size in the following way:</p><ol><li>If ‘n’ is even, reverse the list in a group of n/2 nodes.</li><li>If n is odd, keep the middle node as it is, reverse the first ‘n/2’ nodes and reverse the last ‘n/2’ nodes.</li></ol><p><strong>Solution:</strong> When ‘n’ is even we can perform the following steps:</p><ol><li>Reverse first ‘n/2’ nodes: <code>head = reverse(head, 1, n/2)</code></li><li>Reverse last ‘n/2’ nodes: <code>head = reverse(head, n/2 + 1, n)</code></li></ol><p>When ‘n’ is odd, our algorithm will look like:</p><ol><li><code>head = reverse(head, 1, n/2)</code></li><li><code>head = reverse(head, n/2 + 2, n)</code></li></ol><p>Please note the function call in the second step. We’re skipping two elements as we will be skipping the middle element.</p><h2 id="Reverse-every-K-element-Sub-list-medium"><a href="#Reverse-every-K-element-Sub-list-medium" class="headerlink" title="*Reverse every K-element Sub-list (medium)"></a>*Reverse every K-element Sub-list (medium)</h2><p>leetcode 25但是有点不一样,leetcode中如果不满k,就不会反转</p><h3 id="Problem-Statement-2"><a href="#Problem-Statement-2" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given the head of a LinkedList and a number ‘k’, <strong>reverse every ‘k’ sized sub-list</strong> starting from the head.</p><p>If, in the end, you are left with a sub-list with less than ‘k’ elements, reverse it too.</p><p><img src="/7-pattern-in-place-reversal-of-a-linkedlist/index/5.png"></p><h3 id="Try-it-yourself-2"><a href="#Try-it-yourself-2" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 边看答案边写的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_list</span>(<span class="params">self</span>):</span></span><br><span class="line">        temp = self</span><br><span class="line">        <span class="keyword">while</span> temp <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(temp.value, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">            temp = temp.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_length</span>(<span class="params">head</span>):</span></span><br><span class="line">    temp = head</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> temp <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        temp = temp.<span class="built_in">next</span></span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">head, k</span>):</span></span><br><span class="line">    <span class="comment"># or head == None可以不需要，因为不会是空的list</span></span><br><span class="line">    <span class="keyword">if</span> k &lt;= <span class="number">1</span> <span class="keyword">or</span> head == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    previous, current = <span class="literal">None</span>, head</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        last_node_of_previous_part = previous</span><br><span class="line">        first_node_of_sub_list = current</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> current <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> i &lt; k:</span><br><span class="line">            <span class="built_in">next</span> = current.<span class="built_in">next</span></span><br><span class="line">            current.<span class="built_in">next</span> = previous</span><br><span class="line">            previous = current</span><br><span class="line">            current = <span class="built_in">next</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> last_node_of_previous_part <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            last_node_of_previous_part.<span class="built_in">next</span> = previous</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            head = previous</span><br><span class="line">        first_node_of_sub_list.<span class="built_in">next</span> = current</span><br><span class="line">        <span class="keyword">if</span> current <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 注意这句话</span></span><br><span class="line">        previous = first_node_of_sub_list</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    head = Node(<span class="number">1</span>)</span><br><span class="line">    head.<span class="built_in">next</span> = Node(<span class="number">2</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">3</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">4</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">5</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">6</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">7</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">8</span>)</span><br><span class="line">    res = reverse(head, <span class="number">3</span>)</span><br><span class="line">    res.print_list()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>The problem follows the <strong>In-place Reversal of a LinkedList</strong> pattern and is quite similar to <em>Reverse a Sub-list</em>. The only difference is that we have to reverse all the sub-lists. We can use the same approach, starting with the first sub-list (i.e. <code>p=1, q=k</code>) and keep reversing all the sublists of size ‘k’.</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><p>Most of the code is the same as <em>Reverse a Sub-list;</em> only the highlighted lines have a majority of the changes:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上面的就是solution</span></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-2"><a href="#Time-complexity-2" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of our algorithm will be <strong><em>O(N)</em></strong> where ‘N’ is the total number of nodes in the LinkedList.</p><h4 id="Space-complexity-2"><a href="#Space-complexity-2" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>We only used constant space, therefore, the space complexity of our algorithm is <strong><em>O(1)</em></strong>.</p><h2 id="Problem-Challenge-1"><a href="#Problem-Challenge-1" class="headerlink" title="*Problem Challenge 1"></a>*Problem Challenge 1</h2><p>不在leetcode</p><h3 id="Reverse-alternating-K-element-Sub-list-medium"><a href="#Reverse-alternating-K-element-Sub-list-medium" class="headerlink" title="Reverse alternating K-element Sub-list (medium)"></a>Reverse alternating K-element Sub-list (medium)</h3><p>Given the head of a LinkedList and a number ‘k’, <strong>reverse every alternating ‘k’ sized sub-list</strong> starting from the head.</p><p>If, in the end, you are left with a sub-list with less than ‘k’ elements, reverse it too.</p><p><img src="/7-pattern-in-place-reversal-of-a-linkedlist/index/6.png"></p><h3 id="Try-it-yourself-3"><a href="#Try-it-yourself-3" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在上面一题的基础上改的，过了测试用例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_list</span>(<span class="params">self</span>):</span></span><br><span class="line">        temp = self</span><br><span class="line">        <span class="keyword">while</span> temp <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(temp.value, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">            temp = temp.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">head, k</span>):</span></span><br><span class="line">    <span class="keyword">if</span> k &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    previous, current = <span class="literal">None</span>, head</span><br><span class="line">    isReverse = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        last_node_of_previous_part = previous</span><br><span class="line">        first_node_of_sub_list = current</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> isReverse <span class="keyword">and</span> current <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> i &lt; k:</span><br><span class="line">            <span class="built_in">next</span> = current.<span class="built_in">next</span></span><br><span class="line">            current.<span class="built_in">next</span> = previous</span><br><span class="line">            previous = current</span><br><span class="line">            current = <span class="built_in">next</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> isReverse <span class="keyword">and</span> current <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> i &lt; k:</span><br><span class="line">            previous = current</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> last_node_of_previous_part <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            last_node_of_previous_part.<span class="built_in">next</span> = previous</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            head = previous</span><br><span class="line">        first_node_of_sub_list.<span class="built_in">next</span> = current</span><br><span class="line">        <span class="keyword">if</span> current == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        previous = first_node_of_sub_list</span><br><span class="line">        isReverse = ~isReverse</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    head = Node(<span class="number">1</span>)</span><br><span class="line">    head.<span class="built_in">next</span> = Node(<span class="number">2</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">3</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">4</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">5</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">6</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">7</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">8</span>)</span><br><span class="line">    res = reverse(head, <span class="number">3</span>)</span><br><span class="line">    res.print_list()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>The problem follows the <strong>In-place Reversal of a LinkedList</strong> pattern and is quite similar to <em>Reverse every K-element Sub-list</em>. The only difference is that we have to skip ‘k’ alternating elements. We can follow a similar approach, and in each iteration after reversing ‘k’ elements, we will skip the next ‘k’ elements.</p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><p>Most of the code is the same as <em>Reverse every K-element Sub-list</em>; only the highlighted lines have a majority of the changes:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_list</span>(<span class="params">self</span>):</span></span><br><span class="line">        temp = self</span><br><span class="line">        <span class="keyword">while</span> temp <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(temp.value, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">            temp = temp.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_length</span>(<span class="params">head</span>):</span></span><br><span class="line">    temp = head</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> temp <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        temp = temp.<span class="built_in">next</span></span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">head, k</span>):</span></span><br><span class="line">    <span class="keyword">if</span> k &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    previous, current = <span class="literal">None</span>, head</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        last_node_of_previous_part = previous</span><br><span class="line">        first_node_of_sub_list = current</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> current <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> i &lt; k:</span><br><span class="line">            <span class="built_in">next</span> = current.<span class="built_in">next</span></span><br><span class="line">            current.<span class="built_in">next</span> = previous</span><br><span class="line">            previous = current</span><br><span class="line">            current = <span class="built_in">next</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> last_node_of_previous_part <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            last_node_of_previous_part.<span class="built_in">next</span> = previous</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            head = previous</span><br><span class="line">        first_node_of_sub_list.<span class="built_in">next</span> = current</span><br><span class="line">        <span class="comment"># skip k nodes</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> current <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> i &lt; k:</span><br><span class="line">            previous = current</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> current <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    head = Node(<span class="number">1</span>)</span><br><span class="line">    head.<span class="built_in">next</span> = Node(<span class="number">2</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">3</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">4</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">5</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">6</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">7</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">8</span>)</span><br><span class="line">    res = reverse(head, <span class="number">3</span>)</span><br><span class="line">    res.print_list()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-3"><a href="#Time-complexity-3" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of our algorithm will be <strong><em>O(N)</em></strong> where ‘N’ is the total number of nodes in the LinkedList.</p><h4 id="Space-complexity-3"><a href="#Space-complexity-3" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>We only used constant space, therefore, the space complexity of our algorithm is <strong><em>O(1)</em></strong>.</p><h2 id="Problem-Challenge-2"><a href="#Problem-Challenge-2" class="headerlink" title="Problem Challenge 2"></a>Problem Challenge 2</h2><p>leetcode 61</p><h3 id="Rotate-a-LinkedList-medium"><a href="#Rotate-a-LinkedList-medium" class="headerlink" title="Rotate a LinkedList (medium)"></a>Rotate a LinkedList (medium)</h3><p>Given the head of a Singly LinkedList and a number ‘k’, rotate the LinkedList to the right by ‘k’ nodes.</p><p><img src="/7-pattern-in-place-reversal-of-a-linkedlist/index/7.png"></p><p><img src="/7-pattern-in-place-reversal-of-a-linkedlist/index/8.png"></p><h3 id="Try-it-yourself-4"><a href="#Try-it-yourself-4" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 思路是先成环，然后再适当的地方断开</span></span><br><span class="line"><span class="comment"># 打*是为了提醒自己学习一下code的写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_list</span>(<span class="params">self</span>):</span></span><br><span class="line">        temp = self</span><br><span class="line">        <span class="keyword">while</span> temp <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(temp.value, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">            temp = temp.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_length</span>(<span class="params">head</span>):</span></span><br><span class="line">    temp = head</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> temp <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        temp = temp.<span class="built_in">next</span></span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">head, k</span>):</span></span><br><span class="line">    n = get_length(head)</span><br><span class="line">    k = k % n</span><br><span class="line">    temp, new_head = head, head</span><br><span class="line">    <span class="keyword">while</span> temp <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> temp.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            temp.<span class="built_in">next</span> = head</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        temp = temp.<span class="built_in">next</span></span><br><span class="line">    skip_node = n - k</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(skip_node):</span><br><span class="line">        new_head = new_head.<span class="built_in">next</span></span><br><span class="line">    end = new_head</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):</span><br><span class="line">        end = end.<span class="built_in">next</span></span><br><span class="line">    end.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> new_head</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    head = Node(<span class="number">1</span>)</span><br><span class="line">    head.<span class="built_in">next</span> = Node(<span class="number">2</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">3</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">4</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">5</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">6</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">7</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">8</span>)</span><br><span class="line">    res = rotate(head, <span class="number">3</span>)</span><br><span class="line">    res.print_list()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><p>Another way of defining the rotation is to take the sub-list of ‘k’ ending nodes of the LinkedList and connect them to the beginning. Other than that we have to do three more things:</p><ol><li>Connect the last node of the LinkedList to the head, because the list will have a different tail after the rotation.</li><li>The new head of the LinkedList will be the node at the beginning of the sublist.</li><li>The node right before the start of sub-list will be the new tail of the rotated LinkedList.</li></ol><h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_list</span>(<span class="params">self</span>):</span></span><br><span class="line">        temp = self</span><br><span class="line">        <span class="keyword">while</span> temp <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(temp.value, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">            temp = temp.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">head, k</span>):</span></span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> k &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    temp, end = head, head</span><br><span class="line">    <span class="comment"># 把length放在这里计算，可以减少一次遍历的时间</span></span><br><span class="line">    <span class="keyword">while</span> temp <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> temp.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            temp.<span class="built_in">next</span> = head</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        temp = temp.<span class="built_in">next</span></span><br><span class="line">    k = k % n</span><br><span class="line">    skip_node = n - k</span><br><span class="line">    <span class="comment"># 找尾巴，这样下一个就是new_head,可以再减少一次遍历的时间</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(skip_node - <span class="number">1</span>):</span><br><span class="line">        end = end.<span class="built_in">next</span></span><br><span class="line">    new_head = end.<span class="built_in">next</span></span><br><span class="line">    end.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> new_head</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    head = Node(<span class="number">1</span>)</span><br><span class="line">    head.<span class="built_in">next</span> = Node(<span class="number">2</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">3</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">4</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">5</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">6</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">7</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">8</span>)</span><br><span class="line">    res = rotate(head, <span class="number">3</span>)</span><br><span class="line">    res.print_list()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-4"><a href="#Time-complexity-4" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of our algorithm will be <strong><em>O(N)</em></strong> where ‘N’ is the total number of nodes in the LinkedList.</p><h4 id="Space-complexity-4"><a href="#Space-complexity-4" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>We only used constant space, therefore, the space complexity of our algorithm is <strong><em>O(1)</em></strong>.</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>6. Pattern Cyclic Sort</title>
      <link href="/6-pattern-cyclic-sort/index.html"/>
      <url>/6-pattern-cyclic-sort/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>This pattern describes an interesting approach to deal with problems involving arrays containing numbers in a given range. For example, take the following problem:</p><blockquote><p>You are given an unsorted array containing numbers taken from the range 1 to ‘n’. The array can have duplicates, which means that some numbers will be missing. Find all the missing numbers.</p></blockquote><p>To efficiently solve this problem, we can use the fact that the input array contains numbers in the range of 1 to ‘n’. For example, to efficiently sort the array, we can try placing each number in its correct place, i.e., placing ‘1’ at index ‘0’, placing ‘2’ at index ‘1’, and so on. Once we are done with the sorting, we can iterate the array to find all indices that are missing the correct numbers. These will be our required numbers.</p><p>Let’s jump on to our first problem to understand the <strong>Cyclic Sort</strong> pattern in detail.</p><h2 id="Cyclic-Sort-easy"><a href="#Cyclic-Sort-easy" class="headerlink" title="*Cyclic Sort (easy)"></a>*Cyclic Sort (easy)</h2><p>不在leetcode</p><h3 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>We are given an array containing ‘n’ objects. Each object, when created, was assigned a unique number from 1 to ‘n’ based on their creation sequence. This means that the object with sequence number ‘3’ was created just before the object with sequence number ‘4’.</p><p>Write a function to sort the objects in-place on their creation sequence number in <strong><em>O(n)</em></strong> and without any extra space. For simplicity, let’s assume we are passed an integer array containing only the sequence numbers, though each number is actually an object.</p><p><strong>Example 1:</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="string">[3, 1, 5, 4, 2]</span></span><br><span class="line">Output: <span class="string">[1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="string">[2, 6, 4, 3, 1, 5]</span></span><br><span class="line">Output: <span class="string">[1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="string">[1, 5, 6, 4, 3, 2]</span></span><br><span class="line">Output: <span class="string">[1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself"><a href="#Try-it-yourself" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 看了solution才会做</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cyclic_sort</span>(<span class="params">nums</span>):</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">        <span class="keyword">while</span> nums[i] != i + <span class="number">1</span>:</span><br><span class="line">            j = nums[i] - <span class="number">1</span></span><br><span class="line">            <span class="comment"># 这里需要注意的是需要把j = nums[i] - 1单独写出来</span></span><br><span class="line">            <span class="comment"># 不然要是nums[i], nums[nums[i] - 1] = nums[nums[i] - 1], nums[i]会有问题</span></span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = cyclic_sort([<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line">    res = cyclic_sort([<span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line">    res = cyclic_sort([<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>As we know, the input array contains numbers in the range of 1 to ‘n’. We can use this fact to devise an efficient way to sort the numbers. Since all numbers are unique, we can try placing each number at its correct place, i.e., placing ‘1’ at index ‘0’, placing ‘2’ at index ‘1’, and so on.</p><p>To place a number (or an object in general) at its correct index, we first need to find that number. If we first find a number and then place it at its correct place, it will take us <strong><em>O(N^2)</em></strong>, which is not acceptable.</p><p>Instead, what if we iterate the array one number at a time, and if the current number we are iterating is not at the correct index, we swap it with the number at its correct index. This way we will go through all numbers and place them in their correct indices, hence, sorting the whole array.</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><p>这道题使用的算法有几个约束条件，一定要是连续的自然数，而且没有重复，虽然这里是从1开始的自然数，但是不从一开始也可以，只要加上一个偏置就好了 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cyclic_sort</span>(<span class="params">nums</span>):</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">        j = nums[i] - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[i] != nums[j]:</span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = cyclic_sort([<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line">    res = cyclic_sort([<span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line">    res = cyclic_sort([<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity"><a href="#Time-complexity" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of the above algorithm is <strong><em>O(n)</em></strong>. Although we are not incrementing the index <code>i</code> when swapping the numbers, this will result in more than ‘n’ iterations of the loop, but in the worst-case scenario, the <code>while</code> loop will swap a total of ‘n-1’ numbers and once a number is at its correct index, we will move on to the next number by incrementing <code>i</code>. So overall, our algorithm will take <strong><em>O(n) + O(n-1)</em></strong> which is asymptotically equivalent to <strong><em>O(n)</em></strong>。</p><h4 id="Space-complexity"><a href="#Space-complexity" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The algorithm runs in constant space <strong><em>O(1)</em></strong>.</p><h2 id="Find-the-Missing-Number-easy"><a href="#Find-the-Missing-Number-easy" class="headerlink" title="*Find the Missing Number (easy)"></a>*Find the Missing Number (easy)</h2><p>leetcode 268</p><h3 id="Problem-Statement-1"><a href="#Problem-Statement-1" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>We are given an array containing ‘n’ distinct numbers taken from the range 0 to ‘n’. Since the array has only ‘n’ numbers out of the total ‘n+1’ numbers, find the missing number.</p><p><strong>Example 1:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>:<span class="meta"> [4, 0, 3, 1]</span></span><br><span class="line"><span class="attribute">Output</span>: <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>:<span class="meta"> [8, 3, 5, 2, 4, 6, 0, 1]</span></span><br><span class="line"><span class="attribute">Output</span>: <span class="number">7</span></span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-1"><a href="#Try-it-yourself-1" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是看solution写的</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_missing_num</span>(<span class="params">nums</span>):</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">        j = nums[i]</span><br><span class="line">        <span class="comment"># 一直换位置，直到遇到的超出范围的那个数字</span></span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; <span class="built_in">len</span>(nums) <span class="keyword">and</span> nums[i] != nums[j]:</span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] != i:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="comment"># 这个忘记了，需要加上</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(nums) <span class="comment"># 比如这个例子[0,1]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = find_missing_num([<span class="number">4</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line">    res = find_missing_num([<span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <strong>Cyclic Sort</strong> pattern. Since the input array contains unique numbers from the range 0 to ‘n’, we can use a similar strategy as discussed in <em>Cyclic Sort</em> to place the numbers on their correct index. Once we have every number in its correct place, we can iterate the array to find the index which does not have the correct number, and that index will be our missing number.</p><p>However, there are two differences with <em>Cyclic Sort</em>:</p><ol><li>In this problem, the numbers are ranged from ‘0’ to ‘n’, compared to ‘1’ to ‘n’ in the <em>Cyclic Sort</em>. This will make two changes in our algorithm:<ul><li>In this problem, each number should be equal to its index, compared to <code>index + 1</code> in the Cyclic Sort. Therefore =&gt; <code>nums[i] == nums[nums[i]]</code></li><li>Since the array will have ‘n’ numbers, which means array indices will range from 0 to ‘n-1’. Therefore, we will ignore the number ‘n’ as we can’t place it in the array, so =&gt; <code>nums[i] &lt; nums.length</code></li></ul></li><li>Say we are at index <code>i</code>. If we swap the number at index <code>i</code> to place it at the correct index, we can still have the wrong number at index <code>i</code>. This was true in Cyclic Sort too. It didn’t cause any problems in Cyclic Sort as over there, we made sure to place one number at its correct place in each step, but that wouldn’t be enough in this problem as we have one extra number due to the larger range. Therefore, we will not move to the next number after the swap until we have a correct number at the index <code>i</code>.</li></ol><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和我写的一样，这里就不在赘述了</span></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-1"><a href="#Time-complexity-1" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of the above algorithm is <strong><em>O(n)</em></strong>. In the <code>while</code> loop, although we are not incrementing the index <code>i</code> when swapping the numbers, this will result in more than ‘n’ iterations of the loop, but in the worst-case scenario, the <code>while</code> loop will swap a total of ‘n-1’ numbers and once a number is at its correct index, we will move on to the next number by incrementing <code>i</code>. In the end, we iterate the input array again to find the first number missing from its index, so overall, our algorithm will take <strong><em>O(n) + O(n-1) + O(n)</em></strong> which is asymptotically equivalent to <strong><em>O(n)</em></strong>.</p><h4 id="Space-complexity-1"><a href="#Space-complexity-1" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The algorithm runs in constant space <strong><em>O(1)</em></strong>.</p><h2 id="Find-all-Missing-Numbers-easy"><a href="#Find-all-Missing-Numbers-easy" class="headerlink" title="Find all Missing Numbers (easy)"></a>Find all Missing Numbers (easy)</h2><p>leetcode 448</p><h3 id="Problem-Statement-2"><a href="#Problem-Statement-2" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>We are given an unsorted array containing numbers taken from the range 1 to ‘n’. The array can have duplicates, which means some numbers will be missing. Find all those missing numbers.</p><p><strong>Example 1:</strong></p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [2, 3, 1, 8, 2, 3, 5, 1]</span><br><span class="line">Output: 4, 6, 7</span><br><span class="line">Explanation: The<span class="built_in"> array </span>should have all numbers from 1 to 8, due to duplicates 4, 6,<span class="built_in"> and </span>7 are missing.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>:<span class="meta"> [2, 4, 1, 2]</span></span><br><span class="line"><span class="attribute">Output</span>: <span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>:<span class="meta"> [2, 3, 2, 1]</span></span><br><span class="line"><span class="attribute">Output</span>: <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-2"><a href="#Try-it-yourself-2" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是自己根据第一个例子，然后画了一个图，来模拟算法什么时候交换，什么时候不交换的出来的，在第一题(Cyclic Sort)的基础上改了一下</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_all_missing_nums</span>(<span class="params">nums</span>):</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">        j = nums[i] - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[i] != nums[j]:</span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] != i + <span class="number">1</span>:</span><br><span class="line">            res.append(i + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = find_all_missing_nums([<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line">    res = find_all_missing_nums([<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line">    res = find_all_missing_nums([<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <strong>Cyclic Sort</strong> pattern and shares similarities with <em>Find the Missing Number</em> with one difference. In this problem, there can be many duplicates whereas in ‘Find the Missing Number’ there were no duplicates and the range was greater than the length of the array.</p><p>However, we will follow a similar approach though as discussed in <em>Find the Missing Number</em> to place the numbers on their correct indices. Once we are done with the cyclic sort we will iterate the array to find all indices that are missing the correct numbers.</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和我写的一样，这里就不在赘述</span></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-2"><a href="#Time-complexity-2" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of the above algorithm is <strong><em>O(n)</em></strong></p><h4 id="Space-complexity-2"><a href="#Space-complexity-2" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>Ignoring the space required for the output array, the algorithm runs in constant space <strong><em>O(1)</em></strong>.</p><h2 id="Find-the-Duplicate-Number-easy"><a href="#Find-the-Duplicate-Number-easy" class="headerlink" title="*Find the Duplicate Number (easy)"></a>*Find the Duplicate Number (easy)</h2><h3 id="Problem-Statement-3"><a href="#Problem-Statement-3" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>We are given an unsorted array containing ‘n+1’ numbers taken from the range 1 to ‘n’. The array has <strong>only one</strong> duplicate but it can be repeated multiple times. <strong>Find that duplicate number without using any extra space</strong>. You are, however, allowed to modify the input array.</p><p><strong>Example 1:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>:<span class="meta"> [1, 4, 4, 3, 2]</span></span><br><span class="line"><span class="attribute">Output</span>: <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>:<span class="meta"> [2, 1, 3, 3, 5, 4]</span></span><br><span class="line"><span class="attribute">Output</span>: <span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>:<span class="meta"> [2, 4, 1, 4, 4]</span></span><br><span class="line"><span class="attribute">Output</span>: <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-3"><a href="#Try-it-yourself-3" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打*是为了提醒自己看一下相似问题</span></span><br><span class="line"><span class="comment"># 感觉这个类型的题目都是一个模板，自己尝试做的，不过solution的解法会更加节约资源</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_number</span>(<span class="params">nums</span>):</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">        j = nums[i] - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 一直换位置，直到遇到的超出范围的那个数字</span></span><br><span class="line">        <span class="keyword">if</span> nums[i] != nums[j]:</span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] != i + <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[i]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = find_number([<span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line">    res = find_number([<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line">    res = find_number([<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <strong>Cyclic Sort</strong> pattern and shares similarities with <strong><em>Find the Missing Number</em></strong>. Following a similar approach, we will try to place each number on its correct index. Since there is only one duplicate, if while swapping the number with its index both the numbers being swapped are same, we have found our duplicate!</p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 还有更简单的，哎</span></span><br><span class="line"><span class="comment"># 复杂度不变，但是实际的计算时间会少</span></span><br><span class="line"><span class="comment"># 这是看solution写的</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_number</span>(<span class="params">nums</span>):</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">        j = nums[i] - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 一直换位置，直到遇到的超出范围的那个数字</span></span><br><span class="line">        <span class="keyword">if</span> nums[i] != nums[j]:</span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> i != j:</span><br><span class="line">                <span class="keyword">return</span> nums[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = find_number([<span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line">    res = find_number([<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line">    res = find_number([<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-3"><a href="#Time-complexity-3" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of the above algorithm is <strong><em>O(n)</em></strong>.</p><h4 id="Space-complexity-3"><a href="#Space-complexity-3" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The algorithm runs in constant space <strong><em>O(1)</em></strong> but modifies the input array.</p><hr><h3 id="Similar-Problems"><a href="#Similar-Problems" class="headerlink" title="Similar Problems"></a>Similar Problems</h3><p><strong>Problem 1:</strong> Can we solve the above problem in <strong><em>O(1)</em></strong> space and without modifying the input array?</p><p><strong>Solution:</strong> While doing the cyclic sort, we realized that the array will have a cycle due to the duplicate number and that the start of the cycle will always point to the duplicate number. This means that we can use the fast &amp; the slow pointer method to find the duplicate number or the start of the cycle similar to <em>Start of LinkedList Cycle(Pattern 4 problem 3)</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FindDuplicate</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> fast = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">do</span>&#123;</span><br><span class="line">           slow = arr[slow];</span><br><span class="line">           fast = arr[arr[fast]];</span><br><span class="line">       &#125;<span class="keyword">while</span>(slow != fast);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//find cycle length</span></span><br><span class="line">       <span class="keyword">int</span> current = arr[slow];</span><br><span class="line">       <span class="keyword">int</span> cyclelength = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">do</span>&#123;</span><br><span class="line">           current = arr[current];</span><br><span class="line">           cyclelength ++;</span><br><span class="line">       &#125;<span class="keyword">while</span>(current != arr[slow]);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">findStart</span>(arr, cyclelength);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findStart</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> cycleLength)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> pointer1 = arr[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">int</span> pointer2 = arr[<span class="number">0</span>];</span><br><span class="line">       <span class="comment">// move pointer2 ahead &#x27;cycleLength&#x27; steps</span></span><br><span class="line">       <span class="keyword">while</span>(cycleLength &gt; <span class="number">0</span>)&#123;</span><br><span class="line">           pointer2 = arr[pointer2];</span><br><span class="line">           cycleLength --;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//increment both pointers until they meet at the start of the cycle</span></span><br><span class="line">       <span class="keyword">while</span>(pointer1 != pointer2)&#123;</span><br><span class="line">           pointer1 = arr[pointer1];</span><br><span class="line">           pointer2 = arr[pointer2];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> pointer1;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1 = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    cout &lt;&lt; FindDuplicate::<span class="built_in">findDuplicate</span>(v1) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    v1 = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    cout &lt;&lt; FindDuplicate::<span class="built_in">findDuplicate</span>(v1) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    v1 = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    cout &lt;&lt; FindDuplicate::<span class="built_in">findDuplicate</span>(v1) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The time complexity of the above algorithm is <strong><em>O(n)</em></strong> and the space complexity is <strong><em>O(1)</em></strong>.</p><h2 id="Find-all-Duplicate-Numbers-easy"><a href="#Find-all-Duplicate-Numbers-easy" class="headerlink" title="Find all Duplicate Numbers (easy)"></a>Find all Duplicate Numbers (easy)</h2><p>leetcode 442</p><h3 id="Problem-Statement-4"><a href="#Problem-Statement-4" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>We are given an unsorted array containing ‘n’ numbers taken from the range 1 to ‘n’. The array has some duplicates, <strong>find all the duplicate numbers without using any extra space</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>:<span class="meta"> [3, 4, 4, 5, 5]</span></span><br><span class="line"><span class="attribute">Output</span>:<span class="meta"> [4, 5]</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>:<span class="meta"> [5, 4, 7, 2, 3, 5, 3]</span></span><br><span class="line"><span class="attribute">Output</span>:<span class="meta"> [3, 5]</span></span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-4"><a href="#Try-it-yourself-4" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//先排序再遍历</span><br><span class="line"><span class="comment"># 这是看solution写的, 感觉solution的代码有问题</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_all_duplicate_number</span>(<span class="params">nums</span>):</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">        j = nums[i] - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 一直换位置，直到遇到的超出范围的那个数字</span></span><br><span class="line">        <span class="keyword">if</span> nums[i] != nums[j]:</span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    res = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] != i + <span class="number">1</span>:</span><br><span class="line">            res.add(nums[i])</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = find_all_duplicate_number([<span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line">    res = find_all_duplicate_number([<span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <strong>Cyclic Sort</strong> pattern and shares similarities with <em>Find the Duplicate Number</em>. Following a similar approach, we will place each number at its correct index. After that, we will iterate through the array to find all numbers that are not at the correct indices. All these numbers are duplicates.</p><h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">find_all_duplicate_number</span><span class="params">(nums)</span>:</span></span><br><span class="line"><span class="function">    i =</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">        j = nums[i] - <span class="number">1</span></span><br><span class="line">        # 一直换位置，直到遇到的超出范围的那个数字</span><br><span class="line">        <span class="keyword">if</span> nums[i] != nums[j]:</span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    # 个人认为这里有问题，比如[<span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>]就会返回[<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]而不是[<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">    # 但是leetcode <span class="number">442</span>中说明了“each integer appears once <span class="keyword">or</span> twice”那就不用考虑这个情况</span><br><span class="line">    <span class="meta"># solution的解答也是对的</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] != i + <span class="number">1</span>:</span><br><span class="line">            res.<span class="built_in">append</span>(nums[i])</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="built_in">main</span>():</span><br><span class="line">    res = <span class="built_in">find_all_duplicate_number</span>([<span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line">    res = <span class="built_in">find_all_duplicate_number</span>([<span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">main</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-4"><a href="#Time-complexity-4" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of the above algorithm is <strong><em>O(n)</em></strong>.</p><h4 id="Space-complexity-4"><a href="#Space-complexity-4" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>Ignoring the space required for storing the duplicates, the algorithm runs in constant space <strong><em>O(1)</em></strong>.</p><h2 id="Problem-Challenge-1"><a href="#Problem-Challenge-1" class="headerlink" title="Problem Challenge 1"></a>Problem Challenge 1</h2><p>不在leetcode</p><h3 id="Find-the-Corrupt-Pair-easy"><a href="#Find-the-Corrupt-Pair-easy" class="headerlink" title="Find the Corrupt Pair (easy)"></a>Find the Corrupt Pair (easy)</h3><p>We are given an unsorted array containing ‘n’ numbers taken from the range 1 to ‘n’. The array originally contained all the numbers from 1 to ‘n’, but due to a data error, one of the numbers got duplicated which also resulted in one number going missing. Find both these numbers.</p><p><strong>Example 1:</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Inpu<span class="variable">t:</span> [<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">2</span>]</span><br><span class="line">Outpu<span class="variable">t:</span> [<span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">Explanation: <span class="string">&#x27;2&#x27;</span> <span class="keyword">is</span> duplicated <span class="built_in">and</span> <span class="string">&#x27;4&#x27;</span> <span class="keyword">is</span> missing.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Inpu<span class="variable">t:</span> [<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>]</span><br><span class="line">Outpu<span class="variable">t:</span> [<span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">Explanation: <span class="string">&#x27;3&#x27;</span> <span class="keyword">is</span> duplicated <span class="built_in">and</span> <span class="string">&#x27;5&#x27;</span> <span class="keyword">is</span> missing.</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-5"><a href="#Try-it-yourself-5" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是看solution写的</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_corrupt_nums</span>(<span class="params">nums</span>):</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">        j = nums[i] - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 一直换位置，直到遇到的超出范围的那个数字</span></span><br><span class="line">        <span class="keyword">if</span> nums[i] != nums[j]:</span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] != i + <span class="number">1</span>:</span><br><span class="line">            res.append(nums[i])</span><br><span class="line">            res.append(i + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = find_corrupt_nums([<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">2</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line">    res = find_corrupt_nums([<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <strong>Cyclic Sort</strong> pattern and shares similarities with <em>Find all Duplicate Numbers</em>. Following a similar approach, we will place each number at its correct index. Once we are done with the cyclic sort, we will iterate through the array to find the number that is not at the correct index. Since only one number got corrupted, the number at the wrong index is the duplicated number and the index itself represents the missing number.</p><h3 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和我的思路一样，就不在赘述了</span></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-5"><a href="#Time-complexity-5" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of the above algorithm is <strong><em>O(n)</em></strong>.</p><h4 id="Space-complexity-5"><a href="#Space-complexity-5" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The algorithm runs in constant space <strong><em>O(1)</em></strong>.</p><h2 id="Problem-Challenge-2"><a href="#Problem-Challenge-2" class="headerlink" title="# Problem Challenge 2"></a># Problem Challenge 2</h2><p>leetcode 41</p><h3 id="Find-the-Smallest-Missing-Positive-Number-medium"><a href="#Find-the-Smallest-Missing-Positive-Number-medium" class="headerlink" title="Find the Smallest Missing Positive Number (medium)"></a>Find the Smallest Missing Positive Number (medium)</h3><p>Given an unsorted array containing numbers, find the <strong>smallest missing positive number</strong> in it.</p><p><strong>Example 1:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> [-<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line"><span class="symbol">Output:</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">Explanation:</span> The smallest missing positive number <span class="built_in">is</span> <span class="comment">&#x27;3&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>:<span class="meta"> [3, -2, 0, 1, 2]</span></span><br><span class="line"><span class="attribute">Output</span>: <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>:<span class="meta"> [3, 2, 5, 1]</span></span><br><span class="line"><span class="attribute">Output</span>: <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-6"><a href="#Try-it-yourself-6" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//看了solution写的 ，和上面有一题 findMissingNumber很像</span><br><span class="line"><span class="comment"># 这是看solution写的</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first_missing_positive</span>(<span class="params">nums</span>):</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">        j = nums[i] - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 注意这里是nums[i] &gt; 0 而不是 &gt;=0, 不然第一个例子会出现[-3, 1, 2, 5, 4]</span></span><br><span class="line">        <span class="comment"># 此外注意这里应该是&gt;=, 因为排序是[1,n]的数字都排序</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &gt;= nums[i] &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] != nums[j]:</span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] != i + <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">    <span class="comment"># 这个忘记了，比如示例[1]就应该返回2</span></span><br><span class="line">    <span class="comment"># 和“Find the Missing Number”一样，那道也没有考虑类似这种的特殊情况</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(nums) + <span class="number">1</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = first_missing_positive([-<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line">    res = first_missing_positive([<span class="number">3</span>, -<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line">    res = first_missing_positive([<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <strong>Cyclic Sort</strong> pattern and shares similarities with <em>Find the Missing Number</em> with one big difference. In this problem, the numbers are not bound by any range so we can have any number in the input array.</p><p>However, we will follow a similar approach though as discussed in <em>Find the Missing Number</em> to place the numbers on their correct indices and ignore all numbers that are out of the range of the array (i.e., all negative numbers and all numbers greater than or equal to the length of the array). Once we are done with the cyclic sort we will iterate the array and the first index that does not have the correct number will be the smallest missing positive number!</p><h3 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和自己写的一样，这里就不在赘述了 </span></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-6"><a href="#Time-complexity-6" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of the above algorithm is <strong><em>O(n)</em></strong>.</p><h4 id="Space-complexity-6"><a href="#Space-complexity-6" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The algorithm runs in constant space <strong><em>O(1)</em></strong>.</p><h2 id="Problem-Challenge-3"><a href="#Problem-Challenge-3" class="headerlink" title="*Problem Challenge 3"></a>*Problem Challenge 3</h2><p>leetcode 1539 leetcode上是easy？？？</p><h3 id="Find-the-First-K-Missing-Positive-Numbers-hard"><a href="#Find-the-First-K-Missing-Positive-Numbers-hard" class="headerlink" title="Find the First K Missing Positive Numbers (hard)"></a>Find the First K Missing Positive Numbers (hard)</h3><p>Given an unsorted array containing numbers and a number ‘k’, find the first ‘k’ missing positive numbers in the array.</p><p><strong>Example 1:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>:<span class="meta"> [3, -1, 4, 5, 5], k=3</span></span><br><span class="line"><span class="meta">Output: [1, 2, 6]</span></span><br><span class="line"><span class="attribute">Explanation</span>: The smallest missing positive numbers are <span class="number">1</span>, <span class="number">2</span> and <span class="number">6</span>.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>:<span class="meta"> [2, 3, 4], k=3</span></span><br><span class="line"><span class="meta">Output: [1, 5, 6]</span></span><br><span class="line"><span class="attribute">Explanation</span>: The smallest missing positive numbers are <span class="number">1</span>, <span class="number">5</span> and <span class="number">6</span>.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>:<span class="meta"> [-2, -3, 4], k=2</span></span><br><span class="line"><span class="meta">Output: [1, 2]</span></span><br><span class="line"><span class="attribute">Explanation</span>: The smallest missing positive numbers are <span class="number">1</span> and <span class="number">2</span>.</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-7"><a href="#Try-it-yourself-7" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  看了solution写的，</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first_k_missing_positive</span>(<span class="params">nums, k</span>):</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">        j = nums[i] - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &gt;= nums[i] &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] != nums[j]:</span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    res = []</span><br><span class="line">    all_num = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        all_num.add(nums[i])</span><br><span class="line">        <span class="keyword">if</span> nums[i] != i + <span class="number">1</span> <span class="keyword">and</span> <span class="built_in">len</span>(res) &lt; k:</span><br><span class="line">            res.append(i + <span class="number">1</span>)</span><br><span class="line">    i = <span class="built_in">len</span>(nums) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(res) &lt; k:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> all_num:</span><br><span class="line">            res.append(i)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = first_k_missing_positive([<span class="number">3</span>, -<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>], <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line">    res = first_k_missing_positive([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line">    res = first_k_missing_positive([-<span class="number">2</span>, -<span class="number">3</span>, <span class="number">4</span>], <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <strong>Cyclic Sort</strong> pattern and shares similarities with <em>Find the Smallest Missing Positive Number</em>. The only difference is that, in this problem, we need to find the first ‘k’ missing numbers compared to only the first missing number.</p><p>We will follow a similar approach as discussed in <em>Find the Smallest Missing Positive Number</em> to place the numbers on their correct indices and ignore all numbers that are out of the range of the array. Once we are done with the cyclic sort we will iterate through the array to find indices that do not have the correct numbers.</p><p>If we are not able to find ‘k’ missing numbers from the array, we need to add additional numbers to the output array. To find these additional numbers we will use the length of the array. For example, if the length of the array is 4, the next missing numbers will be 4, 5, 6 and so on. One tricky aspect is that any of these additional numbers could be part of the array. Remember, while sorting, we ignored all numbers that are greater than or equal to the length of the array. So all indices that have the missing numbers could possibly have these additional numbers. To handle this, we must keep track of all numbers from those indices that have missing numbers. Let’s understand this with an example:</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums: <span class="string">[2, 1, 3, 6, 5]</span>, k =<span class="number">2</span></span><br></pre></td></tr></table></figure><p>After the cyclic sort our array will look like:</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums: <span class="string">[1, 2, 3, 6, 5]</span></span><br></pre></td></tr></table></figure><p>From the sorted array we can see that the first missing number is ‘4’ (as we have ‘6’ on the fourth index) but to find the second missing number we need to remember that the array does contain ‘6’. Hence, the next missing number is ‘7’.</p><h3 id="Code-7"><a href="#Code-7" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和我的思路一样，就不再赘述了</span></span><br></pre></td></tr></table></figure><h5 id="Time-complexity-7"><a href="#Time-complexity-7" class="headerlink" title="Time complexity"></a>Time complexity</h5><p>The time complexity of the above algorithm is <strong><em>O(n + k)</em></strong>, as the last two <code>for</code> loops will run for <strong><em>O(n)</em></strong> and <strong><em>O(k)</em></strong> times respectively.</p><h5 id="Space-complexity-7"><a href="#Space-complexity-7" class="headerlink" title="Space complexity"></a>Space complexity</h5><p>The algorithm needs <strong><em>O(k)</em></strong> space to store the <code>extraNumbers</code>(the set).</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.Pattern Merge Intervals</title>
      <link href="/5-pattern-merge-intervals/index.html"/>
      <url>/5-pattern-merge-intervals/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>This pattern describes an efficient technique to deal with overlapping intervals. In a lot of problems involving intervals, we either need to find overlapping intervals or merge intervals if they overlap.</p><p>Given two intervals (‘a’ and ‘b’), there will be six different ways the two intervals can relate to each other:</p><p><img src="/5-pattern-merge-intervals/index/1.png"></p><p>Understanding the above six cases will help us in solving all intervals related problems. Let’s jump onto our first problem to understand the <strong>Merge Interval</strong> pattern.</p><h2 id="Merge-Intervals-medium"><a href="#Merge-Intervals-medium" class="headerlink" title="*Merge Intervals (medium)"></a>*Merge Intervals (medium)</h2><p>leetcode 56, leetcode 452 类似</p><h3 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given a list of intervals, <strong>merge all the overlapping intervals</strong> to produce a list that has only mutually exclusive intervals.</p><p><strong>Example 1:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Intervals</span>: [[<span class="number">1</span>,<span class="number">4</span>], [<span class="number">2</span>,<span class="number">5</span>], [<span class="number">7</span>,<span class="number">9</span>]]</span><br><span class="line"><span class="symbol">Output</span>: [[<span class="number">1</span>,<span class="number">5</span>], [<span class="number">7</span>,<span class="number">9</span>]]</span><br><span class="line"><span class="symbol">Explanation</span>: <span class="symbol">Since</span> the first two intervals [<span class="number">1</span>,<span class="number">4</span>] and [<span class="number">2</span>,<span class="number">5</span>] overlap, we merged them into </span><br><span class="line">one [<span class="number">1</span>,<span class="number">5</span>].</span><br></pre></td></tr></table></figure><p><img src="/5-pattern-merge-intervals/index/1.png"></p><p><strong>Example 2:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Intervals</span>: [[<span class="number">6</span>,<span class="number">7</span>], [<span class="number">2</span>,<span class="number">4</span>], [<span class="number">5</span>,<span class="number">9</span>]]</span><br><span class="line"><span class="symbol">Output</span>: [[<span class="number">2</span>,<span class="number">4</span>], [<span class="number">5</span>,<span class="number">9</span>]]</span><br><span class="line"><span class="symbol">Explanation</span>: <span class="symbol">Since</span> the intervals [<span class="number">6</span>,<span class="number">7</span>] and [<span class="number">5</span>,<span class="number">9</span>] overlap, we merged them into one [<span class="number">5</span>,<span class="number">9</span>].</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intervals: <span class="string">[[1,4], [2,6], [3,5]]</span></span><br><span class="line">Output: <span class="string">[[1,6]]</span></span><br><span class="line">Explanation: Since all the given intervals overlap, we merged them into one.</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself"><a href="#Try-it-yourself" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 看了solution才想起来的</span></span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>Let’s take the example of two intervals (‘a’ and ‘b’) such that <code>a.start &lt;= b.start</code>. There are four possible scenarios:</p><p><img src="/5-pattern-merge-intervals/index/2.png"></p><p>Our goal is to merge the intervals whenever they overlap. For the above-mentioned three overlapping scenarios (2, 3, and 4), this is how we will merge them:</p><p><img src="/5-pattern-merge-intervals/index/3.png"></p><p>The diagram above clearly shows a merging approach. Our algorithm will look like this:</p><ol><li>Sort the intervals on the start time to ensure <code>a.start &lt;= b.start</code></li><li>If ‘a’ overlaps ‘b’ (i.e. <code>b.start &lt;= a.end</code>), we need to merge them into a new interval ‘c’ such that:</li></ol><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">c</span>.start <span class="operator">=</span> a.start</span><br><span class="line"><span class="keyword">c</span>.<span class="keyword">end</span> <span class="operator">=</span> <span class="keyword">max</span>(a.<span class="keyword">end</span><span class="punctuation">,</span> b.<span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><ol><li>We will keep repeating the above two steps to merge ‘c’ with the next interval if it overlaps with ‘c’.</li></ol><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interval</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, start, end</span>):</span></span><br><span class="line">        self.start = start</span><br><span class="line">        self.end = end</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_interval</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[&quot;</span> + <span class="built_in">str</span>(self.start) + <span class="string">&quot;,&quot;</span> + <span class="built_in">str</span>(self.end) + <span class="string">&quot;]&quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">intervals</span>):</span></span><br><span class="line">    <span class="comment"># 下面这个if也可以不要。leetcode过了</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(intervals) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> intervals</span><br><span class="line">    intervals.sort(key=<span class="keyword">lambda</span> x: x.start)</span><br><span class="line">    mergedIntervals = []</span><br><span class="line">    start = intervals[<span class="number">0</span>].start</span><br><span class="line">    end = intervals[<span class="number">0</span>].end</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(intervals)):</span><br><span class="line">        interval = intervals[i]</span><br><span class="line">        <span class="keyword">if</span> interval.start &lt;= end:</span><br><span class="line">            end = <span class="built_in">max</span>(end, interval.end)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mergedIntervals.append(Interval(start, end))</span><br><span class="line">            start = interval.start</span><br><span class="line">            end = interval.end</span><br><span class="line">    mergedIntervals.append(Interval(start, end))</span><br><span class="line">    <span class="keyword">return</span> mergedIntervals</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> merge([Interval(<span class="number">1</span>, <span class="number">3</span>), Interval(<span class="number">2</span>, <span class="number">5</span>), Interval(<span class="number">7</span>, <span class="number">9</span>)]):</span><br><span class="line">        i.print_interval()</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> merge([Interval(<span class="number">6</span>, <span class="number">7</span>), Interval(<span class="number">2</span>, <span class="number">4</span>), Interval(<span class="number">5</span>, <span class="number">9</span>)]):</span><br><span class="line">        i.print_interval()</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> merge([Interval(<span class="number">1</span>, <span class="number">4</span>), Interval(<span class="number">2</span>, <span class="number">6</span>), Interval(<span class="number">3</span>, <span class="number">5</span>)]):</span><br><span class="line">        i.print_interval()</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity"><a href="#Time-complexity" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of the above algorithm is <strong><em>O(N \</em> logN)*</strong>, where ‘N’ is the total number of intervals. We are iterating the intervals only once which will take <strong><em>O(N)</em></strong>, in the beginning though, since we need to sort the intervals, our algorithm will take <strong><em>O(N \</em> logN)*</strong>.</p><h4 id="Space-complexity"><a href="#Space-complexity" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity of the above algorithm will be <strong><em>O(N)</em></strong> as we need to return a list containing all the merged intervals. We will also need <strong><em>O(N)</em></strong> space for sorting. For Java, depending on its version, <code>Collection.sort()</code> either uses <a href="https://en.wikipedia.org/wiki/Merge_sort">Merge sort</a> or <a href="https://en.wikipedia.org/wiki/Timsort">Timsort</a>, and both these algorithms need <strong><em>O(N)</em></strong> space. Overall, our algorithm has a space complexity of <strong><em>O(N)</em></strong>.</p><h3 id="Similar-Problems"><a href="#Similar-Problems" class="headerlink" title="Similar Problems"></a>Similar Problems</h3><p><strong>Problem 1:</strong> Given a set of intervals, find out if any two intervals overlap.</p><p><strong>Example:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intervals: <span class="comment">[<span class="comment">[1,4]</span>, <span class="comment">[2,5]</span>, <span class="comment">[7,9]</span>]</span></span><br><span class="line">Output: true</span><br><span class="line">Explanation: Intervals <span class="comment">[1,4]</span> and <span class="comment">[2,5]</span> overlap</span><br></pre></td></tr></table></figure><p><strong>Solution:</strong> We can follow the same approach as discussed above to find if any two intervals overlap.</p><h2 id="Insert-Interval-medium"><a href="#Insert-Interval-medium" class="headerlink" title="*Insert Interval (medium)"></a>*Insert Interval (medium)</h2><p>leetcode 57</p><h3 id="Problem-Statement-1"><a href="#Problem-Statement-1" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given a list of non-<strong>overlapping</strong> intervals <strong>sorted by their start time,</strong> <strong>insert a given interval at the correct position</strong> and merge all necessary intervals to produce a list that has only mutually exclusive intervals.</p><p><strong>Example 1:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input</span>: <span class="symbol">Intervals</span>=[[<span class="number">1</span>,<span class="number">3</span>], [<span class="number">5</span>,<span class="number">7</span>], [<span class="number">8</span>,<span class="number">12</span>]], <span class="symbol">New</span> <span class="symbol">Interval</span>=[<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line"><span class="symbol">Output</span>: [[<span class="number">1</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">7</span>], [<span class="number">8</span>,<span class="number">12</span>]]</span><br><span class="line"><span class="symbol">Explanation</span>: <span class="symbol">After</span> insertion, since [<span class="number">4</span>,<span class="number">6</span>] overlaps with [<span class="number">5</span>,<span class="number">7</span>], we merged them into one [<span class="number">4</span>,<span class="number">7</span>].</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input</span>: <span class="symbol">Intervals</span>=[[<span class="number">1</span>,<span class="number">3</span>], [<span class="number">5</span>,<span class="number">7</span>], [<span class="number">8</span>,<span class="number">12</span>]], <span class="symbol">New</span> <span class="symbol">Interval</span>=[<span class="number">4</span>,<span class="number">10</span>]</span><br><span class="line"><span class="symbol">Output</span>: [[<span class="number">1</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">12</span>]]</span><br><span class="line"><span class="symbol">Explanation</span>: <span class="symbol">After</span> insertion, since [<span class="number">4</span>,<span class="number">10</span>] overlaps with [<span class="number">5</span>,<span class="number">7</span>] &amp; [<span class="number">8</span>,<span class="number">12</span>], we merged them into [<span class="number">4</span>,<span class="number">12</span>].</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input</span>: <span class="symbol">Intervals</span>=[[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">5</span>,<span class="number">7</span>]], <span class="symbol">New</span> <span class="symbol">Interval</span>=[<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line"><span class="symbol">Output</span>: [[<span class="number">1</span>,<span class="number">4</span>], [<span class="number">5</span>,<span class="number">7</span>]]</span><br><span class="line"><span class="symbol">Explanation</span>: <span class="symbol">After</span> insertion, since [<span class="number">1</span>,<span class="number">4</span>] overlaps with [<span class="number">2</span>,<span class="number">3</span>], we merged them into one [<span class="number">1</span>,<span class="number">4</span>].</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-1"><a href="#Try-it-yourself-1" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个思路和上一题的思路一眼，只不过先add一个interval之后再排序，再用和上面一样的代码</span></span><br><span class="line"><span class="comment">// 但是我发现这道题的solution和我的写法不一样哈哈哈，所以看看solution，这个自己写的就算复习上一题的算法好了</span></span><br><span class="line"><span class="comment">// 看了solution意思就是，上一题没有排序，这一题排序了已经，所以我们要写出比nlogn更好的时间复杂度的算法。</span></span><br><span class="line"><span class="comment">// 在第二轮做的时候就直接用了solution的方法,虽然过了测试用例，但是做了很久，不熟</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>If the given list was not sorted, we could have simply appended the new interval to it and used the <code>merge()</code> function from <em>Merge Intervals</em>. But since the given list is sorted, we should try to come up with a solution better than <strong><em>O(N \</em> logN)*</strong></p><p>When inserting a new interval in a sorted list, we need to first find the correct index where the new interval can be placed. In other words, we need to skip all the intervals which end before the start of the new interval. So we can iterate through the given sorted listed of intervals and skip all the intervals with the following condition:</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intervals[i].end &lt; <span class="keyword">new</span><span class="type">Interval</span>.start</span><br></pre></td></tr></table></figure><p>Once we have found the correct place, we can follow an approach similar to <em>Merge Intervals</em> to insert and/or merge the new interval. Let’s call the new interval ‘a’ and the first interval with the above condition ‘b’. There are five possibilities:</p><p><img src="/5-pattern-merge-intervals/index/4.png"></p><p>The diagram above clearly shows the merging approach. To handle all four merging scenarios, we need to do something like this:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c.start = min(a.<span class="keyword">start</span>, b.<span class="keyword">start</span>)</span><br><span class="line">c.end = max(a.<span class="keyword">end</span>, b.<span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p>Our overall algorithm will look like this:</p><ol><li>Skip all intervals which end before the start of the new interval, i.e., skip all <code>intervals</code> with the following condition:</li></ol><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intervals[i].end &lt; <span class="keyword">new</span><span class="type">Interval</span>.start</span><br></pre></td></tr></table></figure><ol><li>Let’s call the last interval ‘b’ that does not satisfy the above condition. If ‘b’ overlaps with the new interval (a) (i.e. <code>b.start &lt;= a.end</code>), we need to merge them into a new interval ‘c’:</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c.start = min(a.<span class="keyword">start</span>, b.<span class="keyword">start</span>)</span><br><span class="line">c.end = max(a.<span class="keyword">end</span>, b.<span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><ol><li>We will repeat the above two steps to merge ‘c’ with the next overlapping interval.</li></ol><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">intervals, new_interval</span>):</span></span><br><span class="line">    merged = []</span><br><span class="line">    i, start, end = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(intervals) <span class="keyword">and</span> intervals[i][end] &lt; new_interval[start]:</span><br><span class="line">        merged.append(intervals[i])</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(intervals) <span class="keyword">and</span> intervals[i][start] &lt;= new_interval[end]:</span><br><span class="line"><span class="comment"># 下面这两条没有想到</span></span><br><span class="line">        new_interval[start] = <span class="built_in">min</span>(intervals[i][start], new_interval[start])</span><br><span class="line">        new_interval[end] = <span class="built_in">max</span>(intervals[i][end], new_interval[end])</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    merged.append([new_interval[start], new_interval[end]])</span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(intervals):</span><br><span class="line">        merged.append(intervals[i])</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> merged</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = insert([[<span class="number">1</span>, <span class="number">3</span>], [<span class="number">5</span>, <span class="number">7</span>], [<span class="number">8</span>, <span class="number">12</span>]], [<span class="number">4</span>, <span class="number">6</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line">    res = insert([[<span class="number">1</span>, <span class="number">3</span>], [<span class="number">5</span>, <span class="number">7</span>], [<span class="number">8</span>, <span class="number">12</span>]], [<span class="number">4</span>, <span class="number">10</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line">    res = insert([[<span class="number">2</span>, <span class="number">3</span>], [<span class="number">5</span>, <span class="number">7</span>]], [<span class="number">1</span>, <span class="number">4</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-1"><a href="#Time-complexity-1" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>As we are iterating through all the intervals only once, the time complexity of the above algorithm is <strong><em>O(N)</em></strong>, where ‘N’ is the total number of intervals.</p><h4 id="Space-complexity-1"><a href="#Space-complexity-1" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity of the above algorithm will be <strong><em>O(N)</em></strong> as we need to return a list containing all the merged intervals.</p><h2 id="Intervals-Intersection-medium"><a href="#Intervals-Intersection-medium" class="headerlink" title="*Intervals Intersection (medium)"></a>*Intervals Intersection (medium)</h2><p>leetcode 986</p><h3 id="Problem-Statement-2"><a href="#Problem-Statement-2" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given two lists of intervals, find the <strong>intersection of these two lists</strong>. Each list consists of <strong>disjoint intervals sorted on their start time</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr1=<span class="string">[[1, 3], [5, 6], [7, 9]]</span>, arr2=<span class="string">[[2, 3], [5, 7]]</span></span><br><span class="line">Output: [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">7</span>]</span><br><span class="line">Explanation: The <span class="built_in">output</span> list contains the common intervals between the two lists.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr1=<span class="string">[[1, 3], [5, 7], [9, 12]]</span>, arr2=<span class="string">[[5, 10]]</span></span><br><span class="line">Output: [<span class="number">5</span>, <span class="number">7</span>], [<span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">Explanation: The <span class="built_in">output</span> list contains the common intervals between the two lists.</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-2"><a href="#Try-it-yourself-2" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是看了solution之后写的，不太会</span></span><br></pre></td></tr></table></figure><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <em>Merge Intervals</em> pattern. As we have discussed under <em>Insert Intervals</em>, there are five overlapping possibilities between two intervals ‘a’ and ‘b’. A close observation will tell us that whenever the two intervals overlap, one of the interval’s start time lies within the other interval. This rule can help us identify if any two intervals overlap or not.</p><p><img src="/5-pattern-merge-intervals/index/5.png"></p><p>Now, if we have found that the two intervals overlap, how can we find the overlapped part?</p><p>Again from the above diagram, the overlapping interval will be equal to:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start = max(a.<span class="keyword">start</span>, b.<span class="keyword">start</span>)</span><br><span class="line">end = min(a.<span class="keyword">end</span>, b.<span class="keyword">end</span>) </span><br></pre></td></tr></table></figure><p>That is, the highest start time and the lowest end time will be the overlapping interval.</p><p>So our algorithm will be to iterate through both the lists together to see if any two intervals overlap. If two intervals overlap, we will insert the overlapped part into a result list and move on to the next interval which is finishing early.</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">intervals_a, intervals_b</span>):</span></span><br><span class="line">    merged = []</span><br><span class="line">    i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(intervals_a) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(intervals_b):</span><br><span class="line">        a_overlap_b = intervals_a[i][<span class="number">0</span>] &gt;= intervals_b[j][<span class="number">0</span>] <span class="keyword">and</span> \</span><br><span class="line">                      intervals_a[i][<span class="number">0</span>] &lt;= intervals_b[j][<span class="number">1</span>]</span><br><span class="line">        b_overlap_a = intervals_b[j][<span class="number">0</span>] &gt;= intervals_a[i][<span class="number">0</span>] <span class="keyword">and</span> \</span><br><span class="line">                      intervals_b[j][<span class="number">0</span>] &lt;= intervals_a[i][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> a_overlap_b <span class="keyword">or</span> b_overlap_a:</span><br><span class="line">            merged.append([<span class="built_in">max</span>(intervals_a[i][<span class="number">0</span>], intervals_b[j][<span class="number">0</span>]), <span class="built_in">min</span>(intervals_a[i][<span class="number">1</span>], intervals_b[j][<span class="number">1</span>])])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> intervals_a[i][<span class="number">1</span>] &gt; intervals_b[j][<span class="number">1</span>]:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> merged</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = insert([[<span class="number">1</span>, <span class="number">3</span>], [<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">9</span>]], [[<span class="number">2</span>, <span class="number">3</span>], [<span class="number">5</span>, <span class="number">7</span>]])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line">    res = insert([[<span class="number">1</span>, <span class="number">3</span>], [<span class="number">5</span>, <span class="number">7</span>], [<span class="number">9</span>, <span class="number">12</span>]], [[<span class="number">5</span>, <span class="number">10</span>]])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-2"><a href="#Time-complexity-2" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>As we are iterating through both the lists once, the time complexity of the above algorithm is <strong><em>O(N+M)</em></strong>, where ‘N’ and ‘M’ are the total number of intervals in the input arrays respectively.</p><h4 id="Space-complexity-2"><a href="#Space-complexity-2" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>Ignoring the space needed for the result list, the algorithm runs in constant space <strong><em>O(1)</em></strong>.</p><h2 id="Conflicting-Appointments-medium"><a href="#Conflicting-Appointments-medium" class="headerlink" title="Conflicting Appointments (medium)"></a>Conflicting Appointments (medium)</h2><p>不在leetcode</p><h3 id="Problem-Statement-3"><a href="#Problem-Statement-3" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given an array of intervals representing ‘N’ appointments, find out if a person can <strong>attend all the appointments</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Appointments: <span class="comment">[<span class="comment">[1,4]</span>, <span class="comment">[2,5]</span>, <span class="comment">[7,9]</span>]</span></span><br><span class="line">Output: false</span><br><span class="line">Explanation: Since <span class="comment">[1,4]</span> and <span class="comment">[2,5]</span> overlap, a <span class="keyword">person</span> cannot attend both <span class="keyword">of</span> these appointments.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Appointments: <span class="string">[[6,7], [2,4], [8,12]]</span></span><br><span class="line">Output: <span class="literal">true</span></span><br><span class="line">Explanation: None of the appointments overlap, therefore a person can attend all of them.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Appointments: <span class="comment">[<span class="comment">[4,5]</span>, <span class="comment">[2,3]</span>, <span class="comment">[3,6]</span>]</span></span><br><span class="line">Output: false</span><br><span class="line">Explanation: Since <span class="comment">[4,5]</span> and <span class="comment">[3,6]</span> overlap, a <span class="keyword">person</span> cannot attend both <span class="keyword">of</span> these appointments.</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-3"><a href="#Try-it-yourself-3" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">can_attend_all_appointment</span>(<span class="params">intervals</span>):</span></span><br><span class="line">    intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(intervals)):</span><br><span class="line">        <span class="comment"># 注意这里是 &lt; 不是 &lt;=,因为&lt;=还是可以参加所有的预约的</span></span><br><span class="line">        <span class="keyword">if</span> intervals[i][<span class="number">0</span>] &lt; intervals[i - <span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = can_attend_all_appointment([[<span class="number">1</span>, <span class="number">4</span>], [<span class="number">2</span>, <span class="number">5</span>], [<span class="number">7</span>, <span class="number">9</span>]])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line">    res = can_attend_all_appointment([[<span class="number">6</span>, <span class="number">7</span>], [<span class="number">2</span>, <span class="number">4</span>], [<span class="number">8</span>, <span class="number">12</span>]])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line">    res = can_attend_all_appointment([[<span class="number">4</span>, <span class="number">5</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">6</span>]])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>The problem follows the <em>Merge Intervals</em> pattern. We can sort all the intervals by start time and then check if any two intervals overlap. A person will not be able to attend all appointments if any two appointments overlap.</p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和我的一样，不在赘述</span></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-3"><a href="#Time-complexity-3" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of the above algorithm is <strong><em>O(N\</em>logN)*</strong>, where ‘N’ is the total number of appointments. Though we are iterating the intervals only once, our algorithm will take <strong><em>O(N\</em>logN)*</strong> since we need to sort them in the beginning.</p><h4 id="Space-complexity-3"><a href="#Space-complexity-3" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity of the above algorithm will be O(N), which we need for sorting. For Java, <code>Arrays.sort()</code> uses <a href="https://en.wikipedia.org/wiki/Timsort">Timsort</a>, which needs <strong><em>O(N)</em></strong> space.</p><hr><h3 id="Similar-Problems-1"><a href="#Similar-Problems-1" class="headerlink" title="Similar Problems"></a>Similar Problems</h3><p><strong>Problem 1:</strong> Given a list of appointments, find all the conflicting appointments.</p><p><strong>Example:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Appointments</span>: [[<span class="number">4</span>,<span class="number">5</span>], [<span class="number">2</span>,<span class="number">3</span>], [<span class="number">3</span>,<span class="number">6</span>], [<span class="number">5</span>,<span class="number">7</span>], [<span class="number">7</span>,<span class="number">8</span>]]</span><br><span class="line"><span class="symbol">Output</span>: </span><br><span class="line">[<span class="number">4</span>,<span class="number">5</span>] and [<span class="number">3</span>,<span class="number">6</span>] conflict. </span><br><span class="line">[<span class="number">3</span>,<span class="number">6</span>] and [<span class="number">5</span>,<span class="number">7</span>] conflict.</span><br></pre></td></tr></table></figure><h2 id="Problem-Challenge-1"><a href="#Problem-Challenge-1" class="headerlink" title="*Problem Challenge 1"></a>*Problem Challenge 1</h2><p>不在leetcode</p><h3 id="Minimum-Meeting-Rooms-hard"><a href="#Minimum-Meeting-Rooms-hard" class="headerlink" title="Minimum Meeting Rooms (hard)"></a>Minimum Meeting Rooms (hard)</h3><p>Given a list of intervals representing the start and end time of ‘N’ meetings, find the <strong>minimum number of rooms</strong> required to <strong>hold all the meetings</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Meetings</span>: [[<span class="number">1</span>,<span class="number">4</span>], [<span class="number">2</span>,<span class="number">5</span>], [<span class="number">7</span>,<span class="number">9</span>]]</span><br><span class="line"><span class="symbol">Output</span>: <span class="number">2</span></span><br><span class="line"><span class="symbol">Explanation</span>: <span class="symbol">Since</span> [<span class="number">1</span>,<span class="number">4</span>] and [<span class="number">2</span>,<span class="number">5</span>] overlap, we need two rooms to hold these two meetings. [<span class="number">7</span>,<span class="number">9</span>] can </span><br><span class="line">occur in any of the two rooms later.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Meetings: <span class="comment">[<span class="comment">[6,7]</span>, <span class="comment">[2,4]</span>, <span class="comment">[8,12]</span>]</span></span><br><span class="line">Output: 1</span><br><span class="line">Explanation: None <span class="keyword">of</span> the meetings overlap, therefore we only need one <span class="keyword">room</span> to hold all meetings.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Meetings</span>: [[<span class="number">1</span>,<span class="number">4</span>], [<span class="number">2</span>,<span class="number">3</span>], [<span class="number">3</span>,<span class="number">6</span>]]</span><br><span class="line"><span class="symbol">Output</span>:<span class="number">2</span></span><br><span class="line"><span class="symbol">Explanation</span>: <span class="symbol">Since</span> [<span class="number">1</span>,<span class="number">4</span>] overlaps with the other two meetings [<span class="number">2</span>,<span class="number">3</span>] and [<span class="number">3</span>,<span class="number">6</span>], we need two rooms to </span><br><span class="line">hold all the meetings.</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Meetings: <span class="comment">[<span class="comment">[4,5]</span>, <span class="comment">[2,3]</span>, <span class="comment">[2,4]</span>, <span class="comment">[3,5]</span>]</span></span><br><span class="line">Output: 2</span><br><span class="line">Explanation: We will need one <span class="keyword">room</span> for <span class="comment">[2,3]</span> and <span class="comment">[3,5]</span>, and another <span class="keyword">room</span> for <span class="comment">[2,4]</span> and <span class="comment">[4,5]</span>.</span><br><span class="line"> </span><br><span class="line">Here <span class="keyword">is</span> a visual representation <span class="keyword">of</span> Example 4:</span><br></pre></td></tr></table></figure><p><img src="/5-pattern-merge-intervals/index/6.png"></p><h3 id="Try-it-yourself-4"><a href="#Try-it-yourself-4" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这是看了solution写的 但是没有定义class，所以在使用heap的时候吧list的两个元素反转了一下</span></span><br><span class="line"><span class="comment"># 在solution可以看到原版答案</span></span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min_meeting_rooms</span>(<span class="params">meetings</span>):</span></span><br><span class="line">    <span class="comment"># 根据开始时间排序</span></span><br><span class="line">    meetings.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    min_rooms = <span class="number">0</span></span><br><span class="line">    min_heap = []</span><br><span class="line">    <span class="keyword">for</span> meeting <span class="keyword">in</span> meetings:</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(min_heap) &gt; <span class="number">0</span> <span class="keyword">and</span> meeting[<span class="number">0</span>] &gt;= min_heap[<span class="number">0</span>][<span class="number">0</span>]:  <span class="comment"># 和最早的会议结束时间去比较，注意min_heap[0][0]是结束时间，因为在插入的时候</span></span><br><span class="line">            heappop(min_heap)</span><br><span class="line">        heappush(min_heap, (meeting[<span class="number">1</span>], meeting[<span class="number">0</span>])) <span class="comment"># 优先根据列表的第二个元素排序,也就是会议的结束时间</span></span><br><span class="line">        min_rooms = <span class="built_in">max</span>(min_rooms, <span class="built_in">len</span>(min_heap))</span><br><span class="line">    <span class="keyword">return</span> min_rooms</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = min_meeting_rooms([[<span class="number">1</span>, <span class="number">4</span>], [<span class="number">2</span>, <span class="number">5</span>], [<span class="number">7</span>, <span class="number">9</span>]])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line">    res = min_meeting_rooms([[<span class="number">6</span>, <span class="number">7</span>], [<span class="number">2</span>, <span class="number">4</span>], [<span class="number">8</span>, <span class="number">12</span>]])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line">    res = min_meeting_rooms([[<span class="number">1</span>, <span class="number">4</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">6</span>]])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><p>Let’s take the above-mentioned example (4) and try to follow our <em>Merge Intervals</em> approach:</p><p><strong>Meetings:</strong> [[4,5], [2,3], [2,4], [3,5]]</p><p><strong>Step 1:</strong> Sorting these meetings on their start time will give us: [[2,3], [2,4], [3,5], [4,5]]</p><p><strong>Step 2:</strong> Merging overlapping meetings:</p><ul><li>[2,3] overlaps with [2,4], so after merging we’ll have =&gt; [[2,4], [3,5], [4,5]]</li><li>[2,4] overlaps with [3,5], so after merging we’ll have =&gt; [[2,5], [4,5]]</li><li>[2,5] overlaps [4,5], so after merging we’ll have =&gt; [2,5]</li></ul><p>Since all the given meetings have merged into one big meeting ([2,5]), does this mean that they all are overlapping and we need a minimum of four rooms to hold these meetings? You might have already guessed that the answer is NO! As we can clearly see, some meetings are mutually exclusive. For example, [2,3] and [3,5] do not overlap and can happen in one room. So, to correctly solve our problem, we need to keep track of the mutual exclusiveness of the overlapping meetings.</p><p>Here is what our strategy will look like:</p><ol><li>We will sort the meetings based on start time.</li><li>We will schedule the first meeting (let’s call it <code>m1</code>) in one room (let’s call it <code>r1</code>).</li><li>If the next meeting <code>m2</code> is not overlapping with <code>m1</code>, we can safely schedule it in the same room <code>r1</code>.</li><li>If the next meeting <code>m3</code> is overlapping with <code>m2</code> we can’t use <code>r1</code>, so we will schedule it in another room (let’s call it <code>r2</code>).</li><li>Now if the next meeting <code>m4</code> is overlapping with <code>m3</code>, we need to see if the room <code>r1</code> has become free. For this, we need to keep track of the end time of the meeting happening in it. If the end time of <code>m2</code> is before the start time of <code>m4</code>, we can use that room <code>r1</code>, otherwise, we need to schedule <code>m4</code> in another room <code>r3</code>.</li></ol><p>We can conclude that we need to <strong>keep track of the ending time of all the meetings currently happening</strong> so that when we try to schedule a new meeting, we can see what meetings have already ended. We need to put this information in a data structure that can easily give us the smallest ending time. A <strong>Min Heap</strong> would fit our requirements best.</p><p>So our algorithm will look like this:</p><ol><li>Sort all the meetings on their start time.</li><li>Create a min-heap to store all the active meetings. This min-heap will also be used to find the active meeting with the smallest end time.</li><li>Iterate through all the meetings one by one to add them in the min-heap. Let’s say we are trying to schedule the meeting <code>m1</code>.</li><li>Since the min-heap contains all the active meetings, so before scheduling <code>m1</code> we can remove all meetings from the heap that have ended before <code>m1</code>, i.e., remove all meetings from the heap that have an end time smaller than or equal to the start time of <code>m1</code>.</li><li>Now add <code>m1</code> to the heap.</li><li>The heap will always have all the overlapping meetings, so we will need rooms for all of them. Keep a counter to remember the maximum size of the heap at any time which will be the minimum number of rooms needed.</li></ol><h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meeting</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, start, end</span>):</span></span><br><span class="line">        self.start = start</span><br><span class="line">        self.end = end</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="comment"># 按照第二个元素由小到大排列</span></span><br><span class="line">        <span class="keyword">return</span> self.end &lt; other.end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min_meeting_rooms</span>(<span class="params">meetings</span>):</span></span><br><span class="line">    <span class="comment"># 根据开始时间排序</span></span><br><span class="line">    meetings.sort(key=<span class="keyword">lambda</span> x: x.start)</span><br><span class="line"></span><br><span class="line">    min_rooms = <span class="number">0</span></span><br><span class="line">    min_heap = []</span><br><span class="line">    <span class="keyword">for</span> meeting <span class="keyword">in</span> meetings:</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(min_heap) &gt; <span class="number">0</span> <span class="keyword">and</span> meeting.start &gt;= min_heap[<span class="number">0</span>].end:  <span class="comment"># 和最早的会议结束时间去比较，注意min_heap[0][0]是结束时间，因为在插入的时候</span></span><br><span class="line">            heappop(min_heap)</span><br><span class="line">        heappush(min_heap, meeting)  <span class="comment"># 优先根据列表的第二个元素排序,也就是会议的结束时间</span></span><br><span class="line">        min_rooms = <span class="built_in">max</span>(min_rooms, <span class="built_in">len</span>(min_heap))</span><br><span class="line">    <span class="keyword">return</span> min_rooms</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = min_meeting_rooms([Meeting(<span class="number">4</span>, <span class="number">5</span>), Meeting(<span class="number">2</span>, <span class="number">3</span>), Meeting(<span class="number">2</span>, <span class="number">4</span>), Meeting(<span class="number">3</span>, <span class="number">5</span>)])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-4"><a href="#Time-complexity-4" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of the above algorithm is <strong><em>O(N\</em>logN)*</strong>, where ‘N’ is the total number of meetings. This is due to the sorting that we did in the beginning. Also, while iterating the meetings we might need to poll/offer meeting to the priority queue. Each of these operations can take <strong><em>O(N\</em>logN)*</strong>. Overall our algorithm will take <strong><em>O(N\</em>logN)*</strong>.</p><h4 id="Space-complexity-4"><a href="#Space-complexity-4" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity of the above algorithm will be <strong><em>O(N)</em></strong> which is required for sorting. Also, in the worst case scenario, we’ll have to insert all the meetings into the <strong>Min Heap</strong> (when all meetings overlap) which will also take <strong><em>O(N)</em></strong> space. The overall space complexity of our algorithm is <strong><em>O(N)</em></strong>.</p><hr><h3 id="Similar-Problems-2"><a href="#Similar-Problems-2" class="headerlink" title="Similar Problems"></a>Similar Problems</h3><p><strong>Problem 1:</strong> Given a list of intervals, find the point where the maximum number of intervals overlap.</p><p><strong>Problem 2:</strong> Given a list of intervals representing the arrival and departure times of trains to a train station, our goal is to find the minimum number of platforms required for the train station so that no train has to wait.</p><p>Both of these problems can be solved using the approach discussed above.</p><h2 id="Problem-Challenge-2"><a href="#Problem-Challenge-2" class="headerlink" title="Problem Challenge 2"></a>Problem Challenge 2</h2><p>不在leetcode</p><h3 id="Maximum-CPU-Load-hard"><a href="#Maximum-CPU-Load-hard" class="headerlink" title="Maximum CPU Load (hard)"></a>Maximum CPU Load (hard)</h3><p>We are given a list of Jobs. Each job has a Start time, an End time, and a CPU load when it is running. Our goal is to find the <strong>maximum CPU load</strong> at any time if all the <strong>jobs are running on the same machine</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Jobs: <span class="string">[[1,4,3], [2,5,4], [7,9,6]]</span></span><br><span class="line">Output: <span class="number">7</span></span><br><span class="line">Explanation: Since [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>] <span class="keyword">and</span> [<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>] overlap, their maximum CPU <span class="built_in">load</span> (<span class="number">3</span>+<span class="number">4</span>=<span class="number">7</span>) will be when both the </span><br><span class="line">jobs are <span class="built_in">running</span> at the same <span class="built_in">time</span> i.e., during the <span class="built_in">time</span> interval (<span class="number">2</span>,<span class="number">4</span>).</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Jobs: <span class="string">[[6,7,10], [2,4,11], [8,12,15]]</span></span><br><span class="line">Output: <span class="number">15</span></span><br><span class="line">Explanation: None of the jobs overlap, therefore we will take the maximum <span class="built_in">load</span> of any job which is <span class="number">15.</span></span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Jobs: <span class="string">[[1,4,2], [2,4,1], [3,6,5]]</span></span><br><span class="line">Output: <span class="number">8</span></span><br><span class="line">Explanation: Maximum CPU <span class="built_in">load</span> will be <span class="number">8</span> as all jobs overlap during the <span class="built_in">time</span> interval [<span class="number">3</span>,<span class="number">4</span>]. </span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-5"><a href="#Try-it-yourself-5" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这是看了solution写的 但是没有定义class，所以在使用heap的时候吧list的两个元素反转了一下</span></span><br><span class="line"><span class="comment"># 在solution可以看到原版答案</span></span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min_meeting_rooms</span>(<span class="params">jobs</span>):</span></span><br><span class="line">    <span class="comment"># 根据开始时间排序</span></span><br><span class="line">    jobs.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    max_load, current_load = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    min_heap = []</span><br><span class="line">    <span class="keyword">for</span> job <span class="keyword">in</span> jobs:</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(min_heap) &gt; <span class="number">0</span> <span class="keyword">and</span> job[<span class="number">0</span>] &gt;= min_heap[<span class="number">0</span>][<span class="number">1</span>]:  <span class="comment"># 和最早的会议结束时间去比较，注意min_heap[0][0]是结束时间，因为在插入的时候</span></span><br><span class="line">            current_load -= min_heap[<span class="number">0</span>][<span class="number">2</span>]</span><br><span class="line">            heappop(min_heap)</span><br><span class="line">        heappush(min_heap, job)  <span class="comment"># 优先根据列表的第二个元素排序,也就是会议的结束时间</span></span><br><span class="line">        current_load += job[<span class="number">2</span>]</span><br><span class="line">        max_load = <span class="built_in">max</span>(max_load, current_load)</span><br><span class="line">    <span class="keyword">return</span> max_load</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = min_meeting_rooms([[<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>], [<span class="number">7</span>, <span class="number">9</span>, <span class="number">6</span>]])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line">    res = min_meeting_rooms([[<span class="number">6</span>, <span class="number">7</span>, <span class="number">10</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">11</span>], [<span class="number">8</span>, <span class="number">12</span>, <span class="number">15</span>]])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line">    res = min_meeting_rooms([[<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>], [<span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>]])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><p>The problem follows the <strong><em>Merge Intervals</em></strong> pattern and can easily be converted to <strong><em>Minimum Meeting Rooms</em></strong>. Similar to ‘Minimum Meeting Rooms’ where we were trying to find the maximum number of meetings happening at any time, for ‘Maximum CPU Load’ we need to find the maximum number of jobs running at any time. We will need to keep a running count of the maximum CPU load at any time to find the overall maximum load.</p><h3 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">job</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, start, end, cpu_load</span>):</span></span><br><span class="line">        self.start = start</span><br><span class="line">        self.end = end</span><br><span class="line">        self.cpu_load = cpu_load</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="comment"># 按照第二个元素由小到大排列</span></span><br><span class="line">        <span class="keyword">return</span> self.end &lt; other.end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min_meeting_rooms</span>(<span class="params">jobs</span>):</span></span><br><span class="line">    <span class="comment"># 根据开始时间排序</span></span><br><span class="line">    jobs.sort(key=<span class="keyword">lambda</span> x: x.start)</span><br><span class="line"></span><br><span class="line">    max_load, current_load = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    min_heap = []</span><br><span class="line">    <span class="keyword">for</span> job <span class="keyword">in</span> jobs:</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(min_heap) &gt; <span class="number">0</span> <span class="keyword">and</span> job.start &gt;= min_heap[<span class="number">0</span>].end:  <span class="comment"># 和最早的会议结束时间去比较，注意min_heap[0][0]是结束时间，因为在插入的时候</span></span><br><span class="line">            current_load -= min_heap[<span class="number">0</span>].cpu_load</span><br><span class="line">            heappop(min_heap)</span><br><span class="line">        heappush(min_heap, job)  <span class="comment"># 优先根据列表的第二个元素排序,也就是会议的结束时间</span></span><br><span class="line">        current_load += job.cpu_load</span><br><span class="line">        max_load = <span class="built_in">max</span>(max_load, current_load)</span><br><span class="line">    <span class="keyword">return</span> max_load</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = min_meeting_rooms([job(<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>), job(<span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>), job(<span class="number">7</span>, <span class="number">9</span>, <span class="number">6</span>)])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line">    res = min_meeting_rooms([job(<span class="number">6</span>, <span class="number">7</span>, <span class="number">10</span>), job(<span class="number">2</span>, <span class="number">4</span>, <span class="number">11</span>), job(<span class="number">8</span>, <span class="number">12</span>, <span class="number">15</span>)])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line">    res = min_meeting_rooms([job(<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>), job(<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>), job(<span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>)])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-5"><a href="#Time-complexity-5" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of the above algorithm is <strong><em>O(N\</em>logN)*</strong>, where ‘N’ is the total number of jobs. This is due to the sorting that we did in the beginning. Also, while iterating the jobs, we might need to poll/offer jobs to the priority queue. Each of these operations can take <strong><em>O(log\</em>N)*</strong>. Overall our algorithm will take <strong><a href><em>O(N\</em>logN)*</a></strong></p><h4 id="Space-complexity-5"><a href="#Space-complexity-5" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity of the above algorithm will be <strong><em>O(N)</em></strong>, which is required for sorting. Also, in the worst case, we have to insert all the jobs into the priority queue (when all jobs overlap) which will also take <strong><em>O(N)</em></strong> space. The overall space complexity of our algorithm is <strong><em>O(N)</em></strong></p><h2 id="Problem-Challenge-3"><a href="#Problem-Challenge-3" class="headerlink" title="**Problem Challenge 3"></a>**Problem Challenge 3</h2><p>不在leetcode</p><h3 id="Employee-Free-Time-hard"><a href="#Employee-Free-Time-hard" class="headerlink" title="Employee Free Time (hard)"></a>Employee Free Time (hard)</h3><p>For ‘K’ employees, we are given a list of intervals representing the working hours of each employee. Our goal is to find out if there is a <strong>free interval that is common to all employees</strong>. You can assume that each list of employee working hours is sorted on the start time.</p><p><strong>Example 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: Employee Working Hours=<span class="comment">[<span class="comment">[<span class="comment">[1,3]</span>, <span class="comment">[5,6]</span>]</span>, <span class="comment">[<span class="comment">[2,3]</span>, <span class="comment">[6,8]</span>]</span>]</span></span><br><span class="line">Output: <span class="comment">[3,5]</span></span><br><span class="line">Explanation: Both the employess <span class="keyword">are</span> free between <span class="comment">[3,5]</span>.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: Employee Working Hours=<span class="string">[[[1,3], [9,12]]</span>, <span class="string">[[2,4]]</span>, <span class="string">[[6,8]]</span>]</span><br><span class="line">Output: [<span class="number">4</span>,<span class="number">6</span>], [<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">Explanation: All employess are free between [<span class="number">4</span>,<span class="number">6</span>] <span class="keyword">and</span> [<span class="number">8</span>,<span class="number">9</span>].</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: Employee Working Hours=<span class="string">[[[1,3]]</span>, <span class="string">[[2,4]]</span>, <span class="string">[[3,5], [7,9]]</span>]</span><br><span class="line">Output: [<span class="number">5</span>,<span class="number">7</span>]</span><br><span class="line">Explanation: All employess are free between [<span class="number">5</span>,<span class="number">7</span>].</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-6"><a href="#Try-it-yourself-6" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不会</span></span><br><span class="line"><span class="comment"># One simple solution can be to put the working hours of all employees in a list and sort them on the start time. Then we can iterate through the list to find the gaps.</span></span><br><span class="line"><span class="comment"># 可以看solution 但是这个的缺点是没有理由本身的排序</span></span><br></pre></td></tr></table></figure><h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <strong><em>Merge Intervals</em></strong> pattern. Let’s take the above-mentioned example (2) and visually draw it:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: Employee Working Hours=<span class="string">[[[1,3], [9,12]]</span>, <span class="string">[[2,4]]</span>, <span class="string">[[6,8]]</span>]</span><br><span class="line">Output: [<span class="number">4</span>,<span class="number">6</span>], [<span class="number">8</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure><p><img src="/5-pattern-merge-intervals/index/7.png"></p><p>One simple solution can be to put the working hours of all employees in a list and sort them on the start time. Then we can iterate through the list to find the gaps. Let’s dig deeper. Sorting the intervals of the above example will give us:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[1,3]</span>, <span class="selector-attr">[2,4]</span>, <span class="selector-attr">[6,8]</span>, <span class="selector-attr">[9,12]</span></span><br></pre></td></tr></table></figure><p>We can now iterate through these intervals, and whenever we find non-overlapping intervals (e.g., [2,4] and [6,8]), we can calculate a free interval (e.g., [4,6]). This algorithm will take <strong><em>O(N \</em> logN)*</strong> time, where ‘N’ is the total number of intervals. This time is needed because we need to sort all the intervals. The space complexity will be <strong><em>O(N)</em></strong>, which is needed for sorting. Can we find a better solution?</p><h4 id="Using-a-Heap-to-Sort-the-Intervals"><a href="#Using-a-Heap-to-Sort-the-Intervals" class="headerlink" title="Using a Heap to Sort the Intervals"></a>Using a Heap to Sort the Intervals</h4><p>One fact that we are not utilizing is that each employee list is individually sorted!</p><p>How about we take the first interval of each employee and insert it in a <strong>Min Heap</strong>. This <strong>Min Heap</strong> can always give us the interval with the smallest start time. Once we have the smallest start-time interval, we can then compare it with the next smallest start-time interval (again from the <strong>Heap</strong>) to find the gap. This interval comparison is similar to what we suggested in the previous approach.</p><p>Whenever we take an interval out of the <strong>Min Heap</strong>, we can insert the next interval of the same employee. This also means that we need to know which interval belongs to which employee.</p><h3 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><p><strong>其实思路没咋看懂，比较难懂，需要自习研究一下</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interval</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, start, end</span>):</span></span><br><span class="line">        self.start = start</span><br><span class="line">        self.end = end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmployeeInterval</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, interval, employeeIndex, intervalIndex</span>):</span></span><br><span class="line">        self.interval = interval</span><br><span class="line">        self.intervalIndex = intervalIndex</span><br><span class="line">        self.employeeIndex = employeeIndex</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="comment"># 按照第一个元素由小到大排列（默认，所以这个不写也可以）</span></span><br><span class="line">        <span class="keyword">return</span> self.interval.start &lt; other.interval.start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_employee_freeTime</span>(<span class="params">schedules</span>):</span></span><br><span class="line">    <span class="comment"># 根据开始时间排序</span></span><br><span class="line">    min_heap, result = [], []</span><br><span class="line">    n = <span class="built_in">len</span>(schedules)  <span class="comment"># 员工人数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        heappush(min_heap, EmployeeInterval(schedules[i][<span class="number">0</span>], i, <span class="number">0</span>))</span><br><span class="line">    previousInterval = min_heap[<span class="number">0</span>].interval</span><br><span class="line">    <span class="keyword">while</span> min_heap:</span><br><span class="line">        queue_top = heappop(min_heap)</span><br><span class="line">        <span class="keyword">if</span> previousInterval.end &lt; queue_top.interval.start:</span><br><span class="line">            result.append([previousInterval.end, queue_top.interval.start])</span><br><span class="line">            previousInterval = queue_top.interval</span><br><span class="line">        <span class="keyword">elif</span> previousInterval.end &lt; queue_top.interval.end:</span><br><span class="line">            previousInterval = queue_top.interval</span><br><span class="line">        employeeSchedule = schedules[queue_top.employeeIndex]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(employeeSchedule) &gt; queue_top.intervalIndex + <span class="number">1</span>:</span><br><span class="line">            heappush(min_heap, EmployeeInterval(employeeSchedule[queue_top.intervalIndex + <span class="number">1</span>], queue_top.employeeIndex,</span><br><span class="line">                                                queue_top.intervalIndex + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    res = find_employee_freeTime(</span><br><span class="line">        [[Interval(<span class="number">1</span>, <span class="number">3</span>), Interval(<span class="number">5</span>, <span class="number">6</span>)], [Interval(<span class="number">2</span>, <span class="number">3</span>), Interval(<span class="number">6</span>, <span class="number">8</span>)]])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line">    res = find_employee_freeTime(</span><br><span class="line">        [[Interval(<span class="number">1</span>, <span class="number">3</span>), Interval(<span class="number">9</span>, <span class="number">12</span>)], [Interval(<span class="number">2</span>, <span class="number">4</span>), Interval(<span class="number">6</span>, <span class="number">8</span>)]])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line">    res = find_employee_freeTime(</span><br><span class="line">        [[Interval(<span class="number">1</span>, <span class="number">3</span>), Interval(<span class="number">2</span>, <span class="number">4</span>)], [Interval(<span class="number">3</span>, <span class="number">5</span>), Interval(<span class="number">7</span>, <span class="number">9</span>)]])</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(res))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-6"><a href="#Time-complexity-6" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of the above algorithm is <strong><em>O(N\</em>logK)*</strong>, where ‘N’ is the total number of intervals and ‘K’ is the total number of employees. This is due to the fact that we are iterating through the intervals only once (which will take <strong><em>O(N)</em></strong>), and every time we process an interval, we remove (and can insert) one interval in the <strong>Min Heap</strong>, (which will take <strong><em>O(N\</em>logK)*</strong>). At any time the heap will not have more than ‘K’ elements.</p><h4 id="Space-complexity-6"><a href="#Space-complexity-6" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity of the above algorithm will be <strong><em>O(K)</em></strong> as at any time the heap will not have more than ‘K’ elements.</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4. Pattern Fast_Slow pointers</title>
      <link href="/4-pattern-fast-slow-pointers/index.html"/>
      <url>/4-pattern-fast-slow-pointers/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>The <strong>Fast &amp; Slow</strong> pointer approach, also known as the <strong>Hare &amp; Tortoise algorithm</strong>, is a pointer algorithm that uses two pointers which move through the array (or sequence/LinkedList) at different speeds. This approach is quite useful when dealing with cyclic LinkedLists or arrays.</p><p>By moving at different speeds (say, in a cyclic LinkedList), the algorithm proves that the two pointers are bound to meet. The fast pointer should catch the slow pointer once both the pointers are in a cyclic loop.</p><p>One of the famous problems solved using this technique was <strong>Finding a cycle in a LinkedList</strong>. Let’s jump onto this problem to understand the <strong>Fast &amp; Slow</strong> pattern.</p><h2 id="LinkedList-Cycle-easy"><a href="#LinkedList-Cycle-easy" class="headerlink" title="LinkedList Cycle (easy)"></a>LinkedList Cycle (easy)</h2><p>leetcode 141</p><h3 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given the head of a <strong>Singly LinkedList</strong>, write a function to determine if the LinkedList has a <strong>cycle</strong> in it or not.</p><p><img src="/4-pattern-fast-slow-pointers/index/1.png"></p><h3 id="Try-it-yourself"><a href="#Try-it-yourself" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.valve = value</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">has_cycle</span>(<span class="params">head</span>):</span></span><br><span class="line">    slow, fast = head, head</span><br><span class="line">    <span class="keyword">while</span> fast <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> fast.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        slow = slow.<span class="built_in">next</span></span><br><span class="line">        fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> fast == slow:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    head = Node(<span class="number">1</span>)</span><br><span class="line">    head.<span class="built_in">next</span> = Node(<span class="number">2</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">3</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">4</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">5</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">6</span>)</span><br><span class="line">    result = has_cycle(head)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = head.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">    result = has_cycle(head)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">    result = has_cycle(head)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>Imagine two racers running in a circular racing track. If one racer is faster than the other, the faster racer is bound to catch up and cross the slower racer from behind. We can use this fact to devise an algorithm to determine if a LinkedList has a cycle in it or not.</p><p>Imagine we have a slow and a fast pointer to traverse the LinkedList. In each iteration, the slow pointer moves one step and the fast pointer moves two steps. This gives us two conclusions:</p><ol><li>If the LinkedList doesn’t have a cycle in it, the fast pointer will reach the end of the LinkedList before the slow pointer to reveal that there is no cycle in the LinkedList.</li><li>The slow pointer will never be able to catch up to the fast pointer if there is no cycle in the LinkedList.</li></ol><p>If the LinkedList has a cycle, the fast pointer enters the cycle first, followed by the slow pointer. After this, both pointers will keep moving in the cycle infinitely. If at any stage both of these pointers meet, we can conclude that the LinkedList has a cycle in it. Let’s analyze if it is possible for the two pointers to meet. When the fast pointer is approaching the slow pointer from behind we have two possibilities:</p><ol><li>The fast pointer is one step behind the slow pointer.</li><li>The fast pointer is two steps behind the slow pointer.</li></ol><p>All other distances between the fast and slow pointers will reduce to one of these two possibilities. Let’s analyze these scenarios, considering the fast pointer always moves first:</p><ol><li><strong>If the fast pointer is one step behind the slow pointer:</strong> The fast pointer moves two steps and the slow pointer moves one step, and they both meet.</li><li><strong>If the fast pointer is two steps behind the slow pointer:</strong> The fast pointer moves two steps and the slow pointer moves one step. After the moves, the fast pointer will be one step behind the slow pointer, which reduces this scenario to the first scenario. This means that the two pointers will meet in the next iteration.</li></ol><p>This concludes that the two pointers will definitely meet if the LinkedList has a cycle. A similar analysis can be done where the slow pointer moves first. Here is a visual representation of the above discussion:</p><p><img src="/4-pattern-fast-slow-pointers/index/2.png"></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和我的代码一摸一样，这里就不在重复了</span></span><br></pre></td></tr></table></figure><h4 id="Time-Complexity"><a href="#Time-Complexity" class="headerlink" title="Time Complexity"></a>Time Complexity</h4><p>As we have concluded above, once the slow pointer enters the cycle, the fast pointer will meet the slow pointer in the same loop. Therefore, the time complexity of our algorithm will be <strong><em>O(N)</em></strong> where ‘N’ is the total number of nodes in the LinkedList.</p><h4 id="Space-Complexity"><a href="#Space-Complexity" class="headerlink" title="Space Complexity"></a>Space Complexity</h4><p>The algorithm runs in constant space <strong><em>O(1)</em></strong>.</p><h3 id="Similar-Problems"><a href="#Similar-Problems" class="headerlink" title="Similar Problems"></a>Similar Problems</h3><p><strong>Problem 1:</strong> Given the head of a LinkedList with a cycle, find the length of the cycle.</p><p><strong>Solution:</strong> We can use the above solution to find the cycle in the LinkedList. Once the fast and slow pointers meet, we can save the slow pointer and iterate the whole cycle with another pointer until we see the slow pointer again to find the length of the cycle.</p><p>Here is what our algorithm will look like:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="keyword">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">        next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedListCycleLength</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findCycleLength</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// todo:</span></span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">calculateLength</span>(slow);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateLength</span><span class="params">(ListNode* slow)</span> </span>&#123;</span><br><span class="line">        ListNode* current = slow;</span><br><span class="line">        <span class="keyword">int</span> cycleLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">            cycleLength++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (current != slow);</span><br><span class="line">        <span class="keyword">return</span> cycleLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">    head-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">    head-&gt;next-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">    head-&gt;next-&gt;next-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">4</span>);</span><br><span class="line">    head-&gt;next-&gt;next-&gt;next-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">5</span>);</span><br><span class="line">    head-&gt;next-&gt;next-&gt;next-&gt;next-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    head-&gt;next-&gt;next-&gt;next-&gt;next-&gt;next-&gt;next = head-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;LinkedList has cycle: &quot;</span></span><br><span class="line">         &lt;&lt; LinkedListCycleLength::<span class="built_in">findCycleLength</span>(head) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    head-&gt;next-&gt;next-&gt;next-&gt;next-&gt;next-&gt;next = head-&gt;next-&gt;next-&gt;next;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;LinkedList has cycle: &quot;</span></span><br><span class="line">         &lt;&lt; LinkedListCycleLength::<span class="built_in">findCycleLength</span>(head) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Time and Space Complexity:</strong> The above algorithm runs in <strong><em>O(N)</em></strong> time complexity and <strong><em>O(1)</em></strong> space complexity.</p><h2 id="Start-of-LinkedList-Cycle-medium"><a href="#Start-of-LinkedList-Cycle-medium" class="headerlink" title="Start of LinkedList Cycle (medium)"></a>Start of LinkedList Cycle (medium)</h2><p>leetcode 142</p><h3 id="Problem-Statement-1"><a href="#Problem-Statement-1" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given the head of a <strong>Singly LinkedList</strong> that contains a cycle, write a function to find the <strong>starting node of the cycle</strong>.</p><p><img src="/4-pattern-fast-slow-pointers/index/3.png"></p><h3 id="Try-it-yourself-1"><a href="#Try-it-yourself-1" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_cycle_start</span>(<span class="params">head</span>):</span></span><br><span class="line">    slow, fast = head, head</span><br><span class="line">    <span class="keyword">while</span> fast <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> fast.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        slow = slow.<span class="built_in">next</span></span><br><span class="line">        fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> fast == slow:</span><br><span class="line">            cycle_len = cal_len(slow)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> find_start(head, cycle_len).value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_len</span>(<span class="params">slow</span>):</span></span><br><span class="line">    current = slow</span><br><span class="line">    <span class="built_in">len</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        current = current.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">len</span> += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> current == slow:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_start</span>(<span class="params">head, length</span>):</span></span><br><span class="line">    p1, p2 = head, head</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        p2 = p2.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">while</span> p1 != p2:</span><br><span class="line">        p1 = p1.<span class="built_in">next</span></span><br><span class="line">        p2 = p2.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> p1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    head = Node(<span class="number">1</span>)</span><br><span class="line">    head.<span class="built_in">next</span> = Node(<span class="number">2</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">3</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">4</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">5</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = head.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">    result = find_cycle_start(head)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">    result = find_cycle_start(head)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = head</span><br><span class="line">    result = find_cycle_start(head)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>If we know the length of the <strong>LinkedList</strong> cycle, we can find the start of the cycle through the following steps:</p><ol><li>Take two pointers. Let’s call them <code>pointer1</code> and <code>pointer2</code>.</li><li>Initialize both pointers to point to the start of the LinkedList.</li><li>We can find the length of the LinkedList cycle using the approach discussed in <em>LinkedList Cycle</em>. Let’s assume that the length of the cycle is ‘K’ nodes.</li><li>Move <code>pointer2</code> ahead by ‘K’ nodes.</li><li>Now, keep incrementing <code>pointer1</code> and <code>pointer2</code> until they both meet.</li><li>As <code>pointer2</code> is ‘K’ nodes ahead of <code>pointer1</code>, which means, <code>pointer2</code> must have completed one loop in the cycle when both pointers meet. Their meeting point will be the start of the cycle.</li></ol><p>Let’s visually see this with the above-mentioned Example-1:</p><p><img src="/4-pattern-fast-slow-pointers/index/4.png"></p><p>We can use the algorithm discussed in <em>LinkedList Cycle</em> to find the length of the cycle and then follow the above-mentioned steps to find the start of the cycle.</p><h4 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h4><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 答案和我写的代码的思路一样的，只是结构不一样，就不重写了</span></span><br></pre></td></tr></table></figure><h4 id="Time-Complexity-1"><a href="#Time-Complexity-1" class="headerlink" title="Time Complexity"></a>Time Complexity</h4><p>As we know, finding the cycle in a LinkedList with ‘N’ nodes and also finding the length of the cycle requires <strong><em>O(N)</em></strong>. Also, as we saw in the above algorithm, we will need <strong><em>O(N)</em></strong> to find the start of the cycle. Therefore, the overall time complexity of our algorithm will be <strong><em>O(N)</em></strong>.</p><h4 id="Space-Complexity-1"><a href="#Space-Complexity-1" class="headerlink" title="Space Complexity"></a>Space Complexity</h4><p>The algorithm runs in constant space <strong><em>O(1)</em></strong>.</p><h2 id="Happy-Number-medium"><a href="#Happy-Number-medium" class="headerlink" title="Happy Number (medium)"></a>Happy Number (medium)</h2><p>leetcode 202</p><h3 id="Problem-Statement-2"><a href="#Problem-Statement-2" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Any number will be called a happy number if, after repeatedly replacing it with a number equal to the <strong>sum of the square of all of its digits, leads us to number ‘1’</strong>. All other (not-happy) numbers will never reach ‘1’. Instead, they will be stuck in a cycle of numbers which does not include ‘1’.</p><p><strong>Example 1:</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Inpu<span class="variable">t:</span> <span class="number">23</span>   </span><br><span class="line">Outpu<span class="variable">t:</span> true (<span class="number">23</span> <span class="keyword">is</span> <span class="keyword">a</span> happy <span class="keyword">number</span>)  </span><br><span class="line">Explanation<span class="variable">s:</span> Here are the steps <span class="keyword">to</span> <span class="keyword">find</span> out that <span class="number">23</span> <span class="keyword">is</span> <span class="keyword">a</span> happy <span class="keyword">number</span>:</span><br></pre></td></tr></table></figure><ol><li>2^2 + 3 ^2 = 4 + 9 = 13</li><li>1^2 + 3^2 = 1 + 9 = 10</li><li>1^2 + 0^2 = 1 + 0 = 1</li></ol><p><strong>Example 2:</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Inpu<span class="variable">t:</span> <span class="number">12</span>   </span><br><span class="line">Outpu<span class="variable">t:</span> false (<span class="number">12</span> <span class="keyword">is</span> not <span class="keyword">a</span> happy <span class="keyword">number</span>)  </span><br><span class="line">Explanation<span class="variable">s:</span> Here are the steps <span class="keyword">to</span> <span class="keyword">find</span> out that <span class="number">12</span> <span class="keyword">is</span> not <span class="keyword">a</span> happy <span class="keyword">number</span>:</span><br></pre></td></tr></table></figure><ol><li>1^2 + 2 ^2 = 1 + 4 = 5</li><li>5^2 = 25</li><li>2^2 + 5^2 = 4 + 25 = 29</li><li>2^2 + 9^2 = 4 + 81 = 85</li><li>8^2 + 5^2 = 64 + 25 = 89</li><li>8^2 + 9^2 = 64 + 81 = 145</li><li>1^2 + 4^2 + 5^2 = 1 + 16 + 25 = 42</li><li>4^2 + 2^2 = 16 + 4 = 20</li><li>2^2 + 0^2 = 4 + 0 = 4</li><li>4^2 = 16</li><li>1^2 + 6^2 = 1 + 36 = 37</li><li>3^2 + 7^2 = 9 + 49 = 58</li><li>5^2 + 8^2 = 25 + 64 = 89</li></ol><p>Step ‘13’ leads us back to step ‘5’ as the number becomes equal to ‘89’, this means that we can never reach ‘1’, therefore, ‘12’ is not a happy number.</p><h3 id="Try-it-yourself-2"><a href="#Try-it-yourself-2" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和solution不太一样 但是也对</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_happy_number</span>(<span class="params">num</span>):</span></span><br><span class="line">    slow, fast = num, num</span><br><span class="line">    <span class="keyword">while</span> fast != <span class="number">1</span> <span class="keyword">and</span> find_square_sum(fast) != <span class="number">1</span>:</span><br><span class="line">        slow = find_square_sum(slow)</span><br><span class="line">        fast = find_square_sum(find_square_sum(fast))</span><br><span class="line">        <span class="keyword">if</span> slow == fast:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_square_sum</span>(<span class="params">num</span>):</span></span><br><span class="line">    _<span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> num != <span class="number">0</span>:</span><br><span class="line">        digit = num % <span class="number">10</span></span><br><span class="line">        _<span class="built_in">sum</span> += digit * digit</span><br><span class="line">        num = num // <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> _<span class="built_in">sum</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    result = find_happy_number(<span class="number">23</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line">    result = find_happy_number(<span class="number">12</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>The process, defined above, to find out if a number is a happy number or not, always ends in a cycle. If the number is a happy number, the process will be stuck in a cycle on number ‘1,’ and if the number is not a happy number then the process will be stuck in a cycle with a set of numbers. As we saw in Example-2 while determining if ‘12’ is a happy number or not, our process will get stuck in a cycle with the following numbers: 89 -&gt; 145 -&gt; 42 -&gt; 20 -&gt; 4 -&gt; 16 -&gt; 37 -&gt; 58 -&gt; 89</p><p>We saw in the <em>LinkedList Cycle</em> problem that we can use the <strong>Fast &amp; Slow pointers</strong> method to find a cycle among a set of elements. As we have described above, each number will definitely have a cycle. Therefore, we will use the same fast &amp; slow pointer strategy to find the cycle and once the cycle is found, we will see if the cycle is stuck on number ‘1’ to find out if the number is happy or not.</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_happy_number</span>(<span class="params">num</span>):</span></span><br><span class="line">    slow, fast = num, num</span><br><span class="line">    <span class="comment"># As we have described above, each number will definitely have a cycle. </span></span><br><span class="line">    <span class="comment"># if the cycle is stuck on number ‘1’ to find out if the number is happy or not.</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        slow = find_square_sum(slow)</span><br><span class="line">        fast = find_square_sum(find_square_sum(fast))</span><br><span class="line">        <span class="keyword">if</span> slow == fast:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> slow == <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_square_sum</span>(<span class="params">num</span>):</span></span><br><span class="line">    _<span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> num != <span class="number">0</span>:</span><br><span class="line">        digit = num % <span class="number">10</span></span><br><span class="line">        _<span class="built_in">sum</span> += digit * digit</span><br><span class="line">        num = num // <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> _<span class="built_in">sum</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    result = find_happy_number(<span class="number">23</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line">    result = find_happy_number(<span class="number">12</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-Complexity-2"><a href="#Time-Complexity-2" class="headerlink" title="Time Complexity"></a>Time Complexity</h4><p>The time complexity of the algorithm is difficult to determine. However we know the fact that all <a href="https://en.wikipedia.org/wiki/Happy_number#Sequence_behavio">unhappy numbers</a> eventually get stuck in the cycle: 4 -&gt; 16 -&gt; 37 -&gt; 58 -&gt; 89 -&gt; 145 -&gt; 42 -&gt; 20 -&gt; 4</p><p>This <a href="https://en.wikipedia.org/wiki/Happy_number#Sequence_behavior">sequence behavior</a> tells us two things:</p><ol><li>If the number N<em>N</em> is less than or equal to 1000, then we reach the cycle or ‘1’ in at most 1001 steps.</li><li>For <strong><em>N &gt; 1000</em></strong>, suppose the number has ‘M’ digits and the next number is ‘N1’. From the above Wikipedia link, we know that the sum of the squares of the digits of ‘N’ is at most $9^2M$, or $81M$ (this will happen when all digits of ‘N’ are ‘9’).</li></ol><p>This means:</p><ol><li>$N1 &lt; 81M$</li><li>As we know $M = log(N+1)$</li><li>Therefore: $N1 &lt; 81 * log(N+1) =&gt; N1 = O(logN)$</li></ol><p>This concludes that the above algorithm will have a time complexity of <strong><em>O(logN)</em></strong>.</p><h4 id="Space-Complexity-2"><a href="#Space-Complexity-2" class="headerlink" title="Space Complexity"></a>Space Complexity</h4><p>The algorithm runs in constant space <strong><em>O(1)</em></strong>.</p><h2 id="Middle-of-the-LinkedList-easy"><a href="#Middle-of-the-LinkedList-easy" class="headerlink" title="Middle of the LinkedList (easy)"></a>Middle of the LinkedList (easy)</h2><p>leetcode 876</p><h3 id="Problem-Statement-3"><a href="#Problem-Statement-3" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given the head of a <strong>Singly LinkedList</strong>, write a method to return the <strong>middle node</strong> of the LinkedList.</p><p>If the total number of nodes in the LinkedList is even, return the second middle node.</p><p><strong>Example 1:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: <span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="number">4</span> -&gt; <span class="number">5</span> -&gt; null</span><br><span class="line"><span class="attribute">Output</span>: <span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: <span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="number">4</span> -&gt; <span class="number">5</span> -&gt; <span class="number">6</span> -&gt; null</span><br><span class="line"><span class="attribute">Output</span>: <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: <span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="number">4</span> -&gt; <span class="number">5</span> -&gt; <span class="number">6</span> -&gt; <span class="number">7</span> -&gt; null</span><br><span class="line"><span class="attribute">Output</span>: <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-3"><a href="#Try-it-yourself-3" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_middle_of_linked_list</span>(<span class="params">head</span>):</span></span><br><span class="line">    slow, fast = head, head</span><br><span class="line">    <span class="keyword">while</span> fast <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> fast.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        slow = slow.<span class="built_in">next</span></span><br><span class="line">        fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> slow.value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    head = Node(<span class="number">1</span>)</span><br><span class="line">    head.<span class="built_in">next</span> = Node(<span class="number">2</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">3</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">4</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    result = find_middle_of_linked_list(head)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">6</span>)</span><br><span class="line">    result = find_middle_of_linked_list(head)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">7</span>)</span><br><span class="line">    result = find_middle_of_linked_list(head)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>One brute force strategy could be to first count the number of nodes in the LinkedList and then find the middle node in the second iteration. Can we do this in one iteration?</p><p>We can use the <strong>Fast &amp; Slow pointers</strong> method such that the fast pointer is always twice the nodes ahead of the slow pointer. This way, when the fast pointer reaches the end of the LinkedList, the slow pointer will be pointing at the middle node.</p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和我写的一摸一样，这里就不再赘述了</span></span><br></pre></td></tr></table></figure><h4 id="Time-complexity"><a href="#Time-complexity" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The above algorithm will have a time complexity of <strong><em>O(N)</em></strong> where ‘N’ is the number of nodes in the LinkedList.</p><h4 id="Space-complexity"><a href="#Space-complexity" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The algorithm runs in constant space <strong><em>O(1)</em></strong>.</p><h2 id="Problem-Challenge-1"><a href="#Problem-Challenge-1" class="headerlink" title="Problem Challenge 1"></a>Problem Challenge 1</h2><h3 id="Palindrome-LinkedList-medium"><a href="#Palindrome-LinkedList-medium" class="headerlink" title="Palindrome LinkedList (medium)"></a>Palindrome LinkedList (medium)</h3><p>leetcode 234</p><p>Given the head of a <strong>Singly LinkedList</strong>, write a method to check if the <strong>LinkedList is a palindrome</strong> or not.</p><p>Your algorithm should use <strong>constant space</strong> and the input LinkedList should be in the original form once the algorithm is finished. The algorithm should have O(N)<em>O</em>(<em>N</em>) time complexity where ‘N’ is the number of nodes in the LinkedList.</p><p><strong>Example 1:</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">2</span> -&gt; <span class="number">4</span> -&gt; <span class="number">6</span> -&gt; <span class="number">4</span> -&gt; <span class="number">2</span> -&gt; <span class="literal">null</span></span><br><span class="line">Output: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">2</span> -&gt; <span class="number">4</span> -&gt; <span class="number">6</span> -&gt; <span class="number">4</span> -&gt; <span class="number">2</span> -&gt; <span class="number">2</span> -&gt; <span class="literal">null</span></span><br><span class="line">Output: <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-4"><a href="#Try-it-yourself-4" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和solution略微不同 但是有问题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">head</span>):</span></span><br><span class="line">    prev = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">next</span> = head.<span class="built_in">next</span></span><br><span class="line">        head.<span class="built_in">next</span> = prev</span><br><span class="line">        prev = head</span><br><span class="line">        head = <span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> prev</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_palindromic_linked_list</span>(<span class="params">head</span>):</span></span><br><span class="line">    slow, fast = head, head</span><br><span class="line">    <span class="keyword">while</span> fast <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> fast.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        slow = slow.<span class="built_in">next</span></span><br><span class="line">        fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">    head_second_half = reverse(slow)</span><br><span class="line">    copy_head_second_half = head_second_half</span><br><span class="line"><span class="comment"># 这里while略微不同，这样的写法会让直接return False就不会再次reverse 题目需要链表顺序不变，但是leetcode没有这个限制</span></span><br><span class="line">    <span class="keyword">while</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> head_second_half <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> head.value != head_second_half.value:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        head = head.<span class="built_in">next</span></span><br><span class="line">        head_second_half = head_second_half.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    reverse(copy_head_second_half)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    head = Node(<span class="number">2</span>)</span><br><span class="line">    head.<span class="built_in">next</span> = Node(<span class="number">4</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">6</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">4</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    result = is_palindromic_linked_list(head)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">2</span>)</span><br><span class="line">    result = is_palindromic_linked_list(head)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><p>As we know, a palindrome LinkedList will have nodes values that read the same backward or forward. This means that if we divide the LinkedList into two halves, the node values of the first half in the forward direction should be similar to the node values of the second half in the backward direction. As we have been given a Singly LinkedList, we can’t move in the backward direction. To handle this, we will perform the following steps:</p><ol><li>We can use the <strong>Fast &amp; Slow pointers</strong> method similar to <em>Middle of the LinkedList</em> to find the middle node of the LinkedList.</li><li>Once we have the middle of the LinkedList, we will reverse the second half.</li><li>Then, we will compare the first half with the reversed second half to see if the LinkedList represents a palindrome.</li><li>Finally, we will reverse the second half of the LinkedList again to revert and bring the LinkedList back to its original form.</li></ol><h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="keyword">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">        next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PalindromicLinkedList</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// todo:</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到中间节点</span></span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* headSecondHalf = <span class="built_in">reverse</span>(slow);</span><br><span class="line">        ListNode* copyHeadSecondHalf = headSecondHalf;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span> &amp;&amp; headSecondHalf != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head-&gt;value != headSecondHalf-&gt;value) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            headSecondHalf = headSecondHalf-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">reverse</span>(copyHeadSecondHalf);</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || headSecondHalf == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> ListNode* <span class="title">reverse</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* next = head-&gt;next;</span><br><span class="line">            head-&gt;next = prev;</span><br><span class="line">            prev = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">    head-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">4</span>);</span><br><span class="line">    head-&gt;next-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">6</span>);</span><br><span class="line">    head-&gt;next-&gt;next-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">4</span>);</span><br><span class="line">    head-&gt;next-&gt;next-&gt;next-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Middle Node: &quot;</span> &lt;&lt; PalindromicLinkedList::<span class="built_in">isPalindrome</span>(head)</span><br><span class="line">         &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    head-&gt;next-&gt;next-&gt;next-&gt;next-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Middle Node: &quot;</span> &lt;&lt; PalindromicLinkedList::<span class="built_in">isPalindrome</span>(head)</span><br><span class="line">         &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Time-complexity-1"><a href="#Time-complexity-1" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The above algorithm will have a time complexity of <strong><em>O(N)</em></strong> where ‘N’ is the number of nodes in the LinkedList.</p><h4 id="Space-complexity-1"><a href="#Space-complexity-1" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The algorithm runs in constant space <strong><em>O(1)</em></strong>.</p><h2 id="Problem-Challenge-2"><a href="#Problem-Challenge-2" class="headerlink" title="# Problem Challenge 2"></a># Problem Challenge 2</h2><h3 id="Rearrange-a-LinkedList-medium"><a href="#Rearrange-a-LinkedList-medium" class="headerlink" title="Rearrange a LinkedList (medium)"></a>Rearrange a LinkedList (medium)</h3><p>leetcode 143</p><p>Given the head of a Singly LinkedList, write a method to modify the LinkedList such that the <strong>nodes from the second half of the LinkedList are inserted alternately to the nodes from the first half in reverse order</strong>. So if the LinkedList has nodes 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; null, your method should return 1 -&gt; 6 -&gt; 2 -&gt; 5 -&gt; 3 -&gt; 4 -&gt; null.</p><p>Your algorithm should not use any extra space and the input LinkedList should be modified in-place.</p><p><strong>Example 1:</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">2</span> -&gt; <span class="number">4</span> -&gt; <span class="number">6</span> -&gt; <span class="number">8</span> -&gt; <span class="number">10</span> -&gt; <span class="number">12</span> -&gt; <span class="literal">null</span></span><br><span class="line">Output: <span class="number">2</span> -&gt; <span class="number">12</span> -&gt; <span class="number">4</span> -&gt; <span class="number">10</span> -&gt; <span class="number">6</span> -&gt; <span class="number">8</span> -&gt; <span class="literal">null</span> </span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">2</span> -&gt; <span class="number">4</span> -&gt; <span class="number">6</span> -&gt; <span class="number">8</span> -&gt; <span class="number">10</span> -&gt; <span class="literal">null</span></span><br><span class="line">Output: <span class="number">2</span> -&gt; <span class="number">10</span> -&gt; <span class="number">4</span> -&gt; <span class="number">8</span> -&gt; <span class="number">6</span> -&gt; <span class="literal">null</span></span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-5"><a href="#Try-it-yourself-5" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和solution有一点不一样,是自己做错了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_list</span>(<span class="params">self</span>):</span></span><br><span class="line">        temp = self</span><br><span class="line">        <span class="keyword">while</span> temp <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(temp.value) + <span class="string">&quot; &quot;</span> ,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            temp = temp.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">head</span>):</span></span><br><span class="line">    prev = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">next</span> = head.<span class="built_in">next</span></span><br><span class="line">        head.<span class="built_in">next</span> = prev</span><br><span class="line">        prev = head</span><br><span class="line">        head = <span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> prev</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reorder</span>(<span class="params">head</span>):</span></span><br><span class="line">    slow, fast = head, head</span><br><span class="line">    <span class="keyword">while</span> fast <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> fast.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        slow = slow.<span class="built_in">next</span></span><br><span class="line">        fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">    head_second_half = reverse(slow)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> head_second_half <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        temp1 = head.<span class="built_in">next</span></span><br><span class="line">        head.<span class="built_in">next</span> = head_second_half</span><br><span class="line">        head = temp1</span><br><span class="line">        temp2 = head_second_half.<span class="built_in">next</span></span><br><span class="line">        head_second_half.<span class="built_in">next</span> = temp1</span><br><span class="line">        head_second_half = temp2</span><br><span class="line">    <span class="comment"># 这里和solution有一点不一样，但是过了一个测试用例了[1,2,3,4,5]过不了</span></span><br><span class="line">    head.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    head = Node(<span class="number">2</span>)</span><br><span class="line">    head.<span class="built_in">next</span> = Node(<span class="number">4</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">6</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">8</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">10</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">    result = reorder(head)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    head.print_list()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><p>This problem shares similarities with <em>Palindrome LinkedList</em>. To rearrange the given LinkedList we will follow the following steps:</p><ol><li>We can use the <strong>Fast &amp; Slow pointers</strong> method similar to <em>Middle of the LinkedList</em> to find the middle node of the LinkedList.</li><li>Once we have the middle of the LinkedList, we will reverse the second half of the LinkedList.</li><li>Finally, we’ll iterate through the first half and the reversed second half to produce a LinkedList in the required order.</li></ol><h3 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_list</span>(<span class="params">self</span>):</span></span><br><span class="line">        temp = self</span><br><span class="line">        <span class="keyword">while</span> temp <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(temp.value) + <span class="string">&quot; &quot;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            temp = temp.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">head</span>):</span></span><br><span class="line">    prev = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">next</span> = head.<span class="built_in">next</span></span><br><span class="line">        head.<span class="built_in">next</span> = prev</span><br><span class="line">        prev = head</span><br><span class="line">        head = <span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> prev</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reorder</span>(<span class="params">head</span>):</span></span><br><span class="line">    slow, fast = head, head</span><br><span class="line">    <span class="keyword">while</span> fast <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> fast.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        slow = slow.<span class="built_in">next</span></span><br><span class="line">        fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">    head_second_half = reverse(slow)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> head_second_half <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        temp1 = head.<span class="built_in">next</span></span><br><span class="line">        head.<span class="built_in">next</span> = head_second_half</span><br><span class="line">        head = temp1</span><br><span class="line">        temp2 = head_second_half.<span class="built_in">next</span></span><br><span class="line">        head_second_half.<span class="built_in">next</span> = temp1</span><br><span class="line">        head_second_half = temp2</span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        head.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    head = Node(<span class="number">2</span>)</span><br><span class="line">    head.<span class="built_in">next</span> = Node(<span class="number">4</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">6</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">8</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">10</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = Node(<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">    result = reorder(head)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    head.print_list()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-Complexity-3"><a href="#Time-Complexity-3" class="headerlink" title="Time Complexity"></a>Time Complexity</h4><p>The above algorithm will have a time complexity of <strong><em>O(N)</em></strong> where ‘N’ is the number of nodes in the LinkedList.</p><h4 id="Space-Complexity-3"><a href="#Space-Complexity-3" class="headerlink" title="Space Complexity"></a>Space Complexity</h4><p>The algorithm runs in constant space <strong><em>O(1)</em></strong>.</p><h2 id="Problem-Challenge-3"><a href="#Problem-Challenge-3" class="headerlink" title="#Problem Challenge 3"></a>#Problem Challenge 3</h2><h3 id="Cycle-in-a-Circular-Array-hard"><a href="#Cycle-in-a-Circular-Array-hard" class="headerlink" title="Cycle in a Circular Array (hard)"></a>Cycle in a Circular Array (hard)</h3><p>leetcode 457</p><p>We are given an array containing positive and negative numbers. Suppose the array contains a number ‘M’ at a particular index. Now, if ‘M’ is positive we will move forward ‘M’ indices and if ‘M’ is negative move backwards ‘M’ indices. You should assume that the <strong>array is circular</strong> which means two things:</p><ol><li>If, while moving forward, we reach the end of the array, we will jump to the first element to continue the movement.</li><li>If, while moving backward, we reach the beginning of the array, we will jump to the last element to continue the movement.</li></ol><p>Write a method to determine <strong>if the array has a cycle</strong>. The cycle should have more than one element and should follow one direction which means the cycle should not contain both forward and backward movements.</p><p><strong>Example 1:</strong></p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1, 2, -1, 2, 2]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The<span class="built_in"> array </span>has a cycle among indices: 0 -&gt; 1 -&gt; 3 -&gt; 0</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [2, 2, -1, 2]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The<span class="built_in"> array </span>has a cycle among indices: 1 -&gt; 3 -&gt; 1</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [2, 1, -1, -2]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The<span class="built_in"> array </span>does<span class="built_in"> not </span>have any cycle.</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-6"><a href="#Try-it-yourself-6" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不会</span></span><br></pre></td></tr></table></figure><h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h3><p>This problem involves finding a cycle in the array and, as we know, the <strong>Fast &amp; Slow pointer</strong> method is an efficient way to do that. We can start from each index of the array to find the cycle. If a number does not have a cycle we will move forward to the next element. There are a couple of additional things we need to take care of:</p><ol><li>As mentioned in the problem, the cycle should have more than one element. This means that when we move a pointer forward, if the pointer points to the same element after the move, we have a one-element cycle. Therefore, we can finish our cycle search for the current element.</li><li>The other requirement mentioned in the problem is that the cycle should not contain both forward and backward movements. We will handle this by remembering the direction of each element while searching for the cycle. If the number is positive, the direction will be forward and if the number is negative, the direction will be backward. So whenever we move a pointer forward, if there is a change in the direction, we will finish our cycle search right there for the current element.</li></ol><h3 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">circular_array_loop_exists</span>(<span class="params">arr</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">        is_forward = arr[i] &gt;= <span class="number">0</span></span><br><span class="line">        slow, fast = i, i</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            slow = find_next_index(arr, is_forward, slow)</span><br><span class="line">            fast = find_next_index(arr, is_forward, fast)</span><br><span class="line">            <span class="keyword">if</span> fast != -<span class="number">1</span>:</span><br><span class="line">                fast = find_next_index(arr, is_forward, fast)</span><br><span class="line">            <span class="keyword">if</span> slow == -<span class="number">1</span> <span class="keyword">or</span> fast == -<span class="number">1</span> <span class="keyword">or</span> slow == fast:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> slow != -<span class="number">1</span> <span class="keyword">and</span> slow == fast:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_next_index</span>(<span class="params">arr, is_forward, current_index</span>):</span></span><br><span class="line">    direction = arr[current_index] &gt;= <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> is_forward != direction:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    next_index = (current_index + arr[current_index]) % <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">if</span> next_index == current_index:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> next_index</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    result = circular_array_loop_exists([<span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = circular_array_loop_exists([<span class="number">2</span>, <span class="number">2</span>, -<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = circular_array_loop_exists([<span class="number">2</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">2</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-Complexity-4"><a href="#Time-Complexity-4" class="headerlink" title="Time Complexity"></a>Time Complexity</h4><p>The above algorithm will have a time complexity of <strong><em>O(N^2)</em></strong> where ‘N’ is the number of elements in the array. This complexity is due to the fact that we are iterating all elements of the array and trying to find a cycle for each element.</p><h4 id="Space-Complexity-4"><a href="#Space-Complexity-4" class="headerlink" title="Space Complexity"></a>Space Complexity</h4><p>The algorithm runs in constant space <strong><em>O(1)</em></strong>.</p><h4 id="An-Alternate-Approach"><a href="#An-Alternate-Approach" class="headerlink" title="An Alternate Approach"></a>An Alternate Approach</h4><p>In our algorithm, we don’t keep a record of all the numbers that have been evaluated for cycles. We know that all such numbers will not produce a cycle for any other instance as well. If we can remember all the numbers that have been visited, our algorithm will improve to <strong><em>O(N)</em></strong> as, then, each number will be evaluated for cycles only once. We can keep track of this by creating a separate array however the space complexity of our algorithm will increase to <strong><em>O(N)</em></strong>.</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3. Pattern Two Pointers</title>
      <link href="/3-pattern-two-pointers/index.html"/>
      <url>/3-pattern-two-pointers/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In problems where we deal with sorted arrays (or LinkedLists) and need to find <strong>a set of elements</strong> that fulfill certain constraints, the Two Pointers approach becomes quite useful. The set of elements could be a pair, a triplet or even a subarray. For example, take a look at the following problem:</p><blockquote><p>Given an array of sorted numbers and a target sum, find a pair in the array whose sum is equal to the given target.</p></blockquote><p>To solve this problem, we can consider each element one by one (pointed out by the first pointer) and iterate through the remaining elements (pointed out by the second pointer) to find a pair with the given sum. The time complexity of this algorithm will be <strong><em>O(N^2)</em></strong> where ‘N’ is the number of elements in the input array.</p><p>Given that the input array is <strong>sorted</strong>, an efficient way would be to start with one pointer in the beginning and another pointer at the end. At every step, we will see if the numbers pointed by the two pointers add up to the target sum. If they do not, we will do one of two things:</p><ol><li>If the sum of the two numbers pointed by the two pointers is greater than the target sum, this means that we need a pair with a smaller sum. So, to try more pairs, we can decrement the end-pointer.</li><li>If the sum of the two numbers pointed by the two pointers is smaller than the target sum, this means that we need a pair with a larger sum. So, to try more pairs, we can increment the start-pointer.</li></ol><p>Here is the visual representation of this algorithm:</p><p><img src="/3-pattern-two-pointers/index/1.png"></p><p>The time complexity of the above algorithm will be <strong><em>O(N)</em></strong>.</p><p>In the following chapters, we will apply the <strong>Two Pointers</strong> approach to solve a few problems.</p><h2 id="Pair-with-Target-Sum-easy"><a href="#Pair-with-Target-Sum-easy" class="headerlink" title="Pair with Target Sum (easy)"></a>Pair with Target Sum (easy)</h2><p>不在leetcode</p><h3 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given an array of sorted numbers and a target sum, find a <strong>pair in the array whose sum is equal to the given target</strong>.</p><p>Write a function to return the indices of the two numbers (i.e. the pair) such that they add up to the given target.</p><p><strong>Example 1:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>:<span class="meta"> [1, 2, 3, 4, 6], target=6</span></span><br><span class="line"><span class="meta">Output: [1, 3]</span></span><br><span class="line"><span class="attribute">Explanation</span>: The numbers at index <span class="number">1</span> and <span class="number">3</span> add up to <span class="number">6</span>: <span class="number">2</span>+<span class="number">4</span>=<span class="number">6</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>:<span class="meta"> [2, 5, 9, 11], target=11</span></span><br><span class="line"><span class="meta">Output: [0, 2]</span></span><br><span class="line"><span class="attribute">Explanation</span>: The numbers at index <span class="number">0</span> and <span class="number">2</span> add up to <span class="number">11</span>: <span class="number">2</span>+<span class="number">9</span>=<span class="number">11</span></span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself"><a href="#Try-it-yourself" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pari_with_targetsum</span>(<span class="params">arr, target_sum</span>):</span></span><br><span class="line">    p1, p2 = <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> p1 &lt; p2:</span><br><span class="line">        <span class="keyword">if</span> arr[p1] + arr[p2] == target_sum:</span><br><span class="line">            <span class="keyword">return</span> [p1, p2]</span><br><span class="line">        <span class="keyword">elif</span> arr[p1] + arr[p2] &lt; target_sum:</span><br><span class="line">            p1 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p2 -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    result = pari_with_targetsum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>], <span class="number">6</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = pari_with_targetsum([<span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">11</span>], <span class="number">11</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>Since the given array is sorted, a brute-force solution could be to iterate through the array, taking one number at a time and searching for the second number through <strong>Binary Search</strong>. The time complexity of this algorithm will be <strong><em>O(N\</em>logN)*</strong>. Can we do better than this?</p><p>We can follow the <strong>Two Pointers</strong> approach. We will start with one pointer pointing to the beginning of the array and another pointing at the end. At every step, we will see if the numbers pointed by the two pointers add up to the target sum. If they do, we have found our pair; otherwise, we will do one of two things:</p><ol><li>If the sum of the two numbers pointed by the two pointers is greater than the target sum, this means that we need a pair with a smaller sum. So, to try more pairs, we can decrement the end-pointer.</li><li>If the sum of the two numbers pointed by the two pointers is smaller than the target sum, this means that we need a pair with a larger sum. So, to try more pairs, we can increment the start-pointer.</li></ol><p>Here is the visual representation of this algorithm for Example-1:</p><p><img src="/3-pattern-two-pointers/index/2.png"></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">pari_with_targetsum</span><span class="params">(arr, target_sum)</span>:</span></span><br><span class="line"><span class="function">    p1, p2 =</span> <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> p1 &lt; p2:</span><br><span class="line"># 减少计算</span><br><span class="line">        sum = arr[p1] + arr[p2]</span><br><span class="line">        <span class="keyword">if</span> sum == target_sum:</span><br><span class="line">            <span class="keyword">return</span> [p1, p2]</span><br><span class="line">        elif sum &lt; target_sum:</span><br><span class="line">            p1 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p2 -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="built_in">main</span>():</span><br><span class="line">    result = <span class="built_in">pari_with_targetsum</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>], <span class="number">6</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = <span class="built_in">pari_with_targetsum</span>([<span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">11</span>], <span class="number">11</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">main</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-Complexity"><a href="#Time-Complexity" class="headerlink" title="Time Complexity"></a>Time Complexity</h4><p>The time complexity of the above algorithm will be <strong><em>O(N)</em></strong>, where ‘N’ is the total number of elements in the given array.</p><h4 id="Space-Complexity"><a href="#Space-Complexity" class="headerlink" title="Space Complexity"></a>Space Complexity</h4><p>The algorithm runs in constant space <strong><em>O(1)</em></strong>.</p><h3 id="An-Alternate-approach"><a href="#An-Alternate-approach" class="headerlink" title="An Alternate approach"></a>An Alternate approach</h3><p>Instead of using a two-pointer or a binary search approach, we can utilize a <strong>HashTable</strong> to search for the required pair. We can iterate through the array one number at a time. Let’s say during our iteration we are at number ‘X’, so we need to find ‘Y’ such that “<em>X + Y == Target</em>”. We will do two things here:</p><ol><li>Search for ‘Y’ (which is equivalent to “<em>Target - X</em>“ in the <strong>HashTable</strong>. If it is there, we have found the required pair.</li><li>Otherwise, insert “X” in the <strong>HashTable</strong>, so that we can search it for the later numbers.</li></ol><p>Here is what our algorithm will look like:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PairWithTargetSum</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">search</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; str, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// todo:</span></span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; nums;  <span class="comment">// store the num and the index</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums.<span class="built_in">find</span>(target - str[i]) != nums.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">make_pair</span>(nums[target - str[i]], i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[str[i]] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">make_pair</span>(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> result = PairWithTargetSum::<span class="built_in">search</span>(vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>&#125;, <span class="number">6</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Pair with target  sum: [&quot;</span> &lt;&lt; result.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; result.second</span><br><span class="line">         &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; endl;</span><br><span class="line">    result = PairWithTargetSum::<span class="built_in">search</span>(vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">11</span>&#125;, <span class="number">11</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Pair with target  sum: [&quot;</span> &lt;&lt; result.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; result.second</span><br><span class="line">         &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Time-Complexity-1"><a href="#Time-Complexity-1" class="headerlink" title="Time Complexity"></a>Time Complexity</h4><p>The time complexity of the above algorithm will be <strong><em>O(N)</em></strong>, where ‘N’ is the total number of elements in the given array.</p><h4 id="Space-Complexity-1"><a href="#Space-Complexity-1" class="headerlink" title="Space Complexity"></a>Space Complexity</h4><p>The space complexity will also be <strong><em>O(N)</em></strong>, as, in the worst case, we will be pushing ‘N’ numbers in the <strong>HashTable</strong>.</p><h2 id="Remove-Duplicates-easy"><a href="#Remove-Duplicates-easy" class="headerlink" title="Remove Duplicates (easy)"></a>Remove Duplicates (easy)</h2><p>leetcode 26</p><h3 id="Problem-Statement-1"><a href="#Problem-Statement-1" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given an array of sorted numbers, <strong>remove all duplicates</strong> from it. You should <strong>not use any extra space</strong>; after removing the duplicates in-place return the new length of the array.</p><p><strong>Example 1:</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">9</span>]</span><br><span class="line">Output: <span class="number">4</span></span><br><span class="line">Explanation: The <span class="keyword">first</span> <span class="literal">four</span> elements <span class="keyword">after</span> removing <span class="keyword">the</span> duplicates will be [<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>].</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">11</span>]</span><br><span class="line">Output: <span class="number">2</span></span><br><span class="line">Explanation: The <span class="keyword">first</span> <span class="literal">two</span> elements <span class="keyword">after</span> removing <span class="keyword">the</span> duplicates will be [<span class="number">2</span>, <span class="number">11</span>].</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-1"><a href="#Try-it-yourself-1" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_duplicates</span>(<span class="params">arr</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    length = <span class="number">0</span></span><br><span class="line">    now = <span class="number">0</span></span><br><span class="line">    next_new = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> next_new &lt; <span class="built_in">len</span>(arr):</span><br><span class="line">        <span class="keyword">while</span> next_new &lt; <span class="built_in">len</span>(arr) <span class="keyword">and</span> arr[next_new] == arr[now]:</span><br><span class="line">            next_new += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            now = next_new</span><br><span class="line">            next_new += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> length + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    result = remove_duplicates([<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">9</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = remove_duplicates([<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">11</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = remove_duplicates([<span class="number">1</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>In this problem, we need to remove the duplicates in-place such that the resultant length of the array remains sorted. As the input array is sorted, therefore, one way to do this is to shift the elements left whenever we encounter duplicates. In other words, we will keep one pointer for iterating the array and one pointer for placing the next non-duplicate number. So our algorithm will be to iterate the array and whenever we see a non-duplicate number we move it next to the last non-duplicate number we’ve seen.</p><p>Here is the visual representation of this algorithm for Example-1:</p><p><img src="/3-pattern-two-pointers/index/3.png"></p><p><img src="/3-pattern-two-pointers/index/4.png"></p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_duplicates</span>(<span class="params">arr</span>):</span></span><br><span class="line">    end = <span class="number">1</span> <span class="comment"># 这是做替换用的</span></span><br><span class="line">    pointer = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> pointer &lt; <span class="built_in">len</span>(arr):</span><br><span class="line">        <span class="keyword">if</span> arr[pointer] != arr[pointer - <span class="number">1</span>]:</span><br><span class="line">            arr[end] = arr[pointer]</span><br><span class="line">            end += <span class="number">1</span></span><br><span class="line">        pointer += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    result = remove_duplicates([<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">9</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = remove_duplicates([<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">11</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = remove_duplicates([<span class="number">1</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-Complexity-2"><a href="#Time-Complexity-2" class="headerlink" title="Time Complexity"></a>Time Complexity</h4><p>The time complexity of the above algorithm will be O(N)<em>O</em>(<em>N</em>), where ‘N’ is the total number of elements in the given array.</p><h4 id="Space-Complexity-2"><a href="#Space-Complexity-2" class="headerlink" title="Space Complexity"></a>Space Complexity</h4><p>The algorithm runs in constant space O(1)<em>O</em>(1).</p><hr><h3 id="Similar-Questions"><a href="#Similar-Questions" class="headerlink" title="Similar Questions"></a>Similar Questions</h3><p><strong>Problem 1:</strong> Given an unsorted array of numbers and a target ‘key’, remove all instances of ‘key’ in-place and return the new length of the array.</p><p><strong>Example 1:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> [<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">3</span>], <span class="keyword">Key</span>=<span class="number">3</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">Explanation:</span> The first four elements after removing every <span class="comment">&#x27;Key&#x27; will be [2, 6, 10, 9].</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> [<span class="number">2</span>, <span class="number">11</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>], <span class="keyword">Key</span>=<span class="number">2</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="number">2</span></span><br><span class="line"><span class="symbol">Explanation:</span> The first two elements after removing every <span class="comment">&#x27;Key&#x27; will be [11, 1].</span></span><br></pre></td></tr></table></figure><p><strong>Solution:</strong> This problem is quite similar to our parent problem. We can follow a two-pointer approach and shift numbers left upon encountering the ‘key’. Here is what the code will look like:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoveDuplicates</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">remove</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// todo:</span></span><br><span class="line">        <span class="keyword">int</span> nextElement = <span class="number">0</span>;  <span class="comment">// index of the mext element which is not &quot;key&quot;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] != key) &#123;</span><br><span class="line">                arr[nextElement] = arr[i];</span><br><span class="line">                nextElement++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextElement;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; arr = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Array new length: &quot;</span> &lt;&lt; RemoveDuplicates::<span class="built_in">remove</span>(arr, <span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    arr = &#123;<span class="number">2</span>, <span class="number">11</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Array new length: &quot;</span> &lt;&lt; RemoveDuplicates::<span class="built_in">remove</span>(arr, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Time and Space Complexity:</strong> The time complexity of the above algorithm will be <strong><em>O(N)</em></strong>, where ‘N’ is the total number of elements in the given array.</p><p>The algorithm runs in constant space <strong><em>O(1)</em></strong>.</p><h2 id="Squaring-a-Sorted-Array-easy"><a href="#Squaring-a-Sorted-Array-easy" class="headerlink" title="Squaring a Sorted Array (easy)"></a>Squaring a Sorted Array (easy)</h2><p>leetcode 977</p><h3 id="Problem-Statement-2"><a href="#Problem-Statement-2" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given a sorted array, create a new array containing <strong>squares of all the number of the input array</strong> in the sorted order.</p><p><strong>Example 1:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>:<span class="meta"> [-2, -1, 0, 2, 3]</span></span><br><span class="line"><span class="attribute">Output</span>:<span class="meta"> [0, 1, 4, 4, 9]</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>:<span class="meta"> [-3, -1, 0, 1, 2]</span></span><br><span class="line"><span class="attribute">Output</span>:<span class="meta"> [0 1 1 4 9]</span></span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-2"><a href="#Try-it-yourself-2" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_squares</span>(<span class="params">arr</span>):</span></span><br><span class="line">    res = [<span class="number">0</span>] * <span class="built_in">len</span>(arr)</span><br><span class="line">    pointer1, pointer2 = <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">pow</span>(arr[pointer1], <span class="number">2</span>) &lt; <span class="built_in">pow</span>(arr[pointer2], <span class="number">2</span>):</span><br><span class="line">            res[i] = <span class="built_in">pow</span>(arr[pointer2], <span class="number">2</span>)</span><br><span class="line">            pointer2 -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res[i] = <span class="built_in">pow</span>(arr[pointer1], <span class="number">2</span>)</span><br><span class="line">            pointer1 += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    result = make_squares([-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = make_squares([-<span class="number">3</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>This is a straightforward question. The only trick is that we can have negative numbers in the input array, which will make it a bit difficult to generate the output array with squares in sorted order.</p><p>An easier approach could be to first find the index of the first non-negative number in the array. After that, we can use <strong>Two Pointers</strong> to iterate the array. One pointer will move forward to iterate the non-negative numbers and the other pointer will move backward to iterate the negative numbers. At any step, whichever number gives us a bigger square will be added to the output array. For the above-mentioned Example-1, we will do something like this:</p><p><img src="/3-pattern-two-pointers/index/5.png"></p><p>Since the numbers at both the ends can give us the largest square, an alternate approach could be to use two pointers starting at both the ends of the input array. At any step, whichever pointer gives us the bigger square we add it to the result array and move to the next/previous number according to the pointer. For the above-mentioned Example-1, we will do something like this:</p><p><img src="/3-pattern-two-pointers/index/6.png"></p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_squares</span>(<span class="params">arr</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    res = [<span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    pointer1, pointer2 = <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    highestSquarIdx = n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> pointer1 &lt;= pointer2:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">pow</span>(arr[pointer1], <span class="number">2</span>) &lt; <span class="built_in">pow</span>(arr[pointer2], <span class="number">2</span>):</span><br><span class="line">            res[highestSquarIdx] = <span class="built_in">pow</span>(arr[pointer2], <span class="number">2</span>)</span><br><span class="line">            pointer2 -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res[highestSquarIdx] = <span class="built_in">pow</span>(arr[pointer1], <span class="number">2</span>)</span><br><span class="line">            pointer1 += <span class="number">1</span></span><br><span class="line">        highestSquarIdx -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    result = make_squares([-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = make_squares([-<span class="number">3</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity"><a href="#Time-complexity" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of the above algorithm will be <strong><em>O(N)</em></strong> as we are iterating the input array only once.</p><h4 id="Space-complexity"><a href="#Space-complexity" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity of the above algorithm will also be <strong><em>O(N)</em></strong>; this space will be used for the output array.</p><h2 id="Triplet-Sum-to-Zero-medium"><a href="#Triplet-Sum-to-Zero-medium" class="headerlink" title="*Triplet Sum to Zero (medium)"></a>*Triplet Sum to Zero (medium)</h2><p>leetcode 15</p><h3 id="Problem-Statement-3"><a href="#Problem-Statement-3" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given an array of unsorted numbers, find all <strong>unique triplets in it that add up to zero</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="comment">[-3, 0, 1, 2, -1, 1, -2]</span></span><br><span class="line">Output: <span class="comment">[-3, 1, 2]</span>, <span class="comment">[-2, 0, 2]</span>, <span class="comment">[-2, 1, 1]</span>, <span class="comment">[-1, 0, 1]</span></span><br><span class="line">Explanation: There <span class="keyword">are</span> four unique triplets whose sum <span class="keyword">is</span> equal to zero.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="comment">[-5, 2, -1, -2, 3]</span></span><br><span class="line">Output: <span class="comment">[<span class="comment">[-5, 2, 3]</span>, <span class="comment">[-2, -1, 3]</span>]</span></span><br><span class="line">Explanation: There <span class="keyword">are</span> two unique triplets whose sum <span class="keyword">is</span> equal to zero.</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-3"><a href="#Try-it-yourself-3" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_triples</span>(<span class="params">arr</span>):</span></span><br><span class="line">    arr.sort()</span><br><span class="line">    triples = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">        <span class="comment"># 去重</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> arr[i] == arr[i - <span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        search_pair(arr, -arr[i], i + <span class="number">1</span>, triples)</span><br><span class="line">    <span class="keyword">return</span> triples</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_pair</span>(<span class="params">arr, target_sum, left, triples</span>):</span></span><br><span class="line">    right = <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        current_sum = arr[left] + arr[right]</span><br><span class="line">        <span class="comment"># 这个可以修改的更好一点，看solution</span></span><br><span class="line">        <span class="keyword">if</span> current_sum &lt; target_sum:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> current_sum &gt; target_sum:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            triples.append([-target_sum, arr[left], arr[right]])</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    result = search_triples([-<span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">2</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = search_triples([-<span class="number">5</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <strong>Two Pointers</strong> pattern and shares similarities with <em>Pair with Target Sum</em>. A couple of differences are that the input array is not sorted and instead of a pair we need to find triplets with a target sum of zero.</p><p>To follow a similar approach, first, we will sort the array and then iterate through it taking one number at a time. Let’s say during our iteration we are at number ‘X’, so we need to find ‘Y’ and ‘Z’ such that <em>X + Y + Z == 0</em>. At this stage, our problem translates into finding a pair whose sum is equal to “<em>-X</em>” (as from the above equation <em>Y + Z == -X</em>).</p><p>Another difference from <em>Pair with Target Sum</em> is that we need to find all the unique triplets. To handle this, we have to skip any duplicate number. Since we will be sorting the array, so all the duplicate numbers will be next to each other and are easier to skip.</p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_triples</span>(<span class="params">arr</span>):</span></span><br><span class="line">    arr.sort()</span><br><span class="line">    triples = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">        search_pair(arr, -arr[i], i + <span class="number">1</span>, triples)</span><br><span class="line">    <span class="keyword">return</span> triples</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_pair</span>(<span class="params">arr, target_sum, left, triples</span>):</span></span><br><span class="line">    right = <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        current_sum = arr[left] + arr[right]</span><br><span class="line">        <span class="keyword">if</span> current_sum &lt; target_sum:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> current_sum &gt; target_sum:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            triples.append([-target_sum, arr[left], arr[right]])</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> arr[left] == arr[left - <span class="number">1</span>]:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> arr[right] == arr[right + <span class="number">1</span>]:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    result = search_triples([-<span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">2</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = search_triples([-<span class="number">5</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-1"><a href="#Time-complexity-1" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>Sorting the array will take <strong><em>O(N \</em> logN)*</strong>. The <code>searchPair()</code> function will take <strong><em>O(N)</em></strong>. As we are calling <code>searchPair()</code> for every number in the input array, this means that overall <code>searchTriplets()</code> will take <strong><em>O(N \</em> logN + N^2)*</strong>, which is asymptotically equivalent to <strong><em>O(N^2)</em></strong>.</p><h4 id="Space-complexity-1"><a href="#Space-complexity-1" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>Ignoring the space required for the output array, the space complexity of the above algorithm will be O(N)<em>O</em>(<em>N</em>) which is required for sorting.</p><h2 id="Triplet-Sum-Close-to-Target-medium"><a href="#Triplet-Sum-Close-to-Target-medium" class="headerlink" title="Triplet Sum Close to Target (medium)"></a>Triplet Sum Close to Target (medium)</h2><p>不在leecode</p><h3 id="Problem-Statement-4"><a href="#Problem-Statement-4" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given an array of unsorted numbers and a target number, find a <strong>triplet in the array whose sum is as close to the target number as possible</strong>, return the sum of the triplet. If there are more than one such triplet, return the sum of the triplet with the smallest sum.</p><p><strong>Example 1:</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">-2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], target=<span class="number">2</span></span><br><span class="line">Output: <span class="number">1</span></span><br><span class="line">Explanation: The triplet [<span class="number">-2</span>, <span class="number">1</span>, <span class="number">2</span>] has <span class="keyword">the</span> closest <span class="built_in">sum</span> <span class="built_in">to</span> <span class="keyword">the</span> target.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">-3</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>], target=<span class="number">1</span></span><br><span class="line">Output: <span class="number">0</span></span><br><span class="line">Explanation: The triplet [<span class="number">-3</span>, <span class="number">1</span>, <span class="number">2</span>] has <span class="keyword">the</span> closest <span class="built_in">sum</span> <span class="built_in">to</span> <span class="keyword">the</span> target.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>], target=<span class="number">100</span></span><br><span class="line">Output: <span class="number">3</span></span><br><span class="line">Explanation: The triplet [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>] has <span class="keyword">the</span> closest <span class="built_in">sum</span> <span class="built_in">to</span> <span class="keyword">the</span> target.</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-4"><a href="#Try-it-yourself-4" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_triples</span>(<span class="params">arr, target</span>):</span></span><br><span class="line">    arr.sort()</span><br><span class="line">    closest_sum = <span class="number">0</span></span><br><span class="line">    diff = math.inf</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr) - <span class="number">2</span>):</span><br><span class="line">        left, right = i + <span class="number">1</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            local_sum = arr[i] + arr[left] + arr[right]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(local_sum - target) &lt; diff:</span><br><span class="line">                closest_sum = local_sum</span><br><span class="line">                diff = <span class="built_in">abs</span>(local_sum - target)</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">abs</span>(local_sum - target) == diff:</span><br><span class="line">                closest_sum = <span class="built_in">min</span>(closest_sum, local_sum)</span><br><span class="line">            <span class="keyword">if</span> local_sum &lt; target:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> local_sum &gt; target:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> local_sum</span><br><span class="line">    <span class="keyword">return</span> closest_sum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    result = search_triples([-<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = search_triples([-<span class="number">3</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>], <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = search_triples([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>], <span class="number">100</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <strong>Two Pointers</strong> pattern and is quite similar to <em>Triplet Sum to Zero</em>.</p><p>We can follow a similar approach to iterate through the array, taking one number at a time. At every step, we will save the difference between the triplet and the target number, so that in the end, we can return the triplet with the closest sum.</p><h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和我的一样，不在赘述</span></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-2"><a href="#Time-complexity-2" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>Sorting the array will take <strong><em>O(N\</em> logN)*</strong>. Overall <code>searchTriplet()</code> will take <strong><em>O(N \</em> logN + N^2)*</strong>, which is asymptotically equivalent to <strong><em>O(N^2)</em></strong>.</p><h4 id="Space-complexity-2"><a href="#Space-complexity-2" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity of the above algorithm will be <strong><em>O(N)</em></strong> which is required for sorting.</p><h2 id="Triplets-with-Smaller-Sum-medium"><a href="#Triplets-with-Smaller-Sum-medium" class="headerlink" title="Triplets with Smaller Sum (medium)"></a>Triplets with Smaller Sum (medium)</h2><p>不在leetcode</p><h3 id="Problem-Statement-5"><a href="#Problem-Statement-5" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given an array <code>arr</code> of unsorted numbers and a target sum, <strong>count all triplets</strong> in it such that <strong><code>arr[i] + arr[j] + arr[k] &lt; target</code></strong> where <code>i</code>, <code>j</code>, and <code>k</code> are three different indices. Write a function to return the count of such triplets.</p><p><strong>Example 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="comment">[-1, 0, 2, 3]</span>, target=3 </span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There <span class="keyword">are</span> two triplets whose sum <span class="keyword">is</span> less than the target: <span class="comment">[-1, 0, 3]</span>, <span class="comment">[-1, 0, 2]</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="comment">[-1, 4, 2, 1, 3]</span>, target=5 </span><br><span class="line">Output: 4</span><br><span class="line">Explanation: There <span class="keyword">are</span> four triplets whose sum <span class="keyword">is</span> less than the target: </span><br><span class="line">   <span class="comment">[-1, 1, 4]</span>, <span class="comment">[-1, 1, 3]</span>, <span class="comment">[-1, 1, 2]</span>, <span class="comment">[-1, 2, 3]</span></span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-5"><a href="#Try-it-yourself-5" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">triplets_with_smaller_sum</span>(<span class="params">arr, target</span>):</span></span><br><span class="line">    arr.sort()</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr) - <span class="number">2</span>):</span><br><span class="line">        count += search_pair(arr, target - arr[i], i + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_pair</span>(<span class="params">arr, target, left</span>):</span></span><br><span class="line">    right = <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">if</span> arr[left] + arr[right] &lt; target:</span><br><span class="line">            count += right - left</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    result = triplets_with_smaller_sum([-<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = triplets_with_smaller_sum([-<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>], <span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <strong>Two Pointers</strong> pattern and shares similarities with <em>Triplet Sum to Zero</em>. The only difference is that, in this problem, we need to find the triplets whose sum is less than the given target. To meet the condition <code>i != j != k</code> we need to make sure that each number is not used more than once.</p><p>Following a similar approach, first we can sort the array and then iterate through it, taking one number at a time. Let’s say during our iteration we are at number ‘X’, so we need to find ‘Y’ and ‘Z’ such that <em>X + Y + Z &lt; target</em>. At this stage, our problem translates into finding a pair whose sum is less than “$ target - X$” (as from the above equation <em>Y + Z == target - X</em>). We can use a similar approach as discussed in <em>Triplet Sum to Zero</em>.</p><h3 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上面的就是看了solution之后才写出来的，所以这里就不在重新写了</span></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-3"><a href="#Time-complexity-3" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>Sorting the array will take <strong>O(N * logN)</strong>. The <code>searchPair()</code> will take O(N)<em>O</em>(<em>N</em>). So, overall <code>searchTriplets()</code> will take <strong>O(N * logN + N^2)</strong>, which is <em>asymptotically</em> equivalent to <strong><em>O(N^2)</em></strong>.</p><h4 id="Space-complexity-3"><a href="#Space-complexity-3" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>Ignoring the space required for the output array, the space complexity of the above algorithm will be <strong><em>O(N)</em></strong> which is required for sorting if we are not using an in-place sorting algorithm.</p><h3 id="Similar-Problems"><a href="#Similar-Problems" class="headerlink" title="Similar Problems"></a>Similar Problems</h3><p><strong>Problem:</strong> Write a function to return the list of all such triplets instead of the count. How will the time complexity change in this case?</p><p><strong>Solution:</strong> Following a similar approach we can create a list containing all the triplets. Here is the code - only the highlighted lines have changed:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无非就是吧符合条件的加到list中去，这里就不再演示了</span></span><br></pre></td></tr></table></figure><p>Another simpler approach could be to check every triplet of the array with three nested loops and create a list of triplets that meet the required condition.</p><h4 id="Time-complexity-4"><a href="#Time-complexity-4" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>Sorting the array will take <strong><em>O(N \</em> logN)*</strong>. The <code>searchPair()</code>, in this case, will take <strong><em>O(N^2)</em></strong>; the main <code>while</code> loop will run in <strong><em>O(N)</em></strong> but the nested <code>for</code> loop can also take O(N)<em>O</em>(<em>N</em>) - this will happen when the target sum is bigger than every triplet in the array.</p><p>So, overall <code>searchTriplets()</code> will take <strong><em>O(N </em> logN + N^3)*</strong>, which is asymptotically equivalent to <strong><em>O(N^3)</em></strong>.</p><h4 id="Space-complexity-4"><a href="#Space-complexity-4" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>Ignoring the space required for the output array, the space complexity of the above algorithm will be <strong><em>O(N)</em></strong> which is required for sorting.</p><h2 id="Dutch-National-Flag-Problem-medium"><a href="#Dutch-National-Flag-Problem-medium" class="headerlink" title="*Dutch National Flag Problem (medium)"></a>*Dutch National Flag Problem (medium)</h2><p>leetcode 75</p><p>Problem Statement</p><p>Given an array containing 0s, 1s and 2s, sort the array in-place. You should treat numbers of the array as objects, hence, we can’t count 0s, 1s, and 2s to recreate the array.</p><p>The flag of the Netherlands consists of three colors: red, white and blue; and since our input array also consists of three different numbers that is why it is called <a href="https://en.wikipedia.org/wiki/Dutch_national_flag_problem">Dutch National Flag problem</a>.</p><p><strong>Example 1:</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="string">[1, 0, 2, 1, 0]</span></span><br><span class="line">Output: <span class="string">[0 0 1 1 2]</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2, 2, 0, 1, 2, 0]</span><br><span class="line">Output: [0<span class="number"> 0 </span>1<span class="number"> 2 </span>2<span class="number"> 2 </span>]</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-6"><a href="#Try-it-yourself-6" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dutch_flag</span>(<span class="params">arr</span>):</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= right:</span><br><span class="line">        <span class="keyword">if</span> arr[i] == <span class="number">0</span>:</span><br><span class="line">            arr[left], arr[i] = arr[i], arr[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            <span class="comment">#  I think more accurate, The groups that girikuncoro mentioned are nums[0 : red - 1] = 0, nums[red : white - 1] = 1, nums[white : blue] = unclassified, nums[blue + 1: n - 1] = 2. red, and blue are exclusively</span></span><br><span class="line">            <span class="comment"># 这里的i += 1之前不太理解</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> arr[i] == <span class="number">2</span>:</span><br><span class="line">            arr[right], arr[i] = arr[i], arr[right]</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    result = dutch_flag([<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = dutch_flag([<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h3><p>The brute force solution will be to use an in-place sorting algorithm like <a href="https://en.wikipedia.org/wiki/Heapsort">Heapsort</a> which will take <strong><em>O(N</em>logN)*</strong>. Can we do better than this? Is it possible to sort the array in one iteration?</p><p>We can use a <strong>Two Pointers</strong> approach while iterating through the array. Let’s say the two pointers are called <code>low</code> and <code>high</code> which are pointing to the first and the last element of the array respectively. So while iterating, we will move all 0s before <code>low</code> and all 2s after <code>high</code> so that in the end, all 1s will be between <code>low</code> and <code>high</code>.</p><h3 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和我写的一样，这里就不在赘述</span></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-5"><a href="#Time-complexity-5" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of the above algorithm will be <strong><em>O(N)</em></strong> as we are iterating the input array only once.</p><h4 id="Space-complexity-5"><a href="#Space-complexity-5" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The algorithm runs in constant space <strong><em>O(1)</em></strong>.</p><h2 id="Problem-Challenge-1"><a href="#Problem-Challenge-1" class="headerlink" title="Problem Challenge 1"></a>Problem Challenge 1</h2><h3 id="Quadruple-Sum-to-Target-medium"><a href="#Quadruple-Sum-to-Target-medium" class="headerlink" title="Quadruple Sum to Target (medium)"></a>Quadruple Sum to Target (medium)</h3><p>Given an array of unsorted numbers and a target number, find all <strong>unique quadruplets</strong> in it, whose <strong>sum is equal to the target number</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [4, 1, 2, -1, 1, -3], <span class="attribute">target</span>=1</span><br><span class="line">Output: [-3, -1, 1, 4], [-3, 1, 1, 2]</span><br><span class="line">Explanation: Both the quadruplets <span class="builtin-name">add</span> up <span class="keyword">to</span> the target.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [2, 0, -1, 1, -2, 2], <span class="attribute">target</span>=2</span><br><span class="line">Output: [-2, 0, 2, 2], [-1, 0, 1, 2]</span><br><span class="line">Explanation: Both the quadruplets <span class="builtin-name">add</span> up <span class="keyword">to</span> the target.</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-7"><a href="#Try-it-yourself-7" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">search_quadruplets</span><span class="params">(arr, target)</span>:</span></span><br><span class="line"><span class="function">    arr.sort()</span></span><br><span class="line"><span class="function">    quadruplets =</span> []</span><br><span class="line">    <span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(len(arr) - <span class="number">3</span>)</span>:</span></span><br><span class="line"><span class="function">        # skip same element to avoid duplicate quadruplets</span></span><br><span class="line"><span class="function">        if i &gt; <span class="number">0</span> and arr[i] =</span>= arr[i - <span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">for</span> j in <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(arr) - <span class="number">2</span>):</span><br><span class="line">            <span class="meta"># skip same element to avoid duplicate quadruplets</span></span><br><span class="line">            <span class="keyword">if</span> j &gt; i + <span class="number">1</span> <span class="keyword">and</span> arr[j] == arr[j - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="built_in">search_pair</span>(arr, target, i, j, quadruplets)</span><br><span class="line">    <span class="keyword">return</span> quadruplets</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="built_in">search_pair</span>(arr, target, first, second, quadruplets):</span><br><span class="line">    left, right = second + <span class="number">1</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        local_sum = arr[first] + arr[second] + arr[left] + arr[right]</span><br><span class="line">        <span class="keyword">if</span> local_sum &lt; target:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        elif local_sum &gt; target:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            quadruplets.<span class="built_in">append</span>([arr[first], arr[second], arr[left], arr[right]])</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> arr[left] == arr[left - <span class="number">1</span>]:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> arr[right] == arr[right + <span class="number">1</span>]:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> quadruplets</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="built_in">main</span>():</span><br><span class="line">    result = <span class="built_in">search_quadruplets</span>([<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-3</span>], <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = <span class="built_in">search_quadruplets</span>([<span class="number">2</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-2</span>, <span class="number">2</span>], <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">main</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <strong>Two Pointers</strong> pattern and shares similarities with <em>Triplet Sum to Zero</em>（哈哈，答案也是参考了这道题）.</p><p>We can follow a similar approach to iterate through the array, taking one number at a time. At every step during the iteration, we will search for the quadruplets similar to <em>Triplet Sum to Zero</em> whose sum is equal to the given target.</p><h3 id="Code-7"><a href="#Code-7" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和我写的一样，这里就不在赘述</span></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-6"><a href="#Time-complexity-6" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>Sorting the array will take <strong><em>O(NlogN)</em></strong>. Overall <code>searchQuadruplets()</code> will take <strong><em>O(N \</em> logN + N^3)*</strong>, which is asymptotically equivalent to <strong><em>O(N^3)</em></strong>.</p><h4 id="Space-complexity-6"><a href="#Space-complexity-6" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The space complexity of the above algorithm will be <strong><em>O(N)</em></strong> which is required for sorting.</p><h2 id="Problem-Challenge-2"><a href="#Problem-Challenge-2" class="headerlink" title="# Problem Challenge 2"></a># Problem Challenge 2</h2><p>leetcode 844 和leetcode 有点不一样比如这个例子(“ab##”, “c#d#”)</p><p>还有leetcode125 也是比较类似的变体</p><h3 id="Comparing-Strings-containing-Backspaces-medium"><a href="#Comparing-Strings-containing-Backspaces-medium" class="headerlink" title="Comparing Strings containing Backspaces (medium)"></a>Comparing Strings containing Backspaces (medium)</h3><p>Given two strings containing backspaces (identified by the character ‘#’), check if the two strings are equal.</p><p><strong>Example 1:</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="attribute">str1</span>=<span class="string">&quot;xy#z&quot;</span>, <span class="attribute">str2</span>=<span class="string">&quot;xzz#&quot;</span></span><br><span class="line">Output: <span class="literal">true</span></span><br><span class="line">Explanation: After applying backspaces the strings become <span class="string">&quot;xz&quot;</span> <span class="keyword">and</span> <span class="string">&quot;xz&quot;</span> respectively.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="attribute">str1</span>=<span class="string">&quot;xy#z&quot;</span>, <span class="attribute">str2</span>=<span class="string">&quot;xyz#&quot;</span></span><br><span class="line">Output: <span class="literal">false</span></span><br><span class="line">Explanation: After applying backspaces the strings become <span class="string">&quot;xz&quot;</span> <span class="keyword">and</span> <span class="string">&quot;xy&quot;</span> respectively.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: str1=<span class="string">&quot;xp#&quot;</span>, str2=<span class="string">&quot;xyz##&quot;</span></span><br><span class="line">Output: <span class="literal">true</span></span><br><span class="line">Explanation: After applying backspaces <span class="keyword">the</span> strings become <span class="string">&quot;x&quot;</span> <span class="keyword">and</span> <span class="string">&quot;x&quot;</span> respectively.</span><br><span class="line">In <span class="string">&quot;xyz##&quot;</span>, <span class="keyword">the</span> <span class="keyword">first</span> <span class="string">&#x27;#&#x27;</span> removes <span class="keyword">the</span> <span class="keyword">character</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">and</span> <span class="keyword">the</span> <span class="keyword">second</span> <span class="string">&#x27;#&#x27;</span> removes <span class="keyword">the</span> <span class="keyword">character</span> <span class="string">&#x27;y&#x27;</span>.</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="attribute">str1</span>=<span class="string">&quot;xywrrmp&quot;</span>, <span class="attribute">str2</span>=<span class="string">&quot;xywrrmu#p&quot;</span></span><br><span class="line">Output: <span class="literal">true</span></span><br><span class="line">Explanation: After applying backspaces the strings become <span class="string">&quot;xywrrmp&quot;</span> <span class="keyword">and</span> <span class="string">&quot;xywrrmp&quot;</span> respectively.</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-8"><a href="#Try-it-yourself-8" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不会</span></span><br></pre></td></tr></table></figure><h3 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h3><p>To compare the given strings, first, we need to apply the backspaces. An efficient way to do this would be from the end of both the strings. We can have separate pointers, pointing to the last element of the given strings. We can start comparing the characters pointed out by both the pointers to see if the strings are equal. If, at any stage, the character pointed out by any of the pointers is a backspace (’#’), we will skip and apply the backspace until we have a valid character available for comparison.</p><h3 id="Code-8"><a href="#Code-8" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backspace_compare</span>(<span class="params">str1, str2</span>):</span></span><br><span class="line">    index1 = <span class="built_in">len</span>(str1) - <span class="number">1</span></span><br><span class="line">    index2 = <span class="built_in">len</span>(str2) - <span class="number">1</span></span><br><span class="line">    <span class="comment"># 注意这里是or (&quot;bbbextm&quot;, &quot;bbb#extm&quot;)</span></span><br><span class="line">    <span class="keyword">while</span> index1 &gt; <span class="number">0</span> <span class="keyword">or</span> index2 &gt; <span class="number">0</span>:</span><br><span class="line">        i1 = get_next_valid_index(str1, index1)</span><br><span class="line">        i2 = get_next_valid_index(str2, index2)</span><br><span class="line">        <span class="comment"># 这个if是对于这个例子(&quot;ab##&quot;, &quot;c#d#&quot;)</span></span><br><span class="line">        <span class="keyword">if</span> i1 == -<span class="number">1</span> <span class="keyword">and</span> i2 == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> i1 &lt; <span class="number">0</span> <span class="keyword">and</span> i2 &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> i1 &lt; <span class="number">0</span> <span class="keyword">or</span> i2 &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> str1[i1] != str2[i2]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        index1 = i1 - <span class="number">1</span></span><br><span class="line">        index2 = i2 - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_next_valid_index</span>(<span class="params"><span class="built_in">str</span>, index</span>):</span></span><br><span class="line">    backspace_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> index &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">str</span>[index] == <span class="string">&quot;#&quot;</span>:</span><br><span class="line">            backspace_count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> backspace_count &gt; <span class="number">0</span>:</span><br><span class="line">            backspace_count -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        index -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> index</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    result = backspace_compare(<span class="string">&quot;xy#z&quot;</span>, <span class="string">&quot;xzz#&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = backspace_compare(<span class="string">&quot;xy#z&quot;</span>, <span class="string">&quot;xyz#&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = backspace_compare(<span class="string">&quot;xp#&quot;</span>, <span class="string">&quot;xyz##&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = backspace_compare(<span class="string">&quot;xywrrmp&quot;</span>, <span class="string">&quot;xywrrmu#p&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;leetcode:&quot;</span>)</span><br><span class="line">    result = backspace_compare(<span class="string">&quot;ab##&quot;</span>, <span class="string">&quot;c#d#&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = backspace_compare(<span class="string">&quot;a#c&quot;</span>, <span class="string">&quot;b&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = backspace_compare(<span class="string">&quot;bbbextm&quot;</span>, <span class="string">&quot;bbb#extm&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-7"><a href="#Time-complexity-7" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of the above algorithm will be <strong><em>O(M+N)</em></strong> where ‘M’ and ‘N’ are the lengths of the two input strings respectively.</p><h4 id="Space-complexity-7"><a href="#Space-complexity-7" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The algorithm runs in constant space <strong><em>O(1)</em></strong>.</p><h2 id="Problem-Challenge-3"><a href="#Problem-Challenge-3" class="headerlink" title="*Problem Challenge 3"></a>*Problem Challenge 3</h2><p>leetcode 581</p><h3 id="Minimum-Window-Sort-medium"><a href="#Minimum-Window-Sort-medium" class="headerlink" title="Minimum Window Sort (medium)"></a>Minimum Window Sort (medium)</h3><p>Given an array, find the length of the smallest subarray in it which when sorted will sort the whole array.</p><p><strong>Example 1:</strong></p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1, 2, 5, 3, 7, 10, 9, 12]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: We need to sort only the subarray [5, 3, 7, 10, 9] to make the whole<span class="built_in"> array </span>sorted</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1, 3, 2, 0, -1, 7, 10]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: We need to sort only the subarray [1, 3, 2, 0, -1] to make the whole<span class="built_in"> array </span>sorted</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1, 2, 3]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The<span class="built_in"> array </span>is already sorted</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [3, 2, 1]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The whole<span class="built_in"> array </span>needs to be sorted.</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-9"><a href="#Try-it-yourself-9" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不会</span></span><br></pre></td></tr></table></figure><h3 id="Solution-9"><a href="#Solution-9" class="headerlink" title="Solution"></a>Solution</h3><p>As we know, once an array is sorted (in ascending order), the smallest number is at the beginning and the largest number is at the end of the array. So if we start from the beginning of the array to find the first element which is out of sorting order i.e., which is smaller than its previous element, and similarly from the end of array to find the first element which is bigger than its previous element, will sorting the subarray between these two numbers result in the whole array being sorted?</p><p>Let’s try to understand this with Example-2 mentioned above. In the following array, what are the first numbers out of sorting order from the beginning and the end of the array:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">7</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><ol><li>Starting from the beginning of the array the first number out of the sorting order is ‘2’ as it is smaller than its previous element which is ‘3’.</li><li>Starting from the end of the array the first number out of the sorting order is ‘0’ as it is bigger than its previous element which is ‘-1’</li></ol><p>As you can see, sorting the numbers between ‘3’ and ‘-1’ will not sort the whole array. To see this, the following will be our original array after the sorted subarray:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>The problem here is that the smallest number of our subarray is ‘-1’ which dictates that we need to include more numbers from the beginning of the array to make the whole array sorted. We will have a similar problem if the maximum of the subarray is bigger than some elements at the end of the array. To sort the whole array we need to include all such elements that are smaller than the biggest element of the subarray. So our final algorithm will look like:</p><ol><li>From the beginning and end of the array, find the first elements that are out of the sorting order. The two elements will be our candidate subarray.</li><li>Find the maximum and minimum of this subarray.</li><li>Extend the subarray from beginning to include any number which is bigger than the minimum of the subarray.</li><li>Similarly, extend the subarray from the end to include any number which is smaller than the maximum of the subarray.</li></ol><h3 id="Code-9"><a href="#Code-9" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortest_window_sort</span>(<span class="params">arr</span>):</span></span><br><span class="line">    low, high = <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> low &lt; <span class="built_in">len</span>(arr) - <span class="number">1</span> <span class="keyword">and</span> arr[low] &lt;= arr[low + <span class="number">1</span>]:</span><br><span class="line">        low += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> low == <span class="built_in">len</span>(arr) - <span class="number">1</span>:  <span class="comment"># already sorted</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> high &gt; <span class="number">0</span> <span class="keyword">and</span> arr[high] &gt;= arr[high - <span class="number">1</span>]:</span><br><span class="line">        high -= <span class="number">1</span></span><br><span class="line">    subarray_max = -math.inf</span><br><span class="line">    subarray_min = math.inf</span><br><span class="line">    <span class="comment"># subarray_max = -float(&#x27;inf&#x27;) 也可以</span></span><br><span class="line">    <span class="comment"># subarray_min = float(&#x27;inf&#x27;)</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(low, high + <span class="number">1</span>):</span><br><span class="line">        subarray_min = <span class="built_in">min</span>(subarray_min, arr[k])</span><br><span class="line">        subarray_max = <span class="built_in">max</span>(subarray_max, arr[k])</span><br><span class="line">    <span class="keyword">while</span> low &gt; <span class="number">0</span> <span class="keyword">and</span> arr[low - <span class="number">1</span>] &gt; subarray_min:</span><br><span class="line">        low -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> high &lt; <span class="built_in">len</span>(arr) - <span class="number">1</span> <span class="keyword">and</span> arr[high + <span class="number">1</span>] &lt; subarray_max:</span><br><span class="line">        high += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> high - low + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    result = shortest_window_sort([<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">12</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = shortest_window_sort([<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">7</span>, <span class="number">10</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = shortest_window_sort([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = shortest_window_sort([<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-complexity-8"><a href="#Time-complexity-8" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>The time complexity of the above algorithm will be <strong><em>O(N)</em></strong>.</p><h4 id="Space-complexity-8"><a href="#Space-complexity-8" class="headerlink" title="Space complexity"></a>Space complexity</h4><p>The algorithm runs in constant space <strong><em>O(1)</em></strong>.</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2. Pattern Sliding Window</title>
      <link href="/2-pattern-sliding-window/index.html"/>
      <url>/2-pattern-sliding-window/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In many problems dealing with an array (or a LinkedList), we are asked to find or calculate something among all the contiguous subarrays (or sublists) of a given size. For example, take a look at this problem:</p><blockquote><p>Given an array, find the average of all contiguous subarrays of size ‘K’ in it.</p></blockquote><p>Let’s understand this problem with a real input:</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span><span class="operator">:</span> <span class="punctuation">[</span><span class="number">1</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">6</span><span class="operator">,</span> <span class="operator">-</span><span class="number">1</span><span class="operator">,</span> <span class="number">4</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">8</span><span class="operator">,</span> <span class="number">2</span><span class="punctuation">]</span><span class="operator">,</span> <span class="built_in">K</span><span class="operator">=</span><span class="number">5</span></span><br></pre></td></tr></table></figure><p>Here, we are asked to find the average of all contiguous subarrays of size ‘5’ in the given array. Let’s solve this:</p><ol><li>For the first 5 numbers (subarray from index 0-4), the average is: (1+3+2+6-1)/5 =&gt; 2.2(1+3+2+6−1)/5=&gt;2.2</li><li>The average of next 5 numbers (subarray from index 1-5) is: (3+2+6-1+4)/5 =&gt; 2.8(3+2+6−1+4)/5=&gt;2.8</li><li>For the next 5 numbers (subarray from index 2-6), the average is: (2+6-1+4+1)/5 =&gt; 2.4(2+6−1+4+1)/5=&gt;2.4<br>…</li></ol><p>Here is the final output containing the averages of all contiguous subarrays of size 5:</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Output: <span class="string">[2.2, 2.8, 2.4, 3.6, 2.8]</span></span><br></pre></td></tr></table></figure><p>A brute-force algorithm will be to calculate the sum of every 5-element contiguous subarray of the given array and divide the sum by ‘5’ to find the average. This is what the algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_average_of_subarray</span>(<span class="params">K, arr</span>):</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr) - K + <span class="number">1</span>):</span><br><span class="line">        _<span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, i + K):</span><br><span class="line">            _<span class="built_in">sum</span> += arr[j]</span><br><span class="line">        result.append(_<span class="built_in">sum</span> / K)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    result = find_average_of_subarray(<span class="number">5</span>, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, -<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;result:&quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p><strong>Time complexity:</strong> Since for every element of the input array, we are calculating the sum of its next ‘K’ elements, the time complexity of the above algorithm will be <strong><em>O(N\</em>K)*</strong> where ‘N’ is the number of elements in the input array.</p><p>Can we find a better solution? Do you see any inefficiency in the above approach?</p><p>The inefficiency is that for any two consecutive subarrays of size ‘5’, the overlapping part (which will contain four elements) will be evaluated twice. For example, take the above-mentioned input:</p><p><img src="/2-pattern-sliding-window/index/1.jpg"></p><p>As you can see, there are four overlapping elements between the subarray (indexed from 0-4) and the subarray (indexed from 1-5). Can we somehow reuse the <code>sum</code> we have calculated for the overlapping elements?</p><p>The efficient way to solve this problem would be to visualize each contiguous subarray as a sliding window of ‘5’ elements. This means that when we move on to the next subarray, we will slide the window by one element. So, to reuse the <code>sum</code> from the previous subarray, we will subtract the element going out of the window and add the element now being included in the sliding window. This will save us from going through the whole subarray to find the <code>sum</code> and, as a result, the algorithm complexity will reduce to <strong><em>O(N)</em></strong>.</p><p><img src="/2-pattern-sliding-window/index/2.png"></p><p>In the following chapters, we will apply the <strong>Sliding Window</strong> approach to solve a few problems.</p><p>In some problems, the size of the sliding window is not fixed. We have to expand or shrink the window based on the problem constraints. We will see a few examples of such problems in the next chapters.</p><p>Let’s jump onto our first problem and apply the <strong>Sliding Window</strong> pattern.</p><h2 id="Maximum-Sum-Subarray-of-Size-K-easy"><a href="#Maximum-Sum-Subarray-of-Size-K-easy" class="headerlink" title="Maximum Sum Subarray of Size K (easy)"></a>Maximum Sum Subarray of Size K (easy)</h2><p>不在leetcode</p><h3 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given an array of positive numbers and a positive number ‘k’, find the <strong>maximum sum of any contiguous subarray of size ‘k’</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> [<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>], k=<span class="number">3</span> </span><br><span class="line"><span class="symbol">Output:</span> <span class="number">9</span></span><br><span class="line"><span class="symbol">Explanation:</span> Subarray <span class="keyword">with</span> maximum sum <span class="built_in">is</span> [<span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>].</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>], k=<span class="number">2</span> </span><br><span class="line"><span class="symbol">Output:</span> <span class="number">7</span></span><br><span class="line"><span class="symbol">Explanation:</span> Subarray <span class="keyword">with</span> maximum sum <span class="built_in">is</span> [<span class="number">3</span>, <span class="number">4</span>].</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself"><a href="#Try-it-yourself" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">max_sub_array_of_size_k</span><span class="params">(K, arr)</span>:</span></span><br><span class="line"><span class="function">    max_sum </span>= <span class="number">0</span></span><br><span class="line">    window_sum = <span class="number">0</span></span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">for</span> end in <span class="title">range</span><span class="params">(len(arr)</span>):</span></span><br><span class="line"><span class="function">        window_sum +</span>= arr[end]</span><br><span class="line">        max_sum = window_sum <span class="keyword">if</span> window_sum &gt; max_sum <span class="keyword">else</span> max_sum</span><br><span class="line">        <span class="keyword">if</span> end &gt;= K - <span class="number">1</span>:</span><br><span class="line">            window_sum -= arr[start]</span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">max_sum</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function">    result </span>= max_sub_array_of_size_k(<span class="number">3</span>, [<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line">    print(<span class="string">&quot;Result: &quot;</span> + str(result))</span><br><span class="line">    result = max_sub_array_of_size_k(<span class="number">2</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>])</span><br><span class="line">    print(<span class="string">&quot;Result: &quot;</span> + str(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>A basic brute force solution will be to calculate the sum of all ‘k’ sized subarrays of the given array, to find the subarray with the highest sum. We can start from every index of the given array and add the next ‘k’ elements to find the sum of the subarray. </p><p><img src="/2-pattern-sliding-window/index/3.png"></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_sub_array_of_size_k</span>(<span class="params">K, arr</span>):</span></span><br><span class="line">    max_sum, window_sum = <span class="number">0</span>, <span class="number">0</span> <span class="comment">#一点变化</span></span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">        window_sum += arr[end]</span><br><span class="line">        max_sum = <span class="built_in">max</span>(window_sum, max_sum) <span class="comment">#一点变化</span></span><br><span class="line">        <span class="keyword">if</span> end &gt;= K - <span class="number">1</span>:</span><br><span class="line">            window_sum -= arr[start]</span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> max_sum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    result = max_sub_array_of_size_k(<span class="number">3</span>, [<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = max_sub_array_of_size_k(<span class="number">2</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-Complexity"><a href="#Time-Complexity" class="headerlink" title="Time Complexity"></a>Time Complexity</h4><p>The time complexity of the above algorithm will be <strong><em>O(N)</em></strong>.</p><h4 id="Space-Complexity"><a href="#Space-Complexity" class="headerlink" title="Space Complexity"></a>Space Complexity</h4><p>The algorithm runs in constant space <strong><em>O(1)</em></strong>.</p><h2 id="Smallest-Subarray-with-a-given-sum-easy"><a href="#Smallest-Subarray-with-a-given-sum-easy" class="headerlink" title="Smallest Subarray with a given sum (easy)"></a>Smallest Subarray with a given sum (easy)</h2><p>不在leetcode</p><h3 id="Problem-Statement-1"><a href="#Problem-Statement-1" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given an array of positive numbers and a positive number ‘S’, find the length of the <strong>smallest contiguous subarray whose sum is greater than or equal to ‘S’</strong>. Return 0, if no such subarray exists.</p><p><strong>Example 1:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> [<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>], S=<span class="number">7</span> </span><br><span class="line"><span class="symbol">Output:</span> <span class="number">2</span></span><br><span class="line"><span class="symbol">Explanation:</span> The smallest subarray <span class="keyword">with</span> a sum great than <span class="built_in">or</span> equal <span class="keyword">to</span> <span class="comment">&#x27;7&#x27; is [5, 2].</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> [<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>], S=<span class="number">7</span> </span><br><span class="line"><span class="symbol">Output:</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">Explanation:</span> The smallest subarray <span class="keyword">with</span> a sum greater than <span class="built_in">or</span> equal <span class="keyword">to</span> <span class="comment">&#x27;7&#x27; is [8].</span></span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> [<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>], S=<span class="number">8</span> </span><br><span class="line"><span class="symbol">Output:</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">Explanation:</span> Smallest subarrays <span class="keyword">with</span> a sum greater than <span class="built_in">or</span> equal <span class="keyword">to</span> <span class="comment">&#x27;8&#x27; are [3, 4, 1] or [1, 1, 6].</span></span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-1"><a href="#Try-it-yourself-1" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误的</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smallest_subarray_with_given_sum</span>(<span class="params">s, arr</span>):</span></span><br><span class="line">    min_length = math.inf <span class="comment"># 看答案的</span></span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    window_sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">        window_sum += arr[end]</span><br><span class="line">        <span class="keyword">while</span> window_sum &gt;= s <span class="keyword">and</span> start &lt;= end:</span><br><span class="line">            min_length = <span class="built_in">min</span>(min_length, end - start + <span class="number">1</span>)</span><br><span class="line">            window_sum -= arr[start]</span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> min_length</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    result = smallest_subarray_with_given_sum(<span class="number">7</span>, [<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = smallest_subarray_with_given_sum(<span class="number">7</span>, [<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = smallest_subarray_with_given_sum(<span class="number">8</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <strong>Sliding Window</strong> pattern and we can use a similar strategy as discussed in <em>Maximum Sum Subarray of Size K</em>. There is one difference though: in this problem, the size of the sliding window is not fixed. Here is how we will solve this problem:</p><ol><li>First, we will add-up elements from the beginning of the array until their sum becomes greater than or equal to ‘S’.</li><li>These elements will constitute our sliding window. We are asked to find the smallest such window having a sum greater than or equal to ‘S’. We will remember the length of this window as the smallest window so far.</li><li>After this, we will keep adding one element in the sliding window (i.e. slide the window ahead), in a stepwise fashion.</li><li>In each step, we will also try to shrink the window from the beginning. We will shrink the window until the window’s sum is smaller than ‘S’ again. This is needed as we intend to find the smallest window. This shrinking will also happen in multiple steps; in each step we will do two things:<ul><li>Check if the current window length is the smallest so far, and if so, remember its length.</li><li>Subtract the first element of the window from the running sum to shrink the sliding window.</li></ul></li></ol><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smallest_subarray_with_given_sum</span>(<span class="params">s, arr</span>):</span></span><br><span class="line">    min_length = math.inf</span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    window_sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">        window_sum += arr[end]</span><br><span class="line">        <span class="keyword">while</span> window_sum &gt;= s :</span><br><span class="line">            min_length = <span class="built_in">min</span>(min_length, end - start + <span class="number">1</span>)</span><br><span class="line">            window_sum -= arr[start]</span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> min_length == math.inf:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> min_length</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    result = smallest_subarray_with_given_sum(<span class="number">7</span>, [<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = smallest_subarray_with_given_sum(<span class="number">7</span>, [<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = smallest_subarray_with_given_sum(<span class="number">8</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-Complexity-1"><a href="#Time-Complexity-1" class="headerlink" title="Time Complexity"></a>Time Complexity</h4><p>The time complexity of the above algorithm will be <strong><em>O(N)</em></strong>. The outer <code>for</code> loop runs for all elements and the inner <code>while</code> loop processes each element only once, therefore the time complexity of the algorithm will be <strong><em>O(N+N)</em></strong> which is asymptotically equivalent to <strong><em>O(N)</em></strong>.</p><h4 id="Space-Complexity-1"><a href="#Space-Complexity-1" class="headerlink" title="Space Complexity"></a>Space Complexity</h4><p>The algorithm runs in constant space <strong><em>O(1)</em></strong>.</p><h2 id="Longest-Substring-with-K-Distinct-Characters-medium"><a href="#Longest-Substring-with-K-Distinct-Characters-medium" class="headerlink" title="Longest Substring with K Distinct Characters (medium)"></a>Longest Substring with K Distinct Characters (medium)</h2><p>不在leetcode</p><h3 id="Problem-Statement-2"><a href="#Problem-Statement-2" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given a string, find the length of the <strong>longest substring</strong> in it <strong>with no more than K distinct characters</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Input</span>: String=&quot;araaci&quot;, K=<span class="number">2</span></span><br><span class="line">Output: <span class="number">4</span></span><br><span class="line">Explanation: The longest substring <span class="keyword">with</span> <span class="keyword">no</span> more than <span class="string">&#x27;2&#x27;</span> <span class="keyword">distinct</span> characters <span class="keyword">is</span> &quot;araa&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Input</span>: String=&quot;araaci&quot;, K=<span class="number">1</span></span><br><span class="line">Output: <span class="number">2</span></span><br><span class="line">Explanation: The longest substring <span class="keyword">with</span> <span class="keyword">no</span> more than <span class="string">&#x27;1&#x27;</span> <span class="keyword">distinct</span> characters <span class="keyword">is</span> &quot;aa&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="attribute">String</span>=<span class="string">&quot;cbbebi&quot;</span>, <span class="attribute">K</span>=3</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The longest substrings with <span class="literal">no</span> more than <span class="string">&#x27;3&#x27;</span> distinct characters are <span class="string">&quot;cbbeb&quot;</span> &amp; <span class="string">&quot;bbebi&quot;</span>.</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-2"><a href="#Try-it-yourself-2" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longest_substring_with_k_distinct</span>(<span class="params">string, k</span>):</span></span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    max_length = <span class="number">0</span></span><br><span class="line">    char_frequency = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(string)):</span><br><span class="line">        right_char = string[end]</span><br><span class="line">        <span class="keyword">if</span> right_char <span class="keyword">not</span> <span class="keyword">in</span> char_frequency:</span><br><span class="line">            char_frequency[right_char] = <span class="number">0</span></span><br><span class="line">        char_frequency[right_char] += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 字典长度使用len</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(char_frequency) &gt; k:</span><br><span class="line">            left_char = string[start]</span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line">            char_frequency[left_char] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> char_frequency[left_char] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">del</span> char_frequency[left_char]  <span class="comment"># 删除键</span></span><br><span class="line">        max_length = <span class="built_in">max</span>(max_length, end - start + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> max_length</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    result = longest_substring_with_k_distinct(<span class="string">&quot;araaci&quot;</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = longest_substring_with_k_distinct(<span class="string">&quot;araaci&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = longest_substring_with_k_distinct(<span class="string">&quot;abbebi&quot;</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <strong>Sliding Window</strong> pattern and we can use a similar dynamic sliding window strategy as discussed in <em>Smallest Subarray with a given sum</em>. We can use a <strong>HashMap</strong> to remember the frequency of each character we have processed. Here is how we will solve this problem:</p><ol><li>First, we will insert characters from the beginning of the string until we have ‘K’ distinct characters in the <strong>HashMap</strong>.</li><li>These characters will constitute our sliding window. We are asked to find the longest such window having no more than ‘K’ distinct characters. We will remember the length of this window as the longest window so far.</li><li>After this, we will keep adding one character in the sliding window (i.e. slide the window ahead), in a stepwise fashion.</li><li>In each step, we will try to shrink the window from the beginning if the count of distinct characters in the <strong>HashMap</strong> is larger than ‘K’. We will shrink the window until we have no more than ‘K’ distinct characters in the <strong>HashMap</strong>. This is needed as we intend to find the longest window.</li><li>While shrinking, we’ll decrement the frequency of the character going out of the window and remove it from the <strong>HashMap</strong> if its frequency becomes zero.</li><li>At the end of each step, we’ll check if the current window length is the longest so far, and if so, remember its length.</li></ol><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><p>Here is how our algorithm will look:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和我上面写的一摸一样，这里就不再赘述了</span></span><br></pre></td></tr></table></figure><h4 id="Time-Complexity-2"><a href="#Time-Complexity-2" class="headerlink" title="Time Complexity"></a>Time Complexity</h4><p>The time complexity of the above algorithm will be <strong><em>O(N)</em></strong> where ‘N’ is the number of characters in the input string. The outer <code>for</code> loop runs for all characters and the inner <code>while</code> loop processes each character only once, therefore the time complexity of the algorithm will be O(N+N)<em>O</em>(<em>N</em>+<em>N</em>) which is asymptotically equivalent to <strong><em>O(N)</em></strong>.</p><h4 id="Space-Complexity-2"><a href="#Space-Complexity-2" class="headerlink" title="Space Complexity"></a>Space Complexity</h4><p>The space complexity of the algorithm is <strong><em>O(K)</em></strong>, as we will be storing a maximum of ‘K+1’ characters in the HashMap.</p><h2 id="Fruits-into-Baskets-medium"><a href="#Fruits-into-Baskets-medium" class="headerlink" title="Fruits into Baskets (medium)"></a>Fruits into Baskets (medium)</h2><p>leetcode 904</p><h3 id="Problem-Statement-3"><a href="#Problem-Statement-3" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given an array of characters where each character represents a fruit tree, you are given <strong>two baskets</strong> and your goal is to put <strong>maximum number of fruits in each basket</strong>. The only restriction is that <strong>each basket can have only one type of fruit</strong>.</p><p>You can start with any tree, but once you have started you can’t skip a tree. You will pick one fruit from each tree until you cannot, i.e., you will stop when you have to pick from a third fruit type.</p><p>Write a function to return the maximum number of fruits in both the baskets.</p><p><strong>Example 1:</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: Fruit=[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]</span><br><span class="line">Output: <span class="number">3</span></span><br><span class="line">Explanation: We can <span class="built_in">put</span> <span class="number">2</span> <span class="string">&#x27;C&#x27;</span> <span class="keyword">in</span> <span class="literal">one</span> basket <span class="keyword">and</span> <span class="literal">one</span> <span class="string">&#x27;A&#x27;</span> <span class="keyword">in</span> <span class="keyword">the</span> other <span class="built_in">from</span> <span class="keyword">the</span> subarray [<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: Fruit=[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]</span><br><span class="line">Output: <span class="number">5</span></span><br><span class="line">Explanation: We can <span class="built_in">put</span> <span class="number">3</span> <span class="string">&#x27;B&#x27;</span> <span class="keyword">in</span> <span class="literal">one</span> basket <span class="keyword">and</span> <span class="literal">two</span> <span class="string">&#x27;C&#x27;</span> <span class="keyword">in</span> <span class="keyword">the</span> other basket. </span><br><span class="line">This can be done <span class="keyword">if</span> we <span class="built_in">start</span> <span class="keyword">with</span> <span class="keyword">the</span> <span class="keyword">second</span> letter: [<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-3"><a href="#Try-it-yourself-3" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fruits_in_baskets</span>(<span class="params">fruits</span>):</span></span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    max_length = <span class="number">0</span></span><br><span class="line">    char_frequency = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(fruits)):</span><br><span class="line">        right_fruit = fruits[end]</span><br><span class="line">        <span class="keyword">if</span> right_fruit <span class="keyword">not</span> <span class="keyword">in</span> char_frequency:</span><br><span class="line">            char_frequency[right_fruit] = <span class="number">0</span></span><br><span class="line">        char_frequency[right_fruit] += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 字典长度使用len</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(char_frequency) &gt; <span class="number">2</span>:</span><br><span class="line">            left_fruit = fruits[start]</span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line">            char_frequency[left_fruit] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> char_frequency[left_fruit] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">del</span> char_frequency[left_fruit]  <span class="comment"># 删除键</span></span><br><span class="line">        max_length = <span class="built_in">max</span>(max_length, end - start + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> max_length</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    result = fruits_in_baskets([<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = fruits_in_baskets([<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <strong>Sliding Window</strong> pattern and is quite similar to <em>Longest Substring with K Distinct Characters</em>. In this problem, we need to find the length of the longest subarray with no more than two distinct characters (or fruit types!). This transforms the current problem into <strong>Longest Substring with K Distinct Characters</strong> where K=2.</p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like, only the highlighted lines are different from <em>Longest Substring with K Distinct Characters</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和我写的一摸一样，这里就不再赘述了</span></span><br></pre></td></tr></table></figure><h4 id="Time-Complexity-3"><a href="#Time-Complexity-3" class="headerlink" title="Time Complexity"></a>Time Complexity</h4><p>The time complexity of the above algorithm will be <strong><em>O(N)</em></strong> where ‘N’ is the number of characters in the input array. The outer <code>for</code> loop runs for all characters and the inner <code>while</code> loop processes each character only once, therefore the time complexity of the algorithm will be O(N+N)<em>O</em>(<em>N</em>+<em>N</em>) which is asymptotically equivalent to <strong><em>O(N)</em></strong>.</p><h4 id="Space-Complexity-3"><a href="#Space-Complexity-3" class="headerlink" title="Space Complexity"></a>Space Complexity</h4><p>The algorithm runs in constant space <strong><em>O(1)</em></strong> as there can be a maximum of three types of fruits stored in the frequency map.</p><h3 id="Similar-Problems"><a href="#Similar-Problems" class="headerlink" title="Similar Problems"></a>Similar Problems</h3><p><strong>Problem 1: Longest Substring with at most 2 distinct characters</strong></p><p>Given a string, find the length of the longest substring in it with at most two distinct characters.</p><p><strong>Solution:</strong> This problem is exactly similar to our parent problem.</p><h2 id="No-repeat-Substring-hard"><a href="#No-repeat-Substring-hard" class="headerlink" title="No-repeat Substring (hard)"></a>No-repeat Substring (hard)</h2><p>leetcode 3</p><h3 id="Problem-Statement-4"><a href="#Problem-Statement-4" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given a string, find the <strong>length of the longest substring</strong> which has <strong>no repeating characters</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> <span class="type">String</span>=<span class="string">&quot;aabccbb&quot;</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">Explanation:</span> The longest substring without any repeating characters <span class="built_in">is</span> <span class="string">&quot;abc&quot;</span>.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> <span class="type">String</span>=<span class="string">&quot;abbbb&quot;</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="number">2</span></span><br><span class="line"><span class="symbol">Explanation:</span> The longest substring without any repeating characters <span class="built_in">is</span> <span class="string">&quot;ab&quot;</span>.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> <span class="type">String</span>=<span class="string">&quot;abccde&quot;</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">Explanation:</span> Longest substrings without any repeating characters are <span class="string">&quot;abc&quot;</span> &amp; <span class="string">&quot;cde&quot;</span>.</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-4"><a href="#Try-it-yourself-4" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和solution不太一样 但是也是对的</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">non_repeat_substring</span>(<span class="params"><span class="built_in">str</span></span>):</span></span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    max_length = <span class="number">0</span></span><br><span class="line">    char_frequency = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">str</span>)):</span><br><span class="line">        right_char = <span class="built_in">str</span>[end]</span><br><span class="line">        <span class="keyword">if</span> right_char <span class="keyword">not</span> <span class="keyword">in</span> char_frequency:</span><br><span class="line">            char_frequency[right_char] = <span class="number">0</span></span><br><span class="line">        char_frequency[right_char] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> end - start + <span class="number">1</span> != <span class="built_in">len</span>(char_frequency):</span><br><span class="line">            left_char = <span class="built_in">str</span>[start]</span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line">            char_frequency[left_char] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> char_frequency[left_char] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">del</span> char_frequency[left_char]</span><br><span class="line">        max_length = <span class="built_in">max</span>(max_length, end - start + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> max_length</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    result = non_repeat_substring(<span class="string">&quot;aabccbb&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = non_repeat_substring(<span class="string">&quot;abbb&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = non_repeat_substring(<span class="string">&quot;abccde&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <strong>Sliding Window</strong> pattern and we can use a similar dynamic sliding window strategy as discussed in <em>Longest Substring with K Distinct Characters</em>. We can use a <strong>HashMap</strong> to remember the last index of each character we have processed. Whenever we get a repeating character we will shrink our sliding window to ensure that we always have distinct characters in the sliding window.</p><h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">non_repeat_substring</span>(<span class="params"><span class="built_in">str</span></span>):</span></span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    max_length = <span class="number">0</span></span><br><span class="line">    char_index_map = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">str</span>)):</span><br><span class="line">        right_char = <span class="built_in">str</span>[end]</span><br><span class="line">        <span class="keyword">if</span>  right_char <span class="keyword">in</span>  char_index_map:</span><br><span class="line">            left_char = <span class="built_in">str</span>[start]</span><br><span class="line">            start = <span class="built_in">max</span>(start, char_index_map[right_char] + <span class="number">1</span>)</span><br><span class="line">        char_index_map[right_char] = end</span><br><span class="line">        max_length = <span class="built_in">max</span>(max_length, end - start + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> max_length</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    result = non_repeat_substring(<span class="string">&quot;aabccbb&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = non_repeat_substring(<span class="string">&quot;abbb&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = non_repeat_substring(<span class="string">&quot;abccde&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-Complexity-4"><a href="#Time-Complexity-4" class="headerlink" title="Time Complexity"></a>Time Complexity</h4><p>The time complexity of the above algorithm will be <strong><em>O(N)</em></strong> where ‘N’ is the number of characters in the input string.</p><h4 id="Space-Complexity-4"><a href="#Space-Complexity-4" class="headerlink" title="Space Complexity"></a>Space Complexity</h4><p>The space complexity of the algorithm will be <strong><em>O(K)</em></strong> where K<em>K</em> is the number of distinct characters in the input string. This also means <strong><em>K&lt;=N</em></strong>, because in the worst case, the whole string might not have any repeating character so the entire string will be added to the <strong>HashMap</strong>. Having said that, since we can expect a fixed set of characters in the input string (e.g., 26 for English letters), we can say that the algorithm runs in fixed space <strong><em>O(1)</em></strong>; in this case, we can use a fixed-size array instead of the <strong>HashMap</strong>.</p><h2 id="Longest-Substring-with-Same-Letters-after-Replacement-hard"><a href="#Longest-Substring-with-Same-Letters-after-Replacement-hard" class="headerlink" title="*Longest Substring with Same Letters after Replacement (hard)"></a>*Longest Substring with Same Letters after Replacement (hard)</h2><p>leetcode 424</p><h3 id="Problem-Statement-5"><a href="#Problem-Statement-5" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given a string with lowercase letters only, if you are allowed to <strong>replace no more than ‘k’ letters</strong> with any letter, find the <strong>length of the longest substring having the same letters</strong> after replacement.</p><p><strong>Example 1:</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: String=<span class="string">&quot;aabccbb&quot;</span>, k=<span class="number">2</span></span><br><span class="line">Output: <span class="number">5</span></span><br><span class="line">Explanation: Replace <span class="keyword">the</span> <span class="literal">two</span> <span class="string">&#x27;c&#x27;</span> <span class="keyword">with</span> <span class="string">&#x27;b&#x27;</span> <span class="built_in">to</span> have <span class="keyword">a</span> longest repeating substring <span class="string">&quot;bbbbb&quot;</span>.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="attribute">String</span>=<span class="string">&quot;abbcb&quot;</span>, <span class="attribute">k</span>=1</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Replace the <span class="string">&#x27;c&#x27;</span> with <span class="string">&#x27;b&#x27;</span> <span class="keyword">to</span> have a longest repeating substring <span class="string">&quot;bbbb&quot;</span>.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="attribute">String</span>=<span class="string">&quot;abccde&quot;</span>, <span class="attribute">k</span>=1</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Replace the <span class="string">&#x27;b&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;d&#x27;</span> with <span class="string">&#x27;c&#x27;</span> <span class="keyword">to</span> have the longest repeating substring <span class="string">&quot;ccc&quot;</span>.</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-5"><a href="#Try-it-yourself-5" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">length_of_longest_substring</span>(<span class="params"><span class="built_in">str</span>, k</span>):</span></span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    max_length = <span class="number">0</span></span><br><span class="line">    char_frequency = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">str</span>)):</span><br><span class="line">        right_char = <span class="built_in">str</span>[end]</span><br><span class="line">        <span class="keyword">if</span> right_char <span class="keyword">not</span> <span class="keyword">in</span> char_frequency:</span><br><span class="line">            char_frequency[right_char] = <span class="number">0</span></span><br><span class="line">        char_frequency[right_char] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> end - start + <span class="number">1</span> - <span class="built_in">max</span>(char_frequency.values()) &gt; k:</span><br><span class="line">            left_char = <span class="built_in">str</span>[start]</span><br><span class="line">            char_frequency[left_char] -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 下面这个if 可以不要</span></span><br><span class="line">            <span class="keyword">if</span> char_frequency[left_char] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">del</span> char_frequency[left_char]</span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line">        max_length = <span class="built_in">max</span>(max_length, end - start + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> max_length</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    result = length_of_longest_substring(<span class="string">&quot;aabccbb&quot;</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = length_of_longest_substring(<span class="string">&quot;abbcb&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = length_of_longest_substring(<span class="string">&quot;abccde&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <strong>Sliding Window</strong> pattern and we can use a similar dynamic sliding window strategy as discussed in <em>No-repeat Substring</em>. We can use a HashMap to count the frequency of each letter.</p><p>We’ll iterate through the string to add one letter at a time in the window. We’ll also keep track of the count of the maximum repeating letter <strong>in any window</strong> (let’s call it <code>maxRepeatLetterCount</code>). So at any time, we know that we can have a window which has one letter repeating <code>maxRepeatLetterCount</code> times, this means we should try to replace the remaining letters. If we have more than ‘k’ remaining letters, we should shrink the window as we are not allowed to replace more than ‘k’ letters.</p><h3 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">length_of_longest_substring</span>(<span class="params"><span class="built_in">str</span>, k</span>):</span></span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    max_length = <span class="number">0</span></span><br><span class="line">    char_frequency = &#123;&#125;</span><br><span class="line">    max_repeat_letter_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">str</span>)):</span><br><span class="line">        right_char = <span class="built_in">str</span>[end]</span><br><span class="line">        <span class="keyword">if</span> right_char <span class="keyword">not</span> <span class="keyword">in</span> char_frequency:</span><br><span class="line">            char_frequency[right_char] = <span class="number">0</span></span><br><span class="line">        char_frequency[right_char] += <span class="number">1</span></span><br><span class="line">        <span class="comment"># max_repeat_letter_count 是指满足条件的子串中的max repeat letter count</span></span><br><span class="line">        <span class="comment"># 所以可以借鉴上面自己的解法，使用max(char_frequency.values())</span></span><br><span class="line">        max_repeat_letter_count = <span class="built_in">max</span>(max_repeat_letter_count, char_frequency[right_char])</span><br><span class="line">        <span class="keyword">if</span> end - start + <span class="number">1</span> - max_repeat_letter_count &gt; k:</span><br><span class="line">            left_char = <span class="built_in">str</span>[start]</span><br><span class="line">            char_frequency[left_char] -= <span class="number">1</span></span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line">        max_length = <span class="built_in">max</span>(max_length, end - start + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> max_length</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    result = length_of_longest_substring(<span class="string">&quot;aabccbb&quot;</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = length_of_longest_substring(<span class="string">&quot;abbcb&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = length_of_longest_substring(<span class="string">&quot;abccde&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>我的问题在于当窗口的start加一的时候，这是窗口缩减了，但是却没有更新<code>max_repeat_letter_count</code>，这个变量表示的是任意窗口中的最大重复数。但是想了很久又有点懂了，就是即使当前窗口中的最大重复数不是<code>max_repeat_letter_count</code>，那么我判断的时候<code>if (end - start + 1 - max_repeat_letter_count&gt; k)</code>相当于，我假设窗口中就有<code>max_repeat_letter_count</code>这么多重复的，如果连这种情况都达不到，更不用说目前窗口中没有这么多的重复元素了。牛啊！(好像也不太对 2023/12/14)</p></blockquote><h4 id="Time-Complexity-5"><a href="#Time-Complexity-5" class="headerlink" title="Time Complexity"></a>Time Complexity</h4><p>The time complexity of the above algorithm will be <strong><em>O(N)</em></strong> where ‘N’ is the number of letters in the input string.</p><h4 id="Space-Complexity-5"><a href="#Space-Complexity-5" class="headerlink" title="Space Complexity"></a>Space Complexity</h4><p>As we are expecting only the lower case letters in the input string, we can conclude that the space complexity will be <strong><em>O(26)</em></strong>, to store each letter’s frequency in the <strong>HashMap</strong>, which is asymptotically equal to <strong><em>O(1)</em></strong>.</p><h2 id="Longest-Subarray-with-Ones-after-Replacement-hard"><a href="#Longest-Subarray-with-Ones-after-Replacement-hard" class="headerlink" title="Longest Subarray with Ones after Replacement (hard)"></a>Longest Subarray with Ones after Replacement (hard)</h2><p>不在leetcode</p><h3 id="Problem-Statement-6"><a href="#Problem-Statement-6" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Given an array containing 0s and 1s, if you are allowed to <strong>replace no more than ‘k’ 0s with 1s</strong>, find the length of the <strong>longest contiguous subarray having all 1s</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: Array=[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>], k=<span class="number">2</span></span><br><span class="line"><span class="attribute">Output</span>: <span class="number">6</span></span><br><span class="line"><span class="attribute">Explanation</span>: Replace the &#x27;<span class="number">0</span>&#x27; at index <span class="number">5</span> and <span class="number">8</span> to have the longest contiguous subarray of <span class="number">1</span>s having length <span class="number">6</span>.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: Array=[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>], k=<span class="number">3</span></span><br><span class="line"><span class="attribute">Output</span>: <span class="number">9</span></span><br><span class="line"><span class="attribute">Explanation</span>: Replace the &#x27;<span class="number">0</span>&#x27; at index <span class="number">6</span>, <span class="number">9</span>, and <span class="number">10</span> to have the longest contiguous subarray of <span class="number">1</span>s having length <span class="number">9</span>.</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-6"><a href="#Try-it-yourself-6" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我认为这道题和上一题没有区别，只是输入的是数组了</span></span><br><span class="line"><span class="comment"># 我就改了上面一道题的输入就通过了</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">length_of_longest_substring</span>(<span class="params">arr, k</span>):</span></span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    max_length = <span class="number">0</span></span><br><span class="line">    char_frequency = &#123;&#125;</span><br><span class="line">    max_repeat_letter_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">        right_char = arr[end]</span><br><span class="line">        <span class="keyword">if</span> right_char <span class="keyword">not</span> <span class="keyword">in</span> char_frequency:</span><br><span class="line">            char_frequency[right_char] = <span class="number">0</span></span><br><span class="line">        char_frequency[right_char] += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 其实不太理解这个 max_repeat_letter_count 是指什么 因为这不是当前窗口中的max repeat letter count</span></span><br><span class="line">        max_repeat_letter_count = <span class="built_in">max</span>(max_repeat_letter_count, char_frequency[right_char])</span><br><span class="line">        <span class="keyword">if</span> end - start + <span class="number">1</span> - max_repeat_letter_count &gt; k:</span><br><span class="line">            left_char = arr[start]</span><br><span class="line">            char_frequency[left_char] -= <span class="number">1</span></span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line">        max_length = <span class="built_in">max</span>(max_length, end - start + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> max_length</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    result = length_of_longest_substring([<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>], <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = length_of_longest_substring([<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>], <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <strong>Sliding Window</strong> pattern and is quite similar to <em>Longest Substring with same Letters after Replacement</em>. The only difference is that, in the problem, we only have two characters (1s and 0s) in the input arrays.</p><p>Following a similar approach, we’ll iterate through the array to add one number at a time in the window. We’ll also keep track of the maximum number of repeating 1s in the current window (let’s call it <code>maxOnesCount</code>). So at any time, we know that we can have a window which has 1s repeating <code>maxOnesCount</code> time, so we should try to replace the remaining 0s. If we have more than ‘k’ remaining 0s, we should shrink the window as we are not allowed to replace more than ‘k’ 0s.</p><h3 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h3><p>Here is how our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由于列表中只有两类元素，所以更加简单。这里不需要使用unorder_map作为辅助。</span></span><br><span class="line"><span class="comment"># 直接可以记录窗口中1 或者0 的个数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">length_of_longest_substring</span>(<span class="params">arr, k</span>):</span></span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    max_length = <span class="number">0</span></span><br><span class="line">    window_ones_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">        <span class="keyword">if</span> arr[end] == <span class="number">1</span>:</span><br><span class="line">            window_ones_count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> end - start + <span class="number">1</span> - window_ones_count &gt; k:</span><br><span class="line">            <span class="keyword">if</span> arr[start] == <span class="number">1</span>:</span><br><span class="line">                window_ones_count -= <span class="number">1</span></span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line">        max_length = <span class="built_in">max</span>(max_length, end - start + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> max_length</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    result = length_of_longest_substring([<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>], <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = length_of_longest_substring([<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>], <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-Complexity-6"><a href="#Time-Complexity-6" class="headerlink" title="Time Complexity"></a>Time Complexity</h4><p>The time complexity of the above algorithm will be <em>O(N)</em> where ‘N’ is the count of numbers in the input array.</p><h4 id="Space-Complexity-6"><a href="#Space-Complexity-6" class="headerlink" title="Space Complexity"></a>Space Complexity</h4><p>The algorithm runs in constant space <em>O(1)</em>.</p><h2 id="Problem-Challenge-1"><a href="#Problem-Challenge-1" class="headerlink" title="*Problem Challenge 1"></a>*Problem Challenge 1</h2><p>leetcode 567</p><h3 id="Permutation-in-a-String-hard"><a href="#Permutation-in-a-String-hard" class="headerlink" title="Permutation in a String (hard)"></a>Permutation in a String (hard)</h3><p>Given a string and a pattern, find out if the <strong>string contains any permutation of the pattern</strong>.</p><p><strong>Permutation</strong> is defined as the re-arranging of the characters of the string. For example, “abc” has the following six permutations:</p><ol><li>abc</li><li>acb</li><li>bac</li><li>bca</li><li>cab</li><li>cba</li></ol><p>If a string has ‘n’ <strong>distinct</strong> characters it will have <em>n!</em> permutations.</p><p><strong>Example 1:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> <span class="type">String</span>=<span class="string">&quot;oidbcaf&quot;</span>, Pattern=<span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="literal">true</span></span><br><span class="line"><span class="symbol">Explanation:</span> The <span class="type">string</span> contains <span class="string">&quot;bca&quot;</span> which <span class="built_in">is</span> a permutation <span class="keyword">of</span> the given pattern.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> <span class="type">String</span>=<span class="string">&quot;odicf&quot;</span>, Pattern=<span class="string">&quot;dc&quot;</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="literal">false</span></span><br><span class="line"><span class="symbol">Explanation:</span> No permutation <span class="keyword">of</span> the pattern <span class="built_in">is</span> present <span class="keyword">in</span> the given <span class="type">string</span> <span class="keyword">as</span> a substring.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> <span class="type">String</span>=<span class="string">&quot;bcdxabcdy&quot;</span>, Pattern=<span class="string">&quot;bcdyabcdx&quot;</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="literal">true</span></span><br><span class="line"><span class="symbol">Explanation:</span> Both the <span class="type">string</span> <span class="built_in">and</span> the pattern are a permutation <span class="keyword">of</span> <span class="keyword">each</span> other.</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> <span class="type">String</span>=<span class="string">&quot;aaacb&quot;</span>, Pattern=<span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="literal">true</span></span><br><span class="line"><span class="symbol">Explanation:</span> The <span class="type">string</span> contains <span class="string">&quot;acb&quot;</span> which <span class="built_in">is</span> a permutation <span class="keyword">of</span> the given pattern.</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-7"><a href="#Try-it-yourself-7" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 看着答案一点一点想起来的，也过了leetcode</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_permutation</span>(<span class="params"><span class="built_in">str</span>, pattern</span>):</span></span><br><span class="line">    start, match = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    pattern_char_frequency = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> pattern:</span><br><span class="line">        <span class="keyword">if</span> _ <span class="keyword">not</span> <span class="keyword">in</span> pattern_char_frequency:</span><br><span class="line">            pattern_char_frequency[_] = <span class="number">0</span></span><br><span class="line">        pattern_char_frequency[_] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">str</span>)):</span><br><span class="line">        right_char = <span class="built_in">str</span>[end]</span><br><span class="line">        <span class="keyword">if</span> right_char <span class="keyword">in</span> pattern_char_frequency :</span><br><span class="line">            pattern_char_frequency[right_char] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> pattern_char_frequency[right_char] == <span class="number">0</span>:</span><br><span class="line">                match += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 这里的if在答案是没有缩减，但是也是可以缩进的，leetcode过了</span></span><br><span class="line">            <span class="keyword">if</span> match == <span class="built_in">len</span>(pattern_char_frequency):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 这里需要注意，当end指向长度末尾的时候就要执行操作了，这样下次循环还是又是相同的长度，才是sliding window</span></span><br><span class="line">        <span class="keyword">if</span> end &gt;= <span class="built_in">len</span>(pattern) - <span class="number">1</span>:</span><br><span class="line">            left_char = <span class="built_in">str</span>[start]</span><br><span class="line">            <span class="keyword">if</span> left_char <span class="keyword">in</span> pattern_char_frequency:</span><br><span class="line">                <span class="keyword">if</span> pattern_char_frequency[left_char] == <span class="number">0</span>:</span><br><span class="line">                    match -= <span class="number">1</span></span><br><span class="line">                pattern_char_frequency[left_char] += <span class="number">1</span></span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    result = find_permutation(<span class="string">&quot;oidbcaf&quot;</span>, <span class="string">&quot;abc&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = find_permutation(<span class="string">&quot;odicf&quot;</span>, <span class="string">&quot;dc&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = find_permutation(<span class="string">&quot;bcdxabcdy&quot;</span>, <span class="string">&quot;bcdyabcdx&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = find_permutation(<span class="string">&quot;aaacb&quot;</span>, <span class="string">&quot;abc&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <strong>Sliding Window</strong> pattern and we can use a similar sliding window strategy as discussed in <em>Longest Substring with K Distinct Characters</em>. We can use a <strong>HashMap</strong> to remember the frequencies of all characters in the given pattern. Our goal will be to match all the characters from this <strong>HashMap</strong> with a sliding window in the given string. Here are the steps of our algorithm:</p><ol><li>Create a <strong>HashMap</strong> to calculate the frequencies of all characters in the pattern.</li><li>Iterate through the string, adding one character at a time in the sliding window.</li><li>If the character being added matches a character in the <strong>HashMap</strong>, decrement its frequency in the map. If the character frequency becomes zero, we got a complete match.</li><li>If at any time, the number of characters matched is equal to the number of distinct characters in the pattern (i.e., total characters in the <strong>HashMap</strong>), we have gotten our required permutation.</li><li>If the window size is greater than the length of the pattern, shrink the window to make it equal to the size of the pattern. At the same time, if the character going out was part of the pattern, put it back in the frequency <strong>HashMap</strong>.</li></ol><h3 id="Code-7"><a href="#Code-7" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和自己写的一样 就是if的缩进都可以</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_permutation</span>(<span class="params"><span class="built_in">str</span>, pattern</span>):</span></span><br><span class="line">    start, match = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    pattern_char_frequency = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> pattern:</span><br><span class="line">        <span class="keyword">if</span> _ <span class="keyword">not</span> <span class="keyword">in</span> pattern_char_frequency:</span><br><span class="line">            pattern_char_frequency[_] = <span class="number">0</span></span><br><span class="line">        pattern_char_frequency[_] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">str</span>)):</span><br><span class="line">        right_char = <span class="built_in">str</span>[end]</span><br><span class="line">        <span class="keyword">if</span> right_char <span class="keyword">in</span> pattern_char_frequency:</span><br><span class="line">            pattern_char_frequency[right_char] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> pattern_char_frequency[right_char] == <span class="number">0</span>:</span><br><span class="line">                match += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> match == <span class="built_in">len</span>(pattern_char_frequency):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> end &gt;= <span class="built_in">len</span>(pattern) - <span class="number">1</span>:</span><br><span class="line">            left_char = <span class="built_in">str</span>[start]</span><br><span class="line">            <span class="keyword">if</span> left_char <span class="keyword">in</span> pattern_char_frequency:</span><br><span class="line">                <span class="keyword">if</span> pattern_char_frequency[left_char] == <span class="number">0</span>:</span><br><span class="line">                    match -= <span class="number">1</span></span><br><span class="line">                pattern_char_frequency[left_char] += <span class="number">1</span></span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    result = find_permutation(<span class="string">&quot;oidbcaf&quot;</span>, <span class="string">&quot;abc&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = find_permutation(<span class="string">&quot;odicf&quot;</span>, <span class="string">&quot;dc&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = find_permutation(<span class="string">&quot;bcdxabcdy&quot;</span>, <span class="string">&quot;bcdyabcdx&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = find_permutation(<span class="string">&quot;aaacb&quot;</span>, <span class="string">&quot;abc&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Time-Complexity-7"><a href="#Time-Complexity-7" class="headerlink" title="Time Complexity"></a>Time Complexity</h4><p>The time complexity of the above algorithm will be <strong><em>O(N + M)</em></strong> where ‘N’ and ‘M’ are the number of characters in the input string and the pattern respectively.</p><h4 id="Space-Complexity-7"><a href="#Space-Complexity-7" class="headerlink" title="Space Complexity"></a>Space Complexity</h4><p>The space complexity of the algorithm is <strong><em>O(M)</em></strong> since in the worst case, the whole pattern can have distinct characters which will go into the <strong>HashMap</strong>.</p><h2 id="Problem-Challenge-2"><a href="#Problem-Challenge-2" class="headerlink" title="Problem Challenge 2"></a>Problem Challenge 2</h2><p>leetcode 438</p><h3 id="String-Anagrams-hard"><a href="#String-Anagrams-hard" class="headerlink" title="String Anagrams (hard)"></a>String Anagrams (hard)</h3><p>Given a string and a pattern, find <strong>all anagrams of the pattern in the given string</strong>.</p><p><strong>Anagram</strong> is actually a <strong>Permutation</strong> of a string. For example, “abc” has the following six anagrams:</p><ol><li>abc</li><li>acb</li><li>bac</li><li>bca</li><li>cab</li><li>cba</li></ol><p>Write a function to return a list of starting indices of the anagrams of the pattern in the given string.</p><p><strong>Example 1:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> <span class="type">String</span>=<span class="string">&quot;ppqp&quot;</span>, Pattern=<span class="string">&quot;pq&quot;</span></span><br><span class="line"><span class="symbol">Output:</span> [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="symbol">Explanation:</span> The two anagrams <span class="keyword">of</span> the pattern <span class="keyword">in</span> the given <span class="type">string</span> are <span class="string">&quot;pq&quot;</span> <span class="built_in">and</span> <span class="string">&quot;qp&quot;</span>.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> <span class="type">String</span>=<span class="string">&quot;abbcabc&quot;</span>, Pattern=<span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="symbol">Output:</span> [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="symbol">Explanation:</span> The three anagrams <span class="keyword">of</span> the pattern <span class="keyword">in</span> the given <span class="type">string</span> are <span class="string">&quot;bca&quot;</span>, <span class="string">&quot;cab&quot;</span>, <span class="built_in">and</span> <span class="string">&quot;abc&quot;</span>.</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-8"><a href="#Try-it-yourself-8" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和上一题几乎一样，只要加上一个用于存储index即可</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_string_anagrams</span>(<span class="params"><span class="built_in">str</span>, pattern</span>):</span></span><br><span class="line">    start, match = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    pattern_char_frequency = &#123;&#125;</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> pattern:</span><br><span class="line">        <span class="keyword">if</span> _ <span class="keyword">not</span> <span class="keyword">in</span> pattern_char_frequency:</span><br><span class="line">            pattern_char_frequency[_] = <span class="number">0</span></span><br><span class="line">        pattern_char_frequency[_] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">str</span>)):</span><br><span class="line">        right_char = <span class="built_in">str</span>[end]</span><br><span class="line">        <span class="keyword">if</span> right_char <span class="keyword">in</span> pattern_char_frequency:</span><br><span class="line">            pattern_char_frequency[right_char] -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 可以是匹配完一个字符在match，也可以是匹配了一个字符就match</span></span><br><span class="line">            <span class="keyword">if</span> pattern_char_frequency[right_char] == <span class="number">0</span>:</span><br><span class="line">                match += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> match == <span class="built_in">len</span>(pattern_char_frequency):</span><br><span class="line">            res.append(start)</span><br><span class="line">        <span class="keyword">if</span> end &gt;= <span class="built_in">len</span>(pattern) - <span class="number">1</span>:</span><br><span class="line">            left_char = <span class="built_in">str</span>[start]</span><br><span class="line">            <span class="keyword">if</span> left_char <span class="keyword">in</span> pattern_char_frequency:</span><br><span class="line">                <span class="keyword">if</span> pattern_char_frequency[left_char] == <span class="number">0</span>:</span><br><span class="line">                    match -= <span class="number">1</span></span><br><span class="line">                pattern_char_frequency[left_char] += <span class="number">1</span></span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    result = find_string_anagrams(<span class="string">&quot;ppqp&quot;</span>, <span class="string">&quot;pq&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = find_string_anagrams(<span class="string">&quot;abbcabc&quot;</span>, <span class="string">&quot;abc&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <strong>Sliding Window</strong> pattern and is very similar to <em>Permutation in a String</em>. In this problem, we need to find every occurrence of any permutation of the pattern in the string. We will use a list to store the starting indices of the anagrams of the pattern in the string.</p><h3 id="Code-8"><a href="#Code-8" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like, only the highlighted lines have changed from <em>Permutation in a String</em>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和我写的一样，这里就不在赘述了</span></span><br></pre></td></tr></table></figure><h4 id="Time-Complexity-8"><a href="#Time-Complexity-8" class="headerlink" title="Time Complexity"></a>Time Complexity</h4><p>The time complexity of the above algorithm will be <strong><em>O(N + M)</em></strong> where ‘N’ and ‘M’ are the number of characters in the input string and the pattern respectively.</p><h4 id="Space-Complexity-8"><a href="#Space-Complexity-8" class="headerlink" title="Space Complexity"></a>Space Complexity</h4><p>The space complexity of the algorithm is <strong><em>O(M)</em></strong> since in the worst case, the whole pattern can have distinct characters which will go into the <strong>HashMap</strong>. In the worst case, we also need <strong><em>O(N)</em></strong> space for the result list, this will happen when the pattern has only one character and the string contains only that character.</p><h2 id="Problem-Challenge-3"><a href="#Problem-Challenge-3" class="headerlink" title="Problem Challenge 3"></a>Problem Challenge 3</h2><p>leetcode 76</p><h3 id="Smallest-Window-containing-Substring-hard"><a href="#Smallest-Window-containing-Substring-hard" class="headerlink" title="Smallest Window containing Substring (hard)"></a>Smallest Window containing Substring (hard)</h3><p>Given a string and a pattern, find the <strong>smallest substring</strong> in the given string which has <strong>all the characters of the given pattern</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> <span class="type">String</span>=<span class="string">&quot;aabdec&quot;</span>, Pattern=<span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="string">&quot;abdec&quot;</span></span><br><span class="line"><span class="symbol">Explanation:</span> The smallest substring having all characters <span class="keyword">of</span> the pattern <span class="built_in">is</span> <span class="string">&quot;abdec&quot;</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> <span class="type">String</span>=<span class="string">&quot;abdabca&quot;</span>, Pattern=<span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="symbol">Explanation:</span> The smallest substring having all characters <span class="keyword">of</span> the pattern <span class="built_in">is</span> <span class="string">&quot;abc&quot;</span>.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> <span class="type">String</span>=<span class="string">&quot;adcad&quot;</span>, Pattern=<span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="symbol">Explanation:</span> No substring <span class="keyword">in</span> the given <span class="type">string</span> has all characters <span class="keyword">of</span> the pattern.</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-9"><a href="#Try-it-yourself-9" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_substring</span>(<span class="params"><span class="built_in">str</span>, pattern</span>):</span></span><br><span class="line">    start, match = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    pattern_char_frequency = &#123;&#125;</span><br><span class="line">    res_start, res_length = <span class="number">0</span>, math.inf</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> pattern:</span><br><span class="line">        <span class="keyword">if</span> _ <span class="keyword">not</span> <span class="keyword">in</span> pattern_char_frequency:</span><br><span class="line">            pattern_char_frequency[_] = <span class="number">0</span></span><br><span class="line">        pattern_char_frequency[_] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">str</span>)):</span><br><span class="line">        right_char = <span class="built_in">str</span>[end]</span><br><span class="line">        <span class="keyword">if</span> right_char <span class="keyword">in</span> pattern_char_frequency:</span><br><span class="line">            pattern_char_frequency[right_char] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> pattern_char_frequency[right_char] == <span class="number">0</span>:</span><br><span class="line">                match += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 可以用两种写法，match可以是每匹配到一个字符就加一，也可以是匹配完相同的字符在加一，也就是这道题的做法</span></span><br><span class="line">        <span class="keyword">while</span> match == <span class="built_in">len</span>(pattern_char_frequency):</span><br><span class="line">            <span class="keyword">if</span> end - start + <span class="number">1</span> &lt; res_length:</span><br><span class="line">                res_start = start</span><br><span class="line">                res_length = end - start + <span class="number">1</span></span><br><span class="line">            left_char = <span class="built_in">str</span>[start]</span><br><span class="line">            <span class="keyword">if</span> left_char <span class="keyword">in</span> pattern_char_frequency:</span><br><span class="line">                <span class="keyword">if</span> pattern_char_frequency[left_char] == <span class="number">0</span>:</span><br><span class="line">                    match -= <span class="number">1</span></span><br><span class="line">                pattern_char_frequency[left_char] += <span class="number">1</span></span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 这个if忘记了 记得加上</span></span><br><span class="line">    <span class="keyword">if</span> res_length == math.inf:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>[res_start:res_start + res_length]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    result = find_substring(<span class="string">&quot;aabdec&quot;</span>, <span class="string">&quot;abc&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = find_substring(<span class="string">&quot;abdabca&quot;</span>, <span class="string">&quot;abc&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = find_substring(<span class="string">&quot;adcad&quot;</span>, <span class="string">&quot;abc&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-9"><a href="#Solution-9" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <strong>Sliding Window</strong> pattern and has a lot of similarities with <em>Permutation in a String</em> with one difference. In this problem, we need to find a substring having all characters of the pattern which means that the required substring can have some additional characters and doesn’t need to be a permutation of the pattern. Here is how we will manage these differences:</p><ol><li>We will keep a running count of every matching instance of a character.</li><li>Whenever we have matched all the characters, we will try to shrink the window from the beginning, keeping track of the smallest substring that has all the matching characters.</li><li>We will stop the shrinking process as soon as we remove a matched character from the sliding window. One thing to note here is that we could have redundant matching characters, e.g., we might have two ‘a’ in the sliding window when we only need one ‘a’. In that case, when we encounter the first ‘a’, we will simply shrink the window without decrementing the matched count. We will decrement the matched count when the second ‘a’ goes out of the window.</li></ol><h3 id="Code-9"><a href="#Code-9" class="headerlink" title="Code"></a>Code</h3><p>Here is how our algorithm will look; only the highlighted lines have changed from <em>Permutation in a String</em>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和我写的一样，这里就不在赘述了</span></span><br></pre></td></tr></table></figure><h4 id="Time-Complexity-9"><a href="#Time-Complexity-9" class="headerlink" title="Time Complexity"></a>Time Complexity</h4><p>The time complexity of the above algorithm will be <strong><em>O(N + M)</em></strong> where ‘N’ and ‘M’ are the number of characters in the input string and the pattern respectively.</p><h4 id="Space-Complexity-9"><a href="#Space-Complexity-9" class="headerlink" title="Space Complexity"></a>Space Complexity</h4><p>The space complexity of the algorithm is <strong><em>O(M)</em></strong> since in the worst case, the whole pattern can have distinct characters which will go into the <strong>HashMap</strong>. In the worst case, we also need <strong><em>O(N)</em></strong> space for the resulting substring, which will happen when the input string is a permutation of the pattern.</p><h2 id="Problem-Challenge-4"><a href="#Problem-Challenge-4" class="headerlink" title="*Problem Challenge 4"></a>*Problem Challenge 4</h2><p>leetcode 30</p><h3 id="Words-Concatenation-hard"><a href="#Words-Concatenation-hard" class="headerlink" title="Words Concatenation (hard)"></a>Words Concatenation (hard)</h3><p>Given a string and a list of words, find all the starting indices of substrings in the given string that are a <strong>concatenation of all the given words</strong> exactly once <strong>without any overlapping</strong> of words. It is given that all words are of the same length.</p><p><strong>Example 1:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> <span class="type">String</span>=<span class="string">&quot;catfoxcat&quot;</span>, Words=[<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;fox&quot;</span>]</span><br><span class="line"><span class="symbol">Output:</span> [<span class="number">0</span>, <span class="number">3</span>]</span><br><span class="line"><span class="symbol">Explanation:</span> The two substring containing both the words are <span class="string">&quot;catfox&quot;</span> &amp; <span class="string">&quot;foxcat&quot;</span>.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> <span class="type">String</span>=<span class="string">&quot;catcatfoxfox&quot;</span>, Words=[<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;fox&quot;</span>]</span><br><span class="line"><span class="symbol">Output:</span> [<span class="number">3</span>]</span><br><span class="line"><span class="symbol">Explanation:</span> The only substring containing both the words <span class="built_in">is</span> <span class="string">&quot;catfox&quot;</span>.</span><br></pre></td></tr></table></figure><h3 id="Try-it-yourself-10"><a href="#Try-it-yourself-10" class="headerlink" title="Try it yourself"></a>Try it yourself</h3><p>Try solving this question here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把word看作一个整体，这是看答案写的</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_word_connection</span>(<span class="params"><span class="built_in">str</span>, words</span>):</span></span><br><span class="line">    word_frequency = &#123;&#125;</span><br><span class="line">    word_length = <span class="built_in">len</span>(words[<span class="number">0</span>])</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">        <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> word_frequency:</span><br><span class="line">            word_frequency[word] = <span class="number">0</span></span><br><span class="line">        word_frequency[word] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">str</span>) - word_length * <span class="built_in">len</span>(words) + <span class="number">1</span>):</span><br><span class="line">        word_seen = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(words)):</span><br><span class="line">            next_index = i + j * word_length</span><br><span class="line">            word = <span class="built_in">str</span>[next_index:next_index + word_length]</span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> word_frequency:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> word_seen:</span><br><span class="line">                word_seen[word] = <span class="number">0</span></span><br><span class="line">            word_seen[word] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> word_seen[word] &gt; word_frequency[word]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> j + <span class="number">1</span> == <span class="built_in">len</span>(words):</span><br><span class="line">                res.append(i)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    result = find_word_connection(<span class="string">&quot;catfoxcat&quot;</span>, [<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;fox&quot;</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line">    result = find_word_connection(<span class="string">&quot;catcatfoxfox&quot;</span>, [<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;fox&quot;</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: &quot;</span> + <span class="built_in">str</span>(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-10"><a href="#Solution-10" class="headerlink" title="Solution"></a>Solution</h3><p>This problem follows the <strong>Sliding Window</strong> pattern and has a lot of similarities with <em>Maximum Sum Subarray of Size K</em>. We will keep track of all the words in a <strong>HashMap</strong> and try to match them in the given string. Here are the set of steps for our algorithm:</p><ol><li>Keep the frequency of every word in a <strong>HashMap</strong>.</li><li>Starting from every index in the string, try to match all the words.</li><li>In each iteration, keep track of all the words that we have already seen in another <strong>HashMap</strong>.</li><li>If a word is not found or has a higher frequency than required, we can move on to the next character in the string.</li><li>Store the index if we have found all the words.</li></ol><h3 id="Code-10"><a href="#Code-10" class="headerlink" title="Code"></a>Code</h3><p>Here is what our algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参考上面我写的，思路一样</span></span><br></pre></td></tr></table></figure><h4 id="Time-Complexity-10"><a href="#Time-Complexity-10" class="headerlink" title="Time Complexity"></a>Time Complexity</h4><p>The time complexity of the above algorithm will be <strong><em>O(N </em> M <em> Len)</em></strong> where ‘N’ is the number of characters in the given string, ‘M’ is the total number of words, and ‘Len’ is the length of a word.</p><h4 id="Space-Complexity-10"><a href="#Space-Complexity-10" class="headerlink" title="Space Complexity"></a>Space Complexity</h4><p>The space complexity of the algorithm is <strong><em>O(M)</em></strong> since at most, we will be storing all the words in the two <strong>HashMaps</strong>. In the worst case, we also need <strong><em>O(N)</em></strong> space for the resulting list. So, the overall space complexity of the algorithm will be <strong><em>O(M+N)</em></strong>.</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.Introduction</title>
      <link href="/1-introduction/index.html"/>
      <url>/1-introduction/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="Who-should-take-this-course"><a href="#Who-should-take-this-course" class="headerlink" title="Who should take this course?"></a>Who should take this course?</h3><p>Thanks for choosing this course! We hope the techniques you learn here go a long way towards building solid algorithmic skills.</p><h3 id="Intended-Audience"><a href="#Intended-Audience" class="headerlink" title="Intended Audience"></a>Intended Audience</h3><p>If you want to work on your algorithms and problem-solving skills, this course is for you. Systematically, we will start with easier problems to develop an understanding of the underlying solution patterns and then apply these patterns to solve difficult ones. Every problem presented in this course has been solved in <strong>Java, Python, C++,</strong> and <strong>JavaScript</strong>.</p><h3 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h3><p>You need to have a basic understanding of common data-structures like Array, LinkedList, HashMap, Stack, Queue, Heap, and Graph. You should also be familiar with <a href="https://en.wikipedia.org/wiki/Recursion_(computer_science">Recursion</a>) and <a href="https://en.wikipedia.org/wiki/Big_O_notation">Big-O</a>.</p><h2 id="Course-Overview"><a href="#Course-Overview" class="headerlink" title="Course Overview"></a>Course Overview</h2><p>This course categorizes coding interview problems into a set of <strong>16 patterns</strong>. Each pattern will be a complete tool - consisting of data structures, algorithms, and analysis techniques - to solve a specific category of problems. The goal is to develop an understanding of the underlying pattern, so that, we can apply that pattern to solve other problems.</p><p>We have chosen each problem carefully such that it not only maps to the same pattern but also presents different constraints. Overall, the course has around <strong>150 problems</strong> mapped to 16 patterns.</p><p>The problems solved under these patterns use a varied set of algorithmic techniques. We will make use of <strong>Breadth-First Search</strong> and <strong>Depth-First Search</strong> to solve problems related to <strong>Trees</strong> and <strong>Graphs</strong>. Similarly, we will also cover <strong>Dynamic Programming</strong>, <strong>Backtracking</strong>, <strong>Recursion</strong>, <strong>Greedy algorithms</strong>, and <strong>Divide &amp; Conquer</strong>.</p><p>We will start with a brief introduction of each pattern before jumping onto the problems. Under each pattern, the first problem will explain the underlying pattern in detail to build the concepts that can be applied to later problems. The later problems will focus on the different constraints each problem presents and how our algorithm needs to change to handle them.</p><p>Let’s start with the <strong>Sliding Window</strong> pattern.</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人工智能基础课堂笔记</title>
      <link href="/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%9F%BA%E7%A1%80%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/index.html"/>
      <url>/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%9F%BA%E7%A1%80%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git学习笔记</title>
      <link href="/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"/>
      <url>/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="Git命令行操作"><a href="#Git命令行操作" class="headerlink" title="Git命令行操作"></a>Git命令行操作</h2><h3 id="本地库初始化"><a href="#本地库初始化" class="headerlink" title="本地库初始化"></a>本地库初始化</h3><p><code>进入文件夹</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">init</span></span><br><span class="line">注意：生成的 .git 目录中存放的是本地库相关文件，不要删除</span><br></pre></td></tr></table></figure><h3 id="设置签名"><a href="#设置签名" class="headerlink" title="设置签名"></a>设置签名</h3><p>这里设置的签名和GitHub中的用户，密码没有关系。</p><ul><li><p>项目(仓库)级别<code>仅在当前本地库有效</code></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config <span class="keyword">user</span>.name tom  <span class="comment">#设置用户名tom</span></span><br><span class="line">git config <span class="keyword">user</span>.email liu@qq.com <span class="comment">#设置用户邮箱</span></span><br></pre></td></tr></table></figure></li><li><p>系统用户级别<code>仅在当前登录的操作系统用户有效</code></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">config</span> <span class="comment">--global user.name tom</span></span><br><span class="line">git <span class="built_in">config</span> <span class="comment">--global user.email liu@qq.com</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>仅仅加了一个 <code>--global</code></p><p>优先级别：<code>项目级别</code>  &gt;  <code>系统级别</code></p><p>项目级别的作用范围更小，类似于局部变量 &gt; 全局变量。<strong>二者必须要有其一。</strong></p><p>信息保存位置：<code>~/.gitconfig 文件</code>   </p><p>查看方式：<code>cat .git/config</code></p><p>查看当前用户（global）配置     <code>git config --global  --list</code><br>查看当前仓库配置信息    <code>git config --local    --list</code></p></blockquote><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="状态查看"><a href="#状态查看" class="headerlink" title="状态查看"></a>状态查看</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git</span> status   <span class="comment">#查看工作区、暂存区状态</span></span><br></pre></td></tr></table></figure><h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">add </span>fileName  <span class="comment">#指定文件</span></span><br><span class="line">git <span class="keyword">add </span>. <span class="comment">#所有</span></span><br><span class="line">说明：将工作区的文件添加到暂存区</span><br><span class="line">git rm --<span class="keyword">cached </span>filename <span class="comment">#将暂存区的文件撤销</span></span><br></pre></td></tr></table></figure><h4 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git</span> commit -m <span class="string">&#x27;commit message&#x27;</span> fileName</span><br><span class="line">说明：将暂存区内容提交到本地库</span><br></pre></td></tr></table></figure><h4 id="查看历史记录"><a href="#查看历史记录" class="headerlink" title="查看历史记录"></a>查看历史记录</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> </span><br><span class="line">git reflog  <span class="comment">#常用，说明：HEAD@&#123;移动到当前版本需要多少步&#125;</span></span><br><span class="line">git <span class="built_in">log</span> <span class="comment">--greph #图形显示,更直观</span></span><br><span class="line">git <span class="built_in">log</span> <span class="comment">--pretty=oneline #漂亮一行显示</span></span><br><span class="line">git <span class="built_in">log</span> <span class="comment">--oneline #简洁显示</span></span><br></pre></td></tr></table></figure><h4 id="前进后退"><a href="#前进后退" class="headerlink" title="前进后退"></a>前进后退</h4><ul><li><p>基于索引值<code>推荐</code></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">reset</span> <span class="comment">--hard 指针位置</span></span><br><span class="line">例子：git <span class="keyword">reset</span> <span class="comment">--hard a6ace91 #回到这个状态</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <strong>^</strong> 符号<code>只能后退</code></p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">git</span> <span class="comment">reset</span> --<span class="comment">hard</span> <span class="comment">HEAD^例子：git</span> <span class="comment">reset</span> --<span class="comment">hard</span> <span class="comment">HEAD^^注意：几个</span> <span class="comment">^</span> <span class="comment">表示后退几步</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <strong>~</strong> 符号<code>只能后退</code></p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">git</span> <span class="comment">reset</span> --<span class="comment">hard</span> <span class="comment">HEAD~n例子：git</span> <span class="comment">reset</span> --<span class="comment">hard</span> <span class="comment">HEAD~3</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="reset的三个参数比较"><a href="#reset的三个参数比较" class="headerlink" title="reset的三个参数比较"></a>reset的三个参数比较</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">soft:   - 仅本地库移动HEAD 指针</span><br><span class="line">mixed：  - 在本地库移动HEAD指针  </span><br><span class="line"><span class="bullet">    -</span> 重置暂存区</span><br><span class="line">hard：   - 在本地库移动HEAD指针</span><br><span class="line"><span class="bullet">-</span> 重置暂存区  </span><br><span class="line"><span class="bullet">-</span> 重置工作区</span><br></pre></td></tr></table></figure><h4 id="删除文件并找回"><a href="#删除文件并找回" class="headerlink" title="删除文件并找回"></a>删除文件并找回</h4><ul><li><p><strong>相当于建立一个快照，虽然删除了，但只要添加到暂存区，就能找回</strong></p><p>如果文件删除之后已经commit了，那么在log里就有有一条记录，这时，使用<code>git reset --hard 指针位置</code>来还原。</p><p>如果删除文件之后只是add,没有commit，那么log中没有新的记录，使用<code>git reset --hard HEAD</code>来刷新工作区。</p></li></ul><h4 id="文件差异比较"><a href="#文件差异比较" class="headerlink" title="文件差异比较"></a>文件差异比较</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">diff </span>文件名 <span class="comment">#工作区文件和暂存区比较</span></span><br><span class="line">git <span class="keyword">diff </span>哈希值 文件名  <span class="comment">#工作区文件和本地库历史记录比较</span></span><br><span class="line">git <span class="keyword">diff </span> <span class="comment">#不带文件名，则比较多个文件</span></span><br></pre></td></tr></table></figure><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><h4 id="什么是分支管理"><a href="#什么是分支管理" class="headerlink" title="什么是分支管理"></a>什么是分支管理</h4><ul><li>在版本控制中，使用推进多个任务</li></ul><h4 id="分支的好处"><a href="#分支的好处" class="headerlink" title="分支的好处"></a>分支的好处</h4><ul><li><p>同时并行推进多个功能开发，提高开发效率</p></li><li><p>某一分支开发失败，不会对其它分支有任何影响</p><p><img src="/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index/1.png"></p></li></ul><h4 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h4><ul><li>创建分支</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">branch </span>分支名</span><br></pre></td></tr></table></figure><ul><li>查看分支</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">branch</span></span><br><span class="line"><span class="keyword"></span>git <span class="keyword">branch </span>-v </span><br></pre></td></tr></table></figure><ul><li>切换分支</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout 分支名</span><br><span class="line">git checkout -<span class="keyword">b </span>分支名   <span class="comment">#创建分支并直接切换到该分支</span></span><br></pre></td></tr></table></figure><ul><li><p>合并分支<code>相当于把修改了的文件拉过来</code></p><ul><li><p>第一步：切换到接收修改的分支名上</p><p><code>git checkout [分支名]</code></p></li><li><p>第二步：执行merge命令</p><p><code>git merge [分支名]</code></p></li></ul></li></ul><ul><li>删除分支</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">branch </span>-d 分支名</span><br></pre></td></tr></table></figure><h4 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h4><ul><li><p>冲突的表现</p><p><img src="/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index/2.png"></p></li><li><p>冲突的解决</p><ul><li>第一步：编辑，删除特殊标记<code>&lt;&lt;&lt;</code> <code>===</code></li><li>第二步：修改到满意位置，保存退出</li><li>第三步：添加到缓存区  <code>git  add 文件名</code></li><li>第四步：提交到本地库<code>git commit -m &#39;日志信息&#39;</code>  <ul><li><strong>注意：后面一定不能带文件名</strong></li></ul></li></ul></li></ul><h2 id="Git-结合Github"><a href="#Git-结合Github" class="headerlink" title="Git 结合Github"></a>Git 结合Github</h2><h3 id="创建远程库地址别名"><a href="#创建远程库地址别名" class="headerlink" title="创建远程库地址别名"></a>创建远程库地址别名</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git remote -v  <span class="meta">#查看远程地址别名</span></span><br><span class="line">git remote <span class="keyword">add</span> 别名 远程地址 </span><br><span class="line">例子：git remote <span class="keyword">add</span> origin https:<span class="comment">//xx</span></span><br><span class="line">这里的 origin 是别名的意思</span><br></pre></td></tr></table></figure><h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><p><code>开发修改完把本地库的文件推送到远程仓库</code> <code>前提是提交到了本地库才可以推送</code></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">push</span> 别名 分支名</span><br><span class="line">git <span class="keyword">push</span> -u 别名 分支名    <span class="meta">#-u指定默认主机</span></span><br><span class="line">例子：git <span class="keyword">push</span> origin master</span><br></pre></td></tr></table></figure><h3 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h3><p>完整的把远程库克隆到本地<code>`克隆下来后不要在主分支里面做开发</code> `clone进行一次，从无到有的过程，更新用pull</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span>  <span class="title">远程地址</span></span><br><span class="line"><span class="title">例子：git</span> <span class="keyword">clone</span> <span class="title">https</span>://xx</span><br></pre></td></tr></table></figure><h3 id="常见建立仓库方式"><a href="#常见建立仓库方式" class="headerlink" title="常见建立仓库方式"></a>常见建立仓库方式</h3><ol><li>建立仓库 —&gt; 打开空文件夹（还没有项目） —&gt; 克隆下来</li><li>建立仓库 —&gt; 打开项目文件夹（已经有项目）—&gt; 初始化仓库 —&gt; 设置remote仓库链接</li></ol><h3 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h3><p><code>pull = fetch + merge</code></p><p>把远程库中的内容拉取到本地库，但是在本地库没有 被更新，这个时候当前分支（本地库）是看不到变化的，只有进入<code>origin/分支名</code>才能看到变化。这个时候在本地的分支执行merge命令之后才能在本地的分支看到变化。</p><p>  本地存在clone下来的文件  就用pull更新</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pull = fetch + merge</span><br><span class="line">git fetch <span class="comment">[远程地址别名]</span> <span class="comment">[分支名]</span></span><br><span class="line">git merge <span class="comment">[远程地址别名]</span> <span class="comment">[分支名]</span></span><br><span class="line">git pull <span class="comment">[远程地址别名]</span> <span class="comment">[分支名]</span></span><br></pre></td></tr></table></figure><h3 id="解决冲突-1"><a href="#解决冲突-1" class="headerlink" title="解决冲突"></a>解决冲突</h3><p><strong>注意：解决冲突后的提交是不能带文件名的</strong></p><ul><li>如果不是基于GitHub 远程库的最新版所做的修改，不能推送，必须先拉取。</li><li>拉取下来后如果进入冲突状态，则按照“分支冲突解决”操作解决即可。</li></ul><p><img src="/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index/3.png"></p><h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><p><code>提交记录简洁不分叉</code>  <code>没学懂，感觉有点鸡肋</code> <code>混眼熟</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -<span class="selector-tag">i</span> 索引号git rebase -<span class="selector-tag">i</span> HEAD~<span class="number">3</span>  #合并最近三条记录说明：在vim编辑里面改成s</span><br></pre></td></tr></table></figure><h3 id="beyond-compare"><a href="#beyond-compare" class="headerlink" title="beyond compare"></a>beyond compare</h3><p><code>用软件解决冲突</code> </p> <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.安装 ：beyond compare <span class="number">2</span>.配置：    git <span class="keyword">config</span> --<span class="keyword">local</span> merge<span class="variable">.tool</span> bc3  #合并名称    git <span class="keyword">config</span> --<span class="keyword">local</span> mergetool<span class="variable">.path</span> &#x27;/usr/<span class="keyword">local</span>/bin/bcomp&#x27; #软件路径    git <span class="keyword">config</span> --<span class="keyword">local</span> mergetool<span class="variable">.keepBackup</span> false  #False不用保存备份<span class="number">3</span>.应用：git mergetool说明：--<span class="keyword">local</span>指只在当前操作系统有效</span><br></pre></td></tr></table></figure><h3 id="跨团队合作"><a href="#跨团队合作" class="headerlink" title="跨团队合作"></a>跨团队合作</h3><p><code>代码review之后合并</code></p><ul><li><p><strong>适用于个人</strong></p><p><strong>邀请成员</strong>:<code>Settings</code> —&gt; <code>Collaborators</code> —&gt;<code>填写用户名</code> —&gt;<code>打开链接接受邀请</code></p></li><li><p><strong>企业</strong>   <code>创建一个组织</code> <code>方便管理</code></p></li><li><p><strong>review</strong></p><p><code>组织做review</code>  <code>通过Pull request</code></p></li><li><p><strong>给开源社区共享代码</strong></p><p><code>点击别人仓库的fork 到自己的仓库</code>   — &gt; <code>然后clone下来 修改后推送到远程库</code>  —&gt; <code>点击Pull Request请求</code> —&gt; <code>Create pull request发消息</code></p></li></ul><h3 id="Tag标签"><a href="#Tag标签" class="headerlink" title="Tag标签"></a>Tag标签</h3><p><code>为了清晰的版本管理，公司一般不会直接使用commit提交</code></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">tag</span> -<span class="keyword">a</span> v1.<span class="number">0</span> -<span class="keyword">m</span> <span class="string">&#x27;版本介绍&#x27;</span>   #创建本地<span class="keyword">tag</span>信息git <span class="keyword">tag</span> -d v1.<span class="number">0</span>    #删除taggit push origin --<span class="keyword">tags</span>   #将本地<span class="keyword">tag</span>信息推送到远程库git pull origin --<span class="keyword">tags</span>    #拉取到本地git checkout v.<span class="number">10</span>    #切换taggit clone -<span class="keyword">b</span> v0.<span class="number">1</span> 地址   #指定<span class="keyword">tag</span>下载代码</span><br></pre></td></tr></table></figure><h3 id="SSH-免密登录"><a href="#SSH-免密登录" class="headerlink" title="SSH 免密登录"></a>SSH 免密登录</h3><ul><li><p>进入当前的家目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~</span><br></pre></td></tr></table></figure></li><li><p>删除<code>.ssh</code>目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm -rvf .ssh</span><br></pre></td></tr></table></figure></li><li><p>运行命令生成SSH密钥目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C [Github邮箱]</span><br><span class="line">或者 </span><br><span class="line">$ ssh-keygen (会让你设置SSH的登录密码，可以不输入，一直Enter)</span><br></pre></td></tr></table></figure></li><li><p>进入.ssh目录查看文件列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> .ssh</span><br><span class="line">$ ls -la</span><br></pre></td></tr></table></figure><p><img src="/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index/4.png"></p></li><li><p>查看<code>id_rsa.pub</code>的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat id_rsa.pub</span><br></pre></td></tr></table></figure><p><img src="/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index/5.png"></p></li><li><p>在GitHub上建立SSH Key, 把刚刚生成的ssh密钥填进去。</p></li><li><p>保证本地库对应的远程库是SSH方式的。</p><p><img src="/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index/6.png"></p><p>如果没有：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add remote origin_ssh[(这是别名) [SSH地址]</span><br></pre></td></tr></table></figure></li><li><p>然后就可以愉快的push啦~~</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push [别名] [分支名]</span><br><span class="line"><span class="comment"># 这里要注意，如果你在本地库只建立了一个远程地址，</span></span><br><span class="line"><span class="comment"># 那么不用使用[别名]和[分支名]。如果有多个才要使用。</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Git工作流"><a href="#Git工作流" class="headerlink" title="Git工作流"></a>Git工作流</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在项目开发过程中使用Git的方式</span><br></pre></td></tr></table></figure><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="集中式工作流"><a href="#集中式工作流" class="headerlink" title="集中式工作流"></a>集中式工作流</h4><p>像SVN一样，集中式工作流有一个中央仓库，所有的修改都提交到了Master分支上</p><h4 id="GitFlow工作流"><a href="#GitFlow工作流" class="headerlink" title="GitFlow工作流 *"></a>GitFlow工作流 <code>*</code></h4><p>主干分支<code>master</code>  开发分支<code>develop</code>  修复分支<code>hotfix</code>   预发布分支<code>release</code>  功能分支<code>feature</code></p><p>GitFlow 有独立的分支，让发布迭代过程更流畅。</p><p><img src="/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index/7.png"></p><h4 id="Forking-工作流"><a href="#Forking-工作流" class="headerlink" title="Forking 工作流"></a>Forking 工作流</h4><p>在 GitFlow 基础上， 充分利用了 Git 的 Fork 和 pull request 的功能以达到代码审核的目的。 安全可靠地管理大团队的开发者</p>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ Sort()</title>
      <link href="/c-sort/index.html"/>
      <url>/c-sort/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="sort-基本使用方法"><a href="#sort-基本使用方法" class="headerlink" title="sort()基本使用方法"></a>sort()基本使用方法</h2><p> sort()函数可以对给定区间所有元素进行排序。它有三个参数sort(begin, end, cmp)，其中begin为指向待sort()的数组的第一个元素的指针，end为指向待sort()的数组的最后一个元素的下一个位置的指针，cmp参数为排序准则，cmp参数可以不写，如果不写的话，默认从小到大进行排序。如果我们想从大到小排序可以将cmp参数写为greater<int>()就是对int数组进行排序，当然&lt;&gt;中我们也可以写double、long、float等等。如果我们需要按照其他的排序准则，那么就需要我们自己定义一个bool类型的函数来传入。比如我们对一个整型数组进行从大到小排序：</int></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">10</span>] = &#123;<span class="number">6</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(num,num+<span class="number">10</span>,greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">cout&lt;&lt;num[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;<span class="comment">//输出结果:9 8 7 6 5 4 3 2 1 0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="自定义排序"><a href="#自定义排序" class="headerlink" title="自定义排序"></a>自定义排序</h2><h3 id="基本类型的其他需求"><a href="#基本类型的其他需求" class="headerlink" title="基本类型的其他需求"></a>基本类型的其他需求</h3><p>这里指的是，待排序类型的数据是基本类型，但是不希望是从小到大排序的，比如说我们按照每个数的个位进行从大到小排序，我们就可以根据自己的需求来写一个函数作为排序的准则传入到sort()中。</p><p>我们可以这样实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x % <span class="number">10</span> &gt; y % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>完整代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x % <span class="number">10</span> &gt; y % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">10</span>] = &#123;<span class="number">65</span>,<span class="number">59</span>,<span class="number">96</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">80</span>,<span class="number">72</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">99</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(num,num+<span class="number">10</span>,cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">cout&lt;&lt;num[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;<span class="comment">//输出结果：59 99 96 65 44 13 33 72 21 80</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="对于结构体和类进行排序"><a href="#对于结构体和类进行排序" class="headerlink" title="对于结构体和类进行排序"></a>对于结构体和类进行排序</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>写cmp函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interval</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Interval</span>(<span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;start = start;</span><br><span class="line">        <span class="keyword">this</span>-&gt;end = end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Interval a, Interval b)</span> </span>&#123; <span class="keyword">return</span> a.start &lt; b.start; &#125;</span><br><span class="line"><span class="comment">//实现这个函数并且调用</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MergeIntervals</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">static</span> vector&lt;Interval&gt; <span class="title">merge</span><span class="params">(vector&lt;Interval&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        vector&lt;Interval&gt; mergedIntervals;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> interval : intervals)&#123;</span><br><span class="line">            mergedIntervals.<span class="built_in">push_back</span>(interval);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mergedIntervals;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;Interval&gt; input = &#123;&#123;<span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">2</span>, <span class="number">5</span>&#125;, &#123;<span class="number">7</span>, <span class="number">9</span>&#125;&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Merged intervals: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> interval : MergeIntervals::<span class="built_in">merge</span>(input)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; interval.start &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; interval.end &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interval</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Interval</span>(<span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;start = start;</span><br><span class="line">        <span class="keyword">this</span>-&gt;end = end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MergeIntervals</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">static</span> vector&lt;Interval&gt; <span class="title">merge</span><span class="params">(vector&lt;Interval&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        vector&lt;Interval&gt; mergedIntervals;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [](<span class="keyword">const</span> Interval&amp; a, <span class="keyword">const</span> Interval&amp; b)&#123;<span class="keyword">return</span> a.start &lt; b.start;&#125;);</span><br><span class="line">        <span class="comment">//这里的第三个参数用了这个方法</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> interval : intervals)&#123;</span><br><span class="line">            mergedIntervals.<span class="built_in">push_back</span>(interval);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mergedIntervals;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;Interval&gt; input = &#123;&#123;<span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">2</span>, <span class="number">5</span>&#125;, &#123;<span class="number">7</span>, <span class="number">9</span>&#125;&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Merged intervals: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> interval : MergeIntervals::<span class="built_in">merge</span>(input)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; interval.start &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; interval.end &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>人类简史读后感</title>
      <link href="/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E8%AF%BB%E5%90%8E%E6%84%9F/index.html"/>
      <url>/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E8%AF%BB%E5%90%8E%E6%84%9F/index.html</url>
      
        <content type="html"><![CDATA[<p></p><h1 align="center">人类简史读后感<p></p><h4 align="right">——猩球崛起：进化</h4><p>书中从四个方面按照时间顺序来阐述了人类从诞生到最后成为主宰世界的主人这一过程，那么到底是什么使得原来是猿人的我们最终成为超过了曾经和我们一样的动物，掌控了世界？</p><p>我们在一开始的时候，总是会从个体上去分析自己和大猩猩有什么区别。人们总是专注在自己和大猩猩有什么区别，但是如果想象一下，把一个普通人和一只大猩猩放在一座孤岛上，人没有办法活的像大猩猩一样的好，这看起来是一件十分正常的事情，个体生存能力如此薄弱，还能成为世界的主宰？估计这也是我们的祖先想不到的。</p><p>人类和其他动物的最大的不同就是人们的集体能力。不可否认，动物中也有集体能力极强的生物，一个蜂群的合作能力极强，但是不够灵活，如果一个蜂群遇到了突然的变故，没有什么办法能够让蜜蜂之间迅速得到一个高效的解决办法。他们不可能去杀死蜂后来建立一个共和国，也不能建立一个以工蜂为主体的社会。与此相对，大猩猩之间的合作已经十分接近人们了，但是很不幸，他们之间的合作只能够建立在小范围之间。因为大猩猩之间的合作必须是建立在大家都相互了解的基础上的，这也就决定了他们和合作网络不会很大。社会学研究指出，借由八卦来为维持的最大”自然”团体大约是150人。即使到了今天，人类的团体还是继续受这个神奇的数字的影响，大猩猩也是如此。</p><p>人类是世界上唯一一个能够同时具备在大范围内灵活合作的种群了。这也就是我们为什么能够成为世界的主宰的重要原因之一。我们能够迅速的改变行为，并将新的行为传给下一代。比如不生育的精英阶层就是一个很好的例子。你一定难以想象一万只黑猩猩聚集在天安门广场的景象，而这个地方却能容纳远多于一万多人。这正是由于人类之间能够遵守规则，灵活合作。</p><p>人类和其他动物的合作的不同还在于，人类之间的合作是有好有坏的，比较典型的例子像“战争”，“集中营”等，这些的本质也是合作，然而这些合作创伤了人类的内心世界。当然，诸如像家庭，学校这样的合作关系能够让人的心智走向成熟。<br>人类是如何能够进行如此大规模的合作呢？是因为人们相信一个共同的准则，这个准则是一种虚构的机制体系。由于大规模的人类合作是以虚构的故事作为基础， 只要改变所讲的故事，就能改变人类的合作方式。所以人类的合作方式是十分灵活的。</p><p>人类的生活在自己虚构的故事当中，而且当所有人都相信这个故事的时候，那么就会有神奇的事情发生，人们就能够产生稳定的合作网络，而且不需要像大猩猩一样要将合作建立在相互认识的基础上。这些故事遍布在我们的身边，从宗教、经济到政治都有他们的声音。</p><p>在宗教中，西方人大多都相信，这个世界上存在上帝，上帝总是在看着自己的所作所为。然而上帝是一个由牧师之类的人员虚构出来并且广为传播的一个故事，当大家都想相信了这个故事，也就有了宗教，不同的故事带来了不同的宗教和信仰，使得信仰同一个宗教的人们能够很好的合作，即使他们之前没有见过；在政治上，这样的概念也数不胜数，“国家”，“民族“，”人权“等等。这些东西同样是看不见摸不着的，是人们所创造出来更好的管理这个世界的。这也体现出人类和其他动物的很大的不同，你一定没有听说过哪一个除了人类的生物想要通过和种群之间的联系来建立起一个帝国，进而掌控这个时间。人类十分善于编造故事，为了使得”国家“这个虚构的故事更加可信，人们又构建出了身份证号，家庭，企业这些虚构概念，复杂了人们之间的合作网络，也就是使得关系更加具有粘性；在经济上，人们最伟大的发明就是货币了，货币作为一种信用体系，货币本身没有任何的使用价值，因为无法直接满足人们的基本需求，它不能吃，也没有观赏价值。这个时候，经济学家来告诉你这张有数字的纸和10个香蕉的价值等效，更加有意思的是，所有的人都相信这个故事，无一例外。于是我们可以拿着这个有数字的纸，走到超市，把钱给一个素不相识的店员就能够得到真正能来果腹的食物。人类的交易方式是最灵活可靠的，其他动物当然也有自己的交易方式，但是他们的交易的东西一定是有直接价值的，用香蕉换取桃子之类，而智人是唯一能够使用货币的动物，这也是人们相信虚拟故事的结果。使得我们能够站上世界权力的顶峰。</p><p>此外还有很多已经被我们习以为常的认为是非虚构的。我们没有经历过历史上那些风云人物经历过的事情，我们只是从书本上，人们口口相传得到的这样的讯息，从某种程度上来讲，我们知道的历史也是一种虚构的故事。但是人类对待事件的态度也是严谨的，所以才会有历史学家不断的考证历史。</p><p>人类经历的认知革命，农业革命，开始统一世界，最后发展出了科学革命。在这个过程中，人类发明出了很多能看见的，看不见的。</p><p>从认知革命以来，智人就一直生活在一种双重的现实之中。一方面，我们有像是河流，树木这种确实存在的客观现实；另一方面，我们也有像是神国家和企业这种想象中的现实。其他动物只是生活在客观世界中，他们的客观世界包含的是客观实体。人类能够主宰世界就是因为我们生活在这样的双重世界中，不仅有客观实体，还建立了由虚拟实体来构建的现实。并且随着历史的发展，我们所创造出的虚拟实体越来越强大，人们也无法摈弃，即使这些实体只是存在于自己的想象中。</p></h1>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>少有人走的路-M.Scott Peck</title>
      <link href="/%E5%B0%91%E6%9C%89%E4%BA%BA%E8%B5%B0%E7%9A%84%E8%B7%AF-m-scott-peck/index.html"/>
      <url>/%E5%B0%91%E6%9C%89%E4%BA%BA%E8%B5%B0%E7%9A%84%E8%B7%AF-m-scott-peck/index.html</url>
      
        <content type="html"><![CDATA[<p>文章在一开篇就提出了：<strong>几乎人人都有心理问题，只不过是程度不同而已；几乎人人都有不同程度的心理疾病，只不过得病的时间不同。</strong>只有直面自己的问题，心智才能变得成熟；如果逃避问题，心智就会停滞不前。</p><p>心智成熟的旅程不但是一项既复杂又艰巨的任务，而且是毕生的任务，其过程十分的漫长。</p><h2 id="自律"><a href="#自律" class="headerlink" title="自律"></a>自律</h2><p>自律是解决人生问题最主要的工具，也是消除人生痛苦最重要的方法。</p><p>作者在一开篇就告诉我们 <strong>人生苦难重重</strong>。只要我们能够真正理解并且接受这个事实，就可以从苦难中解脱出来。然而，大多数人都不愿意正视苦难，抱怨外界。当这些人面对困难的时候，大家的表现常常是：回避痛苦；拖延，希望痛苦自己消失；视而不见，假装不存在；用药物和毒品来麻醉自己。</p><p>解决困难最重要的方法就是自律，<strong>自律的程度决定了你解决问题的多少</strong>。自律有四大原则：<strong>推迟满足感、承担责任、忠于事实、保持平衡</strong>。而<strong>自律的原动力就是爱</strong>。</p><h3 id="推迟满足感"><a href="#推迟满足感" class="headerlink" title="推迟满足感"></a>推迟满足感</h3><p>不贪图暂时的安逸，先苦后甜。在充满问题和痛苦的人生中，推迟满足感是唯一可行的方法。比如先完成棘手的工作，或者是先把玩具让给其他的小伙伴，对待家庭作业的次序等等，将此培养成为习惯，内化于心，外化于行。</p><hr><p>当父母自律的时候才能够让自己的孩子也变得自律。”照我的话去做，但是不要学我”。之前提到自律的源动力是爱，爱是需要时间的付出的。所以要培养孩子学会自律，就需要投入足够的时间。聪明的父母在问题发生之前，他们就会花时间了解孩子，对症下药。</p><p>当孩子面临痛苦的抉择的时候，如果父母真心实意的和孩子一起承受痛苦和折磨，孩子一定能感受到。也许不会表现出来，但是可以提醒自己：“既然爸爸妈妈愿意陪着我忍受痛苦，痛苦也不见得那么可怕，而且也未必是太坏的事情。我也应该承担责任，面对属于自己的痛苦”——自律的起点。</p><p>对于自我价值的认可是自律的基础，因为当一个人觉得自己很有价值的时候，就会采取一切必要的措施来照顾自己。</p><p>让孩子养成推迟满足感的习惯，就必须要让与他们学会自律。要让他们学会自律的，对于安全感产生信任，不仅需要父母真心投入，还需要父母表里如一的爱和持之以恒的照顾。</p><hr><p>忽视问题的存在，反映出人们不愿意推迟满足感的心理。现在承受痛苦，将来就有可能获得更大的满足感；而现在不谋求解决问题，将来的痛苦就会更大，持续的时间也越长。</p><p>在孩子成长的过程中，恰当的给予指导和帮助，多了解他们的问题，必然是有益的事情。问题托的越久，越是积重难返，解决起来自然就更加艰难了。</p><h3 id="承担责任"><a href="#承担责任" class="headerlink" title="承担责任"></a>承担责任</h3><p>如果不能及时解决自己的问题，问题就会像山一样横亘在在我们的心中，自己的问题只有自己才能解决。</p><ul><li>神经官能症：为自己强加责任</li><li>人格失调症：不愿意承受原本就属于自己的责任</li></ul><p><strong>你不能解决问题，你就会成为问题</strong></p><p>作者在年轻的时候把自己的日程表安排的很满，然后觉得很累。在像自己的上司请教了之后，上司只是告诉他：这是你时间管理的问题，不是我的问题。这让年轻的作者十分生气。过了几个月之后，作者发现了：同事们选择了和我不同的工作方式，我就心怀不满，因为我完全可以像他们一样去安排时间。憎恨他们的自由自在，其实是在憎恨我自己的选择，可是这本是我引以为豪的一个选择。<strong>当他想通了之后，对于那些比他早下班的同时也就不在嫉妒。虽然他还是像以前一样工作，但是心态发生了本质的变化。</strong><br>对个人行为承担责任，难处在于它会带来痛苦，而我们却想要躲开这种痛苦。作者请求上司替我安排时间，其实是在逃避长时间工作的痛苦，而这正是我选择努力工作的必然结果。我向主任求助，是希望增加她对我的权利，我是在请求她，请为我负责吧，既然你是我的上司，力图把责任推给别人或是组织，就意味着我们甘愿处于附属的地位。把权力和自由拱手交给命运，社会政府，独裁者和上司。<br>为了躲开责任带来的痛苦，数不清的人甘愿放弃权力，实则是在逃避自由。[为什么就是逃避自由T_T]?</p><h3 id="忠于事实"><a href="#忠于事实" class="headerlink" title="忠于事实"></a>忠于事实</h3><blockquote><p>个人认为这一个部分写的很棒，用地图做比喻简直绝了。而且所有的的话语一针见血，直至核心。</p></blockquote><p>我们越是了解事实，处理问题就越是得心应手，对于事实了解的越少,思维就越是混乱。</p><p>我们对于现实的观念就是一个地图。地图会被不断的修订。只有地图准确我们才能了解人生的地形，沟壑，指引自己的前进的道路。我们不是在一出生的时候就带着地图，我们需要努力绘制自己的地图。而大多数人一旦过完青春期就放弃了对于自己的地图的绘制。这样的地图狭小、粗略而且肤浅，从而导致对于现实的认知过于狭隘和偏激。大多数人过了中年，就认为自己的地图完美无缺，世界观没有任何的瑕疵，甚至自认为神圣不可侵犯，而对于新的信息和资讯缺乏兴趣。只有极少数的幸运者能够继续努力，他们不停地探索，扩大和更新自己对于世界的认知，直到生命终结。</p><p>人生苦短，我们只想一帆风顺，我们由儿童成长为青年人，中年人乃至老年人，付出了不懈的努力，才会成了现在这幅关于人生观和世界观的地图，似乎各个方面都完美无缺。一旦新的信息与过去的观念发生冲突，需要对地图大幅修正，我们就会感到恐惧，宁可对于新的信息视而不见。我们的态度也变得十分奇特，不仅抗拒新的信息，甚至指责新的信息，混淆是非，说他们是异端邪说。我们想控制周围的一切，使之完全符合我们的地图。我们花费大量时间和精力去捍卫陈腐的观念。其消耗的时间与精力远比修订地图本身多的多，这是一件多么可悲的事情啊。</p><p>这里提出了移情的概念：把产生和适用于童年时期的那些感知世界、对于世界做出反应的方式，照搬到成年之后的环境中，尽管这些方式已经不在适用于新的环境。</p><p><strong>我们必须忠于事实，尽管这会带来暂时的痛苦，但是远比沉湎于虚假的舒适中要好，要让心灵或者获得成长，心智走线成熟，就要竭尽全力。不惜一切代价。完全忠于事实。</strong></p><h4 id="如何做到？"><a href="#如何做到？" class="headerlink" title="如何做到？"></a>如何做到？</h4><p>完全忠于事实的生活意味着我们要<strong>不间断的严格地反省自己。</strong>自我反省带来的快乐，甚至远远大于痛苦。</p><p>完全忠于事实的生活还意味着我们要<strong>敢于接受外界的挑战和质疑</strong>。当发现外界开始质疑我们的地图的时候，意味着我们的地图可能已经需要重绘制了，而接受挑战和质疑是重绘地图的最好的方法。</p><p>完全忠于事实还意味着我们<strong>要一辈子保持诚实</strong>。区别两种谎言：</p><ul><li>白色谎言：本身或许能反应事实，但是有意隐瞒大部分真相。</li><li>黑色谎言：彻头彻尾的说谎，所说的和事实完全不符。</li></ul><p>在日常交往中，我们有时候要开诚布公，有的时候要抑制表达想法和感觉的欲望。</p><h4 id="如何不违背忠于事实的自律精神"><a href="#如何不违背忠于事实的自律精神" class="headerlink" title="如何不违背忠于事实的自律精神"></a>如何不违背忠于事实的自律精神</h4><ol><li><p>永远不要说假话，避免黑色谎言。</p></li><li><p>要牢牢记住，除非是迫不得已，或者出于重大道德因素的考虑，否则不说出全部真相就等于说谎！</p></li><li><p>不可因为个人自私自利的欲望，例如满足权力欲，刻意讨上司的欢心，逃避修订心灵地图的挑战等等，而将部分真相隐瞒下来。</p></li><li><p>只有在对对方确有好处的情况下，才能有选择的隐瞒部分真相。</p></li><li><p>尽可能忠实的评估对方的需要，这是一件极为复杂的工作，只有以真爱为出发点，才能做出恰当的评判和选择。</p></li><li><p>评估的要点在于，对方能否借助我们提供的事实获得心灵的成长。</p></li><li><p><strong>需要铭记在心的是，我们通常会低估，而不是高估别人运用事实使心灵获得成长的能力。</strong></p></li></ol><h3 id="保持平衡"><a href="#保持平衡" class="headerlink" title="保持平衡"></a>保持平衡</h3><p>我们既要以追求诚实为己任，又要隐瞒部分事实和真相。</p><p>我们既要承担责任，也要拒绝不该承担的责任。</p><p>我们既要学会推迟满足感，先苦后甜，也要把眼光放得长远，同时尽可能过好当前生活。</p><p>所以保持平衡十分重要。</p><p><strong>保持平衡的最高原则就是放弃。</strong>失去平衡远比放弃更加痛苦。放弃是一种必须要掌握的技能，我们将他称为 <strong>兼容并包</strong>。得到的永远比放弃的多，<strong>自律的过程就是自我发展，自我完善的过程。</strong>放弃的痛苦是死亡的痛苦，但是旧事物的死亡带来的是新事物的重生。</p><h2 id="爱"><a href="#爱" class="headerlink" title="爱"></a>爱</h2><h3 id="什么是爱"><a href="#什么是爱" class="headerlink" title="什么是爱"></a>什么是爱</h3><p>是什么能够让我们自己愿意通过自我约束来承受人生的痛苦呢？是爱。爱是自律的原动力。</p><p>作者将爱定义为:爱是一种为了促进自己和他人心智成熟，而不断拓展自我的界限，实现自我完善的一种意愿。</p><ul><li>爱与非爱最重要的区别就在于当事人意识和潜意识是否一致。</li><li>爱是长期的，渐进的，双向的。我们付出的爱，不仅能让他人心智成熟，也会让自己获益。</li><li>真正意义上的爱，是爱自己也是爱别人。随着时间的推进，两者不但越来越近，其界限最后甚至会模糊不清，乃至完全泯灭。</li><li>爱要付出努力。努力不断拓展自我和他人界限的过程。</li><li>爱是要有实际行动的。爱一个人却没有付诸行动，就等于没有爱过。</li></ul><h3 id="人们对于爱的荒谬的认识"><a href="#人们对于爱的荒谬的认识" class="headerlink" title="人们对于爱的荒谬的认识"></a>人们对于爱的荒谬的认识</h3><p>把男女之爱当作坠入情网当作是爱，或者是一种爱的表现，这是不正确的。因为人们之所以坠入情网，是因为他们在潜意识里有一种性的冲动。其次，坠入情网的爱不会持久。</p><p>想要避免呆在一起之后，两个人出现矛盾和冲突的状态，两个人就要面对现实，学会真正的相知和相爱。</p><p>而坠入情网不算真正的爱原因如下：</p><ul><li>坠入情网不是出于主观上的意愿，不是有计划，有意识的选择。</li><li>坠入情网不是自我界限的扩展，而是自我界限部分的<strong>暂时</strong>的奔溃——认为自己和他人融为一体。当最初的激情褪去的时候，自我界限也就恢复了。留下的只有失落和幻想，所以心灵不会成长。而真正的爱，才能让自己的界限得到扩展，让心灵得到成长和完善，而且不在恢复原状。</li><li>坠入情网唯一的作用是消除寂寞，而不是有目的地促进心灵的成长。坠入情网会让自己觉得自己生活在了幸福的巅峰，以为人生无与伦比，开始对于对方的缺点视而不见（或者说觉得算不上什么），会觉得心智的成熟不那么重要，重要的是满足当前的满足感。而事实是：我们和爱人的心智都还不成熟。</li><li>坠入情网的本质是什么？作者认为和人的性欲有关，是人类内在性需求和外在刺激发生作用产生的典型的生理和心理反应。<strong>坠入情网是人类原始基因对于人类理性的征服。</strong></li></ul><hr><p>人们坠入情网往往会给我们给我们创造“爱情是永恒的”这一个幻觉，大多来源于那些浪漫的神话故事。</p><hr><p>坠入情网不是爱。作者在阐述这一观点到时候，给出了<strong>自我界限</strong>这一概念。作者认为真正的爱是一种拓展自我的体验，被自我界限之外的对象吸引，促使我们产生冲动，想把一切都献给对方（这种状态心理学家称之为<strong>“精神贯注”</strong>）。对于<strong>自我界限</strong>，我的理解是，自我界限是自己生活体验的总和，包含了自己的所见所闻，所思所感。而当我们遇到那些能够给我们带来没有经历过的体会的人的时候，或者这个人能够给我们带来自己一直想要拥有的体验的时候，我们就会开始坠入情网，我们尝到了自我界限消失的快乐，在这种坠入情网的激情退散之后，我们仍然会陶醉于这种感受，这会成为我们追寻真爱的诱因。<strong>坠入情网本身不是爱，但是却是爱的神秘架构中的最重要的一环。</strong></p><hr><h3 id="把依赖当成爱"><a href="#把依赖当成爱" class="headerlink" title="把依赖当成爱"></a>把依赖当成爱</h3><p>这种情感会出现在哪些人身上？</p><ol><li>情感失意而又十分沮丧的患者身上</li><li>幼年时期没有得到持续的爱（亲密关系一书中提到，没有得到持续性的爱，就会称为痴迷型人格）</li></ol><p>把对于他人的依赖当成的爱和真正的爱有几个区别：</p><ol><li>依赖产生的爱不在乎依赖的对象是谁，只需要有一个人能够填补自己的内心的空缺就可以了。而真正的爱是从一而终的，也是一种自由的选择，真正相爱的人不一定要生活在一起，只是选择生活在了一起。</li><li>对于他人依赖产生的爱，只是从他人那里汲取爱，自己却无法给予对方爱，是一种单向的自我满足。而真正的爱是双方都有值得被对方爱的地方，这种爱是相互的，存在的意义是扩展双方的自我界限，而不是只是对于自己的空虚的心灵的填补。</li><li>过分依赖的人只关注自己的需要和滋养，只在乎自己的感受，他们不关心自己的心智的成熟，也不关心别人的心智的成熟，哪怕是他们依赖的对象。</li></ol><hr><h3 id="精神关注"><a href="#精神关注" class="headerlink" title="精神关注"></a>精神关注</h3><p>在之前提到“精神关注”是一种被自我界限之外的对象吸引，促使我们产生冲动，想把一切都献给对方的体验。但是不是所有 精神关注都是爱，那些不能促进心智成长的，不能给心灵带来任何滋养的”精神关注“，都不是真正意义上的爱。</p><p>比如有的人爱金钱，有的人爱名利，他们愿意为了这些东西，把自己的一切都献给对方，产生了精神贯注的体验，但是金钱的积累，权力的巩固，不能意味着自己能够获得真正的拓展和完善（但是怎么知道自己是不是获得了真正的拓展和完善了呢？。所以此爱非彼爱。爱的唯一目标是促进心智的成熟和人性的进步。但是倘若人们爱金钱，爱名利的终极目标不是这些爱不见摸不着的东西，而是人。比如有的人投身政治，用自己的影响力来为人们谋求幸福。有的人努力赚钱，只是为了供子女上大学，或者用金钱来换取时间和自由，这样才有条件去学习。对于这些人来说，通过权力和金钱，未必不能实现爱的目标。</p><hr><p>本章中对于爱的定义是基于人的。<strong>大多数</strong>爱宠物，给他们最好的照顾，食物。一旦他们生病了，就可能放下一切的事情，带他们去看医生。但是人和人的关系与人和宠物之间的关系是不同的。首先，我们和宠物的沟通是有限的。我们总是把自己的想法和感受投射到他们的身上。其次，我们喜欢宠物的原因是，它们<strong>表现乖巧，任人摆布</strong>。但是对于人而言不是这样，我们容许人有自己的想法，而且爱一个人，就会容许这个人有自己的想法。最后，我们爱宠物是希望他们不要长大，希望宠物对自己有依赖性。</p><p><strong>真正的爱，不是单纯的给予，还包括适当的拒绝，及时的赞美，得体的批评，适当的争论，必要的鼓励，温柔的安慰和有效的敦促。</strong></p><h3 id="自我牺牲"><a href="#自我牺牲" class="headerlink" title="自我牺牲"></a>自我牺牲</h3><p>一个牧师由于在自己小的时候受到了父亲的虐待和不关心，所以他希望自己要做一个和父亲完全不一样的人。对于自己的妻儿有求必应，尽管自己不喜欢这样，自己美其名曰是对于妻儿的爱，但是事实上他只是为了维护自己是一个好丈夫，好父亲的形象，树立这一目的的动机是出于自己对于父亲的恨，而不是爱。</p><p>过分的爱还不如不爱，该拒绝的时候却一味的给予，不是仁慈，而是伤害。越俎代庖地去照顾本来有能力照顾自己地人，只会使对方产生更大的依赖，这就是对爱的滥用。</p><p>很多时候，我们自称为了别人着想，可能只是为了逃避某种责任，满足自己的愿望：我们所作的一切都是出于个人的意愿，核心动机是满足自我的需求；不管为了别人做了什么，真正的原因都是为了自己。<strong>真正的爱能够使人发生改变，在本质上是一种自我拓展，而不是自我牺牲。</strong></p><hr><p>爱不是感觉。</p><p>真正的爱不是忘乎所以，而是深思熟虑，是奉献全部身心的重大决定。它出自于自我意愿，只能依靠行动来证明。</p><p>到这里为止，作者提出了几个会被误以为是爱的东西，比如依赖，精神贯注，自我牺牲，爱的感觉等等。所以，接下来，进一步讨论一下爱究竟是什么？我们知道，自我拓展和实现自我完善是爱的目的。<strong>爱，最重要的体现形式，就是关注，而体现关注最常见，最重要的方式是努力倾听。</strong></p><hr><p>对于不同的人，要采用不同的倾听方式。一个6岁大孩子，很多时候只是自言自语，没有明确的意图，所以不一定需要倾听；有时6岁大的孩子渴望和父母亲近，与父母之间的亲密感大于了语言交流，这时可以假装倾听，而找到其中的平衡点很难。</p><p>在真正的倾听中，倾听者需要把暂时把自己的想法和欲望放在一边，努力去体会说话人的内心世界和感受。倾听是表达关注的最重要的形式，而其他形式的关注也同样重要，比如和孩子一起玩游戏，看电影，外出野餐，开车兜风，出门旅行，看球赛等等。这些关注都一个重要的特征：<strong>必须在孩子身上花足够多的时间</strong>。</p><p>对他人付出自己的关注和注意力，认真体会对方的问题和感受，这一切可能会枯燥乏味，让你感到不自在，甚至要花很大的精力，但是有一点是值得肯定的——着意味着真正的爱。</p><h3 id="爱也有风险"><a href="#爱也有风险" class="headerlink" title="爱也有风险"></a>爱也有风险</h3><p>爱意味着自我界限的拓展，也就是让自我拓展到未知的，全新的领域，再塑造一个不同的，崭新的自己，这一过程就是自我完善的过程。再拓展到未知的领域的过程中，我们会遇到很多陌生的人、事务和活动，都会让我们产生恐惧，这个时候我们最需要的就是勇气。在拓展自我的过程中，除了痛苦和悲伤，也会收获幸福和快乐。完整的人生一定伴随着痛苦，而其中最大的痛苦之一就是心爱之人或心爱之物的逝去。如果想要避免其中的痛苦，恐怕只有完全脱离现实，去过完全没有任何意义的生活。</p><hr><p>投入的爱越多，经受的风险也就越大，成长、独立就是其中之一。成长，意味着心智的成熟，而这也是爱的表现结果之一。心智的成熟需要突破自我的界限，还需要学会自尊自爱。尊重自我的个性和愿望，敢于冒险进入未知的领域，才能活得自由自在，使得心智不断的成熟，体验到爱的至高境界。</p><hr><p>如果童年时没有从父母那里得到爱，就会产生极大的不安全感，到了成年，就会出现一种特殊的心理疾病——他们总是先发制人的“抛弃对方”。</p><p>家长对于孩子的投入，其风险不仅在于投入的状态本身，也在于可能经历意想不到的挑战，甚至要对于以往的认识做大幅的修正。聆听子女的新生，满足他们的需要，而不是盲目坚守权威，颐指气使，才能有助于家长拓展自我，走向成熟，这对于双方都是有很大益处的。</p><hr><p>爱的最大风险就是发生冲突时的职责和假谦虚。我们常常以爱的名义去指责所爱的人。富有爱心的人，经常出于两难境地——既要尊重对方的独立性，渴望给予对方爱的指导。勤于自省才能走出这样的境地，自我反省的基本前提之一就是诚实和谦逊的态度。</p><p>经过反省，认为自己可能时正确的，在对他人提出批评，这个时候更加可能成功，不会有灾难性的后果。父母爱孩子，就必须指出孩子的错误，而且要采取谨慎而又积极的态度，他们也要允许子女指出自己的错误。</p><h3 id="爱和自律"><a href="#爱和自律" class="headerlink" title="爱和自律"></a>爱和自律</h3><p>自律的原动力来自于爱，而爱的本质是一种意愿。自律是将爱转换为实际行动的具体方法。所有的爱，都离不开自律，必然懂得自我约束。</p><p>爱和自律结合起来，才能体验到快乐的极致。真正的爱，会同时促进双方的心智成熟，体验到的快乐和幸福感也会更加从持久。</p><h3 id="爱与独立"><a href="#爱与独立" class="headerlink" title="爱与独立"></a>爱与独立</h3><p>爱者和被爱者都不是双方的附属品，每一个人都是一个独立的个体。在家庭中，家长也要将孩子看一个独立的个体，不能因为顾及自己的名利去要求孩子干一些事情。</p><p>不能接收所爱之人的独立性，就会给亲情和爱情带来危害。夫妻双方，只有更加独立，保持各自的情操和特性，而不是合二为一，才能够使婚姻生活更加美满。</p><h2 id="成长与信仰"><a href="#成长与信仰" class="headerlink" title="成长与信仰"></a>成长与信仰</h2><h3 id="信仰与世界观"><a href="#信仰与世界观" class="headerlink" title="信仰与世界观"></a>信仰与世界观</h3><p>通常，人们对于信仰的定义十分的狭隘。我们认为，拥有某种信仰，就意味着要相信神灵，加入某个信徒组织，举行某个宗教仪式。</p><p>在孩子的心目中，父母就像是神和上帝，父母的处理事情的方式，就是宇宙间的之高法则。孩子们对于神性的了解，往往来自于父母的人性——父母充满爱心，悲天悯人，孩子就会相信这个世界充满爱心。这样，即使到了成年，在他们的心中，世界任然和同年一样，充满爱和温暖。</p><h3 id="科学与信仰"><a href="#科学与信仰" class="headerlink" title="科学与信仰"></a>科学与信仰</h3><p>只有学习和进步，才能摆脱昔日的经验的限制。本书之之前提到过，爱的本质是拓展自我，而爱的风险之一就是就似乎必须进入未知的领域。所以我们要对于过去的信仰提出疑问，主动探索陌生的领域，挑战某些被视为真理的结论。我们要逐步以科学为信仰来代替父母发信仰。</p><p>有关科学的关键词有“真实”，“观察”，“知识”，“怀疑”，“经验”等。<strong>科学是以怀疑为基础的信仰，我们必须怀疑自以为了解的一切。</strong></p><hr><p>对于别人交给我们的一切，包括通常的文焕观念以及一切陈规旧习，采取冷静和怀疑的态度，才是心智成熟不可或缺的元素。</p><h2 id="恩典"><a href="#恩典" class="headerlink" title="恩典"></a>恩典</h2><p>恩典其实是一种普遍存在的现象，并且再一定程度上是可以预测的。</p><h3 id="潜意识的奇迹"><a href="#潜意识的奇迹" class="headerlink" title="潜意识的奇迹"></a>潜意识的奇迹</h3><p>要让心智成熟，我们要聆听潜意识的声音，让意识中对自己的认识更加接近真实的自己。</p><hr><p>心灵的成长，心智的成熟需要不断努力，而且必然是艰苦的过程，他必须与自然法则对抗。但是遗憾的是，我们却习惯于保持原状，热衷于使用陈旧的地图与陈旧的方法；我们习惯于走平坦的道路，害怕路上荆棘遍布。</p><hr><p>人们为了解释恩典与进化的奇迹，假设了上帝不仅存在，而且是爱我们的，希望我们成长的。这看上去很天真和简单，但是我们没有别的解释，我们不能因为无法解释就忽略显而易见的事实，绝不是正确的态度。</p><h3 id="熵与原罪"><a href="#熵与原罪" class="headerlink" title="熵与原罪"></a>熵与原罪</h3><p>知道目前为止我们在讨论心智的成熟，那么究竟是什么阻碍了心智的成熟呢？其中最大的障碍就是懒惰，我们只要克服了懒惰，其他阻力就能迎刃而解。我们总是想要必要的痛苦，习惯于选择平坦的道路，这是惰性使然，懒惰是爱的对立面，很多人的爱是虚假的爱，因为他们不愿意承受自我拓展和自我完善的痛苦。</p><p>所有人都是懒惰的，只是程度和表现的方向不一样。懒惰是我们内心熵的力量，在心灵进化的过程中，他始终与我们对抗着，阻止我们的心智走向成熟。懒惰的一个重要特征就是就x是恐惧感，并非所有的恐惧都等于懒惰，但是绝大部分恐惧都与懒惰有关。人们接收的新的信息是有威胁的（让我们感到恐惧），如果我们新收到的信息属实，我们就要花费大量的幸苦工作来修改自己的地图。我们对本能的抗拒，因为我们懒得去做大量的辛苦工作。</p><h3 id="邪恶的问题"><a href="#邪恶的问题" class="headerlink" title="邪恶的问题"></a>邪恶的问题</h3><p>邪恶是运用一切影响力组织他人心智成长和自我完善的行为。邪恶的人极力摧毁光明，善良和爱，以此来逃避面对觉醒的良知的痛苦。至少在目前，人类进化到这个阶段，邪恶是不可避免的。熵是一种强大的力量，是人性的恶的体现，然而在人类进化的巨大历史框架中，邪恶永远处于弱势地位。</p><p>邪恶之手曾把耶稣送上十字架，结果却使得人们从很远的地方就能看到耶稣的身影，从此团结一心，纷纷加入 对抗邪恶的战斗，邪恶本身也成为了推动人类心智成熟的一种有效的方式。</p><h3 id="意识的进化"><a href="#意识的进化" class="headerlink" title="意识的进化"></a>意识的进化</h3><p>我们的潜意识里蕴含着丰富的知识，潜意识知道的事情永远比意识多得多。我们获得的新的真理和启示，其实是意识和潜意识达成一致，获得了共同的认知。意识的成长和进步，意味着它开始认同潜意识里所熟识的一切。不妨把潜意识假想成是埋藏在地下的广袤根系，意识则是地面上矮小的枝干，吸收潜意识提供的养分。</p><h3 id="力量的本质"><a href="#力量的本质" class="headerlink" title="力量的本质"></a>力量的本质</h3><p>力量分为心灵力量和政治力量。政治的力量是以公开或者隐秘的方式，去强迫别人遵守自己的意愿。而心灵的力量是在意识基础上做出决定的力量，也就是意识的力量。</p><p>心灵汲取到足够强大的力量，固然令人感到愉快，同时也可能使人恐惧。<strong>一个人知道的越多，就越难采取行动。</strong>心灵力量的不断积累还会带来另一个问题就是<strong>孤独感</strong>。心智成熟度度接近顶峰的人，就像是一呼百应，权倾天下的王者。他们不可能推卸责任和过错，也没有人告诉他们应该怎么办。他们没有和自己处境和感受相当的人，以便容许自己释放压力，发泄痛苦。</p>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理学 </tag>
            
            <tag> 成长 </tag>
            
            <tag> 心智 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>亲密关系</title>
      <link href="/%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB/index.html"/>
      <url>/%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-人际关系的构成"><a href="#1-人际关系的构成" class="headerlink" title="1. 人际关系的构成"></a>1. 人际关系的构成</h2><h3 id="1-1-亲密关系的性质和重要性"><a href="#1-1-亲密关系的性质和重要性" class="headerlink" title="1.1 亲密关系的性质和重要性"></a>1.1 亲密关系的性质和重要性</h3><ul><li><p>亲密关系和泛泛之交<strong>至少</strong>在一下六点不同：</p><ul><li><strong>了解</strong>，如果人们认为自己的伴侣了解、理解并欣赏自己，其亲密程度就会增加</li><li><strong>关心</strong>，这意味着他们认同双方在生活上的融合，自称为“我们”，而不是“我”和“他/<br>她”</li><li><strong>相互依赖性</strong>，</li><li><strong>相互一致性</strong>，</li><li><strong>信任</strong>，</li><li><strong>承诺</strong>。</li></ul></li><li><p>在亲密关系中，包含有人的归属需要，如果这种需要得不到满足，就会发生各种各样的问题。</p></li></ul><h3 id="1-2-文化的影响"><a href="#1-2-文化的影响" class="headerlink" title="1.2 文化的影响"></a>1.2 文化的影响</h3><ul><li><p>随着时代的发展未婚先孕的比例，结婚的年龄和离婚的比例都在增加。</p></li><li><p>目前婚前同居的人们的想法是希望能够考察彼此是否真正能和睦相处。但是数据表明，如果两个人没有切实的结婚计划，未婚同居不能确保随后的婚姻幸福美满；相反，同居增加了夫妻离婚的危险。即使伴侣之间已经订婚，未婚同居还是会有一定的危害性。所以尽管同居很流行，但是越来越来的人去结婚。</p></li><li><p>影响亲密关系的根源</p><ul><li><p>西方文化中的 <strong>个人主义</strong>。当他们对婚姻不满意的时候，就会理直气壮的结束婚姻生活。</p></li><li><p>高科技（人工授精，体外受孕）等。</p></li><li><p><strong>性别比率</strong>：每100位女性对应多少男性。高性别比率的社会，偏向于男主外，女主内，更加保守。在性生活上也如此。而在低性别比率的社会则更倾向于颠覆传统，更加宽容。</p><p>有关系专家认为这种文化波动不是偶然。他认为社会规范的演变是用来满足强势的人群（男性）。所以当性别比例发生变化的时候，总会朝着有利于男性的方向发展。</p><p>当性比例高的时候，女性少。男性得到女性芳心之后就愿意长相厮守</p><ul><li>鼓励女子成为家庭主妇，在经济上依赖丈夫</li><li>反对离婚（20世纪60年年代）</li></ul><p>当性比例低的时候，妇女多，男人不太像被一个女人拴住。</p><ul><li>妇女工作，推迟结婚</li></ul></li></ul></li></ul><h3 id="1-3-个体经历的影响"><a href="#1-3-个体经历的影响" class="headerlink" title="1.3 个体经历的影响"></a>1.3 个体经历的影响</h3><p>人机关系还受到个体经历和经验的影响，最好的例子就是对于人际关系总体取向有重大影响的 <strong>依恋类型</strong></p><ul><li><p>儿童的三种依恋类型：</p><ul><li>当婴儿哭喊的时候，慈爱的照料者如约而至，得到此种呵护的宝贝就能舒心的依赖他人，觉得他人可以信任，从别人那里获得安全和友善。发展成<strong>安全型</strong>：快乐的与他人交往，很容易发展出轻松信任的人际关系。</li><li>如果大人对于孩子的照顾无法预测也不持续。孩子就会对他人产生焦虑复杂的情绪。发展成为 <strong>焦虑矛盾型</strong>由于不确定照顾者何时会来，与他人的关系就会表现出紧张和依赖，表现出对于他人的渴求。</li><li>如果大人在照顾孩子的时候有拒绝或者敌对的态度，孩子就会发展出<strong>回避型依恋</strong>。</li></ul></li><li><p>成人有四种依恋类型</p><ul><li><img src="/%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB/index/1_1.png"></li></ul></li></ul><ul><li><p><img src="/%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB/index/1_2.png"></p></li><li><p>我们不会被动的受到童年经验的束缚，既然依恋关系是可以习得的，也就可以改变。但是一旦确立的以后，既稳定又持久。</p></li></ul><h3 id="1-4-个体差异的影响"><a href="#1-4-个体差异的影响" class="headerlink" title="1.4 个体差异的影响"></a>1.4 个体差异的影响</h3><p>个体的差异对于人际关系也有影响，这里将探讨四种个体差异：</p><ul><li><p>性别差异</p><p>通过研究得出来一下三点结论：两性差异存在但是非常小；同性之间的差异<strong>远大于</strong>两性之间的<strong>平均</strong>差异；由于两性性别的行为和观点在正态分布上有很大的差异，以至于即使是平均得分低的性别中也有不少人的得分高于另一性别的平均得分。所以在不同性别中的相似性其实大于差异性，性别差异在个体差异中的权重其实没有那么大。</p></li><li><p>性认同差异</p><p>性认同差异是由教育和文化引起的两性在社会性和生理上的差异，是后天形成的，而性别差异是源于自身的自然天性。<strong>性别角色</strong>是诠释性认同差异的一个不错的例子，指的是社会文化期待男性应该更加具有<strong>工具性</strong>（自信，独立，有抱负，领导力，果敢），而期待女性更加有<strong>表达性</strong>（热情，温柔，有同情心，仁慈，敏感）。但是一切都表明，幸福，适应力强、有效率和心理健康的人士通常同时拥有二者。<strong>人们也更加偏向于拥有双性化特质的伴侣</strong>。</p></li><li><p>人格差异</p><p><img src="/%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB/index/1_3.png"></p></li></ul><p>  人格影响人际关系的程度远大于人际关系印象人格的程度。注意上图中排序是按照重要程度由低到高排序的。</p><ul><li><p>自尊差异</p><p>我们对于自己的认识来自于与他人的人际关系，并影响着人际关系的后续发展。</p><p>如果他人不喜欢我们，我们要喜欢自己非常困难，久而久之就会产生低自尊，这样的人有时就会低估伴侣对于他们的爱，以致于损害亲密关系。</p></li></ul><h3 id="1-5-人类本性的影响"><a href="#1-5-人类本性的影响" class="headerlink" title="1.5 人类本性的影响"></a>1.5 人类本性的影响</h3><p>探讨人类本性对于人际关系的影响，提出了三个演化心理学的基本假设。</p><ul><li>性选择（sexual selection）使人类成为今天这样的物种</li><li>演化心理学认为两性之所以存在差异，只是因为某种程度上他们在过去面临着不同的繁殖困境</li><li>文化影响决定了演化形成的行为模式是否具有适应性——并且文化的变化比演化快得多</li></ul><hr><p>人际关系对于人类有价值，但是也有代价。</p><h2 id="2-吸引力"><a href="#2-吸引力" class="headerlink" title="2. 吸引力"></a>2. 吸引力</h2><p>奖赏是吸引力的基础，人们为什么会被吸引？因为在和他人进行交往的时候会产生<strong>直接奖赏或者是间接利益</strong>。多数情况下，人们提供的直接奖赏越多，对我们的吸引力就越强。初次之外还有其他的因素会影响他人对于我们的吸引力。</p><h3 id="2-1-喜欢身边的人"><a href="#2-1-喜欢身边的人" class="headerlink" title="2.1 喜欢身边的人"></a>2.1 喜欢身边的人</h3><p>首先，人们会更加倾向于喜欢和自己临近的人。空间上的临近决定了我们是否会相遇。重复的接触他人会增加我们对他们的喜欢程度，而不会导致厌烦。</p><ul><li>原因之一是如果他人在我们身边，我们很容易得到他们提供的各种奖赏</li><li>空间上的临近也使两个人更可能相遇，彼此变得更加熟悉。</li><li>因为临近常常能导致熟识，而熟识又引起喜欢，所以与他人频繁的接触不仅能使交往更方便，而且会使对方看起来更有吸引力</li><li>我们往往更喜欢身边的人，然而如果他们令我们厌烦，那么临近只会雪上加霜。</li></ul><h3 id="2-2-喜欢长得可爱的人"><a href="#2-2-喜欢长得可爱的人" class="headerlink" title="2.2 喜欢长得可爱的人"></a>2.2 喜欢长得可爱的人</h3><ul><li><p>当然，长相吸引力也是很重要的一环。一般来说，我们倾向于认为外贸俊美的人更讨人喜欢，更好相处。研究表明，即使是新生儿也偏好成人认为漂亮的面孔。对于女性而言，大眼睛，小鼻子，尖下巴和丰满的双唇更加有吸引力。而男性的吸引力就比较复杂。拥有结实下颚和宽阔前额的男性——看上去坚强而有主宰力会被认为是帅哥；稍微有一点女性化的男性也很有吸引力。当女性处有排卵前的受孕期，会绝对不修边幅，有男子特征的面孔更加有吸引力；在其他时间更加喜欢青春型、具有孩子气特征的男性面孔。</p></li><li><p>越平均和对称的脸更加会影响到面孔的美丽。平均化的面孔就是更加有吸引力。对于身材而言，腰臀比例为0.7和姚胸比例为0.75的女性更加会吸引男性。<strong>然而对于男性而言，光有好的身材并不能吸引女性，除非他还有其他资源；只有当他能挣一份体面的薪水的时候，他的身材才会影响女性对他的评价。</strong>从身高来说，162的男性每年必须多赚221000美元才能和186的男性一样吸引女生的注意。长发的女性比短发的女性更加有吸引力。最后，男女两性都认为传红色衣服的约会对象更加有吸引力。</p></li><li><p>红色的衣服更加吸引人，红色的衬衫和红色的裙子。</p></li><li><p>文化在吸引力的方面也有作用，比如只有在全世界都富足的情况下，人们才会认为苗条的女子更加迷人。</p></li><li><p>美丽：交织着代价和收益。俊美之人常常能和他人愉快的交往，但是不如长相平庸的人那么信任别人。因为他人的表扬也许具有不确定性。如果你非常有吸引力，你或许永远无法确定别人赞美你是因为欣赏你的能力还是喜欢你的长相。</p></li><li>长相吸引力的匹配。已确定爱情关系的伴侣，他们的长相吸引力往往是类似的；即他们的容貌是相匹配的。这种现象称为匹配</li></ul><h3 id="2-3-喜欢那些喜欢我们的人"><a href="#2-3-喜欢那些喜欢我们的人" class="headerlink" title="2.3 喜欢那些喜欢我们的人"></a>2.3 喜欢那些喜欢我们的人</h3><p>对于未来伴侣的期望值 = 伴侣外表的吸引力 ✖伴侣接纳自己的可能性。</p><p>我们期望伴侣接纳自己的可能性大小很大程度上和自己的<strong>适配价值</strong>即作为生殖伙伴的综合吸引力有关。被他人拒绝和接纳的经历教会我们在接近新的恋爱对象时所应有的期望。</p><blockquote><p>研究表明，对于男性而言，最好的搭讪女生的方式就是简单的问好，而不是用一些看似幽默的话来搭讪。而男性喜欢女性先主动示好，不会在乎女人只用什么样的开场白，这就使得他们会反过来高估女人对幽默开场白的喜欢程度。</p></blockquote><ul><li><p>人们会更加愿意接触那些有接纳自己和喜欢自己可能性的人。当我们不太确定他人是否会接纳我们时，大多数人都不愿意去冒被拒绝的风险。</p></li><li><p>最好接纳那些挑剔讲究的恋爱对象，对于每个人都表露出愿意接纳的人，最后成功的概率并不高。所以，有选择的故作清高——也就是说，除了你想吸引的人之外，任何人想要得到你都是遥不可及的。</p></li></ul><h3 id="2-4-喜欢那些与我们相似的人"><a href="#2-4-喜欢那些与我们相似的人" class="headerlink" title="2.4 喜欢那些与我们相似的人"></a>2.4 喜欢那些与我们相似的人</h3><p>人类吸引最基本的准则之一：相类似的人彼此吸引对方。</p><p>首先就是在年龄、性别、种族、教育程度、宗教信仰和社会地位等<strong>人口统计学</strong>上的相似，<strong>态度</strong>和<strong>价值观</strong>的相似以及<strong>性格</strong>的相似。</p><p>即使相像达到一定程度之后，吸引力并不会下降，所以“共同点太多”并没有什么危险</p><ul><li>相异并不相吸。我们已经认识到人们倾向于和那些长相相像的人配成一对。但另一方面，长相明显不般配的情况有时也会发生。名望、财富、健康、才能和长相等等都像商品一样，能用来吸引心仪的伴侣。</li></ul><h3 id="2-5-障碍：得不到的就喜欢"><a href="#2-5-障碍：得不到的就喜欢" class="headerlink" title="2.5 障碍：得不到的就喜欢"></a>2.5 障碍：得不到的就喜欢</h3><p>最后一个影响吸引力的因素是人们努力克服障碍以实现期望的基本倾向。</p><p>罗密欧与朱丽叶效应：父母越是干涉子女的恋爱自由，他们彼此之间就会更加相爱。</p><p>打烊效应：在酒吧快要打烊，所有人都准备回家，如果这个时候在寻找一个约会对象，你会发现潜在的对象越来越有吸引力。</p><h3 id="2-6-两性期望的理想伴侣"><a href="#2-6-两性期望的理想伴侣" class="headerlink" title="2.6 两性期望的理想伴侣"></a>2.6 两性期望的理想伴侣</h3><p>在寻找短期的情人的时候，大家都不会过多的苛求什么。然而在彼此都在谋求一个相伴一生的伴侣的时候：</p><p>女人往往确保丈夫<strong>至少有点</strong>金钱会让前途，然后再来寻找尽可能多的热情，友善，诚实，坦率，稳定，幽默智慧等等。金钱和财富是女人所渴求的，但是不如高水平的热情和忠诚重要，长相排在第三位。</p><p>男人往往首先确保妻子有普通的长相，然后再来寻找尽可能多的热情，友善，诚实，坦率，稳定，幽默智慧等等。绝世美颜是男人所渴求的，但是不如高水平的热情和忠诚重要，社会资源和经济资源屈居第三位。</p><h2 id="3-社会认知"><a href="#3-社会认知" class="headerlink" title="3. 社会认知"></a>3. 社会认知</h2><p>同一个事实可以有很多不同的解释。但不论你选择何种解释，你的判断都可能非常重要。其结果是你的认知既可能巩固也可能损害你们之间的关系。</p><p>本章我自始至终都会强调人们对同伴关系知觉和解释的重要性：<strong>认知决定了人们的感受和行动</strong>。</p><p>社会认知指的是我们理解社会现象的知觉和判断过程。</p><h3 id="3-1-第一印象极其影响"><a href="#3-1-第一印象极其影响" class="headerlink" title="3.1 第一印象极其影响"></a>3.1 第一印象极其影响</h3><p>人们对于不同类型的人群都持有刻板化的第一印象。根据刻板印象做出的判断往往<strong>非常不准确</strong>，但却<strong>又很难避免影响</strong>，甚至有时还<strong>意识不到他们的存在</strong>。只要与他人交往，我们就会不断的妄下结论。</p><p>人们对于他人的判断受到<strong>首因效应</strong>的影响，从而使最先获得的信息印象深刻，即时影响和刻板印象一起，塑造出他人的整体印象。第一印象会微妙的影响人们<strong>选择和使用</strong>后来获得的信息。人们常常会表现出<strong>验证者偏差</strong>，会去寻找那些能够证明自己的正确信息，而不是那些证明自己错误证据。</p><p>随着时间的增加和经验的积累，对伴侣的了解会加深。亲密程度的标志之一就是对伴侣私人情况的了解，随着伴侣彼此熟悉程度的增加，第一印象肯定会发生变化。</p><p>人们对于自己的人际关系的知觉并不像自己认为的那样超然客观，准确无误。并且不管这种认知是对是错，对于后来的亲密关系中的情感和行为都有相当大的影响。并且人们不能准确的知道自己解释行为的原因，比如对于同一个人，参与者双手拿的饮料的温度也会左右他们的判断。</p><h3 id="3-2-知觉的力量"><a href="#3-2-知觉的力量" class="headerlink" title="3.2 知觉的力量"></a>3.2 知觉的力量</h3><p>人们很少意识到自己持有的观点往往都是<strong>通过选择而采纳的</strong>，这种选择进而会促进或妨碍亲密关系的满足。</p><h4 id="伴侣的理想化"><a href="#伴侣的理想化" class="headerlink" title="伴侣的理想化"></a>伴侣的理想化</h4><p>现实中和理想中的人总是有一些差距的，我们要如何与自己的恋人快乐相处？</p><p>方法1: 建立对伴侣善意和大度的认知，突出他们的美德而缩小他们的缺陷。以积极错觉来评价对方，尽可能用积极的眼光来表述伴侣。但是同时也要注意积极错觉与现实不符合的程度会决定这种积极错觉是否会带来危险。随着对于对方的理解越来越深入，不断的调整自己对于理想伴侣的期望，这样伴侣期望的标准就能够契合伴侣的现状。当我们以积极错觉来评价对方的时候，对方也能够感受到，同时也积极错觉来评价我们，实现双赢。</p><hr><h4 id="归因过程"><a href="#归因过程" class="headerlink" title="归因过程"></a>归因过程</h4><p>人们的喜怒哀乐还受到解释伴侣行为时所选择理由的影响。归因（attribution）就是指人们对事情发生的原因（特别是指人为什么要做或者不做某件事情）提出的解释。</p><p>人际关系的归因研究发现三个普遍存在的现象。</p><ol><li><p>伴侣之间随着深入的了解，仍然会受到<strong>行动者/观察者效应</strong>的强烈影响。他们对自己行为的解释，与对观察到的伴侣的类似行为的解释完全两样，即便是在同样的环境下，也总是会将自己的行为归结为外部压力，而把对方的行为归结为对方自己的原因。比如在吵架的时候都会认为是对方的原因，并且觉得对返回也是这么想的，这种归因的差异是很难被意识到的。如果伴侣有意识地去努力了解对方的观点，行动者/观察者效应就会减少，但是不会完全消失。<strong>所以及时交换看法是十分重要的，因为即使是最亲密的伴侣也很少能够真正理解你所有行为的原因。</strong></p></li><li><p>尽管伴侣之间有真爱，但是依然会存在<strong>自我服务偏差</strong>，欣然把成功归因于自己，而极力推脱自己在失败中的罪责。但是如果伴侣认为他们非常亲密，彼此的自我服务偏差就比与其他人相处要少得多。这一现象有意思的地方是，人们都能估计到他人存在自我服务偏差，而看不到自己也存在。大多数人都能轻易地认识到别人对功劳过分的自居，对失败苍白的托词；但却认为自己类似的自我服务偏差明智而准确。这部分地是因为即使在自己的善良意图没有实现的情况下，人们仍能清醒地意识到它，并给予充分的肯定；而判断别人则仅仅依据他们的行为，完全无视他们行动的意图。<strong>所以对于没有实现的善举不要居功自傲，但是也要时常明确表现出自己的好心好意，让对方感受到。</strong></p></li><li><p>伴侣双方总的归因模式能决定亲密关系的满意程度。幸福的爱人对伴侣行为都是能改善关系的。认为伴侣的积极行动都是刻意的，习惯的，还能据此推断伴侣在其他情境下的行为。<strong>幸福的配偶</strong>对彼此的积极行为都通常给以内部的，稳定的，普遍的归因。他们也倾向于淡化彼此的过失，认为他们是偶然的，特殊的和局部的。因而，消极的行为都通过外部的、易变的、特定的归因而得到谅解。</p></li></ol><hr><h4 id="关系信念"><a href="#关系信念" class="headerlink" title="关系信念"></a>关系信念</h4><ul><li><strong>浪漫信念</strong><ul><li>浪漫信念中的一些不好的观念：<ol><li>争吵具有破坏性。争吵就表明伴侣爱自己还不够深。如果彼此深深相爱，就不会发生任何争执。</li><li>“读心术”很重要。真正彼此关爱的伴侣仅凭直觉就能知道对方的需要和偏好，根本不需要告知对方自己的所思所想。如果必须告诉伴侣自己的想法和愿望，那只能说明伴侣爱自己还不够深。</li><li>伴侣是不会发生改变的。一旦亲密关系变糟，就无法得到改善。如果爱人曾伤害过你，毫无疑问还会一而再，再而三地伤害你。</li><li>每一次的性生活都应该是完美的。只要爱情是忠贞的，每一次的性生活都应该是神奇美妙、令人满足的。伴侣应该经常渴望并为性生活做好准备。</li><li>男人和女人就是不一样。男人和女人的性格和需要非常不同，很难真正理解对方。</li><li>美好姻缘天注定。根本无需努力来维护美满的夫妻关系。夫妻要么彼此脾性相投、快乐到老，要么格格不入、争执一生。</li></ol></li><li>具有这种观点的人只会更加的愿意结束不幸福的亲密关系而不是努力的修复亲密关系。</li></ul></li><li><strong>宿命信念</strong>：认为伴侣要么是天造地设的一对，婚姻生活注定幸福美满；要么不是冤家不聚头，婚姻生活注定痛苦悲惨。这样的爱情往往出现在电影里。</li><li><strong>成长信念</strong>：假定幸福的亲密关系乃是辛勤维护的结果。幸福的关系是努力和付出的回报，如果伴侣一起努力战胜挑战、克服困难，良性的亲密关系就能逐渐建立起来。其<strong>基本假设</strong>是：只要努力付出，几乎任何亲密关系都能取得成功。</li></ul><h3 id="3-3-印象管理"><a href="#3-3-印象管理" class="headerlink" title="3.3 印象管理"></a>3.3 印象管理</h3><p>不论我们是否能意识到，我们总是在进行着印象管理，试图影响别人对我们的印象。有时我们会仔细地选择自己的动作、言语、穿着和背景，企图给他人留下精心策划的好印象；甚至会仔细挑选自己的好友以呈现某种公共形象。</p><hr><h4 id="印象管理策略"><a href="#印象管理策略" class="headerlink" title="印象管理策略"></a>印象管理策略</h4><ul><li><strong>逢迎讨好策略</strong>：寻求他人的接纳和喜欢，尽量显得自己充满魅力，讨人喜欢。这种印象管理策略在恋人中是常用的。</li><li><strong>自我推销策略</strong>：希望自己的能力得到他人的认可和尊重，描述自己的成就，公开展示自己的技能。在职场中常用。在求职面试中，逢迎讨好策略和自我推销策略一起使用是效果最好的。</li><li><strong>恐吓策略</strong>：把自己描绘成无情、危险和凶恶的形象，以使他人顺从自己。这样的行为令人反感，会使人避而远之。</li><li><strong>恳求的策略</strong>：人们看上去显得无能或体弱，以逃避责任或求取他人的帮助和支持。</li><li>如果你曾经做出姿态，让伴侣知道你对某事很生气或者伤心，以此来达到自己的目的，就分别用到了恐吓或恳求策略</li></ul><hr><h4 id="亲密关系中的印象管理"><a href="#亲密关系中的印象管理" class="headerlink" title="亲密关系中的印象管理"></a>亲密关系中的印象管理</h4><p>亲密关系中的印象管理有两个特点：</p><ol><li><p>人们管理印象的动机存在个体差异，这种差异具有重要的影响。</p></li><li><p>尽管我们给好友和恋人营造的印象比为熟人或陌生人营造的更为重要，但是为了维持良好的形象，我们在前者所花的心思通常不如后者。</p><p>人们在谈恋爱时，凭借优雅的举止赢得浪漫伴侣的爱情后，却再也不肯努力在爱人面前保持风度（这或许是许多亲密关系中存在的重大问题，在第6章<strong>相互依赖</strong>我们会详细探讨）。</p></li></ol><h3 id><a href="#" class="headerlink" title=" "></a> </h3><h2 id="4-沟通"><a href="#4-沟通" class="headerlink" title="4. 沟通"></a>4. 沟通</h2><p>我们常常认识不到，传递者的意图和对接受者产生的影响并不相同，这就是我们所面临的<strong>人际隔阂</strong>。</p><h3 id="4-1-非言语沟通"><a href="#4-1-非言语沟通" class="headerlink" title="4.1 非言语沟通"></a>4.1 非言语沟通</h3><p>非语言沟通的功能：</p><p><img src="/%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB/index/5_1.png"></p><h4 id="非语言沟通的组成"><a href="#非语言沟通的组成" class="headerlink" title="非语言沟通的组成"></a>非语言沟通的组成</h4><ol><li><strong>面部表情</strong>  即使人们试图控制自己的表情，仍然会泄露真实的情绪。</li><li><strong>注视行为</strong>  居于支配地位的人在交往中会坚持，“我跟你说话时要看着我！”，但通常不会反过来也给予对方同样多的视觉注意。</li><li><strong>身体动作</strong>  身体的姿势或动作传达的信息虽不太明确，却仍很有用。</li><li><strong>身体接触</strong>  </li><li><strong>人际距离</strong>  人际距离都是测定人际交往亲密程度的巧妙手段，甚至能用来间接衡量人际关系的质量：不幸福的配偶比满意的配偶保持的人际距离更大。</li><li><strong>副语言</strong>  副语言指除了言语过程中的词语之外，个体发出的各种声音特征，如节奏、音调、音量和速度，比如说话时气喘、嗓子沙哑或者尖溜、哧哧笑、整句话带鼻音、某个字音拉得很长、结结巴巴说话不连贯等等。</li></ol><h4 id="非言语的敏感性"><a href="#非言语的敏感性" class="headerlink" title="非言语的敏感性"></a>非言语的敏感性</h4><p>非言语沟通不良的夫妻往往对婚姻不太满意。而且如果出现这类问题，一般都是丈夫的过错。</p><h3 id="4-2-言语沟通"><a href="#4-2-言语沟通" class="headerlink" title="4.2 言语沟通"></a>4.2 言语沟通</h3><h4 id="自我表露"><a href="#自我表露" class="headerlink" title="自我表露"></a>自我表露</h4><p>向他人透露个人信息的过程就是自我表露，它是亲密程度的指标之一：如果两个人彼此之间不共同拥有一些相对秘密的私人信息，他们的关系就称不上亲密。</p><p><img src="/%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB/index/5_2.png"></p><p>两个人要变得亲近，必须满足三个条件：</p><ul><li>首先，他们必须进行有意义的自我表露</li><li>其次，他们必须对彼此的个人信息有兴趣和同理心，在异性恋的关系中如果男性能做到这一点尤其有价值（Mitchell et al.，2008）</li><li>最后一点很重要，双方必须都认识到另一方具有应答性。</li></ul><p>即使人际关系变得非常亲密，人们也可能保留一些只属于自己的秘密。亲密的自我表露和选择性地保留一些秘密都能促成婚姻的美满。</p><p>亲密关系中禁忌话题越多，伴侣间的满意度就越低，除非他们认为避开敏感话题能改善和保护他们的亲密关系因为怯懦或能力不足而逃避讨论，会降低伴侣的满意度，但有礼貌地一起努力维持伴侣关系很少有什么不好的影响。</p><h4 id="言语沟通中的性别差异"><a href="#言语沟通中的性别差异" class="headerlink" title="言语沟通中的性别差异"></a>言语沟通中的性别差异</h4><p>至此我们还没有发现男女两性的言语沟通存在巨大的差异。但这里有个差异很重要：在已确立的人际关系中，女性比男性表现出更多的自我表露。男性对女性较为开放，女性彼此之间也较为开放，但男性不怎么对其他男性进行自我表露。</p><h3 id="4-3-沟通障碍及其应对"><a href="#4-3-沟通障碍及其应对" class="headerlink" title="4.3 沟通障碍及其应对"></a>4.3 沟通障碍及其应对</h3><h4 id="沟通不良"><a href="#沟通不良" class="headerlink" title="沟通不良"></a>沟通不良</h4><ul><li>首先，不幸福的伴侣在表述意图上表现得很糟糕。如果他们抱怨某事，很少能准确到位；相反，他们倾向于数怨并诉。</li><li>其次，不幸福的伴侣在彼此倾听方面也表现得很糟糕。</li><li>不幸福的伴侣还会进行反向抱怨，避开对方关注的问题，只用自己的抱怨来应对伴侣的抱怨，而不是对伴侣所说的话表示关注。</li><li>最后，不幸福的伴侣在交谈时常常表现出消极情感。他们常常对伴侣的抱怨报以讽刺挖苦，贬低和鄙视伴侣的人格。</li></ul><p>如果我们感到愤怒、憎恨或焦虑，或许会发现自己正在进行反向抱怨、数怨并诉或者其他诸如此类的行为。如何避免这些沟通陷阱呢？这要根据情境而定，我们或许需要表达更为清楚、不太有火药味的信息，更好地倾听，保持冷静和礼貌，有时这三条都需要做好。</p><h4 id="精确表述"><a href="#精确表述" class="headerlink" title="精确表述"></a>精确表述</h4><p>尽可能清楚明白、详细具体地指出惹怒我们的特定行为，伴侣间的沟通就会变得更为明智、准确。这样不仅能告诉伴侣自己的想法，还能把谈话重点集中在可处理的、单独的某个行为上，而行为比人格更容易改变。</p><h4 id="积极倾听"><a href="#积极倾听" class="headerlink" title="积极倾听"></a>积极倾听</h4><p>在沟通中当我们接受到他人的信息时，有<strong>两个重要</strong>的任务要完成。第一是要准确地理解对方话语所表达的意思，第二是要向对方传达关注和理解，让他知道我们对他的话是在意的。这两个任务都可以通过<strong>复述</strong>接受到的信息而完成，即用自己的话重复对方的意思，让信息的传递者有机会肯定那就是他真正想要表达的意思。</p><h4 id="守礼而镇定"><a href="#守礼而镇定" class="headerlink" title="守礼而镇定"></a>守礼而镇定</h4><p>幸福的伴侣偶尔也有这样的行为——大多数的亲密关系中都可能会发生尖酸刻薄的蔑视——但是他们比起不幸福的伴侣能更快地摆脱这些恶性循环。</p><p>实际上，在争吵不断升级之初就进行化解是非常有益的，但却不太容易做到。因而，在被伴侣激怒的时候能保持清醒，在开始生气的时候能冷静下来，都是非常可贵的技能。</p><p>当然，人在被激怒的时候很难保持平静，镇定地思考。所以只要有可能就应该事先允诺与伴侣彼此以礼相待，这也是（试着）减少使人愤怒的事件的好方法。</p><h4 id="尊重和确认的力量"><a href="#尊重和确认的力量" class="headerlink" title="尊重和确认的力量"></a>尊重和确认的力量</h4><p>良好的沟通包括很多构成要素：有意识地努力传递清晰、直接的信息，认真倾听，即使出现争执仍保持礼貌和克制等等。<strong>但最关键的要素却是明确地表现我们对伴侣观点的关心和尊重。</strong>对伴侣的确认，即承认他们观点的合理性，表达对他们立场的<strong>尊重</strong>，一直是亲密交往中值得拥有的目标。</p><p>确认并不需要你一定与伴侣观点一致。即使与伴侣的观点相左，你也能对其观点表示适当的尊重和认可。</p><p><img src="/%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB/index/5_3.png"></p><h2 id="5-相互依赖"><a href="#5-相互依赖" class="headerlink" title="5. 相互依赖"></a>5. 相互依赖</h2><h3 id="5-1-社会交换"><a href="#5-1-社会交换" class="headerlink" title="5.1 社会交换"></a>5.1 社会交换</h3><p>相互依赖理论认为，人们就像购物那样在人际商厦里浏览。所有人都在寻找最合意的商品。我们在寻求以<strong>最小代价</strong>获取能提供<strong>最大奖赏价值</strong>的人际交往，我们只会与那些能提供足够利益的伴侣维持亲密关系。不过，由于每个人都这样做，所以亲密关系中的伴侣双方都必须满足自己的利益，否则亲密关系不可能持续下去。</p><h4 id="奖赏和代价"><a href="#奖赏和代价" class="headerlink" title="奖赏和代价"></a>奖赏和代价</h4><p>人际交往中的奖赏指的是，我们与他人接触时所获得的令人高兴的经验和物品。交往中所有令人沮丧或苦恼的后果都是代价。</p><p>某一特定的人际交往所带来的奖赏和代价之和就是结果，即：结果=奖赏-代价</p><p>相互依赖理论的一个深刻的观点就认为，人际交往的结果是正还是负并不重要，重要的是我们评价结果的两个标准。第一个标准是我们的期望，第二个标准是假如没有现在的伴侣，我们认为自己会过得怎样。</p><h4 id="人际关系的期望收益"><a href="#人际关系的期望收益" class="headerlink" title="人际关系的期望收益"></a>人际关系的期望收益</h4><p>相互依赖理论假定每个人都有一个与众不同的比较水平（CL），并且是建立在过去经验的基础之上，是测量我们对关系满意程度的标准。如果人们曾有过奖赏价值很高的伴侣关系，就可能有较高的CL，表明他们现在还期望并觉得自己理应得到非常好的交往结果。相反，如果过去经历过困难重重的亲密关系，那么他们的期望和CL都会很低。</p><p><strong>结论：</strong> 即使你在与他人的交往中仍有所收益，如果这一收益没有大到足够满足你的期望，你仍不会感到幸福。</p><p>满意度来自交往结果和比较水平之差，即：结果- CL =满意度</p><h4 id="人际关系的替代收益"><a href="#人际关系的替代收益" class="headerlink" title="人际关系的替代收益"></a>人际关系的替代收益</h4><p>对亲密关系的满意程度并不是决定我们要保持或离开关系的主要因素，这一观点是相互依赖理论的<strong>最有趣最深刻</strong>的发现之一。</p><p>相互依赖理论的另一个重要假设是，<strong>满意度并不是唯一的、甚至也不是决定亲密关系持续与否的最主要的影响因素</strong>。无论我们是否乐意，我们都会用到第二个标准，即替代的比较水平（comparison level for alternative，$CL_{alt}$ ).  $CL_{alt}$是指如果我们抛弃目前的亲密关系，而转投可以选择的更好的伴侣或情境，所能得到的交往结果。</p><p>可以把 $CL_{alt}$视为亲密关系的全部结果，即个体认为把所有因素考虑在内，更换伴侣所产生的净盈亏。如果结束当前的伴侣关系、投入新的替代关系的整个过程有希望获得更好的结果，个体就会放弃原来的亲密关系。这只是经济学的常理。</p><p><strong>问题是要算清这些盈亏非常困难.</strong> 比如对现有亲密关系的投入，也就是亲密关系结束的时候个体会失去的事物，包括有形的物品也有无形的心理收益，比如他人的关爱和尊重。此外， $CL_{alt}$作为主观的产物，个人的自尊，习得性无助等等也会有所影响。人们如果不喜欢自己或者过去在一段不好的亲密关系，那么就会低估自己和伴侣的相处的前景。</p><p>所以，我们应该记住，计算 $CL_{alt}$是个复杂的评判过程，包括离开亲密关系的代价——如投入的损失——和他人产生的诱惑，这样就得到：</p><p>结果 - $CL_{alt}$ =依赖度</p><blockquote><p>总结来说：人们在交往中得到的净盈亏就是他们关系的结果。如果他们的结果超过期望，或者CL，他们就感到满意；然而如果现有的亲密关系结果不如他们的期望（即结果低于CL），他们就不满意。此外，如果人们当前的结果好于从别处能得到的结果（即他们的结果超过他们的$CL_{alt}$），他们就依赖于现在的伴侣，不太可能离开。然而，如果他们从现在的伴侣处得到的结果比他们从别处能获得的结果更差（他们的结果降到$CL_{alt}$以下），他们就会倾向独立，很可能离开当前的伴侣。</p></blockquote><h4 id="人际关系的四种类型"><a href="#人际关系的四种类型" class="headerlink" title="人际关系的四种类型"></a>人际关系的四种类型</h4><p><img src="/%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB/index/6_1.png"></p><h4 id="与时俱变的比较水平"><a href="#与时俱变的比较水平" class="headerlink" title="与时俱变的比较水平"></a>与时俱变的比较水平</h4><p>因为比较水平是建立在我们过去经验的基础上，所以它往往会随着我们得到的关系结果而不断波动。当我们最初得到非常好的关系结果时，我们会非常愉悦，但随着我们开始把这些好处视为理所当然，CL开始升高时，我们的愉悦感会渐渐地减少。这样一来，即使没有任何改变（除了我们的期望），具有奖赏意义的亲密关系也会逐渐变得越来越不满意。</p><p>文化的变化也会增加我们的$CL_{alt}$水平。女性更多地参与到劳动大军中，一方面可以接触到有趣的同事，另一方面拥有一定的经济资源，从而能让她们更容易离开不幸福的亲密关系。加上反对离婚的法律、宗教和社会障碍正在逐渐消除，大多数情况下人们有更多的选择机会，有更多可得到的替代伴侣，同时离婚的代价在不断下降。</p><h3 id="5-2-亲密关系的经济论"><a href="#5-2-亲密关系的经济论" class="headerlink" title="5.2 亲密关系的经济论"></a>5.2 亲密关系的经济论</h3><p>相互依赖理论把浪漫的亲密关系功利化了。<strong>亲密关系中的奖赏和代价不是亲密关系中的一切，过于在意奖赏和代价会使我们忽视其他影响伴侣关系成败的重要因素。</strong></p><p>计算亲密关系的奖赏和代价，能为关系的现状和未来提供非同寻常的信息。亲密关系中的负面行为比相同数量的正面行为有着更大的心理影响力。实际上，要保持满意的亲密关系，我们或许需要保持至少5:1的奖赏-代价比率。 所以，奖赏和代价对亲密关系的满足和稳定都有重要影响，要想亲密关系兴旺繁荣，<strong>需要更多的奖赏而不是减少代价</strong>。不过伴侣可能不认为对方做的意图良好的事情是特别体贴的，也有可能对方没有注意到他们的爱人的表达爱心和温情的行为。研究发现发现两性对其伴侣所说的正面行为的注意还不到四分之一。</p><h4 id="奖赏的作用不同于代价"><a href="#奖赏的作用不同于代价" class="headerlink" title="奖赏的作用不同于代价"></a>奖赏的作用不同于代价</h4><p>奖赏和代价对亲密关系的影响是各自独立，彼此相异的。寻求奖赏时，我们企图满足自己喜好体验的欲望，即<strong>接近动机</strong>。我们渴望逃避代价的是另一种不同的驱力，即<strong>回避动机</strong></p><p>关注亲密关系这两种动机的理由：</p><ol><li>这两种动机时相互独立的，所以这两种动机的满足于不满足会产生四种伴侣关系，可以参照上图。</li><li>强烈的、回避代价的动机会使人们注意到伴侣所做的所有烦心之事，而接近奖赏的动机却会使人们关注伴侣采取的所有体贴和慷慨之举。具有强烈接近动机的人（很少有孤独感，容易感到满足）愿意追求和伴侣更多的亲密感；他们对自己的行动感觉良好，其亲密关系也就能获益。相形之下，具有回避动机的人会努力避开冲突；他们很吝啬，不愿意做出些许牺牲，其亲密关系也就会受损。</li></ol><p>如果想要亲密关系兴旺繁荣，快乐充实，我们需要做的不仅仅是避开痛苦的冲突和其他代价。我们还要还要克服沉闷的亲密关系：必须尽力满足他们的接近目标，为伴侣提供快乐的、有趣的、兴奋的经验。这一结论也是人类动机的<strong>自我延伸模型</strong>的核心思想。该理论认为，能扩展我们的兴趣、技能和经验的伴侣关系就能吸引我们。所以伴侣熟络起来之后也要寻求新奇的活动和挑战，保持快乐的关键是创造性地发现持续你个人成长的方法，从而消除关系的沉闷。</p><h4 id="与时俱变的奖赏和代价"><a href="#与时俱变的奖赏和代价" class="headerlink" title="与时俱变的奖赏和代价"></a>与时俱变的奖赏和代价</h4><p><img src="/%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB/index/6_3.png"></p><p>成功的亲密关系在熬过动荡的过渡期后，伴侣作为配偶的新身份得到了认可。随着亲密关系继续发展，满意度开始重新但却缓慢地增加。</p><p><img src="/%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB/index/6_4.png"></p><p>能区分婚姻幸福和欢乐减少的夫妻的因素有很多，不过主要的是幸福的配偶会控制其欲望，所以他们的CL不会太高。如果你求全责备，期望过高，就很难得到满足。<strong>对亲密关系之未来保守而慎重的期望远比浪漫的理想主义更明智和理性。因为人们通常不能维持步入婚姻时的那种亲密关系结果。理由如下：</strong></p><ol><li>缺少努力。进入亲密关系之后人们就不会在努力取保持风度翩翩。</li><li>相互依赖的放大镜作用。我们花了大量的时间与亲密伴侣共处，依赖对方以得到独特的、宝贵的奖赏，这就意味着他们肯定会比其他任何人带给我们更多的挫折感——即使是出于无心的。</li><li>对敏感信息武器的了解。亲密意味着伴侣了解你的秘密、缺点和劣势。如果发生冲<br>突，这些就是伴侣用来嘲笑和伤害我们的武器。</li><li>不受欢迎的意外。<ol><li>第一种是了解了那些我们自以为已知事情的真相。结婚之初你知道甚至乐见自己的爱人爱好玩乐、天真率直，但在婚后数年当你要疲于应付抵押贷款、养育孩子时，爱人同样的行为就显得不负责任、轻浮多变和不可信赖。</li><li>第二种是获悉了那些你根本不知道的令人讨厌的事情。比如孩子出生之后，冲突会增多，对婚姻的满意度会减少。</li></ol></li><li>不现实的期望。亲密关系与我们想象中的快乐无忧、亲密无间的田园似的婚姻生活相去甚远。</li></ol><h3 id="5-3-亲密关系中的贪婪"><a href="#5-3-亲密关系中的贪婪" class="headerlink" title="5.3 亲密关系中的贪婪"></a>5.3 亲密关系中的贪婪</h3><h4 id="相互依赖的实质"><a href="#相互依赖的实质" class="headerlink" title="相互依赖的实质"></a>相互依赖的实质</h4><p>根据相互依赖理论，人们都想以最小的代价获得最大的奖赏，总是想得到最好的人际交易。相互依赖理论认为，在追求美满的关系结果时，个体应经常对自己所依赖的人宽容大度，因为这样做合乎情理（而且很有价值）。如果伴侣双方都想亲密关系持续，双方都应该深思熟虑地保护和维持对方的幸福。</p><h4 id="交换关系与共有关系"><a href="#交换关系与共有关系" class="headerlink" title="交换关系与共有关系"></a>交换关系与共有关系</h4><p><strong>交换关系：</strong>由外在的公平交换规范调节。人们为他人付出期望得到同等的回报。交换关系多为陌生人或一般熟人之间的关系，其典型的特征是肤浅、短暂、很大程度上是任务导向的。</p><p><strong>共有关系：</strong>伴侣特别关注对方的幸福，彼此不期望任何回报地支持和关照对方。在共有的亲密关系中，人们常会为伴侣做出一些小牺牲，彼此帮对方的大忙，结果是他们享受到更高质量的亲密关系。</p><p><img src="/%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB/index/6_5.png"></p><p>由于我们信任伴侣并预期关系将持续，所以我们也能等待更长时间以得到奖赏。在这个意义上来看，交换和共有的伴侣关系都是“交换”的关系，人们都期望自己得到的利益能配得上自己的付出；只不过在共有关系中交换的形式不同，表现得更不明显而已。</p><h4 id="公平关系"><a href="#公平关系" class="headerlink" title="公平关系"></a>公平关系</h4><p>公平理论扩展了社会交换的理论框架。根据公平理论，只有在伴侣贡献较多而同时也得到较多时，亲密关系才是公平的。</p><h4 id="承诺的本质"><a href="#承诺的本质" class="headerlink" title="承诺的本质"></a>承诺的本质</h4><p>令人欣慰的是，对亲密伴侣的幸福依赖可以孕育承诺，即持续亲密关系的意图。</p><p>把承诺视为一种复杂的决策过程，这一做法是与著名的承诺理论,即投入模型相一致的投入模型认为在以下三种情况下人们希望与现有的伴侣保持亲密：<strong>感到幸福（满意水平）；没有其他更好的选择（替代伴侣的质量）；离开的代价太高（投入数量）</strong>。</p><p><img src="/%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB/index/6_6.png"></p><p>投入模型将承诺视为整体单一的概念。不过社会学家迈克尔·约翰逊就宣称实际上存在三种类型的承诺：</p><ol><li>个人承诺（通常是最强烈的），即人们受到伴侣的吸引、亲密关系令人满意，而希望关系继续时表现出的承诺。</li><li>强迫承诺，即因为离开关系的代价过高，人们觉得不得不继续现有关系时表现出的承诺。</li><li>第三种道德承诺来自对伴侣或者亲密关系的道德责任感。</li></ol><h4 id="承诺引起的后果"><a href="#承诺引起的后果" class="headerlink" title="承诺引起的后果"></a>承诺引起的后果</h4><p>承诺的特征之一是指向长期发展，这能减少亲密关系遭遇坎坷时产生的痛苦。如果人们认为他们的亲密关系会长久发展，就能很好地容忍一时出现的低奖赏和高代价。</p><p>不过，承诺引起的最重要的结果可能是，它会使人们采取行动以保护和维持亲密关系，即使这样做的代价很高。</p><ol><li>承诺会促进顺应性行为。具有顺应性的人能容忍伴侣的破坏性行为而不还击；他们吞下侮辱、嘲讽或自私的恶果而不报复。</li><li><p>承诺的人还表现出更大程度的牺牲意愿。</p></li><li><p>承诺会改变人们对伴侣关系的认知。详而言之，他们认为在亲密关系中比别人享有更多的奖赏、付出更少的代价。认为自己的亲密关系比别人的要好。</p></li></ol><h2 id="6-友谊"><a href="#6-友谊" class="headerlink" title="6. 友谊"></a>6. 友谊</h2><h3 id="6-1-友谊的本质"><a href="#6-1-友谊的本质" class="headerlink" title="6.1 友谊的本质"></a>6.1 友谊的本质</h3><p>如果配偶和朋友都在身边，那将是最美好的时光。但如果两者只能择一，朋友带来的快乐和兴奋往往比配偶带来的要多。</p><h4 id="友谊的属性"><a href="#友谊的属性" class="headerlink" title="友谊的属性"></a>友谊的属性</h4><p>深厚的友谊虽然不如爱情充满激情，但仍然具有奖赏价值，包含着亲密关系的所有其他组成部分。下面我们就来看看友谊的这些成分。</p><hr><p><strong>尊重</strong></p><p>最亲密的朋友往往是我们尊重的人。当我们自信地认为朋友会仁慈地对待我们，无私地考虑我们最大的利益时，我们就对他们产生了信任。</p><hr><p><strong>资本化</strong></p><p>在资本化的交往模式中，我们常常能和朋友分享好消息，得到有益于紧密关系的热烈而有价值的反应。</p><p>具有资本化特征的人际关系通常比资本化不足的人际关系更令人满意、持续的时间也更长。</p><hr><p><strong>社会支持</strong></p><p>我们获得的援助或社会支持有4种。表现为关爱、接纳和安慰等形式的感情支持；表现为拥抱或搂抱的身体安慰；表现为资讯和指导形式的建议支持；和表现为金钱或物品的物质支持或有形援助。</p><h4 id="友谊的规则"><a href="#友谊的规则" class="headerlink" title="友谊的规则"></a>友谊的规则</h4><p>虽然我们通常不会在内心详细阐述朋友的含义，但大多数人都会有一套人际关系的规则（rules for relationships），这种规则即是朋友应（或不应）履行某些行为的共同文化信念。</p><p><img src="/%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB/index/6_7.png"></p><h3 id="6-2-友谊的毕生变化"><a href="#6-2-友谊的毕生变化" class="headerlink" title="6.2 友谊的毕生变化"></a>6.2 友谊的毕生变化</h3><p>社会情绪选择理论的观点认为，随着有生之年变得越来越屈指可数，老年人交际的目标指向友谊的质量而非数量；他们更注重精选出的深厚友情，不愿发生冲突，而让更普通的朋友关系自然消失。</p><p>该理论预测：任何人，只要认为自己的未来不长久，就会花更多的时间与少数几个亲密好友相处，而不是把时间用来和各种各样的普通朋友交往。</p><h3 id="6-3-友谊的差异"><a href="#6-3-友谊的差异" class="headerlink" title="6.3 友谊的差异"></a>6.3 友谊的差异</h3><p>友谊不仅在整个生命周期中有变化，在不同的个体之间和伙伴之间也存在差异。</p><h4 id="同性友谊中的个体差异"><a href="#同性友谊中的个体差异" class="headerlink" title="同性友谊中的个体差异"></a>同性友谊中的个体差异</h4><p>女性的友谊是“面对面”，而男性的友谊则是“肩并肩”。女性之间的友谊往往比男性更亲切、紧密。最终结果是，女性在爱情关系之外仍会向朋友寻求敏感、体贴的理解和支持，而男性常常做不到这点。为什么男性之间的友谊不如女性那样亲密？社会对这种男性同性亲密的接纳程度远低于女性，所以他们不会这样做。传统的教养鼓励男性应该具有工具性而非表达性的特质。</p><h4 id="友谊的个体差异"><a href="#友谊的个体差异" class="headerlink" title="友谊的个体差异"></a>友谊的个体差异</h4><p>除了性别效应之外，还存在其他影响友谊的个体差异。其一就是我们在第4章中谈到的<strong>自我监控</strong>。高自我监控者在友谊中的投入往往比低自我监控者更少；低自我监控者的朋友数量较少，但彼此有着更多的共同点，他们的友谊一般看来更加亲密。</p><p>另一个影响社交网络的个体特征是性取向。。只有约六分之一的异性恋者（知道他们）有朋友是GLB，但80%的GLB有亲密的异性恋朋友。</p><h3 id="6-4-友谊发展的障碍"><a href="#6-4-友谊发展的障碍" class="headerlink" title="6.4 友谊发展的障碍"></a>6.4 友谊发展的障碍</h3><h4 id="羞怯"><a href="#羞怯" class="headerlink" title="羞怯"></a>羞怯</h4><p>几乎任何人都会不时地受到羞怯的困扰。当我们置身于陌生的环境，第一次见到有魅力、地位高的陌生人时，很容易产生羞怯，但是当我们在熟悉的环境下与老友交往时，则不太可能会感到羞怯。</p><p>与坦荡的人相比，他们具有三个特征。首先，惯常羞怯者害怕别人的负面评价。其次，他们倾向于怀疑自我。最后，在与人交往的过程中，他们会感到自己能力不足，有时还能找到充分的理由。</p><p>具有讽刺意味的是，无论人们的羞怯是暂时性或习惯性的，只要他们胆怯畏缩，就会给人留下负面印象，而这恰恰是他们与人交往时希望避免的。</p><p><img src="/%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB/index/6_8.png"></p><h4 id="孤独"><a href="#孤独" class="headerlink" title="孤独"></a>孤独</h4><p>孤独与独处并不是一回事；在完全独处的状态我们通常也能感到满足。</p><p>孤独有着不同的层面。其一是社会隔离，指的是我们不满于缺少朋友和熟人的社交网络而引起的孤独；其二是情感隔离，指的是我们缺乏深厚的人际关系而引起的孤独。</p><p>要克服孤独，我们就应该寻求新的友谊，而不是爱情，尽力使自己显得友好。</p><h2 id="7-爱情"><a href="#7-爱情" class="headerlink" title="7. 爱情"></a>7. 爱情</h2><p>在20世纪末，西方文化下的年轻人还坚持认为浪漫爱情是婚姻的必须条件。不过现在人们都会觉得爱情是婚姻比不不可少的一部分，也就是如今大部分人们会拒绝与自己并不爱恋但是各个方面都完美的伴侣结婚。</p><h3 id="7-1-爱情简史"><a href="#7-1-爱情简史" class="headerlink" title="7.1 爱情简史"></a>7.1 爱情简史</h3><p>许多年来，人们对爱情的态度体验至少在以下四个方面有所变化：</p><ul><li>文化价值：爱情是值得拥有的还是可有可无的情感体验？</li><li>性欲：爱情应该有性行为还是与性无关？</li><li>性取向：异性之间和同性之间都能相爱吗？</li><li>婚姻状况：爱情只专属于婚姻，还是可以保留给第三者？</li></ul><p>在古希腊，人们认为，爱情是一种疯狂；爱情与婚姻几乎没有关系；最完美的爱情发生在同性之间。</p><p>在古埃及，人们认为爱情并不需要有性接触。</p><p>在12世纪的欧洲，人们认为爱情是高贵的精神追求。</p><p>在12-17世纪，人们认为爱情是注定要破灭的。</p><p>在17-19世纪，欧洲人认为爱情可以是幸福美满的。</p><p>在今天，世界上局部人会认为爱情和婚姻相伴相随。</p><h3 id="7-2-爱情类型"><a href="#7-2-爱情类型" class="headerlink" title="7.2 爱情类型"></a>7.2 爱情类型</h3><p>罗伯特·斯腾伯格认为各种不同的爱情都能由三个构成成分组合而成：</p><ol><li><p><strong>亲密</strong>，包括热情、理解、沟通、支持和分享等爱情关系中常见的特征。</p></li><li><p><strong>激情</strong>，其主要特征为性的唤醒和欲望。</p></li><li><p><strong>承诺</strong>，指投身于爱情和努力维护爱情的决心。</p></li></ol><p>如果<strong>三角理论</strong>对浪漫爱情的描述是正确的，则浪漫之爱的主要成分之一——高水平的激情——可能难以持续。不过要想知道爱情是否能持续，还需考虑许多因素。</p><p><img src="/%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB/index/7_1.png"></p><p>在生理学的角度看，费希尔认为存在三种既相互联系又截然不同的生物系统控制着爱情成分。</p>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理学 </tag>
            
            <tag> 人际关系 </tag>
            
            <tag> 情感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的心灵成长旅程</title>
      <link href="/%E6%88%91%E7%9A%84%E5%BF%83%E7%81%B5%E6%88%90%E9%95%BF%E6%97%85%E7%A8%8B/index.html"/>
      <url>/%E6%88%91%E7%9A%84%E5%BF%83%E7%81%B5%E6%88%90%E9%95%BF%E6%97%85%E7%A8%8B/index.html</url>
      
        <content type="html"><![CDATA[<p>心灵的成长是人生中一次伟大的改变，派克在《少有人走的路——心智成熟的旅程》这一本书中告诉我们人生是一场艰辛之旅，心智成熟的旅程相当漫长。“人生苦难重重”勇于承担责任，敢于面对困难，才能使心灵变得健康。</p><p>心理健康课程的目的就在于让我们能够在心智成熟的旅程上不断前进，告诉我们在不同的年龄时间，在旅途上回遇到的困难和磨难。在20来岁的年纪，无非就学业上的压力，情感上的不知所措。我更加想要分享自己的恋爱故事。</p><p>心智的成熟就是能够处理好自己人生中的种种苦难，自律就是自己心智成熟的一个伟大的见证，因为自律就是以积极而主动的态度去解决人生痛苦。而自律的原动力就是爱。</p><p>在这个年纪，人总是对于事物充满了好奇心，想要体验爱情的酸甜苦辣。在我刚刚谈恋爱的时候，总是想要去包容对方，去满足对方的要求，这样她快乐了我也会开心，以至于这样的状态持续了一段时间之后，我无法再快乐起来了，这样的状态会让我感觉到疲惫和不堪负重。突然间有一种为他人而生活的感觉了。在这样的关系中，我还会有一种感觉就是，将爱情看作了一种对等的付出，希望双方的付出是相同的。比如我对于游戏不感兴趣，她在一个游戏中买了一个皮肤，其实我对于此没有什么兴趣，我知道在关系中及时的赞美是十分重要的，但是我认为赞美是需要有一定的了解基础的。我赞美她新买的皮肤好看，但是我自己不了解这个皮肤能给她带来什么样的游戏体验，这样的赞美又是否有效果呢？当我和她说自己去医院做核酸检测的时候骑自行车的时候摔了一跤，自行车也断了的惨状的时候，回复也很平淡，没有关心的话语，但是我应该俏皮的说“你都不关心我\doge”之类的，但是我一直告诉自己，也许她只是没有想到吧。</p><p>后来分手的时候，她说我们认识的时间太短了，确实，我们认识一个月左右就确定在一起了。分手后的一段时间里面我还是很伤心的，但是之后我也发现了自己在这段感情中也及其不成熟，没有深入了解对方就莽撞了。有人说，喜欢的是一类人，而爱只是一个人。对于一个人的情感在这个世界上是无法再次被复刻的，就像小王子的那朵玫瑰花。</p><p>究竟什么才是爱？真正的爱的本质之一，就是希望对方拥有独立自主的人格。真正的爱不是单纯的给予，还包括适当的拒绝、及时的赞美、得体的批评、恰当的争论、必要的鼓励、温柔的安慰、有效的敦促。这是我后来才懂得的道理。</p><p>在一个美满的爱情中，需要的是对于对方独立人格的尊重与保护，在确定彼此都有好感之后，在确定关系之前，一定要给自己和对方缓冲的机会，可以出去约会呀，看电影，一起短途旅游之类的。在这当中，可以发现双方在遇到问题的时候是否能够合作默契的解决，双方的价值观，行为方式是否一致。刚刚开始的相互吸引是从外貌，言行开始的，但是之后的吸引一定是建立在心灵的沟通上。</p><p>在心理课上讲的恋爱心理学不过是表面。真正实践的时候还是会有很多的困难，倘若所有的知识在课本上读了就学会，那还有什么意思嘛！更何况是涉及到心智成熟的旅程呢？</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>长沙之旅</title>
      <link href="/%E9%95%BF%E6%B2%99%E4%B9%8B%E6%97%85/index.html"/>
      <url>/%E9%95%BF%E6%B2%99%E4%B9%8B%E6%97%85/index.html</url>
      
        <content type="html"><![CDATA[<p>以此片来纪念一下长沙之旅。</p><p>2021/5/1-2021/5/5</p><p>一号早上10点49分的高铁，我从津南和他们回合。放张合照，懒得一一介绍了。</p><center class="half">    <img src="/%E9%95%BF%E6%B2%99%E4%B9%8B%E6%97%85/index/Blog\source\_posts\长沙之旅\3.png" width="33%/"><img src="/%E9%95%BF%E6%B2%99%E4%B9%8B%E6%97%85/index/Blog\source\_posts\长沙之旅\5.png" width="33%"> </center><p>一切都很顺利，直到中午12点左右，高铁停了一会，当时天真善良的我们还没有意识到事情的严重性。直到广播里面响起了熟悉的提示音，但是紧接的不是“尊敬的旅客您好，本次列车是绿色车厢……”，而是“由于天气原因，本次列车晚点30min，全体车组人员对给您带来的不便表示诚挚的歉意。”然后噩梦开始了，</p><p>“由于天气原因，本次列车晚点60min…”</p><p>“本次列车晚点95min…”</p><p>“晚点两个小时”</p><p>”三个小时“</p><p>没错，最后晚点了三个小时，原本在晚上六点半就该到站的，结果到了晚上11点才到站。</p><p><img src="/%E9%95%BF%E6%B2%99%E4%B9%8B%E6%97%85/index/Blog\source\_posts\长沙之旅\2.png" width="48%"></p><p>到了酒店收拾了一下就去吃饭了。在八碗湘吃的，第一个上的菜是爆炒肥肠，没想到这个菜是接下来几个菜里面最辣的。还有就似乎不得不说，感觉湘菜里面的肉都切的好小，不过瘾，但是入味。要是我烧菜放这么多辣椒一定会被认为是富家子弟吧\^_\^​</p><center class="half">    <img src="/%E9%95%BF%E6%B2%99%E4%B9%8B%E6%97%85/index/Blog\source\_posts\长沙之旅\6.png" width="33%/"><img src="/%E9%95%BF%E6%B2%99%E4%B9%8B%E6%97%85/index/Blog\source\_posts\长沙之旅\7.png" width="33%"><img src="/%E9%95%BF%E6%B2%99%E4%B9%8B%E6%97%85/index/Blog\source\_posts\长沙之旅\8.png" width="33%/"> </center><h2 id="5-2"><a href="#5-2" class="headerlink" title="5/2"></a>5/2</h2><ul><li>早上吃米粉</li><li>橘子洲</li><li>无中饭，去了7mall吃了一盏灯</li><li>晚上ktv</li></ul><p>早上10点起床去楼下吃了粉条，有点小贵，而且味道一般。但是谁吃的最香就不用我多说了吧:dog: </p><p>[假装有一张粉的照片]</p><p>吃过早饭以后，阿皮就去排茶颜悦色了。</p><p><img src="/%E9%95%BF%E6%B2%99%E4%B9%8B%E6%97%85/index/Blog\source\_posts\长沙之旅\9.png"></p><p>感谢阿皮在30+的温度下排了一个多小时的队伍，终于喝到了第一杯茶颜悦色呜呜呜~</p><p><img src="/%E9%95%BF%E6%B2%99%E4%B9%8B%E6%97%85/index/Blog\source\_posts\长沙之旅\10.png"></p><p>然后就是去橘子洲啦~</p><p>真的走了好长好长好长。到了之后合完影在亭子里面休息到大概4 5点吧，吃着从墨茉点心局买的糕点，唠嗑。在进橘子洲的入口还看到了婚礼哎，妙:frog:</p><p><img src="/%E9%95%BF%E6%B2%99%E4%B9%8B%E6%97%85/index/Blog\source\_posts\长沙之旅\11.png"></p><p><img src="/%E9%95%BF%E6%B2%99%E4%B9%8B%E6%97%85/index/Blog\source\_posts\长沙之旅\12.png"></p><p><img src="/%E9%95%BF%E6%B2%99%E4%B9%8B%E6%97%85/index/Blog\source\_posts\长沙之旅\13.png"></p><p>一盏灯的晚饭~</p><p>也没有想象中的那么辣，可能是我们没有点很辣的，我们点的最辣的也就是一颗星的辣度。</p><p>testword</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL ALTER TABLE中改变数据类型时USING的用法</title>
      <link href="/postgresql-alter-table%E4%B8%AD%E6%94%B9%E5%8F%98%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%97%B6using%E7%9A%84%E7%94%A8%E6%B3%95/index.html"/>
      <url>/postgresql-alter-table%E4%B8%AD%E6%94%B9%E5%8F%98%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%97%B6using%E7%9A%84%E7%94%A8%E6%B3%95/index.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/winkey4986/p/6274729.html">原文链接</a></p><p><strong>在修改表字段类型的时候使用Using来进行显示的转换类型。</strong></p><p><strong>原文说明：</strong></p><p>SET DATA TYPE<br>　　This form changes the type of a column of a table. Indexes and simple table constraints involving the column willbe automatically converted to use the new column type by reparsing the originally supplied expression. The optional COLLATE clause specifies a collation for the new column; if omitted, the collation is the default for the new column type. The optional USING clause specifies how to compute the new column value from the old; if omitted, the default conversion is the same as an assignment cast from old data type to new. <strong>A USING clause must be provided if there is no implicit or assignment cast from old to new type.</strong></p><p>　　大致意思是：转换类型的时候有隐含类型转换的时候，会自动转换，如果没有，那么就必须使用using指定一下转换规则。</p><p><strong>1. 建表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="number">101</span>(id <span class="type">integer</span>);</span><br></pre></td></tr></table></figure><p><strong>2. 插入数据</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb10 <span class="keyword">select</span> generate_series(<span class="number">1</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p><strong>3. 把id的int变为varchar</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">alter</span> <span class="keyword">table</span> tb101 <span class="keyword">alter</span> id type <span class="type">varchar</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span></span><br></pre></td></tr></table></figure><p>因为int转varchar有隐式的转换，故可以自动转换过去。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">postgres=# \d tb101</span><br><span class="line"><span class="code">          Table &quot;public.tb101&quot;</span></span><br><span class="line"><span class="section"> Column |       Type        | Modifiers </span></span><br><span class="line"><span class="section">--------+-------------------+-----------</span></span><br><span class="line"><span class="code"> id     | character varying |</span></span><br></pre></td></tr></table></figure><p><strong>4. 把id的varchar变为int</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">postgres=# <span class="keyword">alter</span> <span class="keyword">table</span> tb101 <span class="keyword">alter</span> id <span class="keyword">type</span> <span class="type">int</span>;</span><br><span class="line">ERROR:  <span class="keyword">column</span> &quot;id&quot; cannot be <span class="keyword">cast</span> automatically <span class="keyword">to</span> <span class="keyword">type</span> <span class="type">integer</span></span><br><span class="line">HINT:  Specify a <span class="keyword">USING</span> expression <span class="keyword">to</span> <span class="keyword">perform</span> the <span class="keyword">conversion</span>.</span><br></pre></td></tr></table></figure><p>在没有隐式的转换下，就需要指定Using来显示的转换。</p><p><strong>5. 使用Using进行类型转换</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">postgres=# <span class="keyword">alter</span> <span class="keyword">table</span> tb101 <span class="keyword">alter</span> id <span class="keyword">type</span> <span class="type">int</span> <span class="keyword">using</span> id::<span class="type">int</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span></span><br><span class="line">postgres=# \d tb101</span><br><span class="line">     <span class="keyword">Table</span> &quot;public.tb101&quot;</span><br><span class="line"> <span class="keyword">Column</span> |  <span class="keyword">Type</span>   | Modifiers </span><br><span class="line"><span class="comment">--------+---------+-----------</span></span><br><span class="line"> id     | <span class="type">integer</span> | </span><br></pre></td></tr></table></figure><p>id::int 也可以使用cast(id as int)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>KMP</title>
      <link href="/kmp/index.html"/>
      <url>/kmp/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="KMP算法简介"><a href="#KMP算法简介" class="headerlink" title="KMP算法简介"></a>KMP算法简介</h2><p><strong>定义：</strong> 在串中寻找字串（第一个字符）在串中的位置。</p><p><strong>注意：</strong> 在这个算法中有两个问题要考虑：</p><ol><li>这个位置是指索引（下标）还是小标加一（位置）。</li><li>字符串的第一个位置，也就是<code>S[0]</code>是否要存放长度。</li></ol><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><h3 id="S-0-表示字符串长度"><a href="#S-0-表示字符串长度" class="headerlink" title="S[0]表示字符串长度"></a><code>S[0]</code>表示字符串长度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_Kmp</span><span class="params">(SString S, SString T, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// S表示原串</span></span><br><span class="line">    <span class="comment">// T表示模式串</span></span><br><span class="line">    <span class="comment">// pos表示索引，这个算法中S[0]表示的是字符串的长度</span></span><br><span class="line">    <span class="comment">// 所以如果pos是5，那么是这个字符串的第4个元素</span></span><br><span class="line">    <span class="comment">// 第一个元素从S[1]开始存储</span></span><br><span class="line">    <span class="comment">// 返回的是在S中的位置，也就是第几个元素。比如返回4，表示是S中的第四个元素，由于S[0]是长度，所以其实是S中索引为4的位置，排在第5个。</span></span><br><span class="line">    <span class="keyword">int</span> i = pos;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= S[<span class="number">0</span>] &amp;&amp; j &lt;= T[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || S[i] == T[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; T[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> i - T[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="S-0-不表示字符串长度"><a href="#S-0-不表示字符串长度" class="headerlink" title="S[0]不表示字符串长度"></a><code>S[0]</code>不表示字符串长度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_Kmp</span><span class="params">(String S, String T, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// S表示原串</span></span><br><span class="line">    <span class="comment">// T表示模式串</span></span><br><span class="line">    <span class="comment">// pos表示S中的索引，这个算法中S[0]不表示字符串的长度</span></span><br><span class="line">    <span class="comment">// 这里的pos和上一个代码中的pos意义一样</span></span><br><span class="line">    <span class="comment">// 第一个元素从S[1]开始存储s</span></span><br><span class="line">   <span class="keyword">int</span> i = pos;</span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.<span class="built_in">length</span>() &amp;&amp; j &lt; (<span class="keyword">signed</span>)t.<span class="built_in">length</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || s[i] == t[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = nextval[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt;= t.<span class="built_in">length</span>())</span><br><span class="line">        <span class="keyword">return</span> i - t.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get-next"><a href="#get-next" class="headerlink" title="get_next"></a>get_next</h2><h3 id="S-0-表示字符串长度-1"><a href="#S-0-表示字符串长度-1" class="headerlink" title="S[0]表示字符串长度"></a><code>S[0]</code>表示字符串长度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(SString S, <span class="keyword">int</span> next[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;    <span class="comment">// S的第二个元素，也就是字符串的第一个元素</span></span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;  <span class="comment">// 第一个位置</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; S[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || S[i] == S[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j == next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="S-0-不表示字符串长度-1"><a href="#S-0-不表示字符串长度-1" class="headerlink" title="S[0]不表示字符串长度"></a><code>S[0]</code>不表示字符串长度</h3><p>这种中，next数组从下标0开始存储，存的也是对应的下标，而不是想上面一个算法，next从1开始存，存的是位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(String S, <span class="keyword">int</span> next[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;    <span class="comment">// S的第二个元素，也就是字符串的第一个元素,</span></span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">// 第一个位置</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; S.<span class="built_in">length</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || S[i] == S[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j == next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get-nextval"><a href="#get-nextval" class="headerlink" title="get_nextval"></a>get_nextval</h2><h3 id="S-0-表示字符串长度-2"><a href="#S-0-表示字符串长度-2" class="headerlink" title="S[0]表示字符串长度"></a>S[0]表示字符串长度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(String S, <span class="keyword">int</span> nextval[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;    <span class="comment">// S的第二个元素，也就是字符串的第一个元素,</span></span><br><span class="line">    nextval[<span class="number">1</span>] = <span class="number">0</span>;  <span class="comment">// 第一个位置</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; S.<span class="built_in">length</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || S[i] == S[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span> (S[i] != S[j]) &#123;</span><br><span class="line">                nextval[i] = j;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nextval[i] = nextval[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j == nextval[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="S-0-不表示字符串长度-2"><a href="#S-0-不表示字符串长度-2" class="headerlink" title="S[0]不表示字符串长度"></a>S[0]不表示字符串长度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(String S, <span class="keyword">int</span> nextval[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;    <span class="comment">// S的第二个元素，也就是字符串的第一个元素,</span></span><br><span class="line">    nextval[<span class="number">0</span>] = <span class="number">-1</span>;  <span class="comment">// 第一个位置</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; S.<span class="built_in">length</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || S[i] == S[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span> (S[i] != S[j]) &#123;</span><br><span class="line">                nextval[i] = j;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nextval[i] = nextval[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j == nextval[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我的生命故事</title>
      <link href="/%E6%88%91%E7%9A%84%E7%94%9F%E5%91%BD%E6%95%85%E4%BA%8B/index.html"/>
      <url>/%E6%88%91%E7%9A%84%E7%94%9F%E5%91%BD%E6%95%85%E4%BA%8B/index.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是大二的时候，上的心理健康课的时候，老师布置的期中作业。在写的时候把自己从小到大的点滴回忆了一遍。</p></blockquote><h2 id="生命之重"><a href="#生命之重" class="headerlink" title="生命之重"></a>生命之重</h2><p>​    生命是世界上最值得人们敬畏的事情了。一个生命从孕育到在这个世界上慢慢长大，和这个世界网络紧紧的连接在一起，成为其中一个重要的节点，这是十分不容易的事情，也是人们一直为之奋斗的目标——在这个世界上留下些什么。</p><p>​    在这20年间，和父母一直会谈论我的过去，对于我而言，知道自己小时候的事情是一件十分有意思的事情，对于父母而言，回忆自己年轻时候的样子也是十分的幸福的吧。</p><p>​    在我出生之前，据我母亲所说，我爸爸是不想要我的哈哈。但是最后我还是顺利的来到的这个世界上。当时父母刚刚从江西老家孤身来到上海打拼，来上海的那一年，奶奶只给了父亲50元，父母在上海的一个小地方开了一家裁缝店，从我记事起，我的很多衣服都是母亲做的，记事之前就更不用说了。</p><p>​    我还有一个姐姐，比我大六岁。在我小时候，也就是没有搬家之前，我们一家四口就在店铺里面住着。一张上下铺，父母睡在下面，我和姐姐睡在上面。天冷的时候还好，到了夏天的时候，就热不可耐了。当时也没有空调。在我现在看来，这已经是十分艰苦的生活了，搬家之后，生活条件好了。据父母所说，他们小的时候，除了上学就是砍柴，中午最热的时候，别人在睡觉，自己就上山砍柴，自己山头的柴火砍光了就去别人的山头看。父母的故事，我们现在听来也是十分有趣的，他们讲起来也是喜笑颜开，但是如果那个砍柴的人是我，我也许就不会那么想了。</p><p>​    自己所经历的故事只有在自己多年之后再去回忆的时候才别有一番风味。现在我们所经历的事情是人生轨迹中的一个个点，但是多年之后，你会惊喜的发现那些自己经历的当时看起来八竿子打不着的两个点会连成线。这也是人生的一个乐趣吧。比如，我现在特别感谢小时候父母对于我的教育观念。父母的文化程度都不高，所以他们都十分坚信，只有学习才能够改变命运。在我小时候家里唯一的娱乐电器就是一个收音机，家里不知道哪里来的几盘磁带，分别是唐诗三百首，还有英语书的配套磁带。没有事的时候我就会在门口听着磁带，看着外面街上的孩子们打打闹闹，心里想着，这磁带转的好慢，转完我就去玩了。没想到的是，我在收音机和缝纫机的双重奏下，比同龄人早的背下了好几首唐诗。当时我还不知道“熟能生巧”，“反复做一件简单平凡的事情就能变成伟大的事情”这些道理，但是这些道理在我的心中已经有了雏形了。</p><p>​    还有一件事就是，在我小学的时候，父亲每天都会在我边上监督我写作业。写完之后，在每一份作业上签字表示作业是自己独立完成的。作业做完之后，父亲会要求我把英语课文读几遍，虽然这也是老师布置的作业，但是我现在才知道，当时有很多同学是不读的。父亲还会抽查我的英语单词。正是小学这几年，在父亲的指导下，我的英语口语突飞猛进，即使在现在，我的口语水平也是班级中的前列。当时家里没有电脑，做完作业就差不多睡觉了，小学的时候基本上每天都能睡10小时左右。再加上小时候唯一的娱乐就是和伙伴在街上跑来跑去，所以个子还挺高，就是那种按照基因来说不会达到的高度哈哈。</p><p>​    从哪一年开始，姐姐上了高中，一周回来一次。我周五回到家之后，就在母亲的缝纫机边上等着姐姐回来。姐姐回来之后，穿的是学校统一的正装，很好看。然后在母亲的店铺带了一会就回家了。然后我就坐在店铺里面就哭了起来，现在想来不就是一周没有见么。但是现在我上了大学和父母相见的日子少了很多，也没有哭过了，一个人的时候也会想想他们，但是没有什么表示了。这就是长大了么。</p><p>​    长大之后，和父母之间的关系有了微妙的变化。父亲总是希望我回答问题不要用“哦”，“嗯”之类的词语，而是“好的，知道了”类似的。并且没有得到回应的时候就会一直问下去，现在的我当然十分能够理解父亲的心情，可惜的是当时的我不是这么想的。在我高二的时候，我有过一个女朋友，一个十分可爱的女孩子。晚上在和她聊天的时候，母亲没有敲门进来看到我在玩手机就把手机拿过去了，拿走的时候手机还没有息屏，母亲看到了聊天记录。这件事情是之后几天父母和我谈的时候，我才知道他们已经知道了这件事情的。所以现在我无论进谁的门，都会敲门，得到允许之后才会进去。在我看来，父母应该会直接来和我谈论，没想到的是过了几天才和我谈的。这让我有点诧异。但是也十分感谢父母当时做出的这个选择。之后的事情也就顺着父母的意愿发展了下去。</p><p>​    高中的时候，姐姐结婚了。之后家里就长时间只有我和父母，姐姐不在家的时候，母亲还总是会念叨着她的女儿。</p><p>​    大学的时候，我在天津。转专业遇到了三个很nice的室友。之后家里长时间只有父母，我不在家的时候，应该也会念叨我吧。我不擅长把情感表露出来，也会牵挂家人。</p><p>​    20年很长，一篇文章很短，先写到这里。有空在加。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>穷查理宝典</title>
      <link href="/%E7%A9%B7%E6%9F%A5%E7%90%86%E5%AE%9D%E5%85%B8/index.html"/>
      <url>/%E7%A9%B7%E6%9F%A5%E7%90%86%E5%AE%9D%E5%85%B8/index.html</url>
      
        <content type="html"><![CDATA[<p>查理思考问题总是从逆向开始。 想要明白人生如何获得幸福，就去研究人生如何变得痛苦。</p><p>找出你最擅长的事情，然后持之以恒，乐此不疲的把它做好。</p><p>获取普世的智慧，并相应的调整你的行为。即使你的特立独行让你在人群中不受欢迎，那就随他们去吧。</p><h3 id="芒格的生活、学习和决策方法"><a href="#芒格的生活、学习和决策方法" class="headerlink" title="芒格的生活、学习和决策方法"></a>芒格的生活、学习和决策方法</h3><ul><li>凡事往简单处想，往认真处行</li></ul><blockquote><p>我们的经验往往会验证一个长久以来的观念：只要做好准备，在人生中抓好几个机会，迅速的采取适当的行动，去做简单而合乎逻辑的事情，这辈子的财富就会得到极大的增长。</p><p>上面提到的这种机会很少，他们通常会落在不断寻找和等待、充满求知欲望而又热衷于对各种不同的可能性做出分析的人头上。</p><p>这样的机会来临之后，如果获胜的几率极高，那么动用过去的谨慎和耐心的来的资源，重重地压下堵住就可以了。</p></blockquote><ul><li><p>简单是长期努力的结果而不是起点 ——弗里德里曼·麦可兰德</p></li><li><p>就确定未来而言，没有比历史更好的老师，一本三十美元的历史书里隐藏着价值数亿美元的答案。</p></li><li><p>给你带来麻烦的不是坏主意，而是好主意。因为如果一件事情是一个坏主意，你一定不会做过头。但是如果一件事情是一个好主意，你往往会做过头。——查理<strong>·</strong>芒格</p></li><li><p><strong>为什么芒格投资哲学的文章极其关注”何时买“而极少关注”何时卖“的原因？</strong></p><p>”我们偏向于把大量的钱投放在我们不在用另外决策的地方。如果你因为一样东西被低估而购买了它，那么当它的价格上涨到你预期的水平的时候，你就必须要考虑卖掉它，<strong>那很难</strong>（参照上一条说的好事情）。但是，如果你能购买几个伟大的公司，那么你就可以安坐下来啦，这是很好的事情。</p></li><li><p>能力会让你到达巅峰，但是只有品德会让你停留在那里 ——林肯</p></li></ul><h4 id="投资和决策检查清单"><a href="#投资和决策检查清单" class="headerlink" title="投资和决策检查清单"></a><strong>投资和决策检查清单</strong></h4><ul><li><p><strong>风险：所有投资评估应该从测量风险（尤其是信用的风险）开始</strong></p><p>测算合适的安全边际；</p><p>避免和道德品质有问题的人交往；</p><p>坚持为预定的风险要求合适的补偿；</p><p>永远记住通货膨胀和利率的风险；</p><p>避免犯下大错；</p><p>避免资本金持续亏损。</p></li></ul><ul><li><p><strong>独立：“惟有在童话中，皇帝才会被告知自己没穿衣服”</strong></p><p>客观和理性的态度需要独立思考；</p><p>记住，你是对是错，并不取决于别人同意你还是反对你——唯一重要的是你的分析和判断是否正确；</p><p>随大流只会让你往平均值靠近（只能获得中等的业绩）；</p></li><li><p><strong>准备：“唯一的获胜方法是工作、工作、工作、工作，并希望拥有一点洞察力。”</strong></p><p>通过广泛的阅读把自己培养成一个终生自学者；</p><p>培养好奇心，每天努力使自己聪明一点点；</p><p>比求胜的意愿更重要的是做好准备的意愿；</p><p>熟练地掌握各大学科的思维模型；</p><p>如果你想要变得聪明，你必须不停地追问的问题是“为什么，为什么，为什么”。</p></li><li><p><strong>谦虚：承认自己的无知是智慧的开端</strong></p><p>只在自己明确界定的能力圈内行事；</p><p>辨认和核查否定性的证据；</p><p>抵制追求虚假的精确和错误的确定性的欲望；</p><p>最重要的是，别愚弄你自己，而且要记住，你是最重要被自己愚弄的人。</p></li><li><p><strong>严格分析：使用科学方法和有效的检验清单能够最大限度地减少错误和疏忽</strong></p><p>区分价值和价格、过程和行动、财富和规模；</p><p>记住浅显的好过掌握深奥的；</p><p>成为一名商业分析家，而不是市场、宏观经济或者证券分析家；</p><p>考虑总体的风险和效益，永远关注潜在的二阶效应和更高层次的影响；</p><p>要朝前想、往后看——反过来想、总是反过来想。</p></li><li><p><strong>配置：正确地配置资本是投资者最重要的工作</strong></p><p>记住，最好的用途总是由第二好的用途衡量出来的（机会成本）；</p><p>好主意特别少——当时机对你有利时，狠狠地下赌注吧（配置资本）；</p><p>别“爱上”投资项目——即使你投入巨大心血，也要依情况而定，照机会而行。</p></li><li><p><strong>耐心：克制人类天生爱行动的偏好</strong></p><p><strong>“复利是世界第八大奇迹”（爱因斯坦），不到必要的时候，别去打断它；</strong></p><p>避免多余的交易税和摩擦成本，永远别为了行动而行动；</p><p>幸运来临时要保持头脑清醒；</p><p>享受结果，也享受过程，因为你活在过程当中。</p></li><li><p><strong>决心：当合适的时机出现时，要坚决地采取行动</strong></p><p>当别人贪婪时，要害怕；当别人害怕时，要贪婪；</p><p>机会来临的次数不多，所以当它来临时，抓住它；</p><p>机会只眷顾有准备的人：投资就是这样的游戏。</p></li><li><p><strong>改变：在生活中要学会改变和接受无法消除的复杂性</strong></p><p>认识和适应你身边的世界的真实本质，别指望它来适应你；</p><p>不断地挑战和主动地修正你“最爱的观念”；</p><p>正视现实，即使你并不喜欢它——尤其当你不喜欢它的时候。</p></li><li><p><strong>专注：别把事情搞复杂，记住你原来要做的事</strong></p><p>记住，声誉和正直是你最有价值的财产——而且能够在瞬间化为乌有；</p><p>避免妄自尊大和厌倦无聊的情绪；</p><p>别因为过度关系细节而忽略了显而易见的东西；</p><p>千万要排除不需要的信息</p><p>直面你的大问题，别把它们藏起来</p></li><li><p><strong>终身学习</strong></p><p>就算沃伦·巴菲特也不得不成为一部不断学习的机器。层次较低的生活也有同样的要求，我不断地看到有些人在生活中越过越好，他们不是最聪明的，甚至不是最勤奋的，但他们是学习机器，他们每天夜里睡觉时都比那天早晨聪明一点点。</p><p>再拿沃伦·巴菲特来说，如果你们拿着计时器观察他，会发现他醒着的时候有一半时间是在看书。他把剩下的时间大部分用来跟一些非常有才干的人进行一对一的交谈，有时候是打电话，有时候是当面，那些都是他信任且信任他的人。</p></li></ul><h3 id="芒格主义：查理的即使谈话"><a href="#芒格主义：查理的即使谈话" class="headerlink" title="芒格主义：查理的即使谈话"></a>芒格主义：查理的即使谈话</h3>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 投资 </tag>
            
            <tag> 思维 </tag>
            
            <tag> 人生哲学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>被讨厌的勇气</title>
      <link href="/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94/index.html"/>
      <url>/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="第一夜：我们的不幸是谁的错"><a href="#第一夜：我们的不幸是谁的错" class="headerlink" title="第一夜：我们的不幸是谁的错"></a>第一夜：我们的不幸是谁的错</h2><p>​    在第一夜，年轻人认为每个人都期待改变，但是想要改变也无法改变。然而哲学家认为，人人都可以改变，并且获得幸福。</p><p>​    弗洛伊德式的原因论认为，人现在的状态是由过去的经历所所赋予的，但是阿德勒的心理学认为，决定我们自身的不是过去的经历，而是我们赋予自己经历的意义。直接来说，也就是，<strong>是我们自己选择了自己的生活，而不是由别人所赋予的。</strong></p><p>​    有人也许会反驳这句话，比如“我们的出身，国家，周围环境都不是自己选择的，这是既定的。而且，这些都具有十分强大的影响力，我们也许会对这有不满，会羡慕他人的生活。很多人有时候其实相信自己的人身是由自己所决定的，但是一想到自己的起跑线和别人的不一样，或者差太多，会开始抱怨自己要付出更多的努力才能够赶上别人。在不断的抱怨中，没有付出努力，或者不愿意付出更多的努力。比如当你看到同学打游戏，看电视的时候，你也许会想，我都学习了一天了，也可以放松了，但是发现自己的起跑线落后于别人。这个时候如果你开始犹豫是娱乐还是继续学习，说明你还没有真正了解自己想要什么。</p><p>​    <strong>人们之所以无法改变，是因为自己下了“不改变”的决心。</strong>即使人们有着各种的不满意，但是还是认为保持现状更加轻松，更加安心。</p><p>​    所以一个人的不幸不是因为过去或者环境，更不是因为能力不足，只不过是缺乏勇气，缺乏 <strong>获得幸福的勇气</strong>。之前的人生发生过什么，都对于今后的人生没有影响。</p><h2 id="第二夜：一切的烦恼都来自人际关系"><a href="#第二夜：一切的烦恼都来自人际关系" class="headerlink" title="第二夜：一切的烦恼都来自人际关系"></a>第二夜：一切的烦恼都来自人际关系</h2><p>​    人为什么会讨厌自己？哲人给出的理由是，因为自己 <strong>下定了“不要喜欢自己”的决心</strong>， 因为这对于那个人来说是一种<strong>“善”</strong>。不喜欢自己怎么会变成一种善呢？正是由于这个决心，为了达到不喜欢自己的目的，人才会只看到自己的缺点而不是优点。</p><p>​    不喜欢自己怎么会变成一种善呢？首先要明确的是，这种“善”只是对于个体而言的。当一个人下定决心不喜欢自己的时候，就会找到自己的缺点。由于人是社会性的动物，<strong>只要涉入人际关系就会或大或小的受伤，也会伤害别人</strong>，而这个青年找到自己的缺点以后，<strong>就会认为自己被人讨厌是因为这个缺点，如果没有这个缺点，我就会……他就开始生活在这个幻想之中，因为他不想接受当自己改正了自己的缺点之后，还是会被一些人讨厌的事实。而在这个幻想之中，他可以为所欲为，不用想这么多，所以这对于来说是一种善</strong></p><p>​    再比如考生会想“如果考中的话，我的人生就会一片光明” 如果他为了逃避即使自己考上了前途也不一定会光明的事实，那他也许就会一直不付出行动，努力考上。这样的话一切就会归咎于，“如果我考上了….我就…..”这样的幻想中。</p><p>​    阿德勒心理学的一个基本概念是：<strong>人的烦恼来源于人际关系</strong></p><p>​    当人们感到自卑的时候，其实是和他人的比较产生的，这种比较的基础就是你要是社会的“个人”，是社会关系的一个组成。此外，哲人认为自卑感都是由于自己主观臆造出来的。比如身高，身高矮很多人看来不好，但是换一个角度，小个子会降低对于他人的威胁感，能够更好的在社会中建立网络。<strong>我们无法改变客观事实，但是我们可以改变主观解释。</strong></p><p>​    这里还要区别<strong>自卑感</strong>和<strong>自卑情结</strong>。人人都有自卑感，但是自卑感并不是坏事，它能够敦促人们进步。人生来是一种无力的状态，为了摆脱这种无力的状态，人们会有追求，当自己没有达到既定的目标或者做的没有别人好的时候就会产生自卑。自卑情结和自卑感没有过多的联系，自卑情结是指把自己的自卑感当作某种借口使用的状态。比如“我因为学历低所以无法成功”，“我不好看所以没有对象”等等。</p><p>​    不得否认的是“学历高有更大的成功的机会”，“长得好看，有更多的求偶机会”。在阿德勒看来，<strong>这是一种外部因果律：将原本没有任何因果关系的事情解释成似乎由重大的因果关系一样。</strong>当人们认为自己无法成功的时候，那不是“无法成功”，而是“不想成功”。也就是害怕前进或者不想真正的努力，不愿意为了改变自己而牺牲目前所享受的快乐——比如玩乐或者休闲时间。也就是<strong>拿不出改变的勇气。</strong></p><p>​    <strong>自卑情结</strong>有时候会演变成为<strong>优越情结</strong>，”要不是我学历低，我就会成功，我只是被埋没的天才，真正的我其实很很优秀。”当人们有了自卑感，但是拿不出改变的勇气的时候，就会产生自卑情结，这个时候人们会想出比<em>拥有改变的勇气</em>更加简单的方法，就是<em>优越情结：表现得自己很优秀，继而继续沉浸在一种虚假的优越感之中。</em></p><p>​    <strong>如果有人骄傲自大，一定是因为他有自卑感。</strong></p><p>​    <strong>追求优越性</strong>是指不和其他人竞争，只要自己不断前进。有时我们会根据他人的和自己的差距来调整自己的目标，但是事实上，自己的目标还是理想中的自己，而不是别人。健全的自卑感不是来自于与别人的比较，而是与”理想的自己“作比较。哲人认为我们要把别人当作”伙伴“，而不是”竞争对手“，竞争对手之后会不知不觉的演变成为”敌人“，当你和他人是竞争的关系的时候，你会真心祝福比你幸福的人幸福吗？不太可能，因为这个时候，你就把自己放在了失败者的地位上。但是现实中，很多地方都存在竞争，比如企业之间的竞争，我们还常常提到良性竞争。我个人认为竞争存在是正常的，只不过不要生活在竞争中，所以我们常常说<strong>竞争伙伴</strong>，这也许和哲人说的有一点相通吧，但也不尽相同。</p><p>​    <strong>在人际关系中的权力之争中，无论认为自己多么正确，也不要一次为理由去责难对方。在人机关系中，一旦相信“我是正确的”，那就已经步入了权力之争</strong></p><p>​    当人能够感觉到“与这个人在一起的时候可以无拘无束”的时候，才能够体会到爱。</p><blockquote><p>我们讨厌一个人不是因为无法容忍一个人的缺点而讨厌他，而是你先有讨厌A的这个目的，之后找到了符合的缺点。</p><p>比如在恋爱或者夫妻关系中，过了某个时期之后，有时候对方的任何行为都会让你生气。吃饭的方式让你不满意，在房间里的散漫姿态让你生厌，甚至就连对方睡眠时候的呼吸声都让你生气，尽管几个月前还不是这样。这是因为那个人已经下定决心要“结束这段关系”，继而正在收集结束关系的证据，才会有那样的感觉。对方其实没有任何变化，<strong>只是自己的目的改变了。</strong></p></blockquote><h2 id="第三夜：让干涉你生活的人见鬼去"><a href="#第三夜：让干涉你生活的人见鬼去" class="headerlink" title="第三夜：让干涉你生活的人见鬼去"></a>第三夜：让干涉你生活的人见鬼去</h2><p>​    自由是什么？是不再寻求认可吗？<strong>阿德勒心理学否定寻求他人的认可。</strong>这也就引申出我们是否要生活在他人的期待之中。</p><p>​    人们为什么要寻求他人的认可？其实，很多情况下都是受到<strong>赏罚教育</strong>的影响，阿德勒严厉批判这种赏罚式的教育。这样会产生一种错误的生活方式：“如果没有人表扬我，我就不去做好事，如果没有人惩罚我，我也可以做坏事。”</p><p>​    要将<strong>课题分离</strong>，不要随意的干涉他人的课题。如何判断这是谁的课题呢?考虑一下这种选择带来的后果由谁来承担。</p><p>​    这一节讲到：关于自己的人生能够做的就是”<strong>选择自己认为最好的道路</strong>。另一方面，“<strong>别人如何评价你的选择</strong>，<strong>那是别人的课题</strong>，<strong>我们没有办法左右</strong>”.这里举了一个例子，父母对于你的工作，学习等等十分不顺心，对你大发雷霆，哲人的建议是不用去管这些事情，说的在直白一点就是，无论父母多么伤心都没有关系。这一点我看到的时候有点不太认同。</p><p>​    <strong>选择了不自由的生活方式的大人看着自由活在当下的年轻人就会批判他是享乐主义。当然这只是为了让自己接受不自由生活而捏造出的一种人生谎言</strong></p><p>​    <strong>自由就是被人讨厌。获得幸福的勇气也包括被讨厌的勇气</strong></p><h2 id="第四夜：被讨厌的勇气"><a href="#第四夜：被讨厌的勇气" class="headerlink" title="第四夜：被讨厌的勇气"></a>第四夜：被讨厌的勇气</h2><p>​    人际关系的起点是“课题分离”，终点是“<strong>共同体感觉</strong>”。共同体感觉是指“把他人看成朋友，并在其中能够感受到有自己的位置。</p><p>​    活在关系害怕的恐惧之中，那是为他人而活的不自由的生活方式。</p><p>​    阿德勒心理学反对体罚，也不认可表扬。因为当一个人对另一个人提出表扬的时候，无意之中营造出了一种上下级的关系，这是一种有能力者对于无能力者的评价。</p><p>​    阿德勒心理学反对一切<strong>“纵向关系”</strong>， 提倡把所有的人际关系都看作“<strong>横向关系</strong>”。人们为什么会有干涉他人生活的意愿？这是因为把人际关系看成了纵向关系，把对方看的比自己低，所以才会去干涉。</p><p>​    阿德勒心理学主张既不表扬也不批评。把这种基于横向关系的援助称为“鼓励”。<strong>被表扬会形成自己没有能力的潜意识。</strong></p><p>​    用平等的关系来表达自己对于伙伴帮助的喜悦。或者用“我很高兴”这样的话来表达自己的喜悦。<strong>重要的是不要去评价他人</strong>。况且判断某种行为是好是坏是以他人的标准，如果渴望得到表扬，就相当于活在他人的期待之中。</p><blockquote><p>前几天刚刚和四五岁的小侄女视频通话，她画了两幅画，是那种颜料涂满了画纸的，很用心。我说“你真棒”。现在看了这个章节以后，我在想这样说是否有点不妥？因为这样的表扬在生活中太常见了。我在想，如果我不这样说，我或许可以这样说：“画画的时候开心嘛？你觉得你画的怎么样呀？我看到你画画也很高兴!”这样的言语中没有评价，是在表达自己的喜悦之情，或许会好一点嘛？</p></blockquote><p>​    <strong>但别人听到感谢之词的时候就会知道自己能够对别人有贡献</strong>。</p><p>​    <strong>书上说：人只有感觉自己有价值的时候才可以获得勇气。但是这是什么勇气呢？我还不太明白</strong></p><p>​    哲人说：我们不要用”行为“标准而要用”存在”标准来看待他人。也就是说，当一个人存在的时候，他就是有价值的。即使是卧病在床的老人，他只要还活着就能让你感到舒心，这就是一种价值。</p><p>​    哲人说：我们在看带他人的时候，会先虚构一个对于自己来说的理想形象，然后在想做减法一样的去评价。例如，父母希望孩子学习，运动样样满分，考上好大学，进入好公司。和这样的理想孩子孩子相比，就会对自己的孩子产生种种不满。不要这样，不要将自己的孩子和其他人做比较。即使是一个在家中什么也不干的孩子，也要说谢谢。（没错，这是哲人的原话）如果孩子自己洗碗，你说“这种事就算了，还是去上学吧”，这就是按照理想的孩子去比较了。反而会挫伤孩子的勇气。对于这个，青年认为这是一种伪善，没有人能够做到。阿德勒对此的回应是：”<strong>必须得有人开始，即使其他人不合作，也和你没有关系。</strong></p><p>​    我发现，当我在写“哲人说”的时候，好像就表示我对于这一部分的观点不太认同，要么是我还没有接受，要么是和我自己所接受的价值观有冲突，让我为难。</p><p>​    人与人之间要建立起横向的关系，纵向的关系会让自己不自觉的去纵向把握所有的人际关系。这里的横向关系，指的是相互平等，在意识上平等以及坚持自己的想法。</p><h2 id="第五课：认真的人生”活在当下“"><a href="#第五课：认真的人生”活在当下“" class="headerlink" title="第五课：认真的人生”活在当下“"></a>第五课：认真的人生”活在当下“</h2><p>​    人们常常会受自我意识的羁绊，不能无拘无束的生活。原因在于人们不想在人际关系中被嘲笑，被瞧不起。但是自己一个人的时候，就不会有这种感觉。</p><p>​    也就是说不是本真的自我不存在，而是无法在人面前展露出来。</p><p>​    解决办法就是：<strong>把对于自己的执着，转换称为对于他人的关心，建立起共同体感觉。</strong></p><p>​    具体方式是三点：<strong>自我接纳</strong>， <strong>他者信赖</strong>， <strong>他者贡献</strong>。</p><p>​    <strong>自我接纳：</strong>区别自我肯定和自我接纳。<strong>自我肯定</strong>是指：明明做不到但是还是暗示自己说“我可以”，“我能行”，这是一种容易导致优越情结的想法，是对自己撒谎的生活方式。<strong>自我接纳</strong>是指：假如做不到就诚实的接受这个做不到的事实，然后朝着能够做到的方向去努力。</p><p>​    要分清“能够改变”和“不能改变”的。</p><p>​    <strong>上帝，请赐予我平静，去接受我无法改变的；给予我勇气，去改变我能够改变的；赐我智慧，分辨这两者的区别。</strong></p><p>​    <strong>他者信赖：</strong>区别信用和信赖。<strong>信赖</strong>是指相信他人的时候没有任何的附加条件。阿德勒心理学认为：信赖他人是你的事情，但是背叛与否是对方的课题，你只需要考虑“我该怎么做”。无条件信赖是搞好人际关系和构建横向关系的一种手段。如果不想和某个人搞好关系，就没有必要无条件信赖。</p><p>​    如果不敢去信赖别人，那最终就会与任何人都建立不了联系。</p><p>​    如何克服被他人背叛的恐惧感？<strong>自我接纳</strong>，知道自己什么能够改变，什么不可以。</p><p>​    <strong>他者贡献：</strong> <strong>他者贡献并不是舍弃“我”而为他人效劳，他反而是为了能够体会到“我”的价值而采取的一种手段。</strong></p><p>​    <strong>三者关系：</strong></p><p>​    正是因为接受了真实的自我，也就是自我接纳，才能够不惧背叛的做到他者信赖，而且正因为对他人给予无条件的信赖，并能够使他人为自己的伙伴才能够做到他者贡献。同时，正因为对他人有所贡献，才能够体会到我对他人有用，进而接受真实的自己，做到自我接纳。</p><p>​    对于人而言，最大的不幸就是不喜欢自己。</p><p>​    <strong>幸福就是贡献感，如果一个人不幸福就是没有获得幸福感。</strong></p><p>​    在第三课中，我们提到“不可以寻求认可”。人们为什么想要寻求认可呢？人们想要喜欢自己，想要觉得自己有价值，为此就要拥有“我对他人有用”的贡献感，而获得贡献感的<strong>常见手段</strong>就是寻求他人认可。如果获得幸福感的常见手段一旦变成了“被他人认可”，最终就不得不按照他人的愿望来过自己的人生。<strong>通过认可欲获得的贡献感没有价值。因为我们选择在追求自由的同时追求贡献感。</strong></p><p>​    哲人认为：如果能够真正获得贡献感，那就不在需要他人的认可。因为即使不特意去寻求他人的认可，也可以体会到“我对他人有用”。<strong>有了共同体感觉，认可欲求就会消失。</strong></p><p>​    青年说：人生仅仅凭借他人贡献就能够感受到自己的价值吗？他认为人在这个世界上要留下一点什么。证明“我是独一无二的我”。他提出了<strong>自我实现式的幸福</strong>。哲人说，阿德勒心理学十分重视“甘于平凡的勇气”，<strong>没有必要特意炫耀自己的优越性。</strong></p><p>​    哲人说，把人生当作登山的人其实把自己的人生看作了“一条线”。但是不要把人生看作一条线，而是点的连续。<strong>人生是连续的刹那</strong>。“一条线”是指自己的人生别规划昊了。看起来很有道理，但是哲人说：<strong>计划式的人生不是没有必要，而是不可能完成。</strong>因为人没有办法预料到自己的人生途上会发生什么。</p><p>​    青年认为哲人这是否认了人生的计划性。哲人说,<strong>人生就像是在每个瞬间不停旋转起舞的连续的刹那。只要跳着舞的此时此刻充实就够了。</strong></p><ul><li>潜在性人生：青年说的有目的的人生。也就是在没有达到目的的时候，人生都是不完整的。</li><li>现实性人生：把过程也看作结果的人生。比如旅行是从跨出家门就开始了的。每一个瞬间都是旅行。</li></ul><p>​    之前提到过去的没有办法改变，现在哲人又提出现实性人生否定了计划性。青年看来这样的人生看不到过去，也看不到未来。哲人说，在舞台上，如果聚光灯很强的打在脸上，你会看不清第一排的人，如果灯光很弱，观众都能看得清楚。类比过来就是，如果你十分认真的活在当下，就是会看不到过去和将来。</p><p>​    <strong>认真的过好此时此刻，这本身就是在跳舞。</strong></p><p>​    <strong>人生的最大的谎言就是不活在”此时此刻“</strong></p><p>【完结】</p>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理学 </tag>
            
            <tag> 心灵成长 </tag>
            
            <tag> 哲学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题漏洞</title>
      <link href="/%E5%88%B7%E9%A2%98%E6%BC%8F%E6%B4%9E/index.html"/>
      <url>/%E5%88%B7%E9%A2%98%E6%BC%8F%E6%B4%9E/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="vector的sort方法"><a href="#vector的sort方法" class="headerlink" title="vector的sort方法"></a>vector的sort方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">test</span><span class="params">(n)</span></span>;</span><br><span class="line">sort(test.begin(), test.end()); <span class="comment">// 正序</span></span><br><span class="line">sort(test.rbegin(), test.rend()); <span class="comment">// 倒序</span></span><br></pre></td></tr></table></figure><h2 id="java中建立List"><a href="#java中建立List" class="headerlink" title="java中建立List"></a>java中建立List</h2><div class="table-container"><table><thead><tr><th>操作</th><th>Code</th></tr></thead><tbody><tr><td>新建：</td><td><code>List&lt;type&gt; fruit = new ArrayList&lt;type&gt;()；&lt;br /&gt;List&lt;type&gt; fruit = new LinkedList&lt;type&gt;()；</code></td></tr><tr><td>增</td><td><code>fruit.add(“Apple”);&lt;br /&gt;fruit.add(“Pear”);</code></td></tr><tr><td>删</td><td><code>fruit.remove(0); // 按照索引删、或者按照内容删除；&lt;br/&gt;fruit.remove(“Apple”);</code></td></tr><tr><td>改</td><td><code>fruit.set(1,”Banana”);</code></td></tr><tr><td>查</td><td><code>fruit.contains(“Pear”); Fruit.containsAll(fruit2); // Listfruit2 = new ArrayList&lt;&gt;(); fruit2.add(“Banana”); fruit2.add(“Apple”);</code></td></tr></tbody></table></div><h2 id="java中sort用法"><a href="#java中sort用法" class="headerlink" title="java中sort用法"></a>java中sort用法</h2><p><a href="https://howtodoinjava.com/java/sort/collections-sort/#:~:text=%20Java%20Collections%20sort%20%28%29%20Method%20%201,%E2%80%93%20Collections.sort%20%28%20list%2C%20Comparator%20%29%20More%20">点击查看链接</a></p><h2 id="java-迭代器"><a href="#java-迭代器" class="headerlink" title="java 迭代器"></a>java 迭代器</h2><p><a href="https://www.runoob.com/java/java-iterator.html">点击查看链接</a></p><h2 id="java-List-中取元素"><a href="#java-List-中取元素" class="headerlink" title="java List 中取元素"></a>java List 中取元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Interval&gt; interval = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">interval.add((<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">interval.add((<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line">interval.add((<span class="number">3</span>,<span class="number">4</span>));</span><br><span class="line">interval.add((<span class="number">4</span>,<span class="number">5</span>));</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">Interval aa = interval.get(i);</span><br></pre></td></tr></table></figure><h2 id="java-中-List-和-Array相互转换"><a href="#java-中-List-和-Array相互转换" class="headerlink" title="java 中 List 和 Array相互转换"></a>java 中 List 和 Array相互转换</h2><h3 id="List-gt-Array"><a href="#List-gt-Array" class="headerlink" title="List -&gt; Array"></a>List -&gt; Array</h3><p>List 提供了toArray的接口，所以可以直接调用转为object型数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">Object[] array=list.toArray();</span><br></pre></td></tr></table></figure><p>　　上述方法存在强制转换时会抛异常，下面此种方式更推荐：可以<strong>指定类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] array=list.toArray(<span class="keyword">new</span> String[list.size()]);</span><br></pre></td></tr></table></figure><p>​    比如，我定义了一个Intervals的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interval</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Interval</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntervalsIntersection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Interval[] merge(Interval[] arr1, Interval[] arr2) &#123;</span><br><span class="line">        List&lt;Interval&gt; intervalsIntersection = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> intervalsIntersection.toArray(<span class="keyword">new</span> Interval[intervalsIntersection.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// mian函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Array-gt-List"><a href="#Array-gt-List" class="headerlink" title="Array -&gt; List"></a>Array -&gt; List</h3><p>运用ArrayList的构造方法是目前来说最完美的作法，代码简洁，效率高：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(array));</span><br></pre></td></tr></table></figure><p>​    比如，我定义了一个Intervals的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interval</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Interval</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntervalsIntersection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Interval[] merge(Interval[] arr1, Interval[] arr2) &#123;</span><br><span class="line">        List&lt;Interval&gt; intervalsIntersection = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// List -&gt; Array</span></span><br><span class="line">        <span class="keyword">return</span> intervalsIntersection.toArray(<span class="keyword">new</span> Interval[intervalsIntersection.size()]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Array -&gt; List</span></span><br><span class="line">        Interval[] input1 = <span class="keyword">new</span> Interval[]&#123;<span class="keyword">new</span> Interval(<span class="number">2</span>, <span class="number">3</span>), <span class="keyword">new</span> Interval(<span class="number">5</span>, <span class="number">6</span>), <span class="keyword">new</span> Interval(<span class="number">7</span>, <span class="number">9</span>)&#125;;</span><br><span class="line">        List&lt;Interval&gt; array = <span class="keyword">new</span> ArrayList&lt;Interval&gt;(Arrays.asList(input1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非暴力沟通</title>
      <link href="/%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A/index.html"/>
      <url>/%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A/index.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用暴力的人是因为他们内心的宁静遭到了破坏，所以才会用暴力的方式来维护或寻求内心的和平</p></blockquote><h3 id="让爱融入生活"><a href="#让爱融入生活" class="headerlink" title="让爱融入生活"></a>让爱融入生活</h3><ul><li>非暴力沟通使得我们不再条件反射地反映，而是去明了自己的观察，感受和愿望，有意识的使用语言。</li><li>非暴力沟通的四个要素：<strong>观察、感受、需要、请求</strong><ul><li>一位母亲对儿子说，“我看到咖啡桌下的脏袜子，我不太高兴，因为我看重整洁。””你是否愿意把袜子拿到房间或者是洗衣机。</li></ul></li></ul><h3 id="是什么蒙蔽了爱"><a href="#是什么蒙蔽了爱" class="headerlink" title="是什么蒙蔽了爱"></a>是什么蒙蔽了爱</h3><ul><li><p>有些语言的表达方式虽然在致力于满足某种愿望，但是却忽视了人的感受和需要（异化的沟通方式）</p></li><li><p>有些沟通方式难以让人体会到爱</p><ul><li>比如<strong>道德评判</strong>的沟通方式：如果一个人的行为不符合我们自己的价值观，我们就认为他是不道德的或者是邪恶的。这种道德评判的沟通方式实际上反映了自己的需要和价值观。</li></ul><p>| 价值判断                                                     | 道德评判                     |<br>| —————————————————————————————— | —————————————— |<br>| 对于使用暴力来解决问题，我很担心，我主张通过其他方式来解决。<br>（反映了自己的信念——生命需要怎样才能得到最好的满足。 | 暴力是不好的。杀人者是邪恶的 |</p><ul><li><strong>大多数暴力的根源在于人们忽视了彼此的需要</strong></li><li>在哈佛大学的公开课 <strong>Justice</strong>中的第六讲提到了康德的道德观，康德认为真正的道德行为是纯粹基于义务而做的行为，而为实现某一个个人功利目的而做事情就不能被认为是道德的行为。</li><li>我们对于自己的思想、情感和行动负有责任。但是人们往往使用“不得不”或者“上级的要求”来<strong>回避责任</strong>。这个时候我们把自己看作是上级完成任务的一种手段。这种状态在康德看来是不自由的，因为我们没有尊重自己的基本权力，没有按照自己的意志来行动。（哈佛大学的公开课 <strong>Justice</strong>中的第六讲）</li></ul></li></ul><h3 id="区分观察和评论"><a href="#区分观察和评论" class="headerlink" title="区分观察和评论"></a>区分观察和评论</h3><ul><li>观察是非暴力沟通的第一要素. 不带评论的观察是人类智力的最高形式. 将观察和评论混为一谈,人们就会更加倾向于听到批评,并且反驳我们.</li></ul><h3 id="体会和表达感受"><a href="#体会和表达感受" class="headerlink" title="体会和表达感受"></a>体会和表达感受</h3><ul><li>区分感受和想法:<strong>吉他弹得不好</strong>是想法,<strong>作为吉他手,我很失落,郁闷,厌烦</strong> 是 感受.</li><li>当我们在说”我觉得”的时候,我们更加表达出来的是想法,当我们把”<strong>我觉得</strong>“换成”<strong>我认为</strong>“也许会更好.</li><li>非暴力沟通的第二个因素是感受.通过建立表达感受的词汇表,从而使得沟通更加顺畅.在表达感受的时候,示弱有助于解决冲突. </li><li>简单来说,在表达感受的时候,我们要使用一些描述心情的词语.高兴,害怕等等.</li></ul><h3 id="感受的根源"><a href="#感受的根源" class="headerlink" title="感受的根源"></a>感受的根源</h3><ul><li><p>听到不中听的话的四种选择：</p><ol><li>责备自己 </li><li>指责他人</li><li>体会自己的感受和需要</li><li>体会他人的感受和需要</li></ol><p>对于他人的指责、批评、评论及分析反映了我们的需要和价值观。如果我们通过批评来提出自己的主张，对方往往会申辩或者反击，所以最好的方法就是<strong>直接说出自己的感受和需要。</strong></p></li><li><p>当我们想利用对方的内疚时，我们通常会把自己不愉悦的感受归咎于对方。父母对孩子说:“你成绩不好，让爸爸妈妈伤心透了。”孩子看到了自己导致了父母的痛苦，出于愧疚，孩子会做出行为来<strong>迎合</strong>，但这不是出于<strong>热爱</strong>学习。</p></li><li><p>非暴力沟通强调，感受的根源在我们自己。所以我们可以通过“<strong>我（感到）……因为我……</strong>” 这种表达方式来认识感受和自身的关系。</p><ul><li>“看到公司海报出现拼写错误，我很不高兴，因为我重视公司的形象。”</li><li>“你没把饭吃完，妈妈感到失望。因为妈妈希望你能健康成长。”</li></ul></li><li><p>但是社会环境一般不鼓励我们说出自己的需要。对妇女来说，尤其如此。因为她们的形象往往和无私奉献联系在一起—这可能也受到传统文化的影响。但是在我看来，即便社会文化不太鼓励，但是女性还是要说出自己的需要，因为这是个体的权利，当自己说出了自己的需要的时候，他人才更有可能满足你。</p></li><li><p>对于大多数人来说，个人的成长一般会分为三个阶段。</p><ul><li><p><strong>情感的努力：</strong>我们认为自己有义务使他人快乐</p></li><li><p><strong>面目可憎时期：</strong>我们发现牺牲自己去迎合他人代价很大，所以这时我们拒绝考虑他人的感受和需要。</p></li><li><p><strong>生活的主人：</strong>虽然我们对于自己的感受和意愿负有完全的责任和义务，但是我们无法为他人负责，也无法通过牺牲自己来满足他人。这个时候，我想作者是认为我们没有必要去迎合他人，但是也不能像 <strong>面目可憎时期</strong>去拒绝他人的感受和需要，这时应该既要充分表达自己的需要，也要理解他人的需要，并且组织语言，来找到平衡点。感觉就是，不要刻意的迎合他人，也要直接表达出自己的需要。</p></li></ul></li></ul><h3 id="请求帮助"><a href="#请求帮助" class="headerlink" title="请求帮助"></a>请求帮助</h3><ul><li>用什么样的方式提出请求容易得到积极的回应？<ul><li><strong>提出具体的请求</strong>，当我们提出的请求不具体的或者<strong>请求他人不要干什么</strong>的时候，他人反而不会了解我们要什么，甚至会引起他人的反感（因为大多数人都会更加倾向于积极的回应要做什么，而不是不要做什么）。<ul><li>不要使用<strong>经常</strong>这种不能界定发频率词语，具体到一周一次之类的。</li><li>比如妻子对丈夫说“我希望你每周有一天晚上在家陪我和孩子” 而不是说 “我希望你不要放太多时间在工作上”</li><li>比如在辩论前，“我”告诉自己“不要太激动” — <strong>这只是告诉自己要避免什么，没有告诉自己要主动做什么</strong>。</li></ul></li></ul></li><li><strong>如何区分请求和命令：</strong><ul><li>请求没有得到满足的时候，提出请求的人如果批评和指责，那就是命令</li><li>如果像利用对方的内疚来达到目的，也是命令。</li><li><strong>一个例子：</strong>当母亲对孩子说：“当我看到你没有答应做你答应做的家务的时候，我十分失望。因为我希望回家以后有一个干净整洁的环境。”但是孩子什么都没有干，这时，母亲说“像你这样懒惰的人不会有什么大成就的”</li></ul></li><li>由于我们所要表达的意思与别人的理解有可能不一致，所以我们要<strong>请求他人的反馈</strong>。否则，讨论可能会没有任何的用处。</li><li>当人们认为不答应我们的请求的时候就会受到惩罚，他们就会把我们的请求看作是命令。如果我们清楚的表达我们无意强人所难，也许大家就会认为我们提出的是请求而不是命令。</li></ul><h3 id="用全身心倾听"><a href="#用全身心倾听" class="headerlink" title="用全身心倾听"></a>用全身心倾听</h3><ul><li>为了倾听他人，我们要先放下已有的想法和判断，全神贯注的体会对方。</li><li>然而，用全身心的倾听他人并不容易</li><li>如果一个人想要被人了解他的处境，听到的确实安慰和建议，那么，他就有可能感觉不舒服。</li><li>有哪些行为回妨碍我们体会他人的处境<ul><li><strong>建议：</strong>“我想你应该……”</li><li><strong>比较：</strong>”这算不了什么，你听听我的经历……”</li><li><strong>说教：</strong>“如果你这样做……你将回得到很大的益处”</li><li><strong>安慰：</strong>“这不是你的错；你已经尽最大努力了……”</li><li><strong>回忆：</strong>”这让我们想起，，“</li><li><strong>否定：</strong>”高兴一点，不要那么难过。“</li><li><strong>同情：</strong>”哦，你这个可怜的人……”</li><li><strong>询问：</strong>”这种情况是什么时候开始的？“</li><li><strong>辩解：</strong>”我原想早点打电话给你，但是昨晚……”</li><li><strong>纠正：</strong>“事情的经过不是那样的”</li></ul></li><li>我们常常认为，当亲友感到痛苦的时候，我们应该想办法使他们好受一点。然而，<strong>急于采取行动</strong>使我们无法充分的体会到他们的状况。</li><li><strong>倾听他人意味着放下自己所有的想法和判断，一心一意的体会他人。</strong></li><li>要体会他人的感受和需要<ul><li>“你感到不高兴，是因为你觉得我不理解你？”（这是在关心对方的想法）</li><li>“你感到不高兴，是因为你需要得到理解？”（这是体会对方的需要）</li></ul></li><li>在倾听他人的观察，感受，需要和请求以后，我们要主动表达我们的理解来确认是否理解了对方。</li><li>保持关注：也就是不断的给出反馈，是对方不断的表达自己的感受。当对方得到了充分的倾听的时候，我们将体会到气氛变得轻松，他也会停止谈话。</li><li>当我们痛苦的无法倾听他人的时候，我们需要：<ol><li>体会自己的感受和需要</li><li><strong>大声的</strong>提出请求</li><li>换一个环境</li></ol></li></ul><h3 id="倾听的力量"><a href="#倾听的力量" class="headerlink" title="倾听的力量"></a>倾听的力量</h3><ul><li>如果有人倾听你，不对你评头论足，不替你担惊受怕，也不像改变你，这该多好啊。</li><li>在一个生气的人面前，永远不要用“不过”， “可是”， “但是”之类的词语。</li><li>当别人说“不”的时候，我们常常感觉自己受到了伤害。然而，如果我们能够体会他人的感受和需要，我们就能发现是什么使得他们无法答应我们的请求。</li><li>让谈话变得有趣：提醒说话的人留意自己的感受和需要。</li><li>打断别人比假装在听，更符合对方的愿望。所有人都希望自己的话对人有益，而不像被人当作负担。</li></ul><h3 id="爱自己"><a href="#爱自己" class="headerlink" title="爱自己"></a>爱自己</h3><ul><li>之前的章节都是在讲如何使用非暴力共同来完善和他人之间的关系。然而，非暴力沟通最重要的应用也许在于——爱护自己。</li><li>当我们给予自己负面评价或者习惯于将自己视为工具的时候——一个充满各种缺陷的工具，自我憎恨还奇怪吗？</li><li>如何培养对于自己的爱？<strong>转变自我评价的方式</strong></li><li>当我们表现的不完美的时候，我们会自责，让自己陷于自我憎恨之中。而无法从失误中获益 —— 失误揭示我们的局限性，并引导我们的成长。<strong>自责是尚未满足需要的可悲的表达</strong></li><li>作者希望我们的改变是出于对于生命的爱，而不是出于愧疚或内疚这些具有负面影响的心理。</li><li>在外面的语言中，“应该”这个词常常引起我们的内疚和羞愧。“我应该早点知道” “我不应该在这样“</li><li>当我们开始痛骂自己的时候，我们要注意到的是，自己有什么需要没有满足。要知道需要没有满足，这种遗憾在人生中是难免的，我没有必要责备自己。一旦专注于没有满足的需要，我们就要像办法去满足它。反之，如果用苛刻的语言指责自己，我们不仅难以找到解决的办法，也容易陷入自我惩罚的痛苦之中。</li><li>爱惜自己的关键之一是同时包容两个不同的我：<ul><li>一方面是包容 对于过去行为感到后悔的我</li><li>一方面是包容 采取那种行动的我</li></ul></li><li>当我们开始自责的时候，或许可以选择原谅自己。我们要意识到，尽管过去的选择不理想，但是它也是为了实现自己内心的渴望。</li><li>如果我们致力于满足他人及自己健康成长的需要，那么，即使艰难的工作也不乏乐趣。反之，如果我们的行为是出于义务，职责，恐惧，内疚和羞愧。那么即使是有意义的事情也会变得没有乐趣。</li><li><strong>用”选择做”代替“不得不”</strong><ul><li>第一步：在生活中，你觉得哪些事情没有意思，但是又不得不去做，把他们写下来，记在纸上。</li><li>第二步：在每一件事的前面加上，我 <strong>我选择做</strong>。</li><li>第三步：<strong>解释原因。</strong>我选择做……，是因为我想要……</li></ul></li><li>做了上面的实验之后，在进一步深入了理解我们的动机是什么。一般来说动机如下，但是这些动机是不太健康 的。<ul><li>为了钱。在非暴力沟通中，钱并不被认为是一种“需要”；他只是被用来满足某一种需要的无数种策略中的一种。</li><li>为了得到赞同。我们小时候，家长总会因为我们做了好事而又奖励，做了坏事，就要受到惩罚。于是，等到我们长大之后，我们就会误认为生命的意义就是为了获得奖励，渴望得到他人的赞赏。为了得到赞赏，我们会委曲求全。实际上，如果我们的行为都是出于对于生命的热爱，人们自然会感激，这时我们体会到的快乐是无与伦比的。</li><li>为了逃避惩罚。文中举的例子是纳税，但是目前我还没有这个顾虑哈哈哈。</li><li><strong>不想感到羞愧</strong></li><li><strong>为了避免内疚</strong>不做一些事情，我们担心没有办法满足其他人的期待。</li><li><strong>为了履行职责</strong>“不得不，应当，必须，不能”</li></ul></li><li>当我们评价自己的行为的时候，我们专注于自己尚未满足的需要，这样我们就不会因为羞愧沮丧来寻求改变。</li></ul><h3 id="充分表达愤怒"><a href="#充分表达愤怒" class="headerlink" title="充分表达愤怒"></a>充分表达愤怒</h3><ul><li>当我们生气的时候，不要自己生气归咎于他人，这样我们就难免会去指责他人。<strong>然而，实际情况是我们的心情并不取决于他人。</strong></li><li>当我们生气的时候，是因为我们的需要没有满足。当我们约会的时候，对方来晚了，如果你看重的是诚实守信，那你可能会开始生气了，但是如果这个时候你刚好想要休息一会，你也许就不会感到生气了。</li><li><strong>愤怒的核心是自己的需要没有得到满足。</strong></li><li><strong>愤怒驱使我们去惩罚他人而不是去满足需要。</strong></li><li>用 <strong>我生气是因为我需要……</strong> 来代替 <strong>我生气是因为他们做了什么…..</strong></li><li>表达愤怒的四个步骤：<ul><li><ol><li>停下来，除了呼吸，什么都别做</li></ol></li><li><ol><li>想一想是什么想法使我们生气了</li></ol></li><li><ol><li>体会自己的感受和需要</li></ol></li><li><ol><li>表达感受和尚未满足的需要</li></ol></li><li>在3 和 4中要先倾听别人。</li></ul></li></ul><h3 id="运用强制力避免伤害"><a href="#运用强制力避免伤害" class="headerlink" title="运用强制力避免伤害"></a>运用强制力避免伤害</h3><ul><li>我们运用强制力是出于防卫的目的，而不是出于惩罚他人的目的。</li><li>在实际生活中，惩罚往往加强了对方的敌意和抵触心理，使双方的关系更加疏远。</li><li>体罚的类型：<ul><li>肢体暴力：打屁股</li><li>语言暴力：骂自私等等</li></ul></li><li>体罚从某种程度上来讲是，是在鼓励孩子可以使用暴力解决问题。</li><li><strong>惩罚的代价：</strong>就是让我们树立敌人，当我们被认为是施暴者的时候，我们就很难得到友善的回应。</li></ul><h3 id="重获生活的热情"><a href="#重获生活的热情" class="headerlink" title="重获生活的热情"></a>重获生活的热情</h3><ul><li>一般来说，我们的文化倾向于把个人需要看作是消极的，具有破坏性的。如果一个人公开表达自己的需要，就很有可能被认为是自私的，非暴力沟通帮助我们认识倒是社会文化对于个体的消极影响。一旦认识到社会文化的局限性，我们就有可能突破他的束缚，至少，我们迈出了关键的一步。</li><li>很多时候，我们感到沮丧是因为我们出于激烈的内心冲突之中。一种声音告诉自己“我要这样做”，另一种声音说“不， 你不应该这样做。”。沮丧意味着我不知道自己想要什么，自己的需要到底是什么？</li><li>小结：当情绪低落的时候，我们也许会怨天尤人。然而，无论我们以苛刻的态度对人对己，自己的心情也不会有所改变。我们要发现自己的需要，并且采取积极的行动。（好抽象的感觉）</li></ul><h3 id="表达感激"><a href="#表达感激" class="headerlink" title="表达感激"></a>表达感激</h3><ul><li><p><strong>很多时候，在赞扬他人的时候，我们很少揭示内心活动，而是把自己放在了裁判的位置。所以，作者认为，赞扬并不总是有助于升华彼此的联系。</strong></p><ul><li>看到这句话的时候，我豁然开朗。之前在一段感情的时候，我总是会认为赞扬她做的每一件事是好的，即使有时候我不了解她做的事情或者是我不太喜欢，不太认可的时候。我没有说出自己内心真实的想法，而是用赞扬代替了。</li></ul></li><li><p>非暴力沟通表达感激的三要素：</p><ul><li><strong>对方做了什么事情使得我们的生活得到改善（心灵上也可以）</strong></li><li><strong>我们有哪些需要得到了满足</strong></li><li><strong>我们的心情怎么样</strong></li></ul></li><li><p>当别人向你表达很笼统的感激的时候（你真了不起，你聪明过人），我们可以用上面的三个要素来问对方为何给出这样的评价。</p></li><li><p>听到对方的感激的时候，我们有时候会觉得变扭，因为我们不知道自己是都真的这么好。甚至，我们还会对自己有所期待。</p></li><li><p>当我们听到别人对于自己的表扬的时候，我们常常有两种反映：</p><ul><li>自我膨胀，认为自己比别人优秀</li><li>假谦虚，否定别人的赞赏，说”哦，这没什么“</li><li>我们听到赞扬之后，<strong>我们可以和对方一起庆祝生命之美——不自大，也不要假谦虚。</strong></li></ul></li><li><p><strong>时刻提醒自己不要假谦虚</strong>：当代作家玛丽安威廉斯说：”我们最大 的恐惧不是我们不够完美，我们最大的恐惧而是我们无比强大，缩小自己，好让周边的人不会觉得不自在，这不明智。因为我们生下来就是为了能够彰显内在的光芒。当我们让自己的光芒闪耀的时候，无意之中也允许了他人散发光芒。”</p></li><li><p>所有人对于渴望感激，但是很多时候，人们往往会记住别人对于自己的抱怨而不是感激。</p></li><li><p>这大概是我唯一记录下的这本书中的一个例子，看完之后很有感触，但是说不出来：</p><blockquote><p>有一位老师的学生，因为没有做好考试准备，在一次考试中写上名字交了白卷。当卷子发下来的时候，学生很惊讶，他发现他自己得了14分（满分100）。于是他问老师：“我怎么会有14分呢？” 老师回答说：“整洁”。</p></blockquote><ul><li>很多时候，人们往往会记住别人对于自己的抱怨而不是感激。如果老师看到的只是空白而十分生气，把孩子教训了一顿，于事无补，孩子可能还会对于学习没有热情，或者是出于内疚学习，这不是出于真正的热爱。但是老师这样说，我相信这个孩子会发自内心开始好好复习，下次不会发生这样的事情。</li></ul></li></ul><p><img src="/%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A/index/1.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理学 </tag>
            
            <tag> 人际关系 </tag>
            
            <tag> 沟通 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>富爸爸穷爸爸</title>
      <link href="/%E5%AF%8C%E7%88%B8%E7%88%B8%E7%A9%B7%E7%88%B8%E7%88%B8/index.html"/>
      <url>/%E5%AF%8C%E7%88%B8%E7%88%B8%E7%A9%B7%E7%88%B8%E7%88%B8/index.html</url>
      
        <content type="html"><![CDATA[<p><strong>课程</strong></p><ul><li>今天，您所给孩子的最坏的建议就是：去学校，好好念书，然后找一个安全的工作。这是旧的建议，而且是坏的建议。</li><li>鼓励孩子成为雇员，就是建议你的孩子在他的一生中缴纳超过他们应付的份额的税，只是得到很少而不确定的养老金。</li><li>穷人和破产者的区别是：破产时暂时的，而贫穷是永久的</li><li><strong>穷人和中产阶级为钱而工作，富人让钱为他们工作</strong> </li><li>资产是把钱拿到你口袋了里的东西，而负债是把钱从口袋拿出来的</li><li>剑：武器；宝石：财富；镜子：自知</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">穷爸爸</th><th style="text-align:center">富爸爸</th></tr></thead><tbody><tr><td style="text-align:center">找一个安稳的工作</td><td style="text-align:center">学会钱的运作规律</td></tr></tbody></table></div><ul><li>富人买入资产，穷人只有支出，中产阶级买入他们以为是资产的负债</li><li>几种资产：<ul><li>不需要我到场也可以运营的业务。</li><li>股票，债券，基金，房地产，专利</li></ul></li><li><strong>做一个努力工作的雇员，确保你的工作，但是要不断构筑资产</strong></li><li>奢侈品是对于投资和资产收入的奖励。而不是用自己的血汗钱去买。</li><li>税最初只是针对富人。纳税的方法是由大众制定的并经多数人同意，它要让穷人和中产阶级看到税收是为了惩罚有钱人，因此，大众投了赞同票，并将依法纳税写入了宪法。而初衷是惩罚有钱人的税收，在现实中却惩罚了对它投赞同票的中产阶级和穷人。</li><li>风险无处不在，要学会驾驭风险，而不是一味的回避。</li><li>有一个古老的格言:“工作就是比破产强一点”</li><li>穷爸爸希望我有所专长，但是富爸爸希望我能够“培养”自己</li></ul><p><strong>克服困难</strong></p><ul><li><p>当人们有了财务知识的时候也许还是无法积累资产，原因如下：</p><ul><li><p>恐惧心理：还怕失去金钱</p><ul><li>方法：早点积累自己的钱</li><li>富爸爸经常告诉我和迈克，在财务上不能获得成功的最大原因是大部分人的做法过于安全。“人们因为太害怕失败,所以才会失败。”这是他常说的话。</li><li>胜利意味着不害怕失败</li><li>在我的生活中，我注意到失败常常伴随着成功。在我最终学会骑自行车之前,我曾经跌倒过许多次，我从来没有遇到过不曾打丢球的高尔夫球手,也从未见过不曾伤心过的恋人更未曾见过从不损失金钱的富人。</li><li>人人都想上天堂，但是没有人想死</li><li>成功者在最初都不是追求平衡的，如果一开始就追求平衡，那么就是原地踏步。</li><li>积聚资产项目非常容易,这就好比是玩一场低智能游戏,不需要受到很多教育,五年级数学水平就够了。然而,将资产用于投资却是一种高智商游戏,它需要胆量、耐心和对待失败的良好态度。失败者回避失败,而失败本来是可以使失败者转变为成功者的。</li></ul></li><li><p>克服愤世嫉俗的心理</p><ul><li><blockquote><p>愤世嫉俗：意思是有正义感的人对黑暗的现实社会和不合理的习俗表示愤恨、憎恶。</p></blockquote></li><li><p>当自己感到不安还害怕的时候就会开始怀疑自己</p></li><li><p>愤世嫉俗者从来不会赢，未证实怀疑和恐惧会产生愤世嫉俗者，愤世嫉俗者抱怨现实，而成功者分析现实</p></li></ul></li><li><p>懒惰</p><ul><li>方法：要“贪婪”一点，勇敢追求自己想要的生活。问自己，我应该得到什么？</li></ul></li><li><p>习惯</p><ul><li>富爸爸总是最后在月末付账单，先投资自己，这样迫于压力就不得不找更多的方式去赚钱。</li></ul></li><li><p>傲慢，傲慢是无知的另一面</p><ul><li>很多人用傲慢来掩饰自己的无知</li><li>在资金、金融和投资领域，有许多人完全不知道自已在谈论什么。财经行业的大部分人喜欢滔滔不绝地夸夸其谈，其实他们并没有什么真才实学。</li><li>如果你知道自己在某一问题上欠缺知识，不要试图掩饰,因为那是在欺骗你自己,你应该做的是去找一位这一领域的专家或者找一本有关这一问题的书,马上开始教育自己。</li></ul></li></ul></li></ul><p><strong>开始行动</strong></p><ul><li>十种方法唤醒自己的理财天赋：<ul><li><strong>一个超现实的理由 — 精神的力量</strong><ul><li>“想要”和“不想要”的结合</li><li>我不想一生都工作，不想一直是一个打工仔；想要周游世界，想要财务自由等等</li><li>给自己强有力的理由</li></ul></li><li><strong>选择的力量</strong><ul><li>事实上我们每天都应该进行一个选择:即选择如何利用自己的时间、自己的金钱以及我们头脑里所学到的东西去实现我们的目标，这就是选择的力量。</li><li>当你是一个穷人时，你唯一拥有的资产就是自己的大脑。</li><li>骄傲自大和吹毛求疵的人往往是缺乏自信和不敢冒险的人。</li></ul></li><li><strong>慎重的选择朋友</strong><ul><li>财务情况不是交友的唯一标准，三人行必有我师</li><li>但是要注意，不要听胆小的人的话，否则你也会变得杞人忧天</li><li>在积累财富的过程中，最困难的事莫过于坚持自己的选择而不盲目从众。</li></ul></li><li><strong>掌握一种模式，然后再学习一种新的模式</strong><ul><li>在今天这个快速变化的世界中，并不要求你去学太多的东西，因为当你学到时往往已经过时了，问题在于你<strong>学得有多快</strong>，也就是我前面所说的要具备<strong>快速学习</strong>的能力,这种技能是无价之宝。如果你想赚到钱,寻找一条捷径是非常关键的。为金钱而工作是人类在穴居时代产生的一个公式,它早已过时了。</li></ul></li><li><strong>投资自己：自律的力量</strong><ul><li>是否缺乏自律是富人，穷人和中产阶级区分开来的首要因素。</li><li>再支付每月支出之前，先把钱安排在自己的资产项目上。</li><li>当我偶尔资金短缺时,我仍然首先支付自己。我宁愿让债权人和政府高声喊叫，他们越着急我越高兴。为什么?因为这些人在为我摇旗呐喊，他们在激励我出去挣更多的钱。</li><li><strong>不要背上数额过大的债务包袱。</strong>要使自己的支出保持低水平。首先增加自己的资产，然后，再用自己的资产中产生的现金流购买大房子或好车子。</li><li>当你资金短缺时，去承受外在压力而不要动用你的储蓄或投资,利用这种压力来激发你的财务天赋,想出新办法挣到更多的钱，然后再支付账单。这样做,不但能提高你赚钱的能力,还能提高你的财商。</li><li>穷人有不好的习惯，一全普遍的坏习惯是随便“动用储蓄”。富人知道储蓄只能用于创造更多的钱,而不是用来支付账单。</li><li>致富不以牺牲舒适生活为代价，用储蓄支付账单。</li></ul></li><li><strong>给你的经纪人优厚的报酬</strong><ul><li><strong>我们生活在信息时代，信息是无价的。</strong>一位好的经纪人应该给你提供信息,同时还应花时间来教育你。</li></ul></li><li><strong>做一个“印第安给予者“</strong><ul><li>投资 $\rightarrow$ 盈利 $\rightarrow$ 撤回本金$\rightarrow$继续盈利</li><li>要学会止盈，不要贪婪，要自律</li></ul></li><li><strong>资产用来购买奢侈品</strong><ul><li>奢侈品是对自己的奖励</li></ul></li><li><strong>对英雄的崇拜</strong><ul><li>读相关领域中优秀者的书籍，并且在相关领域刻意模仿。</li></ul></li><li><strong>先付出再收获：给予的力量</strong></li></ul></li></ul><p><strong>一些事情</strong></p><ul><li>对于要开始付出实践的人的，有几点建议：<ul><li>停下手中的活：放弃无效的事情</li><li>寻找新思想：去找新的思想，并且<strong>付出行动</strong></li><li>找一个做过你想做的事的人，<strong>找他共进午餐</strong></li><li>参加辅导班并购买相关磁带</li><li>提供多个报价：寻找 $\rightarrow$ 报价 $\rightarrow$ 还价  $\rightarrow$ 谈判  $\rightarrow$ 拒绝或接受<ul><li>在合同上写“需要我的商业伙伴同意”，即使你没有商业伙伴。这样当他人接受了你的报价以后，可以方便你拒绝（当你反悔的时候）</li></ul></li><li>消费者总是穷人：哪些在超市打折的时候冲进去买东西的人往往在股市下跌的时候下车。</li><li>行动者总会击败不行动者。</li></ul></li></ul><p><strong>结束语</strong></p><ul><li>金钱是一种思想，如果你想要钱，只要改变自己的思想。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 投资理财 </tag>
            
            <tag> 财商 </tag>
            
            <tag> 思维模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>latex转换markdown</title>
      <link href="/latex%E8%BD%AC%E6%8D%A2markdown/index.html"/>
      <url>/latex%E8%BD%AC%E6%8D%A2markdown/index.html</url>
      
        <content type="html"><![CDATA[<ol><li>首先安装pandoc <a href="http://pandoc.org/installing.html">install pandoc into your system</a>到你的电脑</li><li>以windows为例输入如下指令</li></ol><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> tex文件所属的目录</span><br><span class="line">pandoc -s tex文件名.tex -o <span class="built_in">md</span>的文件名.<span class="built_in">md</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>人类简史</title>
      <link href="/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2/index.html"/>
      <url>/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2/index.html</url>
      
        <content type="html"><![CDATA[  <div class="row">    <embed src="https://hasuer.github.io/人类简史/index/document.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 社会 </tag>
            
            <tag> 人类史 </tag>
            
            <tag> 历史 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>改变vscode默认代码格式</title>
      <link href="/%E6%94%B9%E5%8F%98vscode%E9%BB%98%E8%AE%A4%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F/index.html"/>
      <url>/%E6%94%B9%E5%8F%98vscode%E9%BB%98%E8%AE%A4%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F/index.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要解决了vscode 默认代码格式大括号换行的问题</p></blockquote><ol><li><p>打开Vscode <code>setting</code></p><p><img src="/%E6%94%B9%E5%8F%98vscode%E9%BB%98%E8%AE%A4%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F/index/1.png"></p></li><li><p>搜索<code>clang</code>,并做如下修改：</p><p><img src="/%E6%94%B9%E5%8F%98vscode%E9%BB%98%E8%AE%A4%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F/index/2.png"></p><p><img src="/%E6%94%B9%E5%8F%98vscode%E9%BB%98%E8%AE%A4%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F/index/3.png"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Vscode tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Matlab_plot</title>
      <link href="/matlab-plot/index.html"/>
      <url>/matlab-plot/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="Matlab-画柱状图、饼图、折线图"><a href="#Matlab-画柱状图、饼图、折线图" class="headerlink" title="Matlab 画柱状图、饼图、折线图"></a>Matlab 画柱状图、饼图、折线图</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">TBdata = [</span><br><span class="line"><span class="number">1990</span> <span class="number">4889</span> <span class="number">16.4</span>; <span class="number">1991</span> <span class="number">5273</span> <span class="number">17.4</span>; <span class="number">1992</span> <span class="number">5382</span> <span class="number">17.4</span>; <span class="number">1993</span> <span class="number">5173</span> <span class="number">16.5</span>;</span><br><span class="line"><span class="number">1994</span> <span class="number">4860</span> <span class="number">15.4</span>; <span class="number">1995</span> <span class="number">4675</span> <span class="number">14.7</span>; <span class="number">1996</span> <span class="number">4313</span> <span class="number">13.5</span>; <span class="number">1997</span> <span class="number">4059</span> <span class="number">12.5</span>;</span><br><span class="line"><span class="number">1998</span> <span class="number">3855</span> <span class="number">11.7</span>; <span class="number">1999</span> <span class="number">3608</span> <span class="number">10.8</span>; <span class="number">2000</span> <span class="number">3297</span> <span class="number">9.7</span>; <span class="number">2001</span> <span class="number">3332</span> <span class="number">9.6</span>;</span><br><span class="line"><span class="number">2002</span> <span class="number">3169</span> <span class="number">9.0</span>; <span class="number">2003</span> <span class="number">3227</span> <span class="number">9.0</span>; <span class="number">2004</span> <span class="number">2989</span> <span class="number">8.2</span>; <span class="number">2005</span> <span class="number">2903</span> <span class="number">7.9</span>;</span><br><span class="line"><span class="number">2006</span> <span class="number">2779</span> <span class="number">7.4</span>; <span class="number">2007</span> <span class="number">2725</span> <span class="number">7.2</span>];</span><br><span class="line">measles = [<span class="number">38556</span> <span class="number">24472</span> <span class="number">14556</span> <span class="number">18060</span> <span class="number">19549</span> <span class="number">8122</span> <span class="number">28541</span> <span class="number">7880</span> <span class="number">3283</span> <span class="number">4135</span> <span class="number">7953</span> <span class="number">1884</span>]&#x27;;</span><br><span class="line">mumps = [<span class="number">20178</span> <span class="number">23536</span> <span class="number">34561</span> <span class="number">37395</span> <span class="number">36072</span> <span class="number">32237</span> <span class="number">18597</span> <span class="number">9408</span> <span class="number">6005</span> <span class="number">6268</span> <span class="number">8963</span> <span class="number">13882</span>]&#x27;;</span><br><span class="line">chickenPox = [<span class="number">37140</span> <span class="number">32169</span> <span class="number">37533</span> <span class="number">39103</span> <span class="number">33244</span> <span class="number">23269</span> <span class="number">16737</span> <span class="number">5411</span> <span class="number">3435</span> <span class="number">6052</span> <span class="number">12825</span> <span class="number">23332</span>]&#x27;;</span><br><span class="line"></span><br><span class="line">years = TBdata(:, <span class="number">1</span>);</span><br><span class="line">cases = TBdata(:, <span class="number">2</span>);</span><br><span class="line">rate = TBdata(:, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Create the pie chart in position 1 of a 2x2 grid</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">pie([sum(measles) sum(mumps) sum(chickenPox)], &#123;<span class="string">&#x27;Measles&#x27;</span>, <span class="string">&#x27;Mumps&#x27;</span>, <span class="string">&#x27;Chicken Pox&#x27;</span>&#125;)</span><br><span class="line">title(<span class="string">&#x27;Childhood Diseases&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% Create the bar chart in position 2 of a 2x2 grid</span></span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">bar(<span class="number">1</span>:<span class="number">12</span>, [measles/<span class="number">1000</span> mumps/<span class="number">1000</span> chickenPox/<span class="number">1000</span>], <span class="number">0.5</span>, <span class="string">&#x27;stack&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;Month&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;Cases (in thousands)&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Childhood Diseases&#x27;</span>)</span><br><span class="line">axis([<span class="number">0</span> <span class="number">13</span> <span class="number">0</span> <span class="number">100</span>])</span><br><span class="line">set(gca, <span class="string">&#x27;XTick&#x27;</span>, <span class="number">1</span>:<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% Create the stem chart in position 3 of a 2x2 grid</span></span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">stem(years, cases)</span><br><span class="line">xlabel(<span class="string">&#x27;Years&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;Cases&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Tuberculosis Cases&#x27;</span>)</span><br><span class="line">axis([<span class="number">1988</span> <span class="number">2009</span> <span class="number">0</span> <span class="number">6000</span>])</span><br><span class="line"><span class="comment">% Create the line plot in position 4 of a 2x2 grid</span></span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">plot</span>(years, rate)</span><br><span class="line">xlabel(<span class="string">&#x27;Years&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;Infection Rate&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Tuberculosis Cases&#x27;</span>)</span><br><span class="line">axis([<span class="number">1988</span> <span class="number">2009</span> <span class="number">5</span> <span class="number">20</span>])</span><br></pre></td></tr></table></figure><p><img src="/matlab-plot/index/1.png"></p>]]></content>
      
      
      <categories>
          
          <category> Matlab </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PA3实验报告</title>
      <link href="/pa3%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/index.html"/>
      <url>/pa3%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="实验进度"><a href="#实验进度" class="headerlink" title="实验进度"></a>实验进度</h2><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">是否已完成</th></tr></thead><tbody><tr><td style="text-align:center">必做任务1</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">必做任务2</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">必做任务3</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">必做任务4</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">选做任务1</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">选做任务2</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">选做任务3</td><td style="text-align:center">√</td></tr></tbody></table></div><h3 id="思考题1"><a href="#思考题1" class="headerlink" title="思考题1"></a>思考题1</h3><p><strong>GDT有多大？</strong></p><p>段寄存器中用作GDT表下标的位段宽度是13位，所以GDT中可以有2^13=8192个描述项。</p><p>每个进程都要在全局段描述表GDT中占据两个表项</p><p>每个进程的局部段描述表LDT都作为一个独立的段而存在，在全局段描述表GDT中要有一个表项指向这个段的起始地址，并说明该段的长度以及其他一些 参数。除上之外，每个进程还有一个TSS结构(任务状态段)也是一样。所以，每个进程都要在全局段描述表GDT中占据两个表项。</p><h3 id="思考题2"><a href="#思考题2" class="headerlink" title="思考题2"></a>思考题2</h3><p><strong>GDTR中存放的GDT首地址可以是虚拟地址吗？</strong></p><p>不可以，因为GDT的转换规则就是在GDRT中读出段的首地址，根据段寄存器中的选择符index位在表中进行索引 位在表中进行索引 , 找到一个段描述符 。在段描述符中读出的基地址和虚拟地址相加 , 得出线性地址 。</p><p>虚拟地址就是需要通过GDT进行转换来映射到物理地址，所以GDT的首地址一定要是物理地址，不然在不同的工作环境中就使用相同的GDT机制的出来的结果是不相同的。</p><h3 id="思考题３"><a href="#思考题３" class="headerlink" title="思考题３"></a>思考题３</h3><p><strong>如何提高寻找段描述符的效率?</strong></p><p>在段寄存器中保存基地址，之后在进行访问的时候采用映射的方法，基地址加上偏移量找到。</p><h3 id="思考题４"><a href="#思考题４" class="headerlink" title="思考题４"></a>思考题４</h3><p><strong>段式存储管理的缺点</strong></p><ul><li>段的体积大，在内存中无法做到连续存储，容易形成外碎片，降低内存利用率。</li></ul><h3 id="思考题５"><a href="#思考题５" class="headerlink" title="思考题５"></a>思考题５</h3><p><strong>页式存储管理的优点</strong></p><ul><li><p>分页式管理便于进行内存调度，可以有自己的调度算法</p></li><li><p>并且没有外碎片，内碎片不超过页的大小</p></li></ul><h3 id="思考题６"><a href="#思考题６" class="headerlink" title="思考题６"></a>思考题６</h3><p><strong>问题1：</strong></p><p><img src="/pa3%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/index/Users\86150\Desktop\Snipaste_2021-01-17_14-30-55.png" alt="Snipaste_2021-01-17_14-30-55">因为低12位是页内偏移，可以直接根据虚拟地址给出，不需要进行转换。</p><p><strong>问题2：</strong></p><p>是必须的。和问题2一样，CR3是用于物理地址转换的，如果它也是虚拟地址就没有什么可以转换CR3的线性地址了。</p><p><strong>问题3</strong></p><p>一级页表有占用内存过多的缺点。多级页表能够有效的减少内存的占用，虽然看上去消耗内存反而增大了，但是实际上很多对应页表没有用到，并没有实际创建因而减小了内存。</p><h3 id="思考题７"><a href="#思考题７" class="headerlink" title="思考题７"></a>思考题７</h3><p><strong>空指针真的是空的吗？</strong></p><p>空指针并不是空的，只是指向的地址是０，属于操作系统无法访问。</p><h3 id="思考题８"><a href="#思考题８" class="headerlink" title="思考题８"></a>思考题８</h3><p><strong>在扁平模式下如何访问？</strong></p><p>在页表项中有权限位，进行地址转换时首先检查权限位，倘若没有权限就无法访问，也就不会有地址转换的步骤了。</p><h3 id="思考题９"><a href="#思考题９" class="headerlink" title="思考题９"></a>思考题９</h3><p><img src="/pa3%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/index/Users\86150\Desktop\Snipaste_2021-01-17_13-48-29.png" alt="Snipaste_2021-01-17_13-48-29"></p><p>第一个矩形表示的是虚拟地址，虚拟地址中包含了页内偏移和页号，在通过页号来找到对应页表项，在页表项中读取出页框号，将页框号和页内偏移合并到一起成为了实际地址。</p><h3 id="思考题10"><a href="#思考题10" class="headerlink" title="思考题10"></a>思考题10</h3><p><strong>示例代码哪里错了？</strong></p><p><img src="/pa3%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/index/Users\86150\AppData\Roaming\Typora\typora-user-images\image-20210117153643345.png" alt="image-20210117153643345"></p><p>原本的最后 ptable 会到负数，ptable [-1]。</p><h3 id="思考题11"><a href="#思考题11" class="headerlink" title="思考题11"></a>思考题11</h3><p><strong>问题１</strong></p><p>因为这里定义的ｘ生成的地址是虚拟地址，超过了物理地址的界限，报错说 <code>0xc014a000 outside of the physical memory.</code>而kvm.c 中的虚拟地址都经过了 va_to_pa 的转换，在物理地址范围之内</p><p><strong>问题2 </strong></p><p>两个虚拟地址指向同一个物理地址是因为在 <code>0xc0100000</code> 上的在 init 中作为今后访问内核的虚拟地址</p><p><strong>问题3</strong></p><p>两个虚拟地址指向同一个物理地址是因为在 <code>0xc0100000</code> 上的在 init 中作为今后访问内核的虚拟地址，另一份在 updir 没有正常使用时让虚拟地址得以正常转换。</p><p><strong>问题4</strong></p><p>出现了 present = 0 的错误。因为开启 paging 位之后，所有地址都需要进行虚拟地址转换，而 esp 还是使用开始的物理地址发现这个虚拟地址下并没有使用。</p><p><strong>问题5</strong></p><p>出现的问题和上面相同，使用 init_cond () 会先 push 再 jmp, 之后又会通过 ret 进行返回。通过调试得到是在 loader 中出现问题的，而在 lnaddr_read 和 lnaddr_write 处监视发现对应栈的位置也只读写了一次。只能推测是因为将地址压入栈导致栈溢出</p><h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><ul><li><p>这个实验中包含了考试周，所以在内容的衔接上有点不流畅，在本学期的操作系统课程中也正好学习了分页分段。</p></li><li><p>在这个实验中，对于分页和分段的代码实现有了更加深刻的理解。</p></li><li>此外就是nemu实在太难了，有一些代码抄了都不是很懂，哎，菜是原罪。</li><li>出bug不可怕，如果能通过debug的过程对框架代码和计算机系统的原理有更深刻的理解，。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NEMU实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.828 Homework_BigFilesForXV6</title>
      <link href="/mit-6-828-homework-bigfilesforxv6/index.html"/>
      <url>/mit-6-828-homework-bigfilesforxv6/index.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-zero-fill.html">实验指导书</a></p><hr><p><a href="https://hasuer.github.io/mit-6-828-operating-system-engineering/index.html">MIT 6.828 Operating System Engineering</a></p><hr><h1 id="Big-Files"><a href="#Big-Files" class="headerlink" title="Big Files"></a>Big Files</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>在这个作业中，您将增加xv6文件的最大大小。目前，xv6文件被限制为140个扇区，或71680个字节。这个限制来自于这样一个事实:xv6 inode包含12个“直接”块号和一个“单间接”块号，即一个块最多可以包含128个块号，总共是12+128=140。您将修改xv6文件系统代码，以支持每个inode中的“双间接”块，它包含128个单间接块的地址，每个块最多可以包含128个数据块的地址。结果是，一个文件将能够包含16523个扇区(或大约8.5兆字节)。</p><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>修改你的Makefile中的cpu定义，使其如下:</p><p>cpu: = 1</p><p>add</p><p>QEMUEXTRA = -snapshot</p><p>right before QEMUOPTS</p><p>当xv6创建大文件时，以上两个步骤极大地加快了qemu的速度。</p><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><ol><li><h5 id="修改-param-h"><a href="#修改-param-h" class="headerlink" title="修改 param.h"></a>修改 param.h</h5><p>将<code>#define FSSIZE 1000 // size of file system in blocks</code></p><p>修改为<code>#define FSSIZE 20000 // size of file system in blocks</code></p></li><li><h5 id="添加-big-c"><a href="#添加-big-c" class="headerlink" title="添加 big.c"></a>添加 big.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;fcntl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">512</span>];</span><br><span class="line">  <span class="keyword">int</span> fd, i, sectors;</span><br><span class="line"></span><br><span class="line">  fd = open(<span class="string">&quot;big.file&quot;</span>, O_CREATE | O_WRONLY);</span><br><span class="line">  <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="number">2</span>, <span class="string">&quot;big: cannot open big.file for writing\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sectors = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    *(<span class="keyword">int</span>*)buf = sectors;</span><br><span class="line">    <span class="keyword">int</span> cc = write(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">if</span>(cc &lt;= <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    sectors++;</span><br><span class="line"><span class="keyword">if</span> (sectors % <span class="number">100</span> == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="number">2</span>, <span class="string">&quot;.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="number">1</span>, <span class="string">&quot;\nwrote %d sectors\n&quot;</span>, sectors);</span><br><span class="line"></span><br><span class="line">  close(fd);</span><br><span class="line">  fd = open(<span class="string">&quot;big.file&quot;</span>, O_RDONLY);</span><br><span class="line">  <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="number">2</span>, <span class="string">&quot;big: cannot re-open big.file for reading\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sectors; i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> cc = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">if</span>(cc &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="number">2</span>, <span class="string">&quot;big: read error at sector %d\n&quot;</span>, i);</span><br><span class="line">      <span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(*(<span class="keyword">int</span>*)buf != i)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="number">2</span>, <span class="string">&quot;big: read the wrong data (%d) for sector %d\n&quot;</span>,</span><br><span class="line">             *(<span class="keyword">int</span>*)buf, i);</span><br><span class="line">      <span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="number">1</span>, <span class="string">&quot;done; ok\n&quot;</span>); </span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="修改-Makefile"><a href="#修改-Makefile" class="headerlink" title="修改 Makefile"></a>修改 Makefile</h5><p>在<code>UPROGS</code>中添加一行<code>_big\</code></p></li><li><h5 id="inode-数据结构"><a href="#inode-数据结构" class="headerlink" title="inode 数据结构"></a>inode 数据结构</h5><p>在Xv6系统中，每一个文件都有一个对应的inode。</p><p>可以看出，一个inode有12个direct指针，它们指向磁盘中的数据块，还有一个indirect指针指向另一个indirect block，这个indirect有<code>BSIZE / sizeof(uint)</code> = 128个指针指向数据块。因此，一个inode可以指向12+128 = 140个数据块。也就是运行了<code>big</code>命令后输出的<code>140 sectors</code>。</p></li><li><h5 id="修改-fs-c"><a href="#修改-fs-c" class="headerlink" title="修改 fs.c"></a>修改 fs.c</h5><p>修改<code>bmap()</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> uint</span></span><br><span class="line"><span class="function"><span class="title">bmap</span><span class="params">(struct inode *ip, uint bn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint addr, *a, *indirect, *double_indirect,indirect_idx, double_indirect_idx;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>, *<span class="title">bp2</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NDIRECT)&#123;</span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[bn] = addr =balloc(ip-&gt;dev);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  bn -= NDIRECT;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NINDIRECT)&#123;</span><br><span class="line">    <span class="comment">// Load indirect block, allocating ifnecessary.</span></span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT] = addr =balloc(ip-&gt;dev);</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">      a[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  bn -= NINDIRECT;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (bn &lt; NINDIRECT*NINDIRECT) &#123;</span><br><span class="line">    <span class="comment">// Load first indirect block, allocating ifnecessary.</span></span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT + <span class="number">1</span>]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT + <span class="number">1</span>] = addr =balloc(ip-&gt;dev);</span><br><span class="line"> </span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    indirect = (uint *) bp-&gt;data;</span><br><span class="line">    indirect_idx = bn / NINDIRECT;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ((addr = indirect[indirect_idx]) == <span class="number">0</span>) &#123;</span><br><span class="line">      addr = indirect[indirect_idx] =balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    bp2 = bread(ip-&gt;dev, addr);</span><br><span class="line">    double_indirect = (uint *) bp2-&gt;data;</span><br><span class="line">    double_indirect_idx = bn % NINDIRECT;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>((addr = double_indirect[double_indirect_idx]) == <span class="number">0</span>) &#123;</span><br><span class="line">      addr =double_indirect[double_indirect_idx] = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp2);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    brelse(bp2);</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  panic(<span class="string">&quot;bmap: out of range&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><h5 id="修改-fs-h"><a href="#修改-fs-h" class="headerlink" title="修改 fs.h"></a>修改 fs.h</h5><p>将<code>#define NDIRECT 12</code></p><p>修改为<code>#define NDIRECT 11</code></p><p>将<code>uint addrs[NDIRECT+1]; // Data block addresses</code></p><p>修改为<code>uint addrs[NDIRECT+2]; // Data block addresses</code></p><p>将<code>#define MAXFILE (NDIRECT + NINDIRECT)</code></p><p>修改为<code>#define MAXFILE (NDIRECT + NINDIRECT + NINDIRECT * NINDIRECT)</code></p></li><li><p><strong>结果</strong></p><p><img src="/mit-6-828-homework-bigfilesforxv6/index/1.png" alt="在这里插入图片描述" style="zoom:50%;"></p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.828 Homework_Locking</title>
      <link href="/mit-6-828-homework-locking/index.html"/>
      <url>/mit-6-828-homework-locking/index.html</url>
      
        <content type="html"><![CDATA[<p>[实验指导书]<a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-lock.html">https://pdos.csail.mit.edu/6.828/2018/homework/xv6-lock.html</a>)</p><hr><p><a href="https://hasuer.github.io/mit-6-828-operating-system-engineering/index.html">MIT 6.828 Operating System Engineering</a></p><hr><h1 id="Locking"><a href="#Locking" class="headerlink" title="Locking"></a>Locking</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>在这个作业中，你将探索中断和锁定之间的一些交互。</p><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h3 id="锁的结构"><a href="#锁的结构" class="headerlink" title="锁的结构"></a>锁的结构</h3><p>阅读 spinlock.h ，锁的结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mutual exclusion lock.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line">  uint locked;       <span class="comment">// Is the lock held?</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// For debugging:</span></span><br><span class="line">  <span class="keyword">char</span> *name;        <span class="comment">// Name of lock.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">cpu</span>;</span>   <span class="comment">// The cpu holding the lock.</span></span><br><span class="line">  uint pcs[<span class="number">10</span>];      <span class="comment">// The call stack (an array of program counters)</span></span><br><span class="line">                     <span class="comment">// that locked the lock.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>spinlock</code> 结构体中 <code>locked</code> 作为标识位， <code>locked = 1</code> 则为上锁，否则已经释放锁</p><p>阅读 xv6 下 spinlock.c，知道 xv6 提供 <code>acquire()</code> 用于获取锁， <code>release()</code> 用于释放锁</p><blockquote><p>acquire()<code>中首先通过</code>pushcli()<code>关闭中断并记录关闭中断次数：获取当前</code>eflags<code>中</code>IF<code>位，并保存到</code>mycpu()-&gt;intena<code>中；随后增加中断次数</code>mycpu()-&gt;ncli</p></blockquote><p>一般而言需要先通过判断锁的状态然后再上锁，由于上面两个步骤不是同时进行，假设线程 P 执行到 <code>while</code> 循环，锁没被占用，此时在没改变锁状态下发生调度切换，线程 Q 也执行到 <code>while</code> 循环，也可以占用锁，会造成两个线程获取同一个锁的情况，所以通过 <code>xchg()</code> 保证原子操作实现锁</p><p><code>__sync_synchronize()</code> 主要为了避免编译器把指令顺序打乱，禁止编译器乱序内存操作。</p><p><code>getcallerpcs()</code> 用于为调试而保存调用栈的信息</p><p><code>release()</code> 主要用于释放锁，主要通过 <code>asm volatile(&quot;movl $0, %0&quot; : &quot;+m&quot; (lk-&gt;locked) : );</code> 解锁，这句话能原子操作</p><h2 id="Don’t-do-this"><a href="#Don’t-do-this" class="headerlink" title="Don’t do this"></a>Don’t do this</h2><p>注意不要写如下代码，会造成死锁：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lk</span>;</span></span><br><span class="line">initlock(&amp;lk, <span class="string">&quot;test lock&quot;</span>);</span><br><span class="line">acquire(&amp;lk);</span><br><span class="line">acquire(&amp;lk);</span><br></pre></td></tr></table></figure><h2 id="Interrupts-in-ide-c"><a href="#Interrupts-in-ide-c" class="headerlink" title="Interrupts in ide.c"></a>Interrupts in ide.c</h2><ol><li>根据要求修改 <code>ide.c:iderw()</code></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PAGEBREAK!</span></span><br><span class="line"><span class="comment">// Sync buf with disk.</span></span><br><span class="line"><span class="comment">// If B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.</span></span><br><span class="line"><span class="comment">// Else if B_VALID is not set, read buf from disk, set B_VALID.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">iderw</span><span class="params">(struct buf *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> **<span class="title">pp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;iderw: buf not locked&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>((b-&gt;flags &amp; (B_VALID|B_DIRTY)) == B_VALID)</span><br><span class="line">    panic(<span class="string">&quot;iderw: nothing to do&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(b-&gt;dev != <span class="number">0</span> &amp;&amp; !havedisk1)</span><br><span class="line">    panic(<span class="string">&quot;iderw: ide disk 1 not present&quot;</span>);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;idelock);  <span class="comment">//DOC:acquire-lock</span></span><br><span class="line"></span><br><span class="line">  sti();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Append b to idequeue.</span></span><br><span class="line">  b-&gt;qnext = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(pp=&amp;idequeue; *pp; pp=&amp;(*pp)-&gt;qnext)  <span class="comment">//DOC:insert-queue</span></span><br><span class="line">    ;</span><br><span class="line">  *pp = b;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Start disk if necessary.</span></span><br><span class="line">  <span class="keyword">if</span>(idequeue == b)</span><br><span class="line">    idestart(b);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Wait for request to finish.</span></span><br><span class="line">  <span class="keyword">while</span>((b-&gt;flags &amp; (B_VALID|B_DIRTY)) != B_VALID)&#123;</span><br><span class="line">    sleep(b, &amp;idelock);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cli();</span><br><span class="line"></span><br><span class="line">  release(&amp;idelock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Interrupts-in-file-c"><a href="#Interrupts-in-file-c" class="headerlink" title="Interrupts in file.c"></a>Interrupts in file.c</h2><p>获取 <code>file_table_lock()</code> 锁在打开中断后没有 <code>panic</code> 的原因：中断发生后没有再次使用共享数据</p><h2 id="xv6-lock-implementation"><a href="#xv6-lock-implementation" class="headerlink" title="xv6 lock implementation"></a>xv6 lock implementation</h2><p>若不这样执行，在执行完lk-&gt;locked置零后，可能另一进程将获取锁，并将lk-&gt;pcs[0]置为该进程相关的信息，然后当前进程再执行清空lk-&gt;pcs[0]的动作，发生了冲突，导致lk-&gt;pcs[0]信息不正确。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Release the lock.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">release</span><span class="params">(struct spinlock *lk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holding(lk))</span><br><span class="line">    panic(<span class="string">&quot;release&quot;</span>);</span><br><span class="line"></span><br><span class="line">  lk-&gt;pcs[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  lk-&gt;cpu = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;movl $0, %0&quot;</span> : <span class="string">&quot;+m&quot;</span> (lk-&gt;locked) : )</span></span>;</span><br><span class="line"></span><br><span class="line">  popcli();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lk-&gt;pcs[0] = 0; lk-&gt;cpu = 0;</code> 在释放锁前面的原因：</p><p>若在释放锁后面，会发生：</p><ol><li>锁释放， <code>lk-&gt;pcs[0]</code> 跟 <code>lk-&gt;cpu</code> 未清除</li><li>另一个 CPU 尝试获取锁并成功，设置 <code>lk-&gt;pcs[0]</code> 跟 <code>lk-&gt;cpu</code></li><li>当前 CPU 清除 <code>lk-&gt;pcs[0]</code> 跟 <code>lk-&gt;cpu</code></li></ol><p>从而导致锁的信息不正确</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.828 Homework_xv6CPUAlarm</title>
      <link href="/mit-6-828-homework-xv6cpualarm/index.html"/>
      <url>/mit-6-828-homework-xv6cpualarm/index.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-alarm.html">实验指导书</a></p><hr><p><a href="https://hasuer.github.io/mit-6-828-operating-system-engineering/index.html">MIT 6.828 Operating System Engineering</a></p><hr><h1 id="CPU-Alarm"><a href="#CPU-Alarm" class="headerlink" title="CPU Alarm"></a>CPU Alarm</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>在本练习中，您将向xv6添加一个特性，当进程使用CPU时间时，该特性会定期向进程发出警报。对于想要限制占用CPU时间的计算绑定进程，或者想要进行计算但又想采取某些周期性操作的进程，这可能很有用。更一般地说，您将实现用户级中断/错误处理程序的基本形式;例如，您可以在应用程序中使用类似的方法来处理页面错误。</p><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><ol><li>您应该添加一个新的alarm(interval, handler)系统调用。如果一个应用程序调用alarm(n, fn)，那么在程序每消耗n个“节拍”的CPU时间后，内核将导致应用程序函数fn被调用。当fn返回时，应用程序将恢复它停止的地方。在xv6中，tick是一个相当任意的时间单位，由硬件计时器产生中断的频率决定。</li></ol><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><h4 id="添加测试命令"><a href="#添加测试命令" class="headerlink" title="添加测试命令"></a>添加测试命令</h4><p>新建一个文件 <code>alarmtest.c</code> 并将实验指导书中的实例代码写在里面：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">periodic</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="number">1</span>, <span class="string">&quot;alarmtest starting\n&quot;</span>);</span><br><span class="line">    alarm(<span class="number">10</span>, periodic);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">250</span> * <span class="number">500000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((i % <span class="number">250000</span>) == <span class="number">0</span>)</span><br><span class="line">            write(<span class="number">2</span>, <span class="string">&quot;.&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">periodic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="number">1</span>, <span class="string">&quot;alarm!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了将 <code>alarmtest.c</code> 编译成Xv6的用户程序，需要修改 <code>Makefile</code> ，在 <code>UPROGS</code> 中加入下面这一行：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_alarmtest\</span><br></pre></td></tr></table></figure><h4 id="添加系统调用"><a href="#添加系统调用" class="headerlink" title="添加系统调用"></a>添加系统调用</h4><p>在 <code>user.h</code> 中添加：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">int</span> ticks, <span class="keyword">void</span>(*hander)())</span></span>;</span><br></pre></td></tr></table></figure><p>在 <code>usys.S</code> 中添加：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL(alarm)</span><br></pre></td></tr></table></figure><p>在 <code>syscall.h</code> 中添加：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_alarm  23</span></span><br></pre></td></tr></table></figure><p>在 <code>syscall.c</code> 中添加：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">sys_alarm</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  </span><br><span class="line"><span class="comment">//static int (*syscalls[])(void) = &#123;</span></span><br><span class="line">        ...</span><br><span class="line">        [SYS_alarm] sys_alarm,</span><br><span class="line"><span class="comment">//&#125;;</span></span><br></pre></td></tr></table></figure><p>在 <code>proc.h</code> 的结构体 <code>proc</code> 中添加：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> alarmticks;</span><br><span class="line"><span class="keyword">int</span> curalarmticks;</span><br><span class="line"><span class="keyword">void</span> (*alarmhandler)();</span><br></pre></td></tr></table></figure><p>在 <code>sysproc.c</code> 中添加：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpu alarm</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sys_alarm</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ticks;</span><br><span class="line">  <span class="keyword">void</span> (*handler)();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;ticks) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(argptr(<span class="number">1</span>, (<span class="keyword">char</span>**)&amp;handler, <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  myproc()-&gt;alarmticks = ticks;</span><br><span class="line">  myproc()-&gt;alarmhandler = handler;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上，系统调用 <code>alarm</code> 就添加完成了。</p><p>下面，要添加中断处理：</p><h4 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h4><p>打开文件 <code>trap.c</code> ，在函数 <code>void trap(struct trapframe *tf)&#123;&#125;</code> 中修改 <code>case T_IRQ0 + IRQ_TIMER</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> T_IRQ0 + IRQ_TIMER:</span><br><span class="line">  <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">    acquire(&amp;tickslock);</span><br><span class="line">    ticks++;</span><br><span class="line">    wakeup(&amp;ticks);</span><br><span class="line">    release(&amp;tickslock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(myproc() &amp;&amp; (tf-&gt;cs &amp; <span class="number">3</span>) == <span class="number">3</span>)&#123;</span><br><span class="line">      myproc()-&gt;curalarmticks++;</span><br><span class="line">      <span class="keyword">if</span>(myproc()-&gt;alarmticks == myproc()-&gt;curalarmticks)&#123;  <span class="comment">// 到达了周期</span></span><br><span class="line">          myproc()-&gt;curalarmticks = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面两句将eip压栈</span></span><br><span class="line">        tf-&gt;esp -= <span class="number">4</span>;    </span><br><span class="line">        *((uint *)(tf-&gt;esp)) = tf-&gt;eip;</span><br><span class="line">        <span class="comment">// 将alarmhandler复制给eip，准备执行</span></span><br><span class="line">        tf-&gt;eip =(uint) myproc()-&gt;alarmhandler;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  lapiceoi();</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>至此，所有修改都已经完成了。</p><p>在Ubuntu下编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make CPUS=1 qemu-nox</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>其中， <code>CPUS=1</code> 是为了将执行速度变慢，以观察系统中断的执行</p><p>运行Xv6后，输入命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> alarmtest</span></span><br></pre></td></tr></table></figure><p>输出结果如下：</p><p><img src="/mit-6-828-homework-xv6cpualarm/index/1.png" alt="在这里插入图片描述" style="zoom:50%;"></p><h2 id="实验总结与心得体会"><a href="#实验总结与心得体会" class="headerlink" title="实验总结与心得体会"></a>实验总结与心得体会</h2><p>实现用户级中断/错误处理程序的基本形式。例如，在应用程序中使用类似的方法来处理页面错误。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MIT OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.828 Homework_LazyPageAllocation</title>
      <link href="/mit-6-828-homework-lazypageallocation/index.html"/>
      <url>/mit-6-828-homework-lazypageallocation/index.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-zero-fill.html">实验指导书</a></p><hr><p><a href="https://hasuer.github.io/mit-6-828-operating-system-engineering/index.html">MIT 6.828 Operating System Engineering</a></p><hr><h1 id="Lazy-Page-Allocation"><a href="#Lazy-Page-Allocation" class="headerlink" title="Lazy Page Allocation"></a>Lazy Page Allocation</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>O/S可以使用页表硬件的许多巧妙技巧之一是延迟分配堆内存。Xv6应用程序使用<code>sbrk()</code>系统调用向内核请求堆内存。在我们提供的内核中，<code>sbrk()</code>分配物理内存并将其映射到进程的虚拟地址空间。有些程序可以分配内存，但从不使用它，例如实现大型稀疏数组。复杂的内核延迟每个内存页的分配，直到应用程序尝试使用该页——这是由页面错误发出的信号。也就是说，<code>sbrk()</code>不分配物理内存，只是记住分配了哪些地址。当进程第一次尝试使用任何给定的内存页时，CPU会生成一个页错误，内核通过分配物理内存、将其归零并映射它来处理该错误。在本练习中，您将向xv6添加这种延迟分配特性。</p><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h3 id="Part-One"><a href="#Part-One" class="headerlink" title="Part One"></a>Part One</h3><p>您的第一个任务是从sbrk(n)系统调用实现(即sysproc.c中的sys_sbrk()函数)中删除页面分配。sbrk(n)系统调用将进程的内存大小增加n个字节，然后返回新分配的区域的开始部分(即旧的大小)。新的sbrk(n)应该只将进程的大小(myproc()-&gt;sz)增加n，并返回原来的大小。它不应该分配内存——因此您应该删除对growproc()的调用(但您仍然需要增加进程的大小!)</p><h3 id="Part-Two"><a href="#Part-Two" class="headerlink" title="Part Two"></a>Part Two</h3><p>修改<code>trap.c</code>中的代码，通过在错误地址映射新分配的物理内存页，然后返回到用户空间，让进程继续执行，从而响应用户空间中的页面错误。您应该在生成“pid 3 sh: trap 14”消息的cprintf调用之前添加代码。你的代码不需要覆盖所有的极端情况和错误情况;它只需要足够好，让sh运行简单的命令，如echo和ls。</p><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><ol><li>修改sbrk(n)，本来是将进程的内存大小增加n个字节，然后返回新分配区域的开始；改成只需将进程的大小(myproc()-&gt;sz)增加n不分配区域，并返回原来的大小。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将进程的大小(myproc()-&gt;sz)增加n不分配区域，其中n为用户传入的参数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sys_sbrk</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> addr;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  addr = myproc()-&gt;sz;</span><br><span class="line">  <span class="comment">/*if(growproc(n) &lt; 0)</span></span><br><span class="line"><span class="comment">    return -1;*/</span></span><br><span class="line">  myproc()-&gt;sz += n;</span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改之前</p><p><img src="/mit-6-828-homework-lazypageallocation/index/1.png" style="zoom:50%; "></p><p>改之后</p><p><img src="/mit-6-828-homework-lazypageallocation/index/2.png" alt="在这里插入图片描述"></p><p>“addr 0x4004”表示导致页面错误的虚拟地址是0x4004。“pid 3 sh: trap…”消息来自trap.c中的内核陷阱处理程序。它捕获了一个页面错误(trap 14，或T_PGFLT)，所以为什么发生这个错误？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//traps.h中</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_PGFLT         14      <span class="comment">// page fault</span></span></span><br></pre></td></tr></table></figure><p>这个错误肯定是因为代码改成了只增加大小，不分配物理区域导致找不到虚拟地址对应的物理页引发报错。<br>但我有个疑问，echo hi只是把hi输出而已，需要用到物理页吗？还是说hi作为参数存在argv[1]中，也就是需要物理页保存。</p><h3 id="Part-Two-1"><a href="#Part-Two-1" class="headerlink" title="Part Two"></a>Part Two</h3><p>将新分配的物理内存页映射到故障地址然后返回到用户空间，让进程继续执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Hint: look at the cprintf arguments to see how to find the <span class="keyword">virtual</span> address that caused the page fault.</span><br><span class="line">(找到引起错误的虚拟地址)</span><br><span class="line"></span><br><span class="line">Hint: <span class="function">steal code from <span class="title">allocuvm</span><span class="params">()</span> in vm.c, which is what <span class="title">sbrk</span><span class="params">()</span> <span class="title">calls</span> <span class="params">(via growproc())</span>.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Hint: use <span class="title">PGROUNDDOWN</span><span class="params">(va)</span> to round the faulting <span class="keyword">virtual</span> address down to a page boundary.</span></span><br><span class="line"><span class="function"><span class="params">(<span class="number">4</span>k对齐)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Hint: <span class="keyword">break</span> <span class="keyword">or</span> <span class="keyword">return</span> in order to avoid the cprintf <span class="keyword">and</span> the <span class="title">myproc</span><span class="params">()</span>-&gt;killed </span>= <span class="number">1.</span></span><br><span class="line">(及时返回防止再次输出那段提示)</span><br><span class="line"></span><br><span class="line">Hint: yo<span class="string">u&#x27;ll need to call mappages(). </span></span><br><span class="line"><span class="string">In order to do this you&#x27;</span><span class="function">ll need to <span class="keyword">delete</span> the <span class="keyword">static</span> in the declaration of <span class="title">mappages</span><span class="params">()</span> in vm.c, <span class="keyword">and</span> you will need to declare <span class="title">mappages</span><span class="params">()</span> in trap.c. </span></span><br><span class="line"><span class="function">Add <span class="keyword">this</span> declaration to trap.c before any call to <span class="title">mappages</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function">      <span class="keyword">int</span> <span class="title">mappages</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">void</span> *va, uint size, uint pa, <span class="keyword">int</span> perm)</span></span>;</span><br><span class="line"></span><br><span class="line">Hint: you can check whether a fault is a page fault by checking <span class="keyword">if</span> tf-&gt;<span class="function">trapno is equal to T_PGFLT in <span class="title">trap</span><span class="params">()</span>. </span></span><br><span class="line"><span class="function"><span class="comment">//#define T_PGFLT         14      // page fault</span></span></span><br><span class="line"><span class="function"><span class="comment">//将引发缺页异常的线性地址保存在address变量里面  </span></span></span><br><span class="line"><span class="function">    __<span class="title">asm__</span><span class="params">(<span class="string">&quot;movl %%cr2,%0&quot;</span>:<span class="string">&quot;=r&quot;</span> (address))</span></span>;   </span><br></pre></td></tr></table></figure><p>让程序继续执行缺的是什么，如何让程序返回用户空间？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">if</span>(myproc() == <span class="number">0</span> || (tf-&gt;cs&amp;<span class="number">3</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// In kernel, it must be our mistake.</span></span><br><span class="line">      cprintf(<span class="string">&quot;unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n&quot;</span>,</span><br><span class="line">              tf-&gt;trapno, cpuid(), tf-&gt;eip, rcr2());</span><br><span class="line">      panic(<span class="string">&quot;trap&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *mem;</span><br><span class="line">    uint a;</span><br><span class="line">a = PGROUNDDOWN(rcr2()); <span class="comment">//将引起错误的虚拟地址向下4K对齐</span></span><br><span class="line"><span class="keyword">for</span>(; a &lt; myproc()-&gt;sz; a += PGSIZE)&#123; <span class="comment">//从a开始对大小为myproc()-&gt;sz-a的区域分配并映射物理页</span></span><br><span class="line">  mem = kalloc(); <span class="comment">//分配物理页</span></span><br><span class="line">  <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">    cprintf(<span class="string">&quot;allocuvm out of memory\n&quot;</span>);</span><br><span class="line">    <span class="comment">//这里的 myproc()-&gt;tf-&gt;eax瞎写的，我以为sys_sbrk()返回值即oldsz存在tf-&gt;eax中</span></span><br><span class="line">    deallocuvm(myproc()-&gt;pgdir, myproc()-&gt;sz, myproc()-&gt;tf-&gt;eax); </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE); <span class="comment">//初始化物理页</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(myproc()-&gt;pgdir, (<span class="keyword">char</span>*)a, PGSIZE, V2P(mem), PTE_W|PTE_U) &lt; <span class="number">0</span>)&#123; </span><br><span class="line">  <span class="comment">//映射刚分配的物理页到虚拟地址失败</span></span><br><span class="line">    cprintf(<span class="string">&quot;allocuvm out of memory (2)\n&quot;</span>);</span><br><span class="line">    deallocuvm(myproc()-&gt;pgdir, myproc()-&gt;sz, myproc()-&gt;tf-&gt;eax);</span><br><span class="line">    kfree(mem);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// In user space, assume process misbehaved.</span></span><br><span class="line">    cprintf(<span class="string">&quot;pid %d %s: trap %d err %d on cpu %d &quot;</span></span><br><span class="line">            <span class="string">&quot;eip 0x%x addr 0x%x--kill proc\n&quot;</span>,</span><br><span class="line">            myproc()-&gt;pid, myproc()-&gt;name, tf-&gt;trapno,</span><br><span class="line">            tf-&gt;err, cpuid(), tf-&gt;eip, rcr2());</span><br><span class="line">    myproc()-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190717151016657.png" alt="在这里插入图片描述"></p><h2 id="实验总结与心得体会"><a href="#实验总结与心得体会" class="headerlink" title="实验总结与心得体会"></a>实验总结与心得体会</h2><p>经过本次实验，对于线性地址的理解更为深入了，对Unix的分页机制以及地址方面的知识了解到了更多。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MIT OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.828 Homework_SystemCall</title>
      <link href="/mit-6-828-homework-systemcall/index.html"/>
      <url>/mit-6-828-homework-systemcall/index.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-syscall.html">实验指导书</a></p><hr><p><a href="https://hasuer.github.io/mit-6-828-operating-system-engineering/index.html">MIT 6.828 Operating System Engineering</a></p><hr><h1 id="xv6-System-Call"><a href="#xv6-System-Call" class="headerlink" title="xv6 System Call"></a>xv6 System Call</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ol><li>理解系统调用的工作流程和实现系统调用</li><li>修改xv6内核从而打印出每一个系统调用，只需打印出系统调用和他的返回值，不需要打印出参数。</li><li>在已有的基础上增加上一个系统调用，当用户键入<code>date</code>的时候能够打印出当前的时间。</li></ol><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h3 id="Part-One-System-call-tracing"><a href="#Part-One-System-call-tracing" class="headerlink" title="Part One: System call tracing"></a>Part One: System call tracing</h3><p>Your first task is to modify the xv6 kernel to print out a line for each system call invocation. It is enough to print the name of the system call and the return value; you don’t need to print the system call arguments.</p><p>When you’re done, you should see output like this when booting xv6:</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="title">fork</span> -&gt;</span> <span class="number">2</span></span><br><span class="line"><span class="function"><span class="title">exec</span> -&gt;</span> <span class="number">0</span></span><br><span class="line"><span class="function"><span class="title">open</span> -&gt;</span> <span class="number">3</span></span><br><span class="line"><span class="function"><span class="title">close</span> -&gt;</span> <span class="number">0</span></span><br><span class="line">$<span class="function"><span class="title">write</span> -&gt;</span> <span class="number">1</span></span><br><span class="line"> <span class="function"><span class="title">write</span> -&gt;</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>That’s init forking and execing sh, sh making sure only two file descriptors are open, and sh writing the $ prompt. (Note: the output of the shell and the system call trace are intermixed, because the shell uses the write syscall to print its output.)</p><p><strong>Hint:</strong> modify the syscall() function in syscall.c.</p><p><strong>Optional challenge:</strong> print the system call arguments.</p><h3 id="Part-Two-Date-system-call"><a href="#Part-Two-Date-system-call" class="headerlink" title="Part Two: Date system call"></a>Part Two: Date system call</h3><p>Your second task is to add a new system call to xv6. The main point of the exercise is for you to see some of the different pieces of the system call machinery. Your new system call will get the current UTC time and return it to the user program. You may want to use the helper function, <code>cmostime()</code> (defined in <code>lapic.c</code>), to read the real time clock. <code>date.h</code> contains the definition of the <code>struct rtcdate</code> struct, which you will provide as an argument to <code>cmostime()</code> as a pointer.</p><p>You should create a user-level program that calls your new date system call; here’s some source you should put in <code>date.c</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;date.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rtcdate</span> <span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (date(&amp;r)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="number">2</span>, <span class="string">&quot;date failed\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// your code to print the time in any format you like...</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In order to make your new <code>date</code> program available to run from the xv6 shell, add <code>_date</code> to the <code>UPROGS</code> definition in <code>Makefile</code>.</p><p>Your strategy for making a date system call should be to clone all of the pieces of code that are specific to some existing system call, for example the “uptime” system call. You should grep for uptime in all the source files, using <code>grep -n uptime *.[chS]</code>.</p><p>When you’re done, typing <code>date</code> to an xv6 shell prompt should print the current UTC time.</p><p>Write down a few words of explanation for each of the files you had to modify in the process of creating your date system call.</p><p><strong>Optional challenge:</strong> add a dup2() system call and modify the shell to use it.</p><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><h3 id="Part-One-System-call-tracing-1"><a href="#Part-One-System-call-tracing-1" class="headerlink" title="Part One: System call tracing"></a>Part One: System call tracing</h3><p>打开文件：<code>syscall.c</code></p><p>在文件前面添加编号和系统调用名称相互对应的数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> SYS_call_names[][<span class="number">6</span>] = &#123;</span><br><span class="line">        [SYS_fork] <span class="string">&quot;fork&quot;</span>,</span><br><span class="line">        [SYS_exit] <span class="string">&quot;exit&quot;</span>,</span><br><span class="line">        [SYS_wait] <span class="string">&quot;wait&quot;</span>,</span><br><span class="line">        [SYS_pipe] <span class="string">&quot;pipe&quot;</span>,</span><br><span class="line">        [SYS_read] <span class="string">&quot;read&quot;</span>,</span><br><span class="line">        [SYS_kill] <span class="string">&quot;kill&quot;</span>,</span><br><span class="line">        [SYS_exec] <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">        [SYS_fstat] <span class="string">&quot;fstat&quot;</span>,</span><br><span class="line">        [SYS_chdir] <span class="string">&quot;chdir&quot;</span>,</span><br><span class="line">        [SYS_dup] <span class="string">&quot;dup&quot;</span>,</span><br><span class="line">        [SYS_getpid] <span class="string">&quot;getpid&quot;</span>,</span><br><span class="line">        [SYS_sbrk] <span class="string">&quot;sbrk&quot;</span>,</span><br><span class="line">        [SYS_sleep] <span class="string">&quot;sleep&quot;</span>,</span><br><span class="line">        [SYS_uptime] <span class="string">&quot;uptime&quot;</span>,</span><br><span class="line">        [SYS_open] <span class="string">&quot;open&quot;</span>,</span><br><span class="line">        [SYS_write] <span class="string">&quot;write&quot;</span>,</span><br><span class="line">        [SYS_mknod] <span class="string">&quot;mknod&quot;</span>,</span><br><span class="line">        [SYS_unlink] <span class="string">&quot;unlink&quot;</span>,</span><br><span class="line">        [SYS_link] <span class="string">&quot;link&quot;</span>,</span><br><span class="line">        [SYS_mkdir] <span class="string">&quot;mkdir&quot;</span>,</span><br><span class="line">        [SYS_close] <span class="string">&quot;close&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p>然后在函数：<code>syscall</code> 中添加对应的输出命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syscall</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    num = curproc-&gt;tf-&gt;eax;</span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num])</span><br><span class="line">    &#123;</span><br><span class="line">        curproc-&gt;tf-&gt;eax = syscalls[num]();</span><br><span class="line">        <span class="comment">// add begin</span></span><br><span class="line">        cprintf(<span class="string">&quot;%s\t -&gt; %d\n&quot;</span>, SYS_call_names[num], num);</span><br><span class="line">        <span class="comment">//add end</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">                curproc-&gt;pid, curproc-&gt;name, num);</span><br><span class="line">        curproc-&gt;tf-&gt;eax = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改完成，测试结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make qemu</span></span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="/mit-6-828-homework-systemcall/index/1.png" style="zoom:50%;"></p><h3 id="Part-Two-Date-system-call-1"><a href="#Part-Two-Date-system-call-1" class="headerlink" title="Part Two: Date system call"></a>Part Two: Date system call</h3><p>第二步，我们要添加一个系统调用函数，使其可以返回当前系统时间。</p><ol><li><p>在 <code>syscall.h</code> 中最后一行添加系统调用编号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_date   22</span></span><br></pre></td></tr></table></figure></li><li><p>在 <code>syscall.c</code> 中添加系统调用函数的外部声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        [SYS_mkdir] <span class="string">&quot;mkdir&quot;</span>,</span><br><span class="line">        [SYS_close] <span class="string">&quot;close&quot;</span>,</span><br><span class="line"><span class="comment">// 以下为添加内容</span></span><br><span class="line">        [SYS_date] <span class="string">&quot;date&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// 以上为添加内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// User code makes a system call with INT T_SYSCALL.</span></span><br><span class="line"><span class="comment">// System call number in %eax.</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">sys_write</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">sys_uptime</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// 以下为添加内容</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">sys_date</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// 以上为添加内容</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">int</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="keyword">void</span>)</span> </span>= &#123;</span><br><span class="line">        [SYS_fork] sys_fork,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">           [SYS_mkdir] sys_mkdir,</span><br><span class="line">           [SYS_close] sys_close,</span><br><span class="line">   <span class="comment">// 以下为添加内容</span></span><br><span class="line">           [SYS_date] sys_date,</span><br><span class="line">   <span class="comment">// 以上为添加内容</span></span><br><span class="line">   &#125;;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">syscall</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> num;</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><ol><li><p>在 <code>user.h</code> 中添加用户态函数的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sleep</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uptime</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// 以下为添加内容</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">date</span><span class="params">(struct rtcdate*)</span></span>;</span><br><span class="line"><span class="comment">// 以上为添加内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ulib.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">char</span>*, struct stat*)</span></span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>在 <code>usys.S</code> 中最后一行添加用户态函数的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL(date)</span><br></pre></td></tr></table></figure></li><li><p>在 <code>sysproc.c</code> 中最后一行添加系统调用函数的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return current date</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sys_date</span><span class="params">(struct rtcdate *r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argptr(<span class="number">0</span>, (<span class="keyword">void</span> *)&amp;r, <span class="keyword">sizeof</span>(*r)) &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  cmostime(r);  <span class="comment">//从cmos中获取时间</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>至此，就完成了添加系统调用函数 <code>date()</code></p><p>最后，我们需要添加使用这个系统调用函数的方法</p><p>新建文件 <code>date.c</code> ，并添加一下内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;date.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtcdate</span> <span class="title">r</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (date(&amp;r))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="number">2</span>, <span class="string">&quot;date failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// your code to print the time in any format you like...</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="number">1</span>, <span class="string">&quot;%d-%d %d %d:%d:%d\n&quot;</span>, r.month, r.day, r.year, r.hour, r.minute, r.second);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在 <code>Makefile</code> 中添加 <code>UPROGS</code> 对应命令的定义：</li></ol><p>至此，所有文件就修改完成了。</p><p>为了防止第一部分的输出影响我们时间的显示格式，可以先将 <code>syscall.c</code> 中的<code>static char SYS_call_names[][6]</code>注释掉.</p><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make qemu</span></span><br></pre></td></tr></table></figure><p>然后输入命令 <code>date</code>：</p><p><img src="/mit-6-828-homework-systemcall/index/2.png" style="zoom:50%;"></p><h2 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h2><h3 id="Part-One"><a href="#Part-One" class="headerlink" title="Part One"></a>Part One</h3><p>所有的系统调用的编号都在 <code>syscall.h</code>文件中，所以如果我们要增加一个系统调用，我们也需要在这个文件及其对应的<code>.c</code>文件中做修改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// System call numbers</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_fork    1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_exit    2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_wait    3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_pipe    4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_read    5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_kill    6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_exec    7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_fstat   8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_chdir   9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_dup    10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_getpid 11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_sbrk   12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_sleep  13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_uptime 14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_open   15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_write  16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_mknod  17</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_unlink 18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_link   19</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_mkdir  20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_close  21</span></span><br></pre></td></tr></table></figure><p>这里面定义了系统调用的名称和对应的序号，我们要在终端上显示的就是上面这些对应的名字和编号。</p><h3 id="Part-Two"><a href="#Part-Two" class="headerlink" title="Part Two"></a>Part Two</h3><p>在说明中已经给出了大致要完成的步骤。</p><p><code>lapic.c</code> 中定义了函数 <code>cmostime()</code> 来读取时钟时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cmostime</span><span class="params">(struct rtcdate *r)</span> </span>&#123;&#125;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><code>date.h</code> 中定义了 <code>rtcdate</code> 结构体，作为参数提供给函数 <code>cmostime()</code> 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtcdate</span> &#123;</span></span><br><span class="line">  uint second;</span><br><span class="line">  uint minute;</span><br><span class="line">  uint hour;</span><br><span class="line">  uint day;</span><br><span class="line">  uint month;</span><br><span class="line">  uint year;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="实验结论及心得体会"><a href="#实验结论及心得体会" class="headerlink" title="实验结论及心得体会"></a>实验结论及心得体会</h2><ol><li>理解系统调用的工作流程和实现系统调用</li><li>修改xv6内核从而打印出每一个系统调用，只需打印出系统调用和他的返回值，不需要打印出参数。</li><li>在已有的基础上增加上一个系统调用，当用户键入<code>date</code>的时候能够打印出当前的时间。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MIT OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.828 Assignment_Barriers</title>
      <link href="/mit-6-828-assignment-barriers/index.html"/>
      <url>/mit-6-828-assignment-barriers/index.html</url>
      
        <content type="html"><![CDATA[<hr><p><a href="https://pdos.csail.mit.edu/6.828/2018/homework/barrier.html">实验指导书</a></p><hr><p><a href="https://hasuer.github.io/mit-6-828-operating-system-engineering/index.html">MIT 6.828 Operating System Engineering</a></p><hr><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这个实验是要我们去实行barrier,也就是屏障，只有当所有的线程都到了这个地方以后才会继续一起执行下一步。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *xa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> n = (<span class="keyword">long</span>) xa;</span><br><span class="line">  <span class="keyword">long</span> delay;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> t = bstate.round;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d, t = %d&quot;</span>, i, t);</span><br><span class="line">    assert (i == t);</span><br><span class="line">    barrier();</span><br><span class="line">    usleep(random() % <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码中（不在上面列出的部分）定义了两个全局变量，分别是<code>nthread</code>和<code>round</code>。第一个<code>nthread</code>是存储你输入的线程个数，在主函数中被赋值。第一个静态全局变量不知道是干什么的，因为在源代码中也没有看到使用了这个变量。</p><p>这个代码的大致思路是：</p><p>假设输入的是<code>./a.out 2</code>，表示我要创建两个线程。在每一个线程中，运行上面粘贴出来的代码。在这个代码块的<code>for</code>循环中，循环20次，表示每一个线程要被重复执行20次，并且由于<code>barrier</code>函数的存在（暂时还没有实现），我们希望当所有的线程都完成了第一循环以后再开始第二次循环，都完成第二次循环以后一起开始第三次，以此类推，指导都完成了20次循环。</p><p>所以主要问题就是：</p><blockquote><ul><li>You have to deal with a succession of barrier calls, each of which we’ll call a round. <code>bstate.round</code> records the current round. You should increase <code>bstate.round</code> when each round starts.</li><li>You have to handle the case in which one thread races around the loop before the others have exited the barrier. In particular, you are re-using <code>bstate.nthread</code> from one round to the next. Make sure that a thread that leaves the barrier and races around the loop doesn’t increase <code>bstate.nthread</code> while a previous round is still using it.</li></ul></blockquote><p>翻译过来就是：</p><ol><li>要完成连续的<code>barrier()</code>函数的调用，也就是循环执行20次，每一次调用成为一个round，<code>bstate.round</code>记录的是当前round，当每一个round开始的时候，可以将<code>bstate.round</code>加1.</li><li>要解决barrier问题。对于<code>barrier.round</code>我们是循环使用的，从一个round到下一个round。要保证当一个线程离开barrier或者在这个barrier中sleep的时候，<code>barrier.round</code>不会增加。</li></ol><p>在barrier()函数中做修改（实验指导书上说这要在这里做修改）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">barrier</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pthread_mutex_lock(&amp;bstate.barrier_mutex);<span class="comment">//访问互斥量</span></span><br><span class="line">  bstate.nthread++;<span class="comment">//已进入barrier的线程个数加1</span></span><br><span class="line">  <span class="keyword">if</span> (bstate.nthread == nthread) &#123;</span><br><span class="line">      <span class="comment">//表示已经进入线程的个数等于自己设置的线程数</span></span><br><span class="line">      <span class="comment">//已实现的round加1， nthread清空为下一次计数做准备</span></span><br><span class="line">    bstate.round++;</span><br><span class="line">    bstate.nthread = <span class="number">0</span>;</span><br><span class="line">    pthread_cond_broadcast(&amp;bstate.barrier_cond);<span class="comment">//唤醒</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">      pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);<span class="comment">//睡眠</span></span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;bstate.barrier_mutex);<span class="comment">//释放互斥量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="辨析"><a href="#辨析" class="headerlink" title="辨析"></a>辨析</h3><p>倘若不去更改barrier函数，而是对thread函数做如下修改：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">thread</span><span class="params">(<span class="keyword">void</span> *xa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> n = (<span class="keyword">long</span>) xa;</span><br><span class="line">  <span class="keyword">long</span> delay;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  pthread_mutex_lock(&amp;bstate.barrier_mutex );</span><br><span class="line">  <span class="keyword">if</span> (bstate.round != <span class="number">0</span>) &#123;</span><br><span class="line">  pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> t = bstate.round;</span><br><span class="line"><span class="comment">// The assert triggers, because one thread leaves the barrier before the other thread has reached the barrier. </span></span><br><span class="line">    assert (i == t);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;thread %d\n&quot;</span>, i);</span><br><span class="line">    barrier();</span><br><span class="line">    usleep(random() % <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  bstate.round = <span class="number">0</span>;</span><br><span class="line">  pthread_cond_broadcast(&amp;bstate.barrier_cond);</span><br><span class="line">  pthread_mutex_unlock(&amp;bstate.barrier_mutex );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话也能通过，那和上面的有什么不同吗？</p><p>答案是，下面这种写法，在if中，如果<code>bstate.round != 0</code>，不等于零就意味着它不是第一个进程线程，因为第一个线程已经将<code>bstate.round</code>加1了。所以下面的这个代码实现的是线程的轮流执行，也就起不到并行的效果了。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MIT OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PA2实验报告</title>
      <link href="/pa2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/index.html"/>
      <url>/pa2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/index.html</url>
      
        <content type="html"><![CDATA[<div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">是否完成</th></tr></thead><tbody><tr><td style="text-align:center">必做任务1</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">必做任务2</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">必做任务3</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">必做任务4</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">必做任务5</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">选作任务1</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">选作任务2</td><td style="text-align:center">是</td></tr></tbody></table></div><h3 id="思考题1"><a href="#思考题1" class="headerlink" title="思考题1"></a>思考题1</h3><p>【问题】</p><p><code>main</code>函数返回到哪里？查看testcase的相关代码，你知道用户程序从<code>main</code>函数返回以后会跳转到哪里吗？如果用户程序在GNU/Linux中运行，问题的答案又是什么？</p><p>【我的解答】</p><ol><li>程序从主函数执行以后会回到<code>ui_mainloop</code>中继续执行下一条指令，从而达到循环执行的效果</li><li>在Linux中，用户程序执行完main函数会回到类似的地方，叫做<code>_libc_start_main</code></li></ol><p><img src="https://pic4.zhimg.com/v2-9a7034ec1672c8bf903ee373a87133df_1440w.jpg?source=172ae18b" alt="Linux X86 程序启动 - main函数是如何被执行的？"></p><hr><h3 id="思考题2"><a href="#思考题2" class="headerlink" title="思考题2"></a>思考题2</h3><p>【问题】</p><p>比较 FLOAT 和 float。FLOAT和float类型的数据都是32位, 它们都可以表示2^32个不同的数, 但由 于表示方法不一样, FLOAT 和 float 能表示的数集是不一样的。思考一下, 我们 用   来模拟表示 float , 这其中隐含着哪些取舍?</p><p>【我的解答】</p><p>float能表示的数值范围更大，而FLOAT的范围小，但是速度快。</p><hr><h3 id="思考题3"><a href="#思考题3" class="headerlink" title="思考题3"></a>思考题3</h3><p>【问题】</p><p>消失的符号。我们在 add.c 中定义了宏 NR_DATA, 同时也在 add()函数中定义了局部变量 c 和形参 a, b, 但你会发现在符号表中找不到和它们对应的表项, 为什么会这 样?思考一下, 什么才算是一个符号(symbol)?</p><p>【我的解答】</p><p>符号表中所存储的内容包括全局的静态变量，函数的调用，外部引用等。我们在add.c中定义的宏和局部变量，局部变量是存储在stack中，而宏定义会在预处理阶段被替换，不在作为不好存储。</p><hr><h3 id="思考题4"><a href="#思考题4" class="headerlink" title="思考题4"></a>思考题4</h3><p>【问题】</p><p>堆和栈在哪里?我们提到了代码和数据都在可执行文件里面, 但却没有提到堆(heap)和栈 (stack)。为什么堆和栈的内容没有放入可执行文件里面?那程序运行时刻用到 的堆和栈又是怎么来的?</p><p>【我的解答】</p><p>程序在运行的时候会自动分配堆栈的大小。堆由程序员管理，栈由系统管理。</p><p><img src="https://img-blog.csdn.net/20170507162048143?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXV5dXNoaWt1YW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>如图，栈是向下生长，堆是向上生长，两者都是动态分配。</p><hr><h3 id="思考题5"><a href="#思考题5" class="headerlink" title="思考题5"></a>思考题5</h3><p>【问题】</p><p>如何识别不同格式的可执行文件?如果你在GNU/Linux下执行一个从Windows拷过来的可执行文件, 将会报告” 格式错误”。思考一下, GNU/Linux 是如何知道”格式错误”的?</p><p>【我的解答】</p><p>每个文件都有一个扩展名，windows就是靠扩展名来识别不同类型的文件，并以此来决定用哪种程序打开这种文件。</p><p>如果是exe等可执行程序，则是直接执行它（实际上不是，我们可以这样来理解），如果是其它的文件，如是.txt,就调用notepad.exe这个程序，并且打开那个txt文件。并且右键菜单也会因为文件类型不同而不同。</p><p>对于Linux来说，文件的头部会有相应的信息，和windows类似。</p><hr><h3 id="思考题6"><a href="#思考题6" class="headerlink" title="思考题6"></a>思考题6</h3><p>【问题】</p><p>冗余的属性?使用 readelf 查看一个 ELF 文件的信息, 你会看到一个 segment 包含两个大小 的属性, 分别是 FileSiz 和 MemSiz, 这是为什么? 再仔细观察一下, 你会发现 FileSiz 通常不会大于相应的 MemSiz, 这又是为什么?</p><p>【我的解答】</p><p>这是因为，在ELF中需要存储全局变量的初始值，而由于.bss没有初始值，默认被初始化为0，所以不会在ELF中存储，使得变量在文件中占用的大小（FileSiz）小于运行时占用的内存空间（MemSiz）。在加载到内存中时，使用这个特征判断是否到达了最后一个segment。</p><p>同时，可以注意到两个LOAD之间的虚拟地址（即加载到虚拟内存中时的偏移量，上文中的VirtAddr）差距很大，这是因为想要尽量保证可执行的部分与不可执行的部分相差尽可能大，从而最小化溢出时可能造成的写掉.text的风险，</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NEMU实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.828 Assignment_ThreadsandLocks</title>
      <link href="/mit-6-828-assignment-threadsandlocks/index.html"/>
      <url>/mit-6-828-assignment-threadsandlocks/index.html</url>
      
        <content type="html"><![CDATA[<hr><p><a href="https://pdos.csail.mit.edu/6.828/2018/homework/lock.html">实验指导书</a></p><hr><p><a href="https://hasuer.github.io/mit-6-828-operating-system-engineering/index.html">MIT 6.828 Operating System Engineering</a></p><hr><p>【思路】</p><p>代码首先创建了10000个小的node，用每一个node（在代码中名字是entry）来表示一个线程，然后通过平均分配的方法来把这些线程分配给各个进程。</p><p>put函数用来将每一个线程加入链表。然后将这个node的对应信息记录到哈希表：struct entry *table[NBUCKET]中。</p><p>get函数得到一个node（也就是一个线程）。同时这也表示这次线程的结束。</p><p>这样不断通过put 和get来实现并行程序。</p><p>产生错误的原因：当我们在使用put函数的时候，不小心造成两个新的node同时插入链表时（也就是同时使用内存），我们的哈希表只能记录下其中的一个表头，而失去了另外一个node的表头，所以造成了get的时候丢失了node。</p><p>【步骤】</p><ol><li><p>声明锁变量数组</p><p><img src="/mit-6-828-assignment-threadsandlocks/index/1.1.png"></p></li><li><p>在main()函数中初始化锁变量数组</p><p><img src="/mit-6-828-assignment-threadsandlocks/index/1.3.png"></p></li><li><p>当进行insert操作是加锁保护，修改put()函数如下</p></li></ol><p><img src="/mit-6-828-assignment-threadsandlocks/index/1.2.png"></p><ol><li><p>再次运行</p><p><img src="/mit-6-828-assignment-threadsandlocks/index/1.4.png"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MIT OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打印多个hello</title>
      <link href="/%E6%89%93%E5%8D%B0%E5%A4%9A%E4%B8%AAhello/index.html"/>
      <url>/%E6%89%93%E5%8D%B0%E5%A4%9A%E4%B8%AAhello/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="打印多个hello"><a href="#打印多个hello" class="headerlink" title="打印多个hello"></a>打印多个hello</h2><p>这个问题在网上没有找到代码，于是我自己对着代码的运行结果，尝试着去理解，所以不一定对。</p><p><strong>【问题描述：】</strong></p><p>假定下面的C语言程序在 UNIX 系统上运行，并且所有调用都能成功完。其 中<code>pthread_create(&amp;t, NULL, bar, NULL);</code>的功能是创建一个新线程来执行函数bar，并返回线程对象标识 t。<code>pthread_join(t,NULL );</code>的功能是等待线程结束。试问此程序在运行过中会打印出多少个 “hello” ？需要说明分析过程。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">bar</span><span class="params">(<span class="keyword">void</span>* ingore)</span></span>&#123;</span><br><span class="line">counter --;</span><br><span class="line"><span class="keyword">if</span>(counter == <span class="number">0</span>)&#123;</span><br><span class="line">fork();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello1\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> t;</span><br><span class="line"><span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">fork();</span><br><span class="line">pthread_create(&amp;t, <span class="literal">NULL</span>, bar, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello2\n&quot;</span>);</span><br><span class="line">pthread_join(t, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello3\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Ubantu 18.04版本上运行的结果如下:</p><p><img src="/%E6%89%93%E5%8D%B0%E5%A4%9A%E4%B8%AAhello/index/1.1.png"></p><p><strong>【我的分析：】</strong></p><p>这个程序的运行结果很迷，每次的执行结果的顺序是不一样的，比如我重新运行一下：</p><p><img src="/%E6%89%93%E5%8D%B0%E5%A4%9A%E4%B8%AAhello/index/1.2.png"></p><p>这个是什么原因我也不知道。</p><p>但是每次打印出来的结果都有9个hello，并且是4个hello1, 2个hello2， 3个hello3。这是不会变的。</p><p>下面是我的思路：</p><p><img src="/%E6%89%93%E5%8D%B0%E5%A4%9A%E4%B8%AAhello/index/1.3.png"></p><ol><li>main进入<code>foo()</code>以后就fork了，假设先运行父进程（父进程1），由于fork返回给父进程的值是子进程（子进程1）的pid(不为0)，所以<code>foo()</code>执行完了，回到main，打印出hello3.</li><li>在子进程（子进程1）中又fork了，这是原来的子进程（子进程1）是新创建出来的子进程（子进程2）的父进程（子进程1），在这个父进程（子进程1）中，创建了一个线程运行<code>bar</code>,在<code>bar</code>中fork以后，在新创建出来的子进程（子进程3）和原来的子进程（子进程1）各打印一个hello1.</li><li>在子进程2中的结果和上面步骤2是一样的。</li></ol><p><strong>【注意：】</strong></p><ol><li>每次fork以后产生的子进程是一个进程，两个进程间的全局变量是<code>copy on write</code>，也就是说，一开始是一个，或者说只读的时候是一个，但是一旦有人想要修改它，就立刻变成两个。在<code>foo</code>中fork以后，创建了线程，由于线程中要对于全局变量<code>counter</code>进行修改，所以就变成了两个counter，初值都是1，所以两个进程都能进入bar的if 语句再次fork。</li><li>进入bar的if以后的fork,这是创建出来的子进程的counter全局变量也是0，但是，子进程直接接着这个fork后面运行呀，所以对于counter就没有什么要求了，直接答应出hello啦！</li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PV题</title>
      <link href="/pv%E9%A2%98/index.html"/>
      <url>/pv%E9%A2%98/index.html</url>
      
        <content type="html"><![CDATA[<p>除了前两道题是老师给了答案的，后面是自己做的，不能保证正确率。</p><h3 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h3><p>【问题描述】</p><p>读者-写者问题为数据库访问建立了一个模型。例如,一个系统,其中有许多竞争的进程试图读写其中的数据,多个进程同时读是可以接受的,但如果一个进程正在更新数据库,则所有的其他进程都不能访问数据库，即使读操作也不行。分别写出读者优先、写者优先和公平竞争三种情况下的程序。</p><p>【解答】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reader prioriy solutoin</span></span><br><span class="line">semaphore fmutex = <span class="number">1</span>; <span class="comment">// access to file</span></span><br><span class="line">semaphore rdcntmutex = <span class="number">1</span>; <span class="comment">//access to readcount</span></span><br><span class="line"><span class="keyword">int</span> readcount = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*reader*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(rdcntmutex);</span><br><span class="line">        <span class="keyword">if</span>(readcount == <span class="number">0</span>)&#123;</span><br><span class="line">            P(fmutex);</span><br><span class="line">        &#125;</span><br><span class="line">        readcount ++;</span><br><span class="line">        V(rdcntmutex);</span><br><span class="line">        <span class="comment">//do read operation</span></span><br><span class="line">        P(rdcntmutex);</span><br><span class="line">        readcount --;</span><br><span class="line">     <span class="keyword">if</span>(readcounnt == <span class="number">0</span>)&#123;</span><br><span class="line">            V(fmutex);</span><br><span class="line">        &#125;</span><br><span class="line">        V(rdcntmutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*writer*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(fmutex);</span><br><span class="line">        <span class="comment">//do write operation</span></span><br><span class="line">        V(fmutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//writer priority solution</span></span><br><span class="line">semaphore fmutex = <span class="number">1</span>; <span class="comment">// access to file</span></span><br><span class="line">semaphore rdcntmutex = <span class="number">1</span>; <span class="comment">//access to readcount</span></span><br><span class="line">semaphore wtcntmutex = <span class="number">1</span>; <span class="comment">//access to writercount</span></span><br><span class="line">semaphore <span class="built_in">queue</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> readcount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> writercount = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*reader*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(<span class="built_in">queue</span>);</span><br><span class="line">        P(rdcntmutex);</span><br><span class="line">        <span class="keyword">if</span>(readcount == <span class="number">0</span>)&#123;</span><br><span class="line">            P(fmutex);</span><br><span class="line">        &#125;</span><br><span class="line">        readcount ++;</span><br><span class="line">        V(rdcntmutex);</span><br><span class="line">        V(<span class="built_in">queue</span>);</span><br><span class="line">        <span class="comment">//do read operation</span></span><br><span class="line">        P(rdcntmutex);</span><br><span class="line">        readcount --;</span><br><span class="line">     <span class="keyword">if</span>(readcounnt == <span class="number">0</span>)&#123;</span><br><span class="line">            V(fmutex);</span><br><span class="line">        &#125;</span><br><span class="line">        V(rdcntmutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*writer*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(wtcntmutex);</span><br><span class="line">        <span class="keyword">if</span>(writercount == <span class="number">0</span>)&#123;</span><br><span class="line">            P(<span class="built_in">queue</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        V(wtcntmutex);</span><br><span class="line">        P(fmutex);</span><br><span class="line">        <span class="comment">//do write operation</span></span><br><span class="line">        V(fmutex);</span><br><span class="line">        P(wtcntmutex);</span><br><span class="line">        writercount --;</span><br><span class="line">        <span class="keyword">if</span>(writercount == <span class="number">0</span>)&#123;</span><br><span class="line">            V(<span class="built_in">queue</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        V(wtcntmutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fair solution</span></span><br><span class="line">semaphore fmutex = <span class="number">1</span>; <span class="comment">// access to file</span></span><br><span class="line">semaphore rdcntmutex = <span class="number">1</span>; <span class="comment">//access to readcount</span></span><br><span class="line">semaphore wtcntmutex = <span class="number">1</span>; <span class="comment">//access to writercount</span></span><br><span class="line">semaphore <span class="built_in">queue</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> readcount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> writercount = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*reader*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(<span class="built_in">queue</span>);</span><br><span class="line">        P(rdcntmutex);</span><br><span class="line">        <span class="keyword">if</span>(readcount == <span class="number">0</span>)&#123;</span><br><span class="line">            P(fmutex);</span><br><span class="line">        &#125;</span><br><span class="line">        readcount ++;</span><br><span class="line">        V(rdcntmutex);</span><br><span class="line">        V(<span class="built_in">queue</span>);</span><br><span class="line">        <span class="comment">//do read operation</span></span><br><span class="line">        P(rdcntmutex);</span><br><span class="line">        readcount --;</span><br><span class="line">     <span class="keyword">if</span>(readcounnt == <span class="number">0</span>)&#123;</span><br><span class="line">            V(fmutex);</span><br><span class="line">        &#125;</span><br><span class="line">        V(rdcntmutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*writer*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(<span class="built_in">queue</span>);</span><br><span class="line">        P(fmutex);</span><br><span class="line">        <span class="comment">//do write operation</span></span><br><span class="line">        V(<span class="built_in">queue</span>);</span><br><span class="line">        V(fmutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="理发师问题"><a href="#理发师问题" class="headerlink" title="理发师问题"></a>理发师问题</h3><p>【问题描述】</p><p>有一个理发师，一把理发椅和N把供等候理发的顾客坐的椅子。如果没有顾客，则理发师便在理发师椅子上睡觉；当一个顾客到来时，必须唤醒理发师进行理发；如果理发师正在理发时又有顾客来到，则如果有空椅子可坐，他就坐下来等，如果没有空椅子，他就离开。为理发师和顾客各编一段程序（伪代码）描述他们的行为，要求不能带有竞争条件。</p><p>【解答】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHAIRS 5;</span></span><br><span class="line">semaphore customers = <span class="number">0</span>;</span><br><span class="line">semaphore barber = <span class="number">0</span>;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> waiting = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//barber</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">barber</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(customers);</span><br><span class="line">        P(mutex);</span><br><span class="line">        waiting --;</span><br><span class="line">        V(barber);</span><br><span class="line">        V(mutex);</span><br><span class="line">        cut_hair();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//customer</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">customer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    P(mutex);</span><br><span class="line">    <span class="keyword">if</span>(waiting &lt; CHAIRS)&#123;</span><br><span class="line">        waiting ++;</span><br><span class="line">        V(customers);</span><br><span class="line">        V(mutex);</span><br><span class="line">        P(barber);</span><br><span class="line">        get_haircut();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h3><p>三个吸烟者在一间房间内，还有一个香烟供应者。为了制造并抽掉香烟，每个吸烟者需要三样东西：烟草、纸和火柴。供应者有丰富的货物提供。三个吸烟者中，第一个有自己的烟草，第二个有自己的纸，第三个有自己的火柴。供应者将两样东西放在桌子上，允许一个吸烟者进行对健康不利的吸烟。当吸烟者完成吸烟后唤醒供应者，供应者再放两样东西（随机地）在桌面上，然后唤醒另一个吸烟者。试为吸烟者和供应者编写程序解决问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">semaphore empty = <span class="number">1</span>;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore offer1 = <span class="number">0</span>; <span class="comment">//offer paper and match</span></span><br><span class="line">semaphore offer2 = <span class="number">0</span>; <span class="comment">//offer tabacco and match</span></span><br><span class="line">semaphore offer3 = <span class="number">0</span>; <span class="comment">//offer tabacco and paper</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">provider</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(empty);</span><br><span class="line">        P(mutex);</span><br><span class="line">        srand(time(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">switch</span>(rand % <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                V(offer1);</span><br><span class="line">                V(mutex);</span><br><span class="line">                Wakeup(man1);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                V(offer2);</span><br><span class="line">                V(mutex);</span><br><span class="line">                Wakeup(man2);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                V(offer3);</span><br><span class="line">                V(mutex);</span><br><span class="line">                Wakeup(man3);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">man1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    P(mutex);</span><br><span class="line">    <span class="comment">//smoke</span></span><br><span class="line">    V(mutex);</span><br><span class="line">    V(empty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">man2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    P(mutex);</span><br><span class="line">    <span class="comment">//smoke</span></span><br><span class="line">    V(mutex);</span><br><span class="line">    V(empty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">man3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    P(mutex);</span><br><span class="line">    <span class="comment">//smoke</span></span><br><span class="line">    V(mutex);</span><br><span class="line">    V(empty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面包师问题"><a href="#面包师问题" class="headerlink" title="面包师问题"></a>面包师问题</h3><p>面包师有很多面包和蛋糕，由n 个销售人员销售。每个顾客进店后先取一个号，并且等着叫号。当一个销售人员空闲下来，就叫下一个号。请分别编写销售人员和顾客进程的程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore sale = n;</span><br><span class="line">semaphore customer = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">customer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    P(mutex);</span><br><span class="line">    <span class="comment">//叫号</span></span><br><span class="line">    V(mutex);</span><br><span class="line">    V(customer);</span><br><span class="line">    P(sale);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span></span>&#123;</span><br><span class="line">    P(customer);</span><br><span class="line">    P(mutex);</span><br><span class="line">    <span class="comment">//叫号</span></span><br><span class="line">    V(mutex);</span><br><span class="line">    V(sale);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="果盘问题"><a href="#果盘问题" class="headerlink" title="果盘问题"></a>果盘问题</h3><p>桌子上有一只盘子，最多可容纳两个水果，每次只能放入或取出一个水果。爸爸专向盘子放苹果（apple），妈妈专向盘子中放桔子（orange）；儿子专等吃盘子中的桔子，女儿专等吃盘子中的苹果。请用P、V操作来实现爸爸、妈妈、儿子、女儿之间的同步与互斥关系。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore apple = <span class="number">0</span>;</span><br><span class="line">semaphore orange = <span class="number">0</span>;</span><br><span class="line">semaphore empty = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mum</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(empty);</span><br><span class="line">P(mutex);</span><br><span class="line">P(orange);</span><br><span class="line">        V(mutex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dad</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(empty);</span><br><span class="line">P(mutex);</span><br><span class="line">        P(apple);</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">son</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(mutex);</span><br><span class="line">        P(orange);</span><br><span class="line">        V(empty);</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">daughter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(mutex);</span><br><span class="line">        P(apple);</span><br><span class="line">        V(empty);</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="仓库问题"><a href="#仓库问题" class="headerlink" title="仓库问题"></a>仓库问题</h3><p>（1）一次只能存入一种产品（A或B）；<br>（2）-N &lt; (A产品数量-B产品数量) &lt; M。<br>其中，N和M是正整数。试用“存放A”和“存放B”以及P、V操作描述产品A与产品B的入库过程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore a = M - <span class="number">1</span>;</span><br><span class="line">semaphore b = N - <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">storeA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(a);</span><br><span class="line">        P(mutex);</span><br><span class="line">        <span class="comment">//store A</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        V(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">storeB</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(b);</span><br><span class="line">        P(mutex);</span><br><span class="line">        <span class="comment">//store B</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        V(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="奇偶数问题"><a href="#奇偶数问题" class="headerlink" title="奇偶数问题"></a>奇偶数问题</h3><p>三个进程P1、P2、P3 互斥使用一个包含N(N&gt;0)个单元的缓冲区。P1 每次用<code>produce()</code>生成一个正整数并用<code>put()</code>送入缓冲区某一空单元中;P2 每次用<code>getodd()</code>从该缓冲区中取出一个奇数并用<code>countodd()</code>统计奇数个数;P3 每次用<code>geteven()</code>从该缓冲区中取出一个偶数并用<code>counteven()</code>统计偶数个数。请用信号量机制实现这三个进程的同步与互斥活动,并说明所定义信号量的含义。要求用伪代码描述。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore buffer = N;</span><br><span class="line">semaphore odd = <span class="number">0</span>;</span><br><span class="line">semaphore even = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(mutex);</span><br><span class="line">        P(buffer);</span><br><span class="line">        produce();</span><br><span class="line">        put();</span><br><span class="line">        <span class="keyword">if</span>(odd)&#123;</span><br><span class="line">            P(odd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(even)&#123;</span><br><span class="line">            P(even);</span><br><span class="line">        &#125;</span><br><span class="line">        P(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(odd);</span><br><span class="line">        P(mutex);</span><br><span class="line">        getodd();</span><br><span class="line">        countodd();</span><br><span class="line">        V(buffer);</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(even);</span><br><span class="line">        P(mutex);</span><br><span class="line">        geteven();</span><br><span class="line">        counteven();</span><br><span class="line">        V(buffer);</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="大学问题"><a href="#大学问题" class="headerlink" title="大学问题"></a>大学问题</h3><p>在天津大学与南开大学之间有一条弯曲的小路，这条路上每次每个方向上只允许一辆 自行车通过。但其中有一个小的安全岛M，同时允许两辆自行车停留，可供两辆自行 车已从两端进入小路的情况下错车使用。如图所示。下面的算法可以使来往的自行车 均可顺利通过。其中使用了4个信号量，T代表天大路口资源，S代表南开路口资源，L 代表从天大到安全岛一段路的资源，K代表从南开到安全岛一段路的资源。程序如 下，请在空白位置处填写适当的PV操作语句，每处空白可能包含若干个PV操作语句。</p><p><img src="/pv%E9%A2%98/index/Users\86150\AppData\Roaming\Typora\typora-user-images\image-20201121142801538.png" alt="image-20201121142801538"></p><ol><li>P(T), P(L)</li><li>V(L), V(K)</li><li>V(K), V(T)</li></ol><h3 id="南北桥问题"><a href="#南北桥问题" class="headerlink" title="南北桥问题"></a>南北桥问题</h3><p>有桥如下图所示，车流如箭头所示，桥上不允许两车交汇，但允许同方向多辆车依次 通过（即桥上可以有多个同方向的车）。用P、V操作实现交通管理以防止桥上堵塞。</p><p><img src="/pv%E9%A2%98/index/Users\86150\AppData\Roaming\Typora\typora-user-images\image-20201121143059636.png" alt="image-20201121143059636"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore snmutex = <span class="number">1</span>;</span><br><span class="line">semaphore nsmutex = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> sncnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> nscnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SouthtoNorth</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">P</span>(snmutex);</span><br><span class="line">        <span class="keyword">if</span>(sncnt == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">P</span>(mutex);</span><br><span class="line">        sncnt ++;</span><br><span class="line">        <span class="built_in">V</span>(snmutex);</span><br><span class="line">        <span class="comment">//go through</span></span><br><span class="line">        <span class="built_in">P</span>(snmutex);</span><br><span class="line">        sncnt --;</span><br><span class="line">        <span class="keyword">if</span>(sncnt == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">V</span>(mutex)</span><br><span class="line">        <span class="built_in">V</span>(snmutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NorthtoSouth</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">P</span>(nsmutex);</span><br><span class="line">        <span class="keyword">if</span>(nscnt == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">P</span>(mutex);</span><br><span class="line">        nscnt ++;</span><br><span class="line">        <span class="built_in">V</span>(nsmutex);</span><br><span class="line">        <span class="comment">//go through</span></span><br><span class="line">        <span class="built_in">P</span>(nsmutex);</span><br><span class="line">        nscnt --;</span><br><span class="line">        <span class="keyword">if</span>(nscnt == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">V</span>(mutex)</span><br><span class="line">        <span class="built_in">V</span>(nsmutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小解答题"><a href="#小解答题" class="headerlink" title="小解答题"></a>小解答题</h3><p>设有两个优先级相同的进程 P1 和 P2，共享 x、y、z 三个变量，执行代码见下表。信号 量 s1 和 s2 的初值均为 0。试问 P1、P2 并发执行后，x、y、z 的值各是多少？给出解题 过程。</p><p><strong><em>注意有三种情况，但是一共只有两个解</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>132 Pattern</title>
      <link href="/132-pattern/index.html"/>
      <url>/132-pattern/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="132-Pattern"><a href="#132-Pattern" class="headerlink" title="132 Pattern"></a>132 Pattern</h1><p>Given an array of <code>n</code> integers <code>nums</code>, a <strong>132 pattern</strong> is a subsequence of three integers <code>nums[i]</code>, <code>nums[j]</code> and <code>nums[k]</code> such that <code>i &lt; j &lt; k</code> and <code>nums[i] &lt; nums[k] &lt; nums[j]</code>.</p><p>Return <em><code>true</code> if there is a <strong>132 pattern</strong> in <code>nums</code>, otherwise, return <code>false</code>.</em></p><p><strong>Follow up:</strong> The <code>O(n^2)</code> is trivial, could you come up with the <code>O(n logn)</code> or the <code>O(n)</code> solution?</p><p><strong>Example 1:</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Input</span>: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">Output: <span class="keyword">false</span></span><br><span class="line">Explanation: There <span class="keyword">is</span> <span class="keyword">no</span> <span class="number">132</span> pattern <span class="keyword">in</span> the <span class="keyword">sequence</span>.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> nums = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line"><span class="symbol">Output:</span> <span class="literal">true</span></span><br><span class="line"><span class="symbol">Explanation:</span> There <span class="built_in">is</span> a <span class="number">132</span> pattern <span class="keyword">in</span> the sequence: [<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>].</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = <span class="comment">[-1,3,2,0]</span></span><br><span class="line">Output: true</span><br><span class="line">Explanation: There <span class="keyword">are</span> three 132 patterns in the sequence: <span class="comment">[-1, 3, 2]</span>, <span class="comment">[-1, 3, 0]</span> and <span class="comment">[-1, 2, 0]</span>.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li></ul><p><strong>Solution</strong></p><p>QUESTION: To search for a subsequence (<code>s1,s2,s3</code>) such that <code>s1 &lt; s3 &lt; s2</code>.</p><p>INTUITION: Suppose we want to find a <code>123</code> sequence with <code>s1 &lt; s2 &lt; s3</code>, we just need to find <code>s3</code>, followed by <code>s2</code> and <code>s1</code>. Now if we want to find a <code>132</code> sequence with <code>s1 &lt; s3 &lt; s2</code>, we need to switch up the order of searching. we want to first find <code>s2</code>, followed by <code>s3</code>, then <code>s1</code>.</p><p>DETECTION: More precisely, we keep track of highest value of <code>s3</code> for each valid <code>(s2 &gt; s3)</code> pair while searching for a valid <code>s1</code> candidate to the left. Once we encounter any number on the left that is smaller than the largest <code>s3</code> we have seen so far, we know we found a valid sequence, since <code>s1 &lt; s3</code> implies <code>s1 &lt; s2</code>.</p><p>ALGORITHM: We can start from either side but I think starting from the right allow us to finish in a single pass. The idea is to start from end and search for valid <code>(s2,s3)</code> pairs, we just need to remember the largest valid <code>s3</code> value, using a <code>stack</code> will be effective for this purpose. A number becomes a candidate for <code>s3</code> if there is any number on the left bigger than it.</p><p>CORRECTNESS: As we scan from right to left, we can easily keep track of the largest <code>s3</code> value of all <code>(s2,s3)</code> candidates encountered so far. Hence, each time we compare <code>nums[i]</code> with the largest candidate for <code>s3</code> within the interval <code>nums[i+1]...nums[n-1]</code> we are effectively asking the question: <strong>Is there any 132 sequence with <code>s1 = nums[i]</code>?</strong> Therefore, if the function returns false, there must be no 132 sequence.</p><p>IMPLEMENTATION:</p><ol><li>Have a <code>stack</code>, each time we store a new number, we first <code>pop</code> out all numbers that are smaller than that number. The numbers that are <code>popped</code> out becomes candidate for <code>s3</code>.</li><li>We keep track of the <code>maximum</code> of such <code>s3</code> (which is always the most recently <code>popped</code> number from the <code>stack</code>).</li><li>Once we encounter any number smaller than <code>s3</code>, we know we found a valid sequence since <code>s1 &lt; s3</code> implies <code>s1 &lt; s2</code>.</li></ol><p>RUNTIME: Each item is <code>pushed</code> and <code>popped</code> once at most, the time complexity is therefore O(n).</p><p>EXAMPLE:<br><code>i = 6</code>, <strong>nums</strong> = [ 9, 11, 8, 9, 10, 7, <code>9</code> ], <strong>S1 candidate</strong> = <code>9</code>, <strong>S3 candidate</strong> = <code>None</code>, <strong>Stack</strong> = <code>Empty</code><br><code>i = 5</code>, <strong>nums</strong> = [ 9, 11, 8, 9, 10, <code>7</code>, 9 ], <strong>S1 candidate</strong> = <code>7</code>, <strong>S3 candidate</strong> = <code>None</code>, <strong>Stack</strong> = <code>[9]</code><br><code>i = 4</code>, <strong>nums</strong> = [ 9, 11, 8, 9, <code>10</code>, 7, 9 ], <strong>S1 candidate</strong> = <code>10</code>, <strong>S3 candidate</strong> = <code>None</code>, <strong>Stack</strong> = <code>[9,7]</code><br><code>i = 3</code>, <strong>nums</strong> = [ 9, 11, 8, <code>9</code>, 10, 7, 9 ], <strong>S1 candidate</strong> = <code>9</code>, <strong>S3 candidate</strong> = <code>9</code>, <strong>Stack</strong> = <code>[10]</code><br><code>i = 2</code>, <strong>nums</strong> = [ 9, 11, <code>8</code>, 9, 10, 7, 9 ], <strong>S1 candidate</strong> = <code>8</code>, <strong>S3 candidate</strong> = <code>9</code>, <strong>Stack</strong> = <code>[10,9]</code> <strong>We have <code>8&lt;9</code>, sequence <code>(8,10,9)</code> found!</strong></p><p><strong>code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find132pattern</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s3 = INT_MIN;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = nums.<span class="built_in">size</span>()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i -- )&#123;</span><br><span class="line">            <span class="keyword">if</span>( nums[i] &lt; s3 ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">while</span>( !st.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt; st.<span class="built_in">top</span>() )&#123; </span><br><span class="line">              s3 = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>(); </span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>外刊句子</title>
      <link href="/%E5%A4%96%E5%88%8A%E5%8F%A5%E5%AD%90/index.html"/>
      <url>/%E5%A4%96%E5%88%8A%E5%8F%A5%E5%AD%90/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="外刊句子积累"><a href="#外刊句子积累" class="headerlink" title="外刊句子积累"></a>外刊句子积累</h1><ol><li>被动：And such a drop needs to be achieved not by halting the world in its tracks, but by rewiring it.</li><li>Ever since Industrial Revolution[something happened in the past] ago, <strong>mankind</strong> has done sth.</li><li>占比： contributors; account for; make up big slices of the pie</li><li>sth. should be heeded 某事要被留心</li><li>rare to do 渴望做</li><li>retard v. 阻碍，妨碍</li><li>relinquish = quit = give up</li><li>pay off 带来好的结果</li><li>all-out 全力以赴的</li><li>masterstroke 绝招，妙招</li><li>stare down 勇敢的面对</li><li>step down 退位</li><li>at the tender age of 在不谙世故的…岁上</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 新英文杂志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>book_xv6:Chapter_0</title>
      <link href="/book-xv6-chapter-0/index.html"/>
      <url>/book-xv6-chapter-0/index.html</url>
      
        <content type="html"><![CDATA[<p>【转载自：<a href="https://123xzy.github.io/2019/03/08/MIT-6-828-book-xv6-Chapter-0/】">https://123xzy.github.io/2019/03/08/MIT-6-828-book-xv6-Chapter-0/】</a></p><hr><p><a href="https://hasuer.github.io/mit-6-828-operating-system-engineering/index.html">MIT 6.828 Operating System Engineering</a></p><p>这本书要和<code>xv6</code>源码一起阅读</p><h1 id="操作系统接口"><a href="#操作系统接口" class="headerlink" title="操作系统接口"></a>操作系统接口</h1><p>操作系统的任务是在多个程序之间共享计算机，并提供比硬件单独支持更有用的服务集合。操作系统管理和抽象低级硬件，因此像文字处理机就不需要考虑使用哪种类型的磁盘。它还支持多路复用硬件，允许程序间共享计算机（或近似于）并发运行。最后，操作系统提供了程序交互的受控方式，以便程序之间可以共享数据或者协同工作。</p><p>OS通过接口向用户程序提供服务，而设计好的接口是很困难的。一方面，我们希望接口简单和紧凑（窄接口比较容易确保对某一特定点的关注。这点很像铺设自来水管道。管路最初阶段可能从需求和效率考虑需要大口径的，但要入户的时候就要转成小口径，译者注），因为这样更容易正确实现。 另一方面，我们倾向于向应用程序提供更多巧妙的功能。解决这种紧张关系的技巧是设计依赖提供更大的通用性的机制的接口。</p><p>这本书使用一个简单OS作为具体示例来阐述OS相关概念。这个OS，即xv6，提供的简单接口，来自于Ken Thompson and Dennis Ritchie的Unix操作系统，并且模拟了Unix的内部设计。Unix的接口提供的窄接口，其机制很好的融合在了一起，提供了令人惊讶的通用性。这些接口很成功，以至于像BSD、Linux，Mac OS X、Solaris，甚至一部分Windows，都有类Unix接口。理解xv6是理解其他任何系统的良好开始。</p><p>如图0-1所示，xv6采用了传统形式的内核，内核是为运行程序提供服务的特殊程序。每个运行程序（称为进程）的内存中都包含了指令、数据和栈。指令实现了程序的运算，数据则是运算所依赖的变量，栈则组织了程序的调用过程。<br><a href="https://123xzy.github.io/2019/03/08/MIT-6-828-book-xv6-Chapter-0/1.jpg"><img src="https://123xzy.github.io/2019/03/08/MIT-6-828-book-xv6-Chapter-0/1.jpg" alt="图0-1"></a></p><p>当进程需要调用内核服务时，将调用操作系统接口中的过程调用。这种过程称为系统调用。系统调用会陷入内核态，内核执行完服务并返回用户态。因此进程在用户空间和内核空间之间交替变换。</p><p>内核使用CPU的硬件保护机制来确保在用户空间的每个进程只能访问自己的内存。内核在硬件特权上运行，因此需要实现这些保护；用户程序在执行时则没有这些特权。当用户程序调用系统调用时，硬件会提升权限级别，并开始执行在内核中预先写好的函数。</p><p>内核提供的系统调用集合就是用户程序可见的接口。xv6内核提供了Unix内核传统提供的服务和系统调用的子集。图 0-2列出了xv6的所有系统调用。<br><a href="https://123xzy.github.io/2019/03/08/MIT-6-828-book-xv6-Chapter-0/2.JPG"><img src="https://123xzy.github.io/2019/03/08/MIT-6-828-book-xv6-Chapter-0/2.JPG" alt="图0-2"></a></p><p>本章其余部分概述了xv6的服务：进程、内存、文件描述、管道和文件系统，并通过代码段来说明shell如何使用它们。shell对系统调用的使用将说明系统调用设计的是多么精巧。</p><p>shell是一个从用户读取命令并执行他们的普通程序，而且是传统类Unix的主要用户界面。shell只是一个用户程序，而不是内核的一部分，shell没有什么特别之处反倒说明了系统调用接口的力量。这也意味着shell很容易更换，因此现代Unix系统都有各种各样shell去选择，每种shell都有自己的界面和脚本功能。xv6的shell本质上就是Unix Bourne shell的简单实现。其实现源码从第8350行开始。</p><h1 id="进程和内存"><a href="#进程和内存" class="headerlink" title="进程和内存"></a>进程和内存</h1><p>xv6进程由用户空间内存（指令、数据和栈）和内核的每个进程私有状态组成。xv6可以分时（<code>time-share</code>）处理进程，它透明地在等待执行的进程组之间切换，来分配可用的CPU。当进程未执行时，xv6会保存其CPU寄存器，并在下次运行时还原。内核将进程标识符（<code>pid</code>）和每个进程关联。</p><p>进程可以使用<code>fork</code>系统调用来创建新的进程。<code>fork</code>创建的子进程（<code>chile process</code>）和调用进程（父进程，<code>parent process</code>）有着一样的内存信息。<code>fork</code>返回父进程和子进程中都返回，在父进程中返回子进程的pid，在子进程中则返回0。例如考虑下面这个程序片段</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int pid = fork(); </span><br><span class="line"><span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">printf(<span class="string">&quot;parent: child=%d\n&quot;</span>, pid); </span><br><span class="line">pid = wait();</span><br><span class="line">printf(<span class="string">&quot;child %d is done\n&quot;</span>, pid);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">&#123; </span><br><span class="line">printf(<span class="string">&quot;child: exiting\n&quot;</span>); </span><br><span class="line"><span class="keyword">exit</span>();</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">&#123; </span><br><span class="line">printf(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>exit</code>系统调用会导致调用进程结束执行并释放如内存和文件这样的资源。<code>wait</code>系统调用返回当前进程的退出子进程的pid。如果调用者没有子进程退出，则等待。在实例中，命令行输出：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">child=1234</span><br><span class="line"><span class="section">chileL:exiting</span></span><br></pre></td></tr></table></figure><p>上面两句话会按任意顺序出现，这取决于父进程还是子进程先接收到<code>printf</code>调用。当子进程退出后，父进程的<code>wait</code>返回，因此打印出</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">parent:</span>child <span class="number">1234</span> <span class="built_in">is</span> done</span><br></pre></td></tr></table></figure><p>注意父进程和子进程在不同的内存和寄存器中运行，改变变量值不会影响另外一个。</p><p><code>exec</code>系统调用用从存储在文件系统的文件加载的新内存镜像来替换调用进程的内存。该文件必须具有特定格式，其指明文件的那部分是指令，那部分是数据，从哪里开始执行等。xv6使用ELF格式，第二章将详细讨论该格式。</p><p>当<code>exex</code>成功调用后，不会返回调用程序，而是从ELF头部声明的入口开始执行。<code>exec</code>需要两个参数：可执行文件名和字符串参数数组，例如</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">char</span> *argv[<span class="number">3</span>];</span><br><span class="line"><span class="attribute">argv</span>[<span class="number">0</span>] = <span class="string">&quot;echo&quot;</span>; </span><br><span class="line"><span class="attribute">argv</span>[<span class="number">1</span>] = <span class="string">&quot;hello&quot;</span>; </span><br><span class="line"><span class="attribute">argv</span>[<span class="number">2</span>] = <span class="number">0</span>; </span><br><span class="line"><span class="attribute">exec</span>(<span class="string">&quot;/bin/echo&quot;</span>, argv); </span><br><span class="line"><span class="attribute">printf</span>(<span class="string">&quot;exec error\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>这个片段将调用程序替换成参数为<code>echo hello</code>的<code>/bin/echo</code>程序实例。大多数程序会忽略第一个参数，这通常是程序名称。</p><p>xv6使用上述调用来代替用户运行程序。shell的主体结构很简单，见main（8501行）。主循环使用<code>getcmd</code>读取命令行上的输入。然后调用<code>fork</code>，创建shell进程的副本。父进程调用<code>wait</code>，子进程运行命令。例如，如果用户在提示符下输入<code>echo hello</code>，<code>runcmd</code>将被调用，并以<code>echo hello</code>为参数。<code>runcmd</code>（8406行）执行实际命令。对于<code>echo hello</code>，将调用<code>echo</code>（8426行）。如果<code>exec</code>成功执行，子进程会执行<code>echo</code>的指令，而不是<code>runcmd</code>。在某些点，<code>echo</code>会调用<code>exit</code>，这会导致父进程从<code>wait</code>返回。也许你想知道<code>fork</code>和<code>exec</code>为什么没有合成一个调用，稍后我们将看到，单独调用创建进程和加载程序是一个巧妙的设计。</p><p>xv6隐式分配大多数用户空间的内存，<code>fork</code>分配子进程需要的内存，<code>exec</code>分配足够的内存去保存可执行文件。在运行时进程可能需要更多的内存，例如<code>malloc</code>这时候可以调用<code>sbrk(n)</code>将内存扩展n字节。<code>sbrk</code>返回新内存的地址。</p><p>xv6不提供用户的概念，也不提供保护一个用户免受一个用户影响的概念，在unix中，所有xv6都以root身份运行。</p><h1 id="I-O和文件描述符"><a href="#I-O和文件描述符" class="headerlink" title="I/O和文件描述符"></a>I/O和文件描述符</h1><p>文件描述符是只是一个小整数值，代表一个进程读取或写入的内核管理对象。进程可以通过打开文件、目录、设备、创建管道、复制存在的描述符来获取文件描述符。简单起见我们通常把文件描述符就当做文件，但其实文件描述符接口是文件、管道和设备的抽象，使它们看起来都是字节流。</p><p>xv6内部将文件描述符作为每个预处理表（per—process table）的索引，因此每个进程都有一个从零开始的文件描述符的专有空间。按照惯例，进程从文件描述符0（标准输入）读取，将输出写入到文件描述符1（标准输出），并将错误信息写入文件描述符2（标准错误）。正如我们将看到的，shell利用这个约定（exploits the convention）来实现I/O重定向和管道。shell保证始终打开三个文件描述符（8507），这是控制台的默认文件描述符。</p><p><code>read</code>和<code>write</code>系统调用从描述符命令的打开文件中读取和写入字节。<code>read(fd,buf,n)</code>最多从文件描述符<code>fd</code>读取n字节，将其复制到<code>buf</code>，并返回读取的字节数。每个文件描述符都有一个偏移量，其和引用的文件相关。<code>read</code>从当前文件偏移处读取数据，然后将偏移量向前移动所要读取的n字节数，后续的<code>read</code>将从新的位置继续读取字节。当没有更多的字节能读时，返回0，标志着读到了文件末尾。</p><p><code>write(fd,buf,n)</code>从<code>buf</code>中写入n字节到文件描述符<code>fd</code>，并返回写入的字节数。只有在发生错误时，才会写入少于n字节。像<code>read</code>、<code>write</code>在当前文件偏移处写入数据，并将偏移量向前移动写入的n字节，每次<code>write</code>都会从前一个写入位置写入。</p><p>下面的程序片段（构成了<code>cat</code>的本质）从标准输入复制数据到标准输出。如果发生错误，将信息写入标准错误。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">char buf[<span class="number">512</span>]; int n;</span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">n = read(<span class="number">0</span>, buf, sizeof buf); </span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123; </span><br><span class="line">fprintf(<span class="number">2</span>, <span class="string">&quot;read error\n&quot;</span>); </span><br><span class="line"><span class="keyword">exit</span>();</span><br><span class="line">&#125; <span class="keyword">if</span>(write(<span class="number">1</span>, buf, n) != n)&#123;</span><br><span class="line">fprintf(<span class="number">2</span>, <span class="string">&quot;write error\n&quot;</span>); </span><br><span class="line"><span class="keyword">exit</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码段中需要注意的是<code>cat</code>并不知道它是从文件、控制台还是管道读取。同样，<code>cat</code>也不知道它是打印到控制台、文件还是其他地方。文件描述符的使用，文件描述符0是输入，1是输出，这整个约定使得<code>cat</code>能简单实现。</p><p><code>close</code>系统调用释放文件描述符，使其可被<code>cat</code>、<code>open</code>、<code>pipe</code>和<code>dup</code>重用。新分配的文件描述符始终是当前进程的最小未使用编号。</p><p>文件描述符和<code>fork</code>的相互交互使得I/O重定向变得易于实现。<code>fork</code>复制父进程的文件描述符表和内存，使得子进程从和父进程有着相同的打开文件。<code>exec</code>替换调用进程的内存，但是保留其文件表。此行为允许shell通过<code>fork</code>，重新打开选定的文件并执行新的程序来实现I/O重定向。下面是shell命令为<code>cat &lt; input.txt</code>简化代码</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char *argv[<span class="number">2</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">fork</span>() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">close</span>(<span class="number">0</span>); </span><br><span class="line"><span class="keyword">open</span>(<span class="string">&quot;input.txt&quot;</span>, O_RDONLY); </span><br><span class="line"><span class="keyword">exec</span>(<span class="string">&quot;cat&quot;</span>, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子进程关闭文件描述符0之后，保证<code>open</code>能将其用于新打开的input.txt，此时0就是最小的可用文件描述符。<code>cat</code>使用引用input.txt的文件描述符0（标准输入）执行。</p><p>xv6 shell中的I/O重定向就是以上述方式工作（8430）。回想一下，shell已经<code>fork</code>了child shell，并且<code>runcmd</code>将调用<code>exec</code>加载新程序。现在应该清楚为什么<code>fork</code>和<code>exec</code>单独调用是一个好主意。这种分离允许shell在子程序运行所需要的程序之前修复子进程。</p><p>尽管<code>fork</code>复制文件描述符表，但每个基础文件偏移量都在父进程和子进程之间分享。看下面这个实例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(fork() == <span class="number">0</span>) &#123;</span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;hello &quot;</span>, <span class="number">6</span>);</span><br><span class="line"><span class="keyword">exit</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">wait(); </span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;world\n&quot;</span>, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个片段的末尾，附加到文件描述符1的文件将包含数据<code>hello world</code>。父进程的<code>write</code>（由于<code>wait</code>，只能在子进程结束之后才会运行）会在子进程<code>write</code>中断的地方继续执行。这种行为将有助于从shell命令序列中产生有序输出，如<code>(echo hello;echo world) &gt; output.txt</code></p><p><code>dup</code>复制现有的文件描述符，返回一个指向相同I/O对象的新文件描述符。这两个文件描述符共享偏移量，就像<code>fork</code>复制的文件描述符一样。这是将<code>hello world</code>写入文件的另一种方法：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">fd</span> = dup(<span class="number">1</span>); </span><br><span class="line"><span class="attribute">write</span>(<span class="number">1</span>, <span class="string">&quot;hello &quot;</span>, <span class="number">6</span>);</span><br><span class="line"><span class="attribute">write</span>(fd, <span class="string">&quot;world\n&quot;</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>如果文件描述符是通过一系列<code>fork</code>和<code>dup</code>从同一原始文件派生的，则他们共享偏移量，否则即使他们使用<code>open</code>打开同一个文件，也不共享偏移量。<code>dup</code>允许shell实现这样的命令：<code>ls existing-file non-existing-file &gt; tmp1 2&gt;&amp;1</code>。<code>2&gt;&amp;1</code>告诉shell提供一个文件描述符2，它是描述符1的副本。现有文件的名字和错误信息都保存在文件<code>tmp1</code>。xv6 shell不支持错误文件描述符的I/O重定向，但你应该知道如何实现。</p><p>文件描述符是一个强大的抽象，因为它隐藏了连接的细节：写入文件描述符1的进程可能正写入文件、控制台等设备或者管道。</p><h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><p><code>pipe</code>是一个小的内核缓冲区，以一对文件描述符的形式公开给进程，一个用于读取，另一个用于写入。将数据写入管道的一段可使数据从管道的另一端被读取。管道为进程提供了一种通信方式。</p><p>下面的示例代码使用连接到管道读取端的标准输入运行程序<code>WC</code>：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> p[<span class="number">2</span>]; </span><br><span class="line">char *argv[<span class="number">2</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;wc&quot;</span>; </span><br><span class="line">argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pipe</span>(p); </span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">fork</span>() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">close</span>(<span class="number">0</span>);</span><br><span class="line">dup(p[<span class="number">0</span>]); </span><br><span class="line"><span class="keyword">close</span>(p[<span class="number">0</span>]); </span><br><span class="line"><span class="keyword">close</span>(p[<span class="number">1</span>]); </span><br><span class="line"><span class="keyword">exec</span>(<span class="string">&quot;/bin/wc&quot;</span>, argv);</span><br><span class="line">&#125; <span class="keyword">else</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">write</span>(p[<span class="number">1</span>], <span class="string">&quot;hello world\n&quot;</span>, <span class="number">12</span>); </span><br><span class="line"><span class="keyword">close</span>(p[<span class="number">0</span>]); </span><br><span class="line"><span class="keyword">close</span>(p[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序调用<code>pipe</code>，它创建一个新管道，并在数组p中记录读取和写入的文件描述符。在<code>fork</code>之后，父进程和子进程都有引用管道的文件描述符。子进程将读取结果传入文件描述符0，关闭p中的文件描述符，以及执行wc。当wc从标准输入读取时，其实是从管道读取。父进程写入管道的写入端，然后关闭两个文件描述符。</p><p>如果没有可用数据，管道上的<code>read</code>会等待数据的写入或者关闭写入端的所有文件描述符。在后一种情况下，<code>read</code>返回0，就像已达到数据文件的末尾。阻塞<code>read</code>直到不可能到达新数据的一个原因是在执行wc之前，让子进程关闭管道的写入端非常重要。因为如果wc的一个文件描述符指向了管道的写入端，wc将永远不会看到文件末尾。</p><p>xv6 shell实现了诸如<code>grep fork sh.c | wc -l</code>等类似代码（8450）的管道。子进程创建一个管道，将管道的左端和右端相连，然后调用<code>runcmd</code>为管道的左端和右端。然后调用两次<code>wait</code>去等待左端和右端的完成。管道的右端可能是一个命令，该命令本身也是一个管道（如<code>a | b | c</code>），它本省分叉成两个子进程（一个用于b，一个用于c）。因此shell可能会创建一个进程树。树的叶节点是命令，内部节点是等待左右子进程完成的进程。原则上，你可以让内部节点运行管道的左端，但正确的完成会使得实现变得复杂。管道看起来并没有比临时文件强大，例如<code>echo hello world | wc</code>也可以在没有管道的情况下实现<code>echo hello world &gt; /tmp/xyz;wc &lt; /tmp/xzy</code></p><p>管道和临时文件至少有三个关键区别。第一个，管道会自动清理自己，而在文件重定向时，shell必须在完成时小心的溢出<code>/tmp/xzy</code>。其次，管道可以通过任意长度的数据流，而文件重定向需要磁盘上足够的可用空间来存储所有数据。最后，管道允许同步，两个进程可以使用一对管道相互发送消息，每个<code>read</code>都会阻塞调用进程，直到另一个进程通过<code>write</code>写入数据。</p><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p>xv6文件系统提供了数据文件，这些数据文件都是没解释的字节数组和目录，其中包含对数据文件和其他目录的命令引用。xv6将目录实现为一种特殊的文件。目录形成一个从称为<code>root</code>的特殊目录开始的树。像<code>/a/b/c</code>这样的路径指向了根目录中b目录中的命名为c的文件或目录。路径如果没有以<code>/</code>开始，就会改用<code>chdir</code>系统调用，来计算相对于调用进程的当前目录的位置。这两种方式都能打开相同的文件（假设涉及的目录都存在）：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">chdir</span>(<span class="string">&quot;/a&quot;</span>); </span><br><span class="line"><span class="selector-tag">chdir</span>(<span class="string">&quot;b&quot;</span>); </span><br><span class="line"><span class="selector-tag">open</span>(<span class="string">&quot;c&quot;</span>, O_RDONLY); </span><br><span class="line"><span class="selector-tag">open</span>(<span class="string">&quot;/a/b/c&quot;</span>, O_RDONLY);</span><br></pre></td></tr></table></figure><p>第一个片段将进程的当前目录更改为<code>/a/b</code>，第二个既不引用也不修改进程的当前目录。</p><p>这里有多个系统调用来创建新的文件和目录：<code>mkdir</code>创建一个新的目录，使用<code>O_CREAT</code>标志的<code>open</code>创建一个新的数据文件，<code>mknod</code>创建新的设备文件。下面的示例说明了这三个方面：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir(<span class="string">&quot;/dir&quot;</span>)<span class="comment">; </span></span><br><span class="line">fd = open(<span class="string">&quot;/dir/file&quot;</span>, O_CREATE|O_WRONLY)<span class="comment">; </span></span><br><span class="line">close(<span class="name">fd</span>)<span class="comment">;</span></span><br><span class="line">mknod(<span class="string">&quot;/console&quot;</span>, <span class="number">1</span>, <span class="number">1</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><code>mknod</code>在文件系统中创建一个文件，但是该文件没有内容。相反，该文件的元数据将其标记为设备文件，并记录主要和次要的设备编号（传给<code>mknod</code>的两个参数），它们惟一的标志内核设备。当进程之后打开该文件时，内核将<code>read</code>和<code>write</code>调用转移到内核实现，而不是将它们传到文件系统。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fstat`检索有关文件描述符所引用对象的信息。它填充`<span class="keyword">struct</span> <span class="type">stat</span>`，该结构定义在`<span class="type">stat</span>.<span class="type">h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_DIR 1 <span class="comment">// Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_FILE 2 <span class="comment">// File </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_DEV 3 <span class="comment">// Device</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="type">stat</span> </span><br><span class="line">&#123;</span><br><span class="line">short <span class="built_in">type</span>; <span class="comment">// Type of file </span></span><br><span class="line">int dev; <span class="comment">// File system’s disk device </span></span><br><span class="line">uint ino; <span class="comment">// Inode number </span></span><br><span class="line">short nlink; <span class="comment">// Number of links to file </span></span><br><span class="line">uint size; <span class="comment">// Size of file in bytes</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>文件名和文件本身并不同，同一个基础文件，叫做<code>inode</code>，可以有多个名称，叫做<code>links</code>。<code>link</code>系统调用创建另一个文件系统名称，引用和现有文件相同的inode。下面片段创建了一个文件，其名称既可以为<code>a</code>，也可以为<code>b</code></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">open</span>(<span class="string">&quot;a&quot;</span>, O_CREATE|O_WRONLY);</span><br><span class="line"><span class="selector-tag">link</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br></pre></td></tr></table></figure><p>从a或者从b读取、写入是一模一样的。每个inode都是有惟一的inode number标识的。执行了上面的代码之后，可以通过<code>fstat</code>的结果来确定a和b指向相同的基础内容，两者都返回相同的inode number（ino），并且<code>nlink</code>将设置为2。</p><p><code>unlink</code>将从文件系统中删除一个名称。只有当文件的链接数为0并没有文件描述符引用该文件时，才会释放文件的inode和磁盘空间，因此<code>unlink(&quot;a&quot;);</code>将使得inode和文件内容只能被b访问。而且下面的方法是常用的方式来创建临时inode，其在进程关闭<code>fd</code>或者退出时，会被清理。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">&quot;/tmp/xyz&quot;</span>, O_CREATE|O_RDWR)<span class="comment">; </span></span><br><span class="line">unlink(<span class="string">&quot;/tmp/xyz&quot;</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>用于文件系统操作的xv6 命令被作为用户级程序（如<code>mkdir</code>、<code>ln</code>、<code>rm</code>等）实现。这种设计允许任何人使用新的用户命令扩展shell。事后看来，这个计划似乎很明显，但和unix同时期设计的其他系统经常在shell中构建这样的命令（并将shell构建到内核中）。</p><p>一个例外是<code>cd</code>，它内置到shell (8516) 中。<code>cd</code>必须更改shell本身的当前工作目录。如果<code>cd</code> 作为常规命令运行，并且shell 将分叉子进程, 子进程将运行<code>cd</code>，<code>cd</code>将更改子进程的工作目录。父目录（即shell的）工作目录不会更改。</p><h1 id="真实世界"><a href="#真实世界" class="headerlink" title="真实世界"></a>真实世界</h1><p>unix将“标准”文件描述符、管道和方便的shell语法结合起来，用于对其进行操作，这是编写通用可重用程序的一大进步。这个想法引发了整个“软件工具”的文化，它在很大程度上是unix的力量和人气的原因,，shell是第一个所谓的“脚本语言”。在BSD、Linux和Mac OS X等系统中, unix系统调用接口如今仍然存在。</p><p>与xv6相比，现代内核提供了更多的系统调用和更多种类的内核服务。在大多数情况下，现代unix派生的操作系统没有遵循早期的unix模型，即将设备公开为特殊文件，如上面讨论的控制台设备文件。unix的作者接着构建了计划9，该计划将“资源是文件”概念应用于现代设施，将网络、图形和其他资源表示为文件或文件树。</p><p>文件系统抽象是一个强大的想法，最近以万维网的形式应用于网络资源。即使如此，操作系统接口还有其他模型。multics是unix的前身，它的抽象文件存储使其看起来像内存，产生了截然不同的接口风格。multics设计的复杂性直接影响了unix的设计者，他们试图构建更简单的设计器。</p><p>这本书探讨了xv6如何实现类似unix的界面, 但这些想法和概念不仅仅适用于unix。任何操作系统都必须将进程多路复用到底层硬件上，将进程彼此隔离，并提供受控制的进程间通信机制。在研究了xv6之后，您应该能够查看其他更复杂的操作系统，并在这些系统中看到xv6的基本概念。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MIT OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog目录</title>
      <link href="/blog%E7%9B%AE%E5%BD%95/index.html"/>
      <url>/blog%E7%9B%AE%E5%BD%95/index.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://hasuer.github.io/mit-6-828-operating-system-engineering/index.html">MIT 6.828 Operating System Engineering</a></p><p>【】</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.828 Operating System Engineering</title>
      <link href="/mit-6-828-operating-system-engineering/index.html"/>
      <url>/mit-6-828-operating-system-engineering/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="MIT-6-828-Operating-System-Engineering"><a href="#MIT-6-828-Operating-System-Engineering" class="headerlink" title="MIT 6.828 Operating System Engineering"></a>MIT 6.828 Operating System Engineering</h1><p>【转载自：<a href="https://123xzy.github.io/2019/03/08/MIT-6-828-Operating-System-Engineering/】">https://123xzy.github.io/2019/03/08/MIT-6-828-Operating-System-Engineering/】</a></p><p>这个系列的文章会以上面链接中的资源为依据作为学习，在此只是搬运。对于实验和作业会加上自己的理解。每一篇文章前都会加上转载声明，感谢原作者。</p><hr><p>MIT 6.828是一门被广泛好评的e操作系统课程。它最重要的特点就是它实践第一的教学原则。在这门课程中会涉及到非常丰富的实验，也会有非常多的动手机会。而且授课者更是亲自构建了一个简化的基于Unix内核的操作系统xv6。所有的实验都是在这个操作系统上完成。虽然它功能很简单，但是它能够帮助我们真正的了解操作系统在做什么</p><p>这一系列文章会包括以下几个内容：</p><ul><li>Lab：MIT 6.828 Lab <em>*</em></li><li>Exercise：MIT 6.828 Exercise <em>*</em></li><li>Assignment：MIT 6.828 Assignment <em>*</em></li><li>book_xv6：别人的中文翻译，MIT 6.828 book_xv6 <em>*</em></li></ul><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="book"><a href="#book" class="headerlink" title="book"></a>book</h3><ul><li><p><a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev10.pdf">book-rev10</a>：英文原版书籍</p></li><li><p><a href="https://hasuer.github.io/book-xv6-chapter-0/index.html">MIT 6.828 book_xv6:Chapter 0</a>：操作系统接口</p></li><li><a href="https://123xzy.github.io/2019/03/24/MIT-6-828-book-xv6-Chapter-1/">MIT 6.828 book_xv6:Chapter 1</a>：操作系统组成</li><li><a href="https://123xzy.github.io/2019/04/07/MIT-6-828-book-xv6-Chapter-2/">MIT 6.828 book_xv6:Chapter 2</a>：页表</li><li><a href="https://123xzy.github.io/2019/04/14/MIT-6-828-book-xv6-Chapter-3/">MIT 6.828 book_xv6:Chapter 3</a>：陷阱、中断和驱动</li><li><a href="https://123xzy.github.io/2019/04/13/MIT-6-828-book-xv6-Chapter-4/">MIT 6.828 book_xv6:Chapter 4</a>：锁</li><li><a href="https://123xzy.github.io/2019/04/15/MIT-6-828-book-xv6-Chapter-5/">MIT 6.828 book_xv6:Chapter 5</a>：调度程序</li><li><a href="https://123xzy.github.io/2019/04/13/MIT-6-828-book-xv6-Chapter-6/">MIT 6.828 book_xv6:Chapter 6</a>：文件系统</li><li><a href="https://123xzy.github.io/2019/03/14/MIT-6-828-book-xv6-Appendix-A/">MIT 6.828 book_xv6:Appendix A</a>：PC硬件</li><li><a href="https://123xzy.github.io/2019/03/26/MIT-6-828-book-xv6-Appendix-B/">MIT 6.828 book_xv6:Appendix B</a>：Boot loader</li></ul><h3 id="Lab"><a href="#Lab" class="headerlink" title="Lab"></a>Lab</h3><ul><li><a href="https://123xzy.github.io/2019/03/08/MIT-6-828-Lab-Guide/">MIT 6.828 Lab:Guide</a></li><li><a href="https://123xzy.github.io/2019/03/14/MIT-6-828-Lab-Booting-a-PC/">MIT 6.828 Lab:Booting a PC</a></li><li><a href="https://123xzy.github.io/2019/03/24/MIT-6-828-Lab-Memory-Management/">MIT 6.828 Lab:Memory Management</a></li></ul><h3 id="Assignment"><a href="#Assignment" class="headerlink" title="Assignment"></a>Assignment</h3><ul><li><a href="https://hasuer.github.io/mit-6-828-assignment-shell/index.html">MIT 6.828 Assignment:Shell</a></li><li><a href="https://123xzy.github.io/2019/04/08/MIT-6-828-Assignment-Boot-xv6/">MIT 6.828 Assignment:Boot xv6</a></li><li><a href="https://123xzy.github.io/2019/04/08/MIT-6-828-Assignment-System-Calls/">MIT 6.828 Assignment:System Calls</a></li><li><a href="https://hasuer.github.io/mit-6-828-assignment-threadsandlocks/index.html">MIT 6.828 Assignment_ThreadsandLocks</a></li><li><a href="https://hasuer.github.io/mit-6-828-assignment-barriers/index.html">MIT 6.828 Assignment_Barriers</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MIT OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.828 Assignment_Shell</title>
      <link href="/mit-6-828-assignment-shell/index.html"/>
      <url>/mit-6-828-assignment-shell/index.html</url>
      
        <content type="html"><![CDATA[<p>【转载自：】</p><ol><li><a href="https://www.cnblogs.com/jxhd1/p/6706701.html">https://www.cnblogs.com/jxhd1/p/6706701.html</a></li><li><a href="https://www.cnblogs.com/fengbohello/p/4262961.html">https://www.cnblogs.com/fengbohello/p/4262961.html</a></li><li><a href="https://123xzy.github.io/2019/03/08/MIT-6-828-Assignment-Shell/">https://123xzy.github.io/2019/03/08/MIT-6-828-Assignment-Shell/</a></li></ol><hr><p><a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-shell.html">实验指导书</a></p><hr><p><a href="https://hasuer.github.io/mit-6-828-operating-system-engineering/index.html">MIT 6.828 Operating System Engineering</a></p><hr><h1 id="知识了解"><a href="#知识了解" class="headerlink" title="知识了解"></a>知识了解</h1><h2 id="fork-和-exec"><a href="#fork-和-exec" class="headerlink" title="fork 和 exec"></a>fork 和 exec</h2><p>在父进程中fork一个子进程，在子进程中调用<code>exec</code>函数启动新的程序。<code>exec</code>函数一共有六个，其中<code>execve</code>为内核级系统调用，其他（<code>execl</code>，<code>execle</code>，<code>execlp</code>，<code>execv</code>，<code>execvp</code>）都是调用<code>execve</code>的库函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure><p><code>fork</code>是分身，<code>execve</code>是变身。</p><p><code>exec</code>系列的系统调用是把当前程序替换成要执行的程序，而fork用来产生一个和当前进程一样的进程（虽然通常执行不同的代码流）。通常运行另一个程序，而同时保留原程序运行的方法是，fork+exec。</p><p>看看手册里面的例子就知道怎么用了。</p><p><code>exec</code>系列的系统调用已经是变成别的程序了，已经和本程序无关了</p><h2 id="open-和-close"><a href="#open-和-close" class="headerlink" title="open() 和 close()"></a>open() 和 close()</h2><p><code>open</code> 函数用于打开和创建文件。以下是 <code>open</code> 函数的简单描述</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> oflag, ... )</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="comment">/* (char  *) NULL */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="comment">/* (char  *) NULL */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="comment">/*, (char *) NULL, char *const envp[] */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvpe</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[],</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure><p>返回值：成功则返回文件描述符，否则返回 -1</p><p>对于<code>open</code>函数来说，第三个参数（…）仅当创建新文件时才使用，用于指定文件的访问权限位（access permission bits）。pathname 是待打开/创建文件的路径名（如 C:/cpp/a.cpp）；<code>oflag</code> 用于指定文件的打开/创建模式，这个参数可由以下常量（定义于 <code>fcntl.h</code>）通过逻辑或构成。<br>O_RDONLY　　只读模式<br>O_WRONLY　　只写模式<br>O_RDWR　　读写模式</p><p>打开/创建文件时，至少得使用上述三个常量中的一个。以下常量是选用的：</p><p>O_APPEND　　每次写操作都写入文件的末尾<br>O_CREAT　　如果指定文件不存在，则创建这个文件<br>O_EXCL　　如果要创建的文件已存在，则返回 -1，并且修改 <code>errno</code> 的值<br>O_TRUNC　　如果文件存在，并且以只写/读写方式打开，则清空文件全部内容<br>O_NOCTTY　　如果路径名指向终端设备，不要把这个设备用作控制终端。<br>O_NONBLOCK　　如果路径名指向 FIFO/块文件/字符文件，则把文件的打开和后继 I/O设置为非阻塞模式（nonblocking mode）</p><p>以下三个常量同样是选用的，它们用于同步输入输出<br>O_DSYNC　　等待物理 I/O 结束后再 write。在不影响读取新写入的数据的前提下，不等待文件属性更新。<br>O_RSYNC　　read 等待所有写入同一区域的写操作完成后再进行<br>O_SYNC　　等待物理 I/O 结束后再 write，包括更新文件属性的 I/O</p><p>open 返回的文件描述符一定是最小的未被使用的描述符。</p><p>如果 NAME_MAX（文件名最大长度，不包括’\0’）是 14，而我们想在当前目录下创建文件名长度超过 14 字节的文件，早期的 System V 系统（如 SVR2）会截断超出部分，只保留前 14 个字节；而由 BSD 衍生的（BSD-derived）系统会返回错误信息，并且把 <code>errno</code> 置为 ENAMETOOLONG。<br>POSIX.1 引入常量 _POSIX_NO_TRUNC 用于决定是否截断长文件名/长路径名。如果_POSIX_NO_TRUNC 设定为禁止截断，并且路径名长度超过 PATH_MAX（包括 ‘\0’），或者组成路径名的任意文件名长度超过 NAME_MAX，则返回错误信息，并且把 <code>errno</code> 置为 ENAMETOOLONG。</p><h1 id="The-shell"><a href="#The-shell" class="headerlink" title="The shell"></a>The shell</h1><p><a href="https://hasuer.github.io/mit-6-828-operating-system-engineering/index.html">MIT 6.828 Operating System Engineering</a></p><p>做作业之前先熟悉OS<a href="https://hasuer.github.io/book-xv6-chapter-0/index.html">MIT 6.828 book_xv6:Chapter 0</a><br>该作业的<a href="https://pdos.csail.mit.edu/6.828/2014/homework/xv6-shell.html">解释文档</a><br>下载<a href="https://pdos.csail.mit.edu/6.828/2014/homework/sh.c">sh.c</a></p><p>建立<code>t.sh</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ls &gt; y</span><br><span class="line">cat &lt; y | sort | uniq | wc &gt; y1</span><br><span class="line">cat y1</span><br><span class="line">rm y1</span><br><span class="line">ls |  sort | uniq | wc</span><br><span class="line">rm y</span><br></pre></td></tr></table></figure><p>gcc，你可以编译骨架shell，如下所示：<br><code>$ gcc sh.c</code><br>生成一个a.out文件，你可以运行：<br><code>$ ./a.out &lt;t.sh</code><br>此执行将打印错误消息，因为您尚未实现多个功能。在本作业的其余部分中，您将实现这些功能</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>先看看主函数的行为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">  <span class="keyword">int</span> fd, r;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read and run input commands.</span></span><br><span class="line">  <span class="keyword">while</span>(getcmd(buf, <span class="keyword">sizeof</span>(buf)) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="string">&#x27;c&#x27;</span> &amp;&amp; buf[<span class="number">1</span>] == <span class="string">&#x27;d&#x27;</span> &amp;&amp; buf[<span class="number">2</span>] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">      <span class="comment">// Clumsy but will have to do for now.</span></span><br><span class="line">      <span class="comment">// Chdir has no effect on the parent if run in the child.</span></span><br><span class="line">      buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>] = <span class="number">0</span>;  <span class="comment">// chop \n</span></span><br><span class="line">      <span class="keyword">if</span>(chdir(buf+<span class="number">3</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;cannot cd %s\n&quot;</span>, buf+<span class="number">3</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fork1() == <span class="number">0</span>)</span><br><span class="line">      runcmd(parsecmd(buf));</span><br><span class="line">    wait(&amp;r);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环调用<code>getcmd</code>函数读入命令，如果是<code>cd</code>命令，则先切换文件夹，因为如果在子进程切换将对父进程无效。确认不是<code>cd</code>之后，创建子进程并调用关键函数<code>runcmd()</code>，其中<code>parsecmd(buf)</code>无非就是解析命令，里面就是一些字符串处理，不关心。</p><p>下面就我们要完成的代码片段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Execute cmd.  Never returns.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">runcmd</span><span class="params">(struct cmd *cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p[<span class="number">2</span>], r;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">execcmd</span> *<span class="title">ecmd</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pipecmd</span> *<span class="title">pcmd</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">redircmd</span> *<span class="title">rcmd</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(cmd == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">switch</span>(cmd-&gt;type)&#123;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;unknown runcmd\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">    ecmd = (struct execcmd*)cmd;</span><br><span class="line">    <span class="keyword">if</span>(ecmd-&gt;argv[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;exec not implemented\n&quot;</span>);</span><br><span class="line">    <span class="comment">// Your code here ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:</span><br><span class="line">    rcmd = (struct redircmd*)cmd;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;redir not implemented\n&quot;</span>);</span><br><span class="line">    <span class="comment">// Your code here ...</span></span><br><span class="line">    runcmd(rcmd-&gt;cmd);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;|&#x27;</span>:</span><br><span class="line">    pcmd = (struct pipecmd*)cmd;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pipe not implemented\n&quot;</span>);</span><br><span class="line">    <span class="comment">// Your code here ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>parsecmd</code>把命令分成了3个类型，分别是可执行命令，重定向命令，以及管道命令。也就是接下来要实现的</p><h2 id="简单命令"><a href="#简单命令" class="headerlink" title="简单命令"></a>简单命令</h2><p>该题的要求就是先调用当前目录下的可执行程序，如果不存在，就去<code>/bin</code>文件夹下寻找，如果没有则报错</p><p>需要使用的就是<code>execv</code>函数，它是<code>exec</code>函数族的一个，exec函数族的作用就是根据pathname找到可执行文件，并用它取代调用进程的内容。虽然pid未改变，但是实际运行的内容已经不同。结合之前main函数中的内容，可以看出Shell执行某个命令实际上就是fork出一个子进程，然后把子进程替换为想要执行的程序。这个函数在小册子中也讲解过，可以通过<code>man 3 exec</code>去查看函数解释</p><p>除此之外，还需要一个辅助函数<code>access</code>，它的作用是检查能否对某个文件（pathname）执行某个操作（mode）。模式有：</p><ul><li>R_OK：测试读许可权</li><li>W_OK：测试写许可权</li><li>X_OK：测试执行许可权</li><li>F_OK：测试文件是否存在</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">    ecmd = (struct execcmd*)cmd;</span><br><span class="line">    <span class="keyword">if</span> (ecmd-&gt;argv[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// fprintf(stderr, &quot;exec not implemented\n&quot;);</span></span><br><span class="line">    <span class="keyword">if</span> (access(ecmd-&gt;argv[<span class="number">0</span>], F_OK) == <span class="number">0</span>) &#123;</span><br><span class="line">    execv(ecmd-&gt;argv[<span class="number">0</span>], ecmd-&gt;argv);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *binPath = <span class="string">&quot;/bin/&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> pathLen = <span class="built_in">strlen</span>(binPath) + <span class="built_in">strlen</span>(ecmd-&gt;argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">char</span> *abs_path = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>((pathLen+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">strcpy</span>(abs_path, binPath);</span><br><span class="line">    <span class="built_in">strcat</span>(abs_path, ecmd-&gt;argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (access(abs_path, F_OK) == <span class="number">0</span>) &#123;</span><br><span class="line">        execv(abs_path, ecmd-&gt;argv);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s: Command not found\n&quot;</span>, ecmd-&gt;argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是我自己的答案</span></span><br><span class="line">  <span class="number">1</span>         <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">  <span class="number">2</span>             ecmd = (struct execcmd*)cmd;</span><br><span class="line">  <span class="number">3</span>             <span class="keyword">if</span> (ecmd-&gt;argv[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">  <span class="number">4</span>                 <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="number">5</span>             <span class="comment">// fprintf(stderr, &quot;exec not implemented\n&quot;);</span></span><br><span class="line">  <span class="number">6</span>             <span class="keyword">if</span> (execvp(ecmd-&gt;argv[<span class="number">0</span>], ecmd-&gt;argv) == <span class="number">-1</span>) &#123;</span><br><span class="line">  <span class="number">7</span>                 <span class="keyword">const</span> <span class="keyword">char</span> *basePath = <span class="string">&quot;/bin/&quot;</span>;</span><br><span class="line">  <span class="number">8</span>                 <span class="keyword">int</span> pathLen = <span class="built_in">strlen</span>(basePath) + <span class="built_in">strlen</span>(ecmd-&gt;argv[<span class="number">0</span>]);</span><br><span class="line">  <span class="number">9</span>                 <span class="keyword">char</span> *path = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>((pathLen+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line"> <span class="number">10</span>                 <span class="built_in">strcpy</span>(path, basePath);</span><br><span class="line"> <span class="number">11</span>                 <span class="built_in">strcat</span>(path, ecmd-&gt;argv[<span class="number">0</span>]);</span><br><span class="line"> <span class="number">12</span>                 <span class="keyword">if</span> (access(path, F_OK) != <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="number">13</span>                     <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s: Command not found\n&quot;</span>, ecmd-&gt;argv[<span class="number">0</span>]);</span><br><span class="line"> <span class="number">14</span>                 &#125;</span><br><span class="line"> <span class="number">15</span>                 execv(path, ecmd-&gt;argv);</span><br><span class="line"> <span class="number">16</span>             &#125;</span><br><span class="line"> <span class="number">17</span>             <span class="keyword">break</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>shell实验第一部分网上的答案：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">    ecmd = (struct execcmd*)cmd;</span><br><span class="line">    <span class="keyword">if</span> (ecmd-&gt;argv[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// fprintf(stderr, &quot;exec not implemented\n&quot;);</span></span><br><span class="line">    <span class="keyword">if</span> (execvp(ecmd-&gt;argv[<span class="number">0</span>], ecmd-&gt;argv) == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ls error!&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>当时一直没有搞懂为什么要用<code>execp(ecmd-&gt;argv[0], ecmd-&gt;argv)</code>。当时不理解的地方就在于，man文档说的是:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>The <strong>execv</strong>(), <strong>execvp</strong>(), and <strong>execvpe</strong>() functions provide an array of pointers to null-terminated strings that represent the argument list available to the new program. The first argument, by convention, should point to the filename associated with the file being executed. The array of pointers <em>must</em> be terminated by a NULL pointer.</p></blockquote><font color="ff0000">为什么`ecmd->argv[0]`的能作为第一个参数，也就是为什么他就是一个指向文件的指针？</font><p>这就不得不提一下我们的<code>exec</code>这个函数族了。</p><p><strong>函数定义</strong> :</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">char</span> *<span class="keyword">const</span> argv[ ], <span class="keyword">char</span> *<span class="keyword">const</span> envp[ ])</span></span>;</span><br></pre></td></tr></table></figure><p><strong>返回值</strong>: 函数执行成功时没有返回值，执行失败时的返回值为-1.</p><p><strong>函数说明</strong> :<code>execve()</code>用来执行参数filename字符串所代表的文件路径，第二个参数是利用数组指针来传递给执行文件，并且需要以空指针(NULL)结束，最后一个参数则为传递给执行文件的新环境变量数组。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="number">2.</span> main()  </span><br><span class="line"><span class="number">3.</span> &#123;  </span><br><span class="line"><span class="number">4.</span> <span class="keyword">char</span> *argv[ ]=&#123;<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-al&quot;</span>, <span class="string">&quot;/etc/passwd&quot;</span>, <span class="literal">NULL</span>&#125;;  </span><br><span class="line"><span class="number">6.</span> execvp(<span class="string">&quot;/bin/ls&quot;</span>, argv);  </span><br><span class="line"><span class="number">7.</span> &#125; </span><br></pre></td></tr></table></figure><p>这与在bin目录下执行 <code>ls -al /etc/passwd</code>所得到的结果是一样的。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//另一个例子</span></span><br><span class="line"><span class="number">1.</span> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="number">2.</span> main()  </span><br><span class="line"><span class="number">3.</span> &#123;  </span><br><span class="line"><span class="number">4.</span> <span class="keyword">char</span> *argv[ ]=&#123;<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-al&quot;</span>, <span class="string">&quot;/etc/passwd&quot;</span>, <span class="literal">NULL</span>&#125;;  </span><br><span class="line"><span class="number">6.</span> execvp(<span class="string">&quot;/bin/echo&quot;</span>, argv);  </span><br><span class="line"><span class="number">7.</span> &#125; </span><br></pre></td></tr></table></figure><p>这与在bin目录下执行 <code>echo -al /etc/passwd</code>所得到的结果是一样的。会在控制台输出<code>-al /etc/passwd</code>。</p><p>对于这个问题，老师是这样回答的：</p><blockquote><p><code>argv[]</code>的第一个元素的意义何在<br>一个程序，无论是C语言编写的<code>int main(int argc,char** argv[])</code>，还是shell脚本，都可以从命令行得到运行参数，例如：<br><code>./myprogram ant bee cat dog</code><br>那么，<code>argv[1]</code>就是<code>ant</code>，<code>argv[2]</code>就是<code>bee</code>……<strong>注意，<code>argv[0]</code>是<code>myprogram</code>，也就是说，有的程序希望在运行的时候知道自己的名字，它就会从<code>argv[0]</code>里找到自己的名字。</strong><br>这就是你设<code>argv[0]</code>的意义。</p></blockquote><p>这样上面的答案就能说通了。先检查文件是否存在，如果不存在就去<code>/bin/</code>下去找这个文件，如果还没有，就说明命令错误了。</p><p>此外：</p><p><img src="/mit-6-828-assignment-shell/index/1.2.png"></p><h2 id="I-O重定向"><a href="#I-O重定向" class="headerlink" title="I/O重定向"></a>I/O重定向</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">The parser already recognizes <span class="string">&quot;&gt;&quot;</span> <span class="keyword">and</span> <span class="string">&quot;&lt;&quot;</span>, <span class="keyword">and</span> builds a redircmd <span class="keyword">for</span> you, so your job is just filling out the missing code in runcmd <span class="keyword">for</span> those symbols. You might find the man pages <span class="keyword">for</span> open <span class="keyword">and</span> close useful</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:</span><br><span class="line">  rcmd = (struct redircmd*)cmd;</span><br><span class="line">  <span class="comment">// fprintf(stderr, &quot;redir not implemented\n&quot;);</span></span><br><span class="line">  <span class="comment">// Your code here ...</span></span><br><span class="line">  close(rcmd-&gt;fd);</span><br><span class="line">  <span class="keyword">if</span> (open(rcmd-&gt;file, rcmd-&gt;mode, <span class="number">0644</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Unable to open file: %s\n&quot;</span>, rcmd-&gt;file);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  runcmd(rcmd-&gt;cmd);</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>思路就是先关闭程序原先的标准输入/输出，打开指定文件作为新的标准输入/输出。非常容易漏掉权限位，即open的第三个参数。这是权限！</p><p><img src="/mit-6-828-assignment-shell/index/1.3.png"></p><p><img src="/mit-6-828-assignment-shell/index/1.4.png"></p><p><img src="/mit-6-828-assignment-shell/index/1.5.png"></p><p><img src="/mit-6-828-assignment-shell/index/1.6.png"></p><ul><li><code>cat</code>是连接0号文件和1号文件，也就是文件标识符是0和1的文件，默认0号文件（标准输入）是键盘，默认1号文件（标准输出）是屏幕。</li></ul><p><img src="/mit-6-828-assignment-shell/index/1.7.png"></p><p><img src="/mit-6-828-assignment-shell/index/1.8.png"></p><p><img src="/mit-6-828-assignment-shell/index/1.9.png"></p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p><code>You might find the man pages for pipe, fork, close, and dup useful</code>，也就是说这次涉及的函数主要是<code>pipe</code>、<code>dup</code>、<code>fork</code>、<code>close</code>，通过输入前面创建的<code>t.sh</code>批处理文件，来计算当前目录下文件的大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;|&#x27;</span>:</span><br><span class="line">    pcmd = (struct pipecmd*)cmd;</span><br><span class="line">    <span class="comment">// fprintf(stderr, &quot;pipe not implemented\n&quot;);</span></span><br><span class="line">    <span class="comment">// Your code here ...</span></span><br><span class="line">    <span class="keyword">if</span> (pipe(p) &lt; <span class="number">0</span>) <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;pipe failed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fork1() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//子进程</span></span><br><span class="line">        close(<span class="number">1</span>);<span class="comment">//子进程关闭自己的标准输出</span></span><br><span class="line">   dup(p[<span class="number">1</span>]);</span><br><span class="line">    close(p[<span class="number">0</span>]);<span class="comment">//关闭子进程自己的读</span></span><br><span class="line">    close(p[<span class="number">1</span>]);<span class="comment">//关闭子进程自己的写</span></span><br><span class="line">    runcmd(pcmd-&gt;left);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    close(<span class="number">0</span>);<span class="comment">//父进程关闭自己的标准输入</span></span><br><span class="line">    dup(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">0</span>]);<span class="comment">//关闭父进程自己的读</span></span><br><span class="line">    close(p[<span class="number">1</span>]);<span class="comment">//关闭父进程自己的写</span></span><br><span class="line">   runcmd(pcmd-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h3 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h3><ol><li>上面的管道是匿名管道</li><li>先创建管道，再创建子进程（fork）。这样父子就都有一个管道，并且都能够进行读和写的操作。</li><li>p[0]用来读取，p[1]用来写入</li></ol><p>由于批处理文件的命令既有在<code>/bin/</code>下，也有在<code>/usr/bin</code>，因此之前的case需要修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">   ecmd = (struct execcmd*)cmd;</span><br><span class="line">   <span class="keyword">if</span>(ecmd-&gt;argv[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   <span class="comment">// fprintf(stderr, &quot;exec not implemented\n&quot;);</span></span><br><span class="line">   <span class="keyword">if</span>(access(ecmd-&gt;argv[<span class="number">0</span>], F_OK) == <span class="number">0</span>) &#123;</span><br><span class="line">   execv(ecmd-&gt;argv[<span class="number">0</span>], ecmd-&gt;argv);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 将路径改为数组实现</span></span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> *binPath[] = &#123;<span class="string">&quot;/bin/&quot;</span>, <span class="string">&quot;/usr/bin/&quot;</span>&#125;;</span><br><span class="line">   <span class="keyword">char</span> *abs_path;</span><br><span class="line">   <span class="keyword">int</span> bin_count = <span class="keyword">sizeof</span>(binPath)/<span class="keyword">sizeof</span>(binPath[<span class="number">0</span>]);</span><br><span class="line">   <span class="keyword">int</span> found = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;bin_count &amp;&amp; found==<span class="number">0</span>; i++) &#123;</span><br><span class="line">       <span class="keyword">int</span> pathLen = <span class="built_in">strlen</span>(binPath[i]) + <span class="built_in">strlen</span>(ecmd-&gt;argv[<span class="number">0</span>]);</span><br><span class="line">       abs_path = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>((pathLen+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">       <span class="built_in">strcpy</span>(abs_path, binPath[i]);</span><br><span class="line">       <span class="built_in">strcat</span>(abs_path, ecmd-&gt;argv[<span class="number">0</span>]);</span><br><span class="line">       <span class="keyword">if</span>(access(abs_path, F_OK) == <span class="number">0</span>) &#123;</span><br><span class="line">           execv(abs_path, ecmd-&gt;argv);</span><br><span class="line">       found = <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">free</span>(abs_path);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (found == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s: Command not found\n&quot;</span>, ecmd-&gt;argv[<span class="number">0</span>]);</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MIT OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/index.html"/>
      <url>/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>这是一个典型排序问题。用到了递归和分治的思想。</p><p><strong>动图1：</strong></p><p><img src="/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/index/1.1.gif" alt></p><p><strong>动图2：</strong></p><p><img src="/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/index/1.2.gif" alt></p><p>分为三步：</p><ol><li>递归分解</li><li>合并排好序的数组</li><li>主函数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergearray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> first, <span class="keyword">int</span> mid, <span class="keyword">int</span> last, vector&lt;<span class="keyword">int</span>&gt;&amp; temp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = first;</span><br><span class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = mid;</span><br><span class="line">    <span class="keyword">int</span> n = last;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= m &amp;&amp; j &lt;= n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt;= nums[j])&#123;</span><br><span class="line">            temp[k ++] = nums[i ++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            temp[k ++] = nums[j ++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= m)&#123;</span><br><span class="line">        temp[k ++] = nums[i ++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= n)&#123;</span><br><span class="line">        temp[k ++] = nums[j ++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i ++)&#123;</span><br><span class="line">        nums[i + first] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> first, <span class="keyword">int</span> last, vector&lt;<span class="keyword">int</span>&gt;&amp; temp)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(first &lt; last)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (first + last) / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">mergesort</span>(nums, first, mid, temp);</span><br><span class="line"><span class="built_in">mergesort</span>(nums, mid + <span class="number">1</span>, last, temp);</span><br><span class="line"><span class="built_in">mergearray</span>(nums, first, mid, last, temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;How many elements to sort?\n&quot;</span>;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Enter those numbers:\n&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">cin &gt;&gt; nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> first = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> last = n - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">mergesort</span>(nums, first, last, temp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">cout &lt;&lt; nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>09 Working with processes</title>
      <link href="/09-working-with-processes/index.html"/>
      <url>/09-working-with-processes/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="What-is-a-process"><a href="#What-is-a-process" class="headerlink" title="What is a process?"></a>What is a process?</h2><ul><li>进程是一个正在执行的程序。</li><li>每一个程序都有自己的运行环境</li></ul><p>To see the PID of your current shell process, type:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $$</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><p><code>echo</code>表示在屏幕上显示东西</p></li><li><p>$$$$表示查看当前进程的PID</p></li><li><p>Linux 能在同一时间执行多个不同的命令，也可以在同一时间运行多次同一个程序（比如<code>Vi</code>）</p><p><img src="/09-working-with-processes/index/1.1.png"></p></li></ul><h2 id="Starting-and-stopping-a-process"><a href="#Starting-and-stopping-a-process" class="headerlink" title="Starting and stopping a process"></a>Starting and stopping a process</h2><ul><li>所有的进程都是由其他进程发起的</li><li><code>init</code>进程是直接由内核产生，一般来说ID是1</li><li>进程的退出<ul><li>自己执行完毕以后退出</li><li>其他的进程发出了信号要结束这个进程</li></ul></li></ul><h2 id="login-process-environment"><a href="#login-process-environment" class="headerlink" title="login process environment"></a>login process environment</h2><p>输入用户名以后，这个用户名会作为<code>login</code>程序的传入参数，在去请求这个参数的对应密码，在去查看和用户输入的是否一致。</p><h2 id="Monitoring-the-processes"><a href="#Monitoring-the-processes" class="headerlink" title="Monitoring the processes"></a>Monitoring the processes</h2><p>输入:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps</span><br></pre></td></tr></table></figure><p>来输出进程的状态信息。</p><p>有三个可选参数：</p><p>- <strong>a:</strong> All processes sttached to a terminal</p><p>- <strong>x:</strong> All other processes</p><p>- <strong>u:</strong> Provide more columns</p><p><img src="/09-working-with-processes/index/1.2.png"></p><h2 id="Viewing-processes-hierarchy"><a href="#Viewing-processes-hierarchy" class="headerlink" title="Viewing processes hierarchy"></a>Viewing processes hierarchy</h2><p>输入:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pstree</span><br></pre></td></tr></table></figure><p>来显示进程层次。</p><p><img src="/09-working-with-processes/index/1.3.png"></p><h2 id="Starting-processes"><a href="#Starting-processes" class="headerlink" title="Starting processes"></a>Starting processes</h2><ul><li><p>Foreround processes</p><ul><li>they are invoked by typing a command at the command line:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find / -name README </span><br></pre></td></tr></table></figure><p><img src="/09-working-with-processes/index/1.4.png"></p></li><li><p>Background processes</p><ul><li>they are invoked by putting an ampersand(&amp;) at the end of the command line:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find / -name README &amp;</span><br></pre></td></tr></table></figure><p><img src="/09-working-with-processes/index/1.5.png"></p></li></ul><p><img src="/09-working-with-processes/index/1.6.png"></p><p>创建完后台进程以后会有：</p><p>[1] 2320</p><p>- [1]: 这是在后台运行的第一个进程</p><p>- 2320: 这个进程的ID</p><h2 id="Job-control-in-the-bash-shell"><a href="#Job-control-in-the-bash-shell" class="headerlink" title="Job control in the bash shell"></a>Job control in the bash shell</h2><p>- <strong><Ctrl - z>:</Ctrl></strong> Suspend the foreground task</p><p>​        does not kill a process but suspend it , so you can subsequently restart it.</p><p>- <strong>jobs:</strong> Lists background or suspended jobs</p><p>- <strong>fg:</strong> Resume suspended task in the foreground</p><p>- <strong>bg:</strong> Resume suspended task in the background</p><p>- Specify a job number for bg, fg, and kill using <code>%job</code></p><p>​        kill job number 3 : <code>kill %3</code></p><p>【<strong>EXAMPLE</strong>】</p><p><img src="/09-working-with-processes/index/1.7.png"></p><h2 id="Kill-signals"><a href="#Kill-signals" class="headerlink" title="Kill signals"></a>Kill signals</h2><ul><li>Using the kill command:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">kill</span> -signal PID</span><br></pre></td></tr></table></figure><ul><li>Using the killall command to kill all named apps:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ killall -signal application</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center">Signal</th><th style="text-align:center">Keyboard</th><th style="text-align:center">Meaning</th><th style="text-align:center">Default action</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">01</td><td style="text-align:center"></td><td style="text-align:center">Hangup</td><td style="text-align:center">End process</td><td style="text-align:center">send to a process when its parent die(log off acciddently)</td></tr><tr><td style="text-align:center">02</td><td style="text-align:center">Ctrl - C</td><td style="text-align:center">Interrupted</td><td style="text-align:center">End process</td><td style="text-align:center">user presses the interrup key “Ctrl -C”</td></tr><tr><td style="text-align:center">03</td><td style="text-align:center">Ctrl - \</td><td style="text-align:center">Quit</td><td style="text-align:center">End process and core dump</td><td style="text-align:center">Nope</td></tr><tr><td style="text-align:center">09</td><td style="text-align:center"></td><td style="text-align:center">Kill</td><td style="text-align:center">End process - cannot be redifined - handled by kernal</td><td style="text-align:center">die immediately</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center"></td><td style="text-align:center">Terminate</td><td style="text-align:center">End process</td><td style="text-align:center">the most used</td></tr></tbody></table></div><ul><li><p>difference between singal 02 and 03:</p><p>signal 03 by default generate a ‘core dump’(A <a href="https://en.wikipedia.org/wiki/Core_dump">core dump</a> is a file containing a process’s address space (memory) when the process terminates unexpectedly. )</p></li></ul><h2 id="Running-long-processes"><a href="#Running-long-processes" class="headerlink" title="Running long processes"></a>Running long processes</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nohup find / -name README &amp;</span><br></pre></td></tr></table></figure><ul><li>告诉进程忽略01和03信号的中断。即使你登出了系统也能够让程序继续运行</li><li>由于所有的进程都要和他的父进程有所联系，所以使用这个以后，该进程会以<code>init</code>作为他的父进程</li></ul><h2 id="The-nice-command"><a href="#The-nice-command" class="headerlink" title="The nice command"></a>The nice command</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nice [-n &lt;value&gt;] &lt;original <span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure><ul><li>used to start a process with a user-defined priority</li></ul><p><img src="/09-working-with-processes/index/1.8.png"></p><ul><li>Only root can set negative number</li></ul><h2 id="The-renice-command"><a href="#The-renice-command" class="headerlink" title="The renice command"></a>The renice command</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ renice &lt;new_priority&gt; &lt;PID&gt;</span><br></pre></td></tr></table></figure><ul><li>used to change the priority of a <strong>running</strong> process</li></ul><p><img src="/09-working-with-processes/index/1.9.png"></p><h2 id="Daemons-后台驻留进程"><a href="#Daemons-后台驻留进程" class="headerlink" title="Daemons(后台驻留进程)"></a>Daemons(后台驻留进程)</h2><ul><li>这是一个不会停止的进程，从开机开始运行，一直到关机为止</li><li>用来控制计算机系统资源，比如打印机队列</li></ul><h2 id="Unit-Review"><a href="#Unit-Review" class="headerlink" title="Unit Review"></a>Unit Review</h2><ul><li>All processes are started by a parent process (except for init, which is started by the kernel).</li><li>Every process is identified with a process identifier (PID).</li><li>A special process is the shell, which can interpret user commands.</li><li>Processes can terminate by themselves or upon reception of a signal.</li><li>Signals can be sent by the shell, using a keyboard sequence, or by the <strong>kill</strong> and <strong>killall</strong> commands.</li><li>Processes are started with equal priority, but this can be changed using the <strong>nice</strong> and <strong>renice</strong> commands.</li><li>A daemon is a background process that typically controls a system resource or offers a network service.</li></ul><h2 id="Checkpoint"><a href="#Checkpoint" class="headerlink" title="Checkpoint"></a>Checkpoint</h2><ol><li>True or False: Any user can send a signal to a process of another user and cause that process to halt.</li></ol>   <font color="#0000ff" size="3">The answer is false. A normal user will not have the appropriate permission to send signals to another user's processes. The rootuser does have permission to do this.</font><ol><li><p>If a process is hanging, the proper order of trying to terminateit with the lowest chance of data corruption is:</p><ul><li><p>a.kill -1, <Ctrl-C>, kill, <Ctrl-\></Ctrl-\></Ctrl-C></p></li><li><p>b.<Ctrl-Z>, kill, kill -9, kill -15, <Ctrl-C></Ctrl-C></Ctrl-Z></p></li><li><p>c.kill -9, kill -15, <Ctrl-C>, <Ctrl-Z></Ctrl-Z></Ctrl-C></p></li><li><p>d.<Ctrl-C>, <Ctrl-\>, kill, kill -9</Ctrl-\></Ctrl-C></p><font color="#0000ff" size="3">The answer is <Ctrl-C>, <Ctrl-\>, kill, kill -9. kill -9 is always the last resort.</Ctrl-\></Ctrl-C></font></li></ul></li><li><p>What is a daemon?</p><font color="#0000ff" size="3">The answer is a daemon is a never-ending process which provides a system service.</font></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【哈佛公开课】Justice</title>
      <link href="/%E3%80%90%E5%93%88%E4%BD%9B%E5%85%AC%E5%BC%80%E8%AF%BE%E3%80%91justice/index.html"/>
      <url>/%E3%80%90%E5%93%88%E4%BD%9B%E5%85%AC%E5%BC%80%E8%AF%BE%E3%80%91justice/index.html</url>
      
        <content type="html"><![CDATA[<p>这是视频课程笔记，视频<a href="https://www.bilibili.com/video/BV1ct4y167fM?from=search&amp;seid=3357852860603414968&amp;spm_id_from=333.337.0.0">链接</a></p><h2 id="01-杀人的道德侧面-amp-同类自残案"><a href="#01-杀人的道德侧面-amp-同类自残案" class="headerlink" title="01 杀人的道德侧面&amp;同类自残案"></a>01 杀人的道德侧面&amp;同类自残案</h2><p><strong><font size="4">电车难题1</font></strong></p><p>你是电车司机，刹车坏了，转向会杀死一个人，不转向会杀死五个人，你会怎么做？</p><p>【转向：】杀死一个人比杀死五个人好</p><p><strong><font size="4">电车难题2</font></strong></p><p>你是旁观者，看到一个人在桥上，桥上有一个胖子，你可以把他推下去，这样他会死，但是能够救五个人，你会怎么做？</p><p>【与第一个case不同的地方】事实上好像没有什么是不同的。你掌握的主动权，可以选择杀一个还是五个。无论是推人还是转向，你都是选择杀了一个人。</p><p><strong><font size="4">电车难题3</font></strong></p><p>你是一个医生，现在有一个重症患者，五个轻症患者。救重症患者会让他活，但是五个会死，你会怎么做？</p><p>【救五个人】</p><p><strong><font size="4">电车难题4</font></strong></p><p>你是一个医生，5个人要做移植手术，但是没有符合的人选，但是在这是，有一个健康人来体检，你可以杀了他来救五个人，你会怎么做？</p><p>【不会杀】</p><p>&gt;</p><p><strong><font size="4">体现出的原则</font></strong></p><ol><li><p>结果主义道德理论</p><blockquote><p>结果主义认为，行为的道德地位(强制性的、允许的或错误的)总是取决于行为的总体结果。</p></blockquote><ul><li>典例：功利主义</li></ul></li><li><p>绝对主义道德理论</p><ul><li>典例：18世纪 <strong>Immanuel kart</strong></li></ul></li></ol><p><strong>让熟悉的变成陌生的</strong></p><p><strong><font size="4">海难问题</font></strong></p><p>4个人在船上，船翻了，在19天没有进食以后，最后三个人杀死了一个最弱的见习船员得救了，这样做对吗？</p><p>【引出的问题】</p><ol><li><p>我们时候又基本的权力？</p></li><li><p>一个公平的程序（抓阄决定生死）是否会让结果正义化？</p></li><li><p>“征得同意”（见习船员同意被杀）在道德判断上起了什么作用？</p></li></ol><h2 id="02-为生命贴上价格标签-amp-如何衡量快乐"><a href="#02-为生命贴上价格标签-amp-如何衡量快乐" class="headerlink" title="02 为生命贴上价格标签&amp;如何衡量快乐"></a>02 为生命贴上价格标签&amp;如何衡量快乐</h2><ul><li><p>边沁的功利主义</p><ul><li>内容：道德的最高原则就是大众福利和集体幸福最大化&amp;在痛苦和快乐之间寻找平衡点（<strong>效用最大化</strong>）</li><li>由来：边沁认为人都是由快乐和痛苦所支配的，所以所有的道德系统要把他们考虑进去。如何都考虑到？就是<strong>幸福/效益最大化</strong>（追求多数人的最大效益）。</li><li>逻辑：对事物附上价值</li></ul></li><li><p>捷克共和国的吸烟案例：<br>|      成本      |    效益    |<br>| :——————: | :————: |<br>| 医疗成本的增加 | 香烟的税收 |<br>|  |过早死去不用付养老金|<br>| |节省房屋成本|</p><p>结论是政府的公共财政增加了1.47亿美元，在个人上节省了1200美元。</p></li></ul><p>​    <strong>在这个案例中有一个严重的问题：没有将人的生命价值考虑进去！</strong></p><ul><li><p><a href="https://wiki.mbalib.com/wiki/%E7%A6%8F%E7%89%B9%E5%B9%B3%E6%89%98%E8%BD%A6%E6%A1%88">Ford Pinto案例</a></p><p>| 成本                                  | 效益                                |<br>| ——————————————————- | —————————————————- |<br>| 11美元 * 12.5million的车 = 1.37亿美元 | 每年所有由于车祸要付的钱49.5million |</p><p>上述案例将人的生命价值考虑了进去，但是依然被人们所诟病。</p></li><li><p>讨论</p><ul><li>同学A：我们不应该用金钱来衡量人的生命价值，失去亲人失去的不仅仅是收入还有情感纽带</li><li>同学B：人的生命可以用金钱来衡量，但是要考虑通货膨胀，所以不能给出具体的数字。</li><li>同学C：公司不会盈利如果不考虑成本效益，不会盈利。</li><li>同学D：反对功利主义。因为没有考虑少数人的利益。比如上一讲中那个被吃掉的男孩，因为他存活的概率小就不考虑。</li><li>同学E：-&gt;D. 在特定的时间节点，如果必要做出选择，就要牺牲少数人的利益。 </li><li>老师：古罗马，人们会将基督教人扔进斗兽场。少数人（被扔进斗兽场的人）很痛苦，但是围观的人很快乐。假设围观的人很多，快乐远远超过了少数人的痛苦。</li></ul></li><li><p><strong>对功利主义两种反对的意见</strong></p><ul><li>没有考虑少数人的想法与价值</li><li>不能够将所有的价值都标上价格，不能考虑到所有的因素，比如价值和道德因素。<ul><li>不能用统一的金钱量度来衡量</li><li>可以尝试的区分高级的和低级的快乐</li></ul></li></ul></li><li><p>边沁的功利主义的特点：只考虑到了快乐或痛苦的程度大小和持续长短。</p><ul><li><strong>“快乐不分多少，图钉和诗一样美好”</strong></li></ul></li><li><p>密尔对边沁的功利主义进行了完善</p><ul><li>效用是衡量功利主义的唯一标准，但是快乐可以被区别为高级和低级的。</li><li>如何区别高级和低级的快乐？<ul><li>把低级和高级的快乐都体验一遍，人们会自然喜欢高级的快乐。</li></ul></li></ul></li><li><p>密尔的功利主义：人们要经过学习和教育才能够体会到更加高级的快乐，而且当人们一旦经过了教育和学习以后，大多数人会偏爱更加高级的快乐。</p></li></ul><h2 id="03-Free-to-Champ-amp-Who-owns-me"><a href="#03-Free-to-Champ-amp-Who-owns-me" class="headerlink" title="03 Free to Champ &amp; Who owns me"></a>03 Free to Champ &amp; Who owns me</h2><ul><li>自由主义：个人的基本权力是自由。不能简单的将所有人的偏好加起来</li><li>三件自由主义认为是不合理的但是国家都会做的：<ul><li>家长式立法：系安全带，戴头盔</li><li>道德立法：同性恋，认为不道德就禁止</li><li>收入再分配：税收（这个不是很懂，可能没有理解）<ul><li>钱的来源是否公正</li><li>被财产再分配的人是否自愿</li></ul></li><li>自由主义认为：税收 = 拿走别人的收入 = 强迫劳动 = 奴役</li></ul></li><li>自由主义的根本原则：自己能够支配自己，<strong>我属于我自己</strong><ul><li>所以用健康人去救5个人是不对的，因为我们属于我自己，而不是社会。如果一个个体属于社会，那么用一个健康人的器官去救5个人是没有问题的，但是事实上，我们属于我们自己。</li></ul></li></ul><h2 id="04-The-land-is-mine-amp-Consenting-adults"><a href="#04-The-land-is-mine-amp-Consenting-adults" class="headerlink" title="04 The land is mine &amp; Consenting adults"></a>04 The land is mine &amp; Consenting adults</h2><ul><li>Jhon Locke(约翰 洛克)</li><li>他是半个自由主义者<ul><li>同意大多数的的自由主义者，基本权力的不可剥夺性</li><li>他还认为这些基本权力包括了自然权利（财产权，自由权）</li></ul></li><li>要知道自然权利，要想象政府出现前世界万物的样子<ul><li>自然状态是一种自由状态，人生来平等，没有阶级</li></ul></li><li>自然状态也是有法律的—自然法则。它限制了我们，哪怕我们是自由人。<ul><li>自然法则对我们的唯一约束就是：<em>*我们不能放弃这些权力，也不能从他人身上夺取</em></li><li>即使我是自由的，也不能放弃这些权力，也不能抢夺他人的，<strong>（不能违背自然法则）</strong></li><li>这种自然状态从何而来？<ul><li>第一种解释：人们都从属于上帝</li><li>第二种：没有从视频中听到</li></ul></li></ul></li><li>洛克的私有财产理论：只要我们在这个无主土地上有贡献，土地也属于我们。比如开垦了荒地，地上种的粮食是我的，土地也是我的。</li><li>洛克的 consent 起源: 在自然状态下，所有人都是自己的法官，当一个人违反了自然法则，侵犯了他人生命，自由或者财产，你就可以杀死那个人。但是在这种状态下，人们会失去理智，所以人们脱离这种自然状态的唯一方法就是：<strong>同意放弃“执行权”，然后建立一个政府和社区，由他们来建立法律，并且每一个进入这个社区的人都实现同意服从大多数人的决定</strong> </li><li>即使人们进入了政府，但是也不能放弃自然权利。那为什么政府就能让我们交税（财产），服兵役（生命）？<ul><li>洛克认为，政府不能是专制的，不能挑选特定的人来胶水和服兵役。但是，如果政府有一个general law, 来（随机）选择，这就不算对于个人权力的侵犯。</li></ul></li></ul><h2 id="05-Hired-Guns-amp-For-Sale-Motherhood"><a href="#05-Hired-Guns-amp-For-Sale-Motherhood" class="headerlink" title="05 Hired Guns &amp; For Sale Motherhood"></a>05 Hired Guns &amp; For Sale Motherhood</h2><ul><li>自然状态中的生命权<ul><li>政府是否有权去征兵</li><li>洛克认为，政府有权利强制征兵，他只在乎政府是否是专制的。</li><li>他认为，人们进入了政府就已经同意了在享受政府的福利的同时也自愿接受政府的一些约束</li></ul></li><li>通过<strong>征兵</strong>来讨论<strong>同意</strong><ul><li>有人认为，我们自我拥有，有人则认为这是政府的合法权力</li><li>美军攻打伊拉克难征兵，三种方法<ul><li>增加工资和福利</li><li>改用抽签制</li><li>军事外包</li></ul></li><li>内战的时候，联邦采用抽签和军事外包。如果被抽中但是不想去，可以花钱找人顶替。</li><li>内战的征兵政策和现代的志愿军征兵同样都带有强制的感觉，到底有什么区别呢？</li></ul></li><li>代孕是否正确？<ul><li>按照合同来：交易就是交易</li><li><strong>反对按照合同来</strong>：缺乏信息（代孕者不知道自己对于孩子的情感的变化）、无人性。</li></ul></li></ul><h2 id="06-Mind-your-Motiv-amp-The-Supreme-Principle-of-Morality"><a href="#06-Mind-your-Motiv-amp-The-Supreme-Principle-of-Morality" class="headerlink" title="06 Mind your Motiv &amp; The Supreme Principle of Morality"></a>06 Mind your Motiv &amp; The Supreme Principle of Morality</h2><blockquote><p>义务论的观点本质上是反功利主义的，即义务论认为至少有时我们有义务以不会带来最好结果的方式行事。</p></blockquote><ul><li>讨论康德</li><li>为什么我们有尊重个人尊严的绝对义务，即使是出于好意也不能利用他人。</li><li>康德反对功利主义，他认为，每个个体都有一定的尊严,每个人都要尊重。</li><li>在康德看来，个体神圣不可侵犯不是来源于， <strong>我们拥有我们自己</strong>， 而是 <strong>我们都是理性的人</strong>。</li><li>康德同意功利主义的部分观点：我们都会趋利避害。他反对的是边沁的理论：快乐和痛苦是人类至高无上的主宰。</li><li>康德认为是我们的 <strong>理性</strong> 使得我们变得与众不同，不再只是欲望的集合体。</li><li>一般人认为，自由就是指，我们按照自己的意愿行事，或者没有障碍的得到我们想要的。</li><li>而康德认为，当我们像动物一样趋乐避苦，满足欲望的的时候，我们不知真正的自由。这时候，我们成为了欲望的 <strong>奴隶</strong>。我们没有可以的选择满足哪一个欲望，我们满足它只是出于本能。</li><li>康德对于自由的定义十分苛刻。act freely = act autonomously = to act according a law I gave to myself. 而不是根据某一种因果关系去做（比如吃的欲望等等）<ul><li>康德对于这种自由的定义更像是一种自律，（根据自己指定的计划完成）。他自己创造了一个与之对立的单词，也就是<strong>他律</strong>。指的就是我根据的是欲望做出的选择，而不是自己自主选择的。</li><li>所以当我们为了爱好或者快乐去行动的时候，个体成为了<strong>实现外来目的</strong>的一种手段，这个时候我们就成为了工具。而当我们以自己指定的法则去行动的时候，我们是出于目的本身去行动的，也就是自主行动，<strong>我们本身就成为了目的</strong>。康德认为，正是这种自由行动的能力赋予了人类特殊的尊严。</li><li>这里可以回答之前的一个例子，把基督教徒扔到斗兽场和师子搏斗，从而使看表演的人感到兴奋高兴，以此来得到功利最大化是不对的。因为这是把基督教徒这个个体当作了一种工具和手段，而没有尊重他。</li></ul></li><li>康德对于<strong>道德</strong>的定义：所以行为的道德价值取决于动机，个体要基于好的动机去完成好的事情。</li><li>康德认为正是动机赋予了行为以道德价值。</li><li><strong>一个例子</strong><ul><li>有一个店家，可以少给一个顾客找零而且不被发现，但是他担心被其他人知道以后自己臭名远扬，所以还是给了正确的钱数，这样的行为是否具有道德价值？<ul><li>不具有，因为 <strong>通过错误的原因做了正确的事</strong></li><li>所以说 <strong>动机</strong> 赋予了道德价值</li></ul></li></ul></li><li>康德的基本理论包含两个问题<ul><li>什么才是道德的最高原则</li><li>如何自由</li></ul></li></ul><h2 id="07-有关谎言的一课-amp-A-deal-is-a-deal"><a href="#07-有关谎言的一课-amp-A-deal-is-a-deal" class="headerlink" title="07 有关谎言的一课 &amp; A deal is a deal"></a>07 有关谎言的一课 &amp; A deal is a deal</h2><ul><li><p>自律和义务看似对立，康德是怎么认为的？履行义务高尚在哪里？</p><p>康德认为人不是由于遵守法则而显得崇高，而是我遵守的法则是我自己选择的，自愿服从的。从这一点上看，自律和履行义务是高度一致的，相互等价。</p></li><li><p>到底有多少道德法则，如果高尚源于遵守为自己制定的法则，那么如何保证我的道德心和你的一样？</p><p>康德认为，如果我们出于自己的道德心，自由的选择道德法则，那么一定会得到相同的道德心。因为当我们选择的时候，并不是我在选择，也不是你，而是理性——<strong>纯粹的理性</strong>在选择。</p></li><li><p>纯粹的理性是不受外界的条件影响的。所以当我们在选择道德法则的时候，理性会支配意志。由于这些<em>理性</em>都是纯粹的理性，所以大家选择出来的道德法则也是一样的。这叫做<strong>绝对命令</strong>。</p></li><li><p>绝对命令是怎么存在的？</p><p>康德说，我们要区别两种解释人类体验的两种观点。</p><ol><li>作为体验的客体，我属于感观世界，我的行为受到自然法则（满足自己的感观）的约束。</li><li>作为体验的主体，我属于理智世界，在此，我独立于自然法则，我可以按照自己制定的法则来行动。</li></ol><p>只有当第二种论点成立的时候，我们才是自由，因为自由就是不受到感观世界的约束。当我受到感观世界的约束的时候，我们会去选择满足自己的感观（欲望），在这种情况下，我们的意志都伴随着对于某种选择的渴望，意志被感性所主导。康德说，当我们说自己是自由的时候，我们就上升到了理性世界，并且意识到了意志的自主性。所以，绝对命令能实现是因为而且也只能是因为，自由让我成为了智思世界的一员。</p><p>康德认为，人不仅仅是理性世界的一员，因为，如果我们如果人们只是属于理性的世界，那么我们所有的行为都会和自主意志是一致的，而正是由于我们从属于两个世界，自由世界和需求世界，我们所“做”的和我们“应该做”的。康德得出，道德和经验主意是不一样的，人们对于科学的发现不能解决道德上的问题。</p><p>举一个例子：门外凶手的例子。康德认为人们不应该说谎，因为谎言不符合绝对命令。法国哲学家本杰明•康斯坦特写了一篇文章来回应《道德的形而上学基础》，他写道： “这个设想是错的,不可能是对的。如果有一个杀手来到你的门前，寻找你的朋友，而这位朋友正躲在你家里，杀手问你，’你的朋友在你家么？’如果在这样的情况中，还要说真话那真是疯了。”</p><p>康德认为即使对上门的凶手撒谎也是不对的。他解释，当你已经开始考虑事件的后果的时候，试图找出绝对命令的例外，你就已经放弃了整个道德框架，成为了一个结果主义者或者是规则功利主义者。大多数人会不赞同这个想法。教授试图从康德的道德理论来为康德边界。</p></li><li><p>直接的谎言和具有误导性的实话存在道德上的差异吗？</p><p>康德认为两者在道德上是有差异的，尽管这些可能会带来相同的后果。但是康德的道德观不重视结果，而是重视是否坚守了道德法则。康德不会赞同善意的谎言，但是也许会赞同具有误导性的实话。与谎言不同，具有误导性的话语仍然是服从于义务的，由此，即使是具有误导性的事实也是道德的。</p><p>是的，我是希望他人被误导。<strong>我是希望杀手走出马路或者去商场找我的朋友而不是在衣柜里，我是希望起到这样的效果。我无法控制它的后果，但我可以控制的是，不管结果怎样，我都会站在道德这边并尊重它。</strong></p></li></ul><hr><ul><li><p>康德认为公正的法律出自于一种特定的社会契约，这种契约的性质很特殊，因为这不是真正意义上的契约。 这种产生公正的契约，是他所说的理性概念，而不是有人们聚集在一起商量出来的。他认为，那些真实存在的人们有着不同的利益，价值观和目标，有他们产生的契约也就未必公正，未必完全遵从正义的原则。</p></li><li><p>约翰罗尔斯，在他的书《正义论》中阐释了一个作为正义基础的假定协议，他的正义论和康德的理论在两点上高度重合。第一是，罗尔斯批判功利主义，他说，基于公正，每个人的权力都是圣神的，即使是全社会的福利也不能比拟。由正义所保护的权力不能被政治协商和社会利益所左右。第二个是，正义的原则源自于假定的社会契约。并且提出了“无知之幕”来解释他的理论。</p></li><li><p>无知之幕：假象把人们聚集在一起，来商量出指导我们集体生活的正义原则，由于人们不同的利益，会出现很多不同的声音，由强势的，弱势的，贫穷的富有的。罗尔斯提议，假设我们都处在公平的原始状态，而确保平等的，就是无知之幕。在无知之幕下，大家都不会知道自己的角色，种族阶级地位等等。这个时候达到的原则菜是正义的。</p></li><li><p>实际约束对人又怎样的约束和强制作用？</p><p>首先实际契约中的内容不全是的正义的。比如美国曾经有法律允许奴隶的存在，这不代表这儿是正义的。</p><p>实际约束的强制性体现在两个方面：</p><ol><li>自愿的积极同意，默认接收了义务，这包含着独立于其他因素的道德力量。 </li><li>实际契约是实现互惠互利的工具，只要你为我做了事，我对你就有义务。</li></ol></li><li><p>实际契约的道德力量借助于两个不同的理念，自律和互惠。但在现实生活中，每个真实契约都可能没在建立之初赋予道德约束力，因为各方谈判的势力可能是不均衡的，自律的理念就会没有实现；因为各方的知识上可能存在差距，互惠的理念就会没有实现。因此，他们对于什么是真正的相等价值就会存在分歧。</p><p>现在，想象一种契约，它的各方在权力和知识上是平等的，而非不等的；他们的地位是相同的，而非不同的。这就是<strong>罗尔斯的正义观念背后的理论：思考正义的方法就是，站在一个假想契约的角度，站在“不可知面纱”的背后，通过排除，或者使我们暂时忘记，会导致不公平的结果的诸如权力和知识的差距，创造平等的条件。</strong> 这就是为什么对康德和罗尔斯来说一个各方平等的假想契约是思考正义原则的唯一途径。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PA1实验报告</title>
      <link href="/pa1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/index.html"/>
      <url>/pa1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="实验进度"><a href="#实验进度" class="headerlink" title="实验进度"></a>实验进度</h2><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">是否已完成</th></tr></thead><tbody><tr><td style="text-align:center">必做任务1</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">必做任务2</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">必做任务3</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">必做任务4</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">必做任务5</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">必做任务6</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">必做任务7</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">选做任务1</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">选做任务2</td><td style="text-align:center">√</td></tr></tbody></table></div><h3 id="实验前的准备"><a href="#实验前的准备" class="headerlink" title="实验前的准备"></a>实验前的准备</h3><p>【<strong>2020.9.25</strong>】</p><p>完成了<strong>PA0</strong>实验指导书的内容，熟悉了  在<code>Linux</code> 环境下进行实验的基本流程</p><p>【<strong>2020.9.26</strong>】</p><ul><li><p>发现实验平台有点卡顿，所以<strong>自己尝试着配置</strong>了与实验环境一样的虚拟机实验环境来完成实验。</p></li><li><p>由于使用到<code>GitHub</code>的仓库操作，所以查看的相关资料和网站<strong>学习了远程和本地仓库之间的连接</strong>。</p></li></ul><p>【<strong>2020.9.28</strong>】</p><ul><li>跟着<strong>PA0</strong>实验指导书，熟悉了<code>vim</code>的基本使用。</li><li>跟着B站视频，学习了<code>tmux</code>和<code>ctags</code>的基本使用方法。</li></ul><hr><h3 id="实验开始"><a href="#实验开始" class="headerlink" title="实验开始"></a>实验开始</h3><p>【<strong>2020.9.29</strong>】</p><p>跟着<strong>PA1</strong>实验指导书完成了源代码的阅读，配合<code>tmux</code>的快捷键<code>ctrl + ]</code>, <code>ctrl + t</code>大致了解了<code>nemu/src/main.c</code>的代码框架。</p><p>【<strong>2020.9.30</strong>】</p><ul><li><p><strong>实现正确的寄存器存储结构</strong></p><p>寄存器在物理结构是不是相互独立的，而是互用部分内存。</p><ul><li><p><code>union</code>和<code>struct</code>的区别</p><p><code>struct</code>会对其中定义的所有变量都分配内存空间，而是用<code>union</code>只会分配一块内存空间，大小是变量中所需空间的最大空间。和寄存器的结构十分符合。</p></li><li><p>将原来的<code>struct</code>改成<code>union</code>。</p></li><li><p>由于<code>uint32_t</code>,<code>uint16_t</code>,<code>uint8_t</code>是同一个寄存器的不同部分，所以采用<code>unioin</code>将他们定义。</p></li><li><p>考虑到要公用同一块空间的8个寄存器要和空间一一对应，所以采用<code>struct</code>将他们定义。</p></li></ul></li><li><p>考虑到之后的实验的不确定性，学习了<code>git</code>的分支管理操作（点击<a href="https://www.runoob.com/git/git-branch.html">这里</a>查看<code>git</code>相关操作）。</p></li></ul><p>【<strong>2020.10.2</strong>】</p><ul><li>重置了工程文件，新建了分支<code>PA1</code>。</li><li><p><strong>单步执行</strong></p><ul><li>核心就是将输入的指令字符串做分割。将命令在<code>cmd_table[]</code>中做查找，然后执行相应次数的<code>cpu_exec()</code>。</li><li>熟悉<code>sscanf()</code>,<code>strtok()</code>函数的使用。</li><li>要求是当没有输入步数是，缺省值是1，所以要先使用<code>strtok()</code>看看是否有步数的输入，做<code>if</code>判断。之后再使用<code>sscanf()</code>从字符串读入格式化的内容。</li><li><p><strong>注意：</strong></p><ul><li>要在<code>cmd_table</code>中加入相关的命令。</li><li><p><strong>加入<code>if</code>语句对于输入指令格式的判定。</strong></p><ul><li><p>比正确格式多了，少了，配对不匹配</p><p><img src="/pa1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/index/1.4.png"></p></li></ul></li></ul></li></ul></li></ul><p>【<strong>2020.10.3</strong>】</p><ul><li><p><strong>打印寄存器</strong></p><ul><li>这个和单步执行差不多，不在赘述。</li><li><p><strong>要注意的是</strong></p><ul><li>键入的是<code>info r</code>所以还是要对它做字符串的拆分，和<code>r</code>配对了执行。</li><li>还有一个<code>eip</code>寄存器。</li><li><p><strong>加入<code>if</code>语句对于输入指令格式的判定。</strong></p><ul><li><p>比正确格式多了，少了，配对不匹配</p><p><img src="/pa1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/index/1.5.png"></p></li></ul></li></ul></li></ul></li><li><p><strong>扫描内存</strong></p><ul><li><p>传入的参数格式是<code>[x N EXPR]</code></p><ul><li><p>注意结合使用<code>if</code>语句和<code>strtok()</code>函数来判断输入的格式是否正确。</p><p><img src="/pa1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/index/1.6.png"></p></li></ul></li><li><p>使用<code>strtok()</code>和<code>sscanf()</code>函数得到对应的<code>N</code>和<code>EXPR</code>的值，使用<code>swaddr_read()</code>函数一次读取4个字节的内存，将其打印出来。</p></li></ul></li></ul><p>【<strong>2020.10.4</strong>】</p><ul><li>学习正则表达式</li><li>读懂任务指导书求表达式这一部分</li></ul><p>【<strong>2020.10.5</strong>】</p><ul><li><strong>表达式求值</strong><ul><li>使用正则表达式添加词法分析的规则</li><li>对输入的表达式进行遍历，根据自己定义的词法分析规则去分析表达式中的<code>tokens</code>，再使用<code>strncpy()</code>函数将<code>tokens</code>存入对应的数组中。</li><li>实现<code>check_parentheses()</code>,<code>dominant_operator()</code>函数的实现。</li><li>实现单目运算符<code>!</code>,<code>-</code>,<code>*</code>的计算<ul><li>对于<code>!</code> ：由于<code>!</code>是在规则中指定的，并且没有可能被区别为其他的运算符，所以对于<code>!</code>来说，只要使用<code>dominant_operator()</code>是，只要返回的操作符的索引是表示左边界的形参，说明是单目运算符。</li><li>对于<code>-</code>和<code>*</code>：由于，这两个符号还有其他的含义 ：乘以及减。所以需要在<code>eval()</code>中识别出来，改变他们的<code>priority</code>,<code>token_type</code>。接下来思路和<code>!</code>是一样的。</li></ul></li><li>寄存器的计算<ul><li>要区别32位，16位和8位的寄存器，分别计算。</li><li>寄存器在存储进<code>token，str[]</code>中，要注意移除<code>$</code>。</li></ul></li></ul></li></ul><p>【<strong>2020.10.7</strong>】</p><ul><li>实现<code>free_wp()</code>和<code>new_wp()</code>两个函数。<ul><li>这两个函数就是简单的链表操作。加上对于传入参数是否非法的判断。</li></ul></li></ul><p>【<strong>2020.10.8</strong>】</p><ul><li>完成了监视点的操作。</li></ul><hr><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="思考题1"><a href="#思考题1" class="headerlink" title="思考题1"></a><font color="#ff0000" size="3">思考题1</font></h3><p><strong>问：</strong> <code>opcode_table</code>到底是一个什么类型的数组？</p><p><strong>答：</strong><code>opcode_table</code>是一个函数指针数组，其中包含多条指令和它们对应的某种形式。</p><h3 id="思考题2-1"><a href="#思考题2-1" class="headerlink" title="思考题2.1"></a><font color="#ff0000" size="3">思考题2.1</font></h3><p><strong>问：</strong>在<code>cmd_c()</code>函数中，调用<code>cpu_exec()</code>的时候传入了参数<strong>-1</strong>，你知道这是为什么吗？</p><p><strong>答：</strong></p><p><img src="/pa1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/index/1.1.png"></p><p>上图中，函数<code>cpu_exec()</code>的参数是<code>uint32_t</code>类型，也就是32位的<strong>无符号</strong>整型，当参数是<strong>-1</strong>的时候，由于<strong>-1</strong>的二进制编码是<code>0xffff</code>，<strong>-1</strong>会被函数认为是32位中的最大整数，所以会一直循环下取，指导完成所有指令。</p><h3 id="思考题2-2"><a href="#思考题2-2" class="headerlink" title="思考题2.2"></a><font color="#ff0000" size="3">思考题2.2</font></h3><p><strong>问：</strong>框架代码中定义<code>wp_pool</code>等变量的时候使用了关键字<code>static</code>, <code>static</code>在此处的含义是什么? 为什么要在此处使用它?</p><p><strong>答：</strong><code>static</code>是静态的意思，用在函数上，是指编译过程中进行链接时由<code>static</code>修饰的变量不参与与外部文件的链接。只有在这个文件中的函数才能够调用函数，保证了数据的安全和稳定，有点类似于面向对象的思想。</p><h3 id="思考题3"><a href="#思考题3" class="headerlink" title="思考题3"></a><font color="#ff0000" size="3">思考题3</font></h3><font color="#00ff6f" size="3">3.1 查阅i386手册</font><p><strong>问：</strong><code>EFLAGS</code> 寄存器中的 <code>CF</code>位是什么意思 ?</p><p><strong>答：</strong>查阅i386手册P33-P34，2.3.4节有关<code>EFLAGS</code>寄存器的部分。EFLAGS中的CF位是carry flag的意思，在最高位发生进位或者借位时置为1，否则置为0。</p><p><strong>问：</strong><code>ModR/M</code>字节是什么 ?</p><p><strong>答：</strong>P241，<code>17.2.1</code>小节。P40，<code>2.5.3.2</code>小节。<code>ModR/M</code>由<code>mod</code>，<code>reg/opcode</code>，<code>r/m</code>组成。<code>mod</code>字段占字节的两个最高有效位。<code>reg</code>字段占字节的3至5位，它指定一个寄存器的编号或者三位操作码。<code>r/m</code>占字节的后三位，可以与<code>mod</code>结合起来得到32个可能值，8个寄存器和24个内存寻址。这在PA2中有涉及到。</p><p><strong>问：</strong><code>mov</code> 指令的 具体格式是怎么样?</p><p><strong>答：</strong>P45， <code>3.1</code>小节。</p><font color="#00ff6f" size="3">3.2 Shell文件</font><p><strong>问：</strong>如何查看命令行数？</p><p><strong>答：</strong></p><p><code>find . -name &quot;*[.h|.cpp]&quot; | xargs wc -l</code> 可用于计算.c .h文件有多少行。<strong>一共128886行。</strong></p><p><code>find . -name &quot;*[.cpp| .h]&quot; | xargs grep &quot;^.&quot;| wc -l</code>用于计算.c .h文件除去空格有多少行。<strong>一共114922行。</strong></p><font color="#00ff6f" size="3">3.3 Makefile</font><p><strong>答：</strong></p><ol><li><code>-Wal</code>l选项意思是编译后显示所有警告。</li><li><code>-Werror</code>，它要求<code>gcc</code>将所有的警告当成错误进行处理。</li></ol><h2 id="实验遇到的问题，思考和解决方法"><a href="#实验遇到的问题，思考和解决方法" class="headerlink" title="实验遇到的问题，思考和解决方法"></a>实验遇到的问题，思考和解决方法</h2><font color="#ff0000" size="3"> 【**问题1**】</font><p><strong>问题：</strong>在回答思考题2的时候，不知道为什么传入的参数 <strong>-1</strong>就是最大值，放入循环中可以执行所有的指令。</p><p><strong>答：</strong>之前在改完代码以后，没有重新<code>make run</code>导致一直看不到效果。之后通过调试发现当执行<code>cpu_exec(-1)</code>的能够完成所有指令，也就是键入<code>c</code>后的步骤。但是不知道<code>uint32_t</code>是什么类型的数据，查了资料在知道是<strong>无符号整数</strong>，那答案也就知道了。</p><font color="#ff0000" size="3"> 【**问题2**】</font><p><strong>问题：</strong>在实现单步打印的时候，总是和预期不一样</p><p><strong>答：</strong>对于<code>strtok()</code>的理解不到位，点击<a href="https://www.runoob.com/cprogramming/c-function-strtok.html">这里</a>查看使用方法。经过反复的debug发现使用<code>strtok(str, &quot; &quot;)</code>之后，<code>str</code>就已经和原来不一样了。所以在单步打印中，组合使用<code>strtok()</code>,<code>sscanf()</code>时候要注意。</p><font color="#ff0000" size="3"> 【**问题3**】</font><p><strong>问题：</strong>在实现单步打印的时候，当输入的步数时个位数的时候，能够打印输出每一步，当是两位数的时候，就不再打印输出了。</p><p><strong>答：</strong>事实就是这样，我也不知道为什么。当步数是两位数的时候，参数会传递到<code>cpu_exec()</code>函数中，但是不会打印出每一步。所以我才用了<code>for</code>循环来解决传入参数是两位数时无法打印的问题。</p><p><img src="/pa1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/index/1.2.png"></p><p><img src="/pa1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/index/1.3.png"></p><font color="#ff0000" size="3"> 【**问题4**】</font><p><strong>问题：</strong>在使用正则表达式制定词法分析规则的时候，不知道为什么<code>\\+</code>,<code>\\b</code>等需要两个<code>\</code>?</p><p><strong>答：</strong>以<code>+</code>举例，<code>+</code>在正则表达式中是一个特殊字符，要使用<code>\</code>将<code>+</code>转义，又由于<code>\</code>在正则表达式中也有特殊含义，所以第一个<code>\</code>是用来转义第二个<code>\</code>的，第二个<code>\</code>是用来转义<code>+</code>的。</p><font color="#ff0000" size="3"> 【**问题5**】</font><p><strong>问题：</strong>在实现指针解引用和区别负号的时候，按照老师给的思路写代码却出现错误。</p><p><strong>答：</strong>原因在于，在进入函数<code>eval()</code>中时，要对分析出来的<code>tokens</code>进行分析，查看是否符合是<code>-</code>（负号）和<code>*</code>（指针），是的话修改优先级和名称，但是由于指针和符号不是要实现的基本法则，所以在<code>rules[]</code>中定义，所以报错了，加上之后就没有问题了。</p><h2 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h2><ol><li><p>一定要仔细阅读实验指导书和源代码，会有意想不到的收获。</p><p>在这一过程中，你会发现在这个项目中，很多<code>.cpp</code>文件会包含不同的<code>.h</code>文件，这就使得在<code>.h</code>文件中一定要有函数的声明。比如<code>watchpoint.h</code>。</p></li><li><p>发现自己原来C++的很多知识点也有了不同程度的遗忘，做完了PA1，也巩固了不少。</p><p>在PA1中，巩固的知识点有链表的删除插入，结构体和匿名体的区别，寄存器的结构等等。</p></li><li><p>牢记<code>KISS</code>原则，永远不要一下子追求完美，渐渐的就好。</p><p>在刚刚开始编写函数的时候，我总是希望完善，但是事实上这是不太现实的，因为，一开始不可能就想到所有的可能性。所以开始的时候就先假设输入的参数是符合规范的。做到之后在回过头去看看有什么会限制自己想要的答案。</p></li><li><p><code>Vim</code>作为编辑器之神果然名不虚传。</p><p>刚刚开始使用<code>Vim</code>的时候，十分的不习惯。高效地使用<code>Vim</code>要求熟练的使用各种对应的快捷键，我一开始肯定达不到要求，希望在之后的实验中，加强这种训练，体会<code>Vim</code>的魅力所在。</p></li><li><p>要熟悉使用英文文献和网页。在必应搜索的时候，可以看看<code>stackoverflow</code>的著名网址，这里的解答或许会让你豁然开朗。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NEMU实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world/index.html"/>
      <url>/hello-world/index.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-Hexo的搭建"><a href="#1-Hexo的搭建" class="headerlink" title="1.  Hexo的搭建"></a>1.  <a href="https://easyhexo.com/1-Hexo-install-and-config/">Hexo的搭建</a></h3><h3 id="2-主题的选择"><a href="#2-主题的选择" class="headerlink" title="2. 主题的选择"></a>2. 主题的选择</h3><ul><li><p><a href="https://xpoet.cn/2020/04/%E5%8D%83%E5%91%BC%E4%B8%87%E5%94%A4%E5%A7%8B%E5%87%BA%E6%9D%A5%EF%BC%8CHexo%E4%B8%BB%E9%A2%98ILS%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/">ils</a></p></li><li><p><a href="https://github.com/fi3ework/hexo-theme-archer">archer</a></p></li></ul><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><h3 id="自己总结的"><a href="#自己总结的" class="headerlink" title="自己总结的"></a>自己总结的</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure><h3 id="创建新的Post"><a href="#创建新的Post" class="headerlink" title="创建新的Post"></a>创建新的Post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;Postname&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
